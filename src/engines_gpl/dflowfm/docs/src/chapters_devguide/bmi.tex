\svnid{$Id: bmi.tex 78164 2023-02-14 10:41:59Z dam_ar $}

\chapter{The Basic Model Interface (BMI) for \DFLOWFM}

\section{Introduction}
The \emph{Basic Model Interface (BMI)} is a set of standardized subroutine interfaces that a simulation engine/model may use to implement its API. The BMI implementation in \DFLOWFM{} enables easy access to and interaction with a running \DFLOWFM model schematisation from various host languages, for example Python and C\#.

\section{Basic use of the API}
[yet empty]

\section{Full API description}
[yet empty]

\section{List of available model variables via BMI}
\input{chapters_devguide/bmi_listofvars.tex}

\section{Adding new model variables to the BMI interfaces}
New model state variables can be made available to the outside world by adding them to the BMI subroutines.
The various BMI-subroutines can be automatically generated using a Python-script and this is strongly advised. Take the following steps:

\begin{enumerate}
\item \textbf{Make the variable available.} Make sure your module variable is \verb|public| (possibly impli\-citly), and pointerable, by adding the \verb|target| attribute (see below).
%
\item \textbf{Add self-describing documentation to the variable.} Behind the variable declaration in your module, add a correct documentation string in the following format:\\
\begin{small}
\begin{alltt}
double precision, allocatable, target :: s1(:) \textit{!< [m] waterlevel at end of }
   \textit{timestep \{"shape": ["ndx"]\}}
\end{alltt}
\end{small}
\ \\
(Don't use newlines in the documentation string.)

The syntax is:
\def\avar#1{\(\langle\)\textsl{#1}\(\rangle\)}
\begin{small}
\begin{alltt}
\avar{type}, target ::\avar{var}(:,\ldots) !< [\avar{unit}] \avar{some description} \{"shape": ["\avar{isize}"%, \ldots ]\}

\end{alltt}
\end{small}
%   \textit{timestep \{"shape": ["ndx"]\}}

%
\item \textbf{Special case for derived type fields} Alternatively, when wanting to expose a particular member field of a user defined type variable as a regular BMI variable, the special prefix \verb|!$BMIEXPORT| is available, in combination with the attribute \verb|"internal"| in the JSON string.

After the actual variable, put one or more comment lines, each one for a single member field that you want to expose. For example:\\
\begin{small}
\begin{alltt}
type(stmtype), target             :: stmpar \linecont \textit{!< All relevant parameters for sediment-transport-morphology module.}
\itshape
!$BMIEXPORT double precision      :: bodsed(:,:) \linecont !< [kg m-2] Available sediment in the bed in flow cell center. \linecont \{"location": "face", "shape": ["stmpar%morlyr%settings%nfrac", "ndx"], \linecont \ "internal": "stmpar%morlyr%state%bodsed"\}
!$BMIEXPORT double precision      :: dpsed(:) \linecont !< [m] Sediment thickness in the bed in flow cell center. \linecont \{"location": "face", "shape": ["ndx"], \linecont \ "internal": "stmpar%morlyr%state%dpsed"\}
\end{alltt}
\end{small}
\ \\
(Don't use newlines in the documentation string, the $\hookleftarrow$s are for readability only.)\\
The specified internal variable expression will be exposed in the BMI under the specified name (for example, \verb|get_var("bodsed")| will return \verb|stmpar%morlyr%state%bodsed|).
%
\item \textbf{Run the BMI-generator script.} Open a DOS-box located at your source scripts dir and run \verb|generate.cmd|:\\
\begin{Verbatim}
$ cd D:\your_dfm_sourcecode\scripts
$ generate.cmd
\end{Verbatim}
\ \\
Note that the \verb|generate.cmd| file contains a short list of FORTRAN files, only those will be scanned for BMI-comments. Add your file if it is not in the list yet.
%
\item \textbf{In case of new modules.} In addition to the automatically generated BMI-interface code parts, some parts require manual editing. Open \verb|unstruc_bmi.F90| and find all subroutines that contain a statement similar to:
\begin{Verbatim}
include "bmi_set/get_var(_shape/_rank/_name/_role/_type).inc"
\end{Verbatim}
\ \\
At the top of subroutines, verify that you module is being made available via a \verb|use| statement.
\end{enumerate}


