// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pi_timeseries.hxx"

namespace fews
{
  namespace PI
  {
    // TimeSeriesCollectionComplexType
    // 

    const TimeSeriesCollectionComplexType::TimeZoneOptional& TimeSeriesCollectionComplexType::
    getTimeZone () const
    {
      return this->timeZone_;
    }

    TimeSeriesCollectionComplexType::TimeZoneOptional& TimeSeriesCollectionComplexType::
    getTimeZone ()
    {
      return this->timeZone_;
    }

    void TimeSeriesCollectionComplexType::
    setTimeZone (const TimeZoneType& x)
    {
      this->timeZone_.set (x);
    }

    void TimeSeriesCollectionComplexType::
    setTimeZone (const TimeZoneOptional& x)
    {
      this->timeZone_ = x;
    }

    void TimeSeriesCollectionComplexType::
    setTimeZone (::std::auto_ptr< TimeZoneType > x)
    {
      this->timeZone_.set (x);
    }

    TimeSeriesCollectionComplexType::TimeZoneType TimeSeriesCollectionComplexType::
    getTimeZoneDefaultValue ()
    {
      return TimeZoneType (.0);
    }

    const TimeSeriesCollectionComplexType::SeriesSequence& TimeSeriesCollectionComplexType::
    getSeries () const
    {
      return this->series_;
    }

    TimeSeriesCollectionComplexType::SeriesSequence& TimeSeriesCollectionComplexType::
    getSeries ()
    {
      return this->series_;
    }

    void TimeSeriesCollectionComplexType::
    setSeries (const SeriesSequence& s)
    {
      this->series_ = s;
    }

    const TimeSeriesCollectionComplexType::VersionType& TimeSeriesCollectionComplexType::
    getVersion () const
    {
      return this->version_.get ();
    }

    TimeSeriesCollectionComplexType::VersionType& TimeSeriesCollectionComplexType::
    getVersion ()
    {
      return this->version_.get ();
    }

    void TimeSeriesCollectionComplexType::
    setVersion (const VersionType& x)
    {
      this->version_.set (x);
    }

    void TimeSeriesCollectionComplexType::
    setVersion (::std::auto_ptr< VersionType > x)
    {
      this->version_.set (x);
    }

    const TimeSeriesCollectionComplexType::VersionType& TimeSeriesCollectionComplexType::
    getVersionDefaultValue ()
    {
      return version_default_value_;
    }


    // TimeSeriesComplexType
    // 

    const TimeSeriesComplexType::HeaderType& TimeSeriesComplexType::
    getHeader () const
    {
      return this->header_.get ();
    }

    TimeSeriesComplexType::HeaderType& TimeSeriesComplexType::
    getHeader ()
    {
      return this->header_.get ();
    }

    void TimeSeriesComplexType::
    setHeader (const HeaderType& x)
    {
      this->header_.set (x);
    }

    void TimeSeriesComplexType::
    setHeader (::std::auto_ptr< HeaderType > x)
    {
      this->header_.set (x);
    }

    const TimeSeriesComplexType::PropertiesSequence& TimeSeriesComplexType::
    getProperties () const
    {
      return this->properties_;
    }

    TimeSeriesComplexType::PropertiesSequence& TimeSeriesComplexType::
    getProperties ()
    {
      return this->properties_;
    }

    void TimeSeriesComplexType::
    setProperties (const PropertiesSequence& s)
    {
      this->properties_ = s;
    }

    const TimeSeriesComplexType::EventSequence& TimeSeriesComplexType::
    getEvent () const
    {
      return this->event_;
    }

    TimeSeriesComplexType::EventSequence& TimeSeriesComplexType::
    getEvent ()
    {
      return this->event_;
    }

    void TimeSeriesComplexType::
    setEvent (const EventSequence& s)
    {
      this->event_ = s;
    }

    const TimeSeriesComplexType::CommentOptional& TimeSeriesComplexType::
    getComment () const
    {
      return this->comment_;
    }

    TimeSeriesComplexType::CommentOptional& TimeSeriesComplexType::
    getComment ()
    {
      return this->comment_;
    }

    void TimeSeriesComplexType::
    setComment (const CommentType& x)
    {
      this->comment_.set (x);
    }

    void TimeSeriesComplexType::
    setComment (const CommentOptional& x)
    {
      this->comment_ = x;
    }

    void TimeSeriesComplexType::
    setComment (::std::auto_ptr< CommentType > x)
    {
      this->comment_.set (x);
    }


    // HeaderComplexType
    // 

    const HeaderComplexType::TypeType& HeaderComplexType::
    getType () const
    {
      return this->type_.get ();
    }

    HeaderComplexType::TypeType& HeaderComplexType::
    getType ()
    {
      return this->type_.get ();
    }

    void HeaderComplexType::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void HeaderComplexType::
    setType (::std::auto_ptr< TypeType > x)
    {
      this->type_.set (x);
    }

    const HeaderComplexType::LocationIdType& HeaderComplexType::
    getLocationId () const
    {
      return this->locationId_.get ();
    }

    HeaderComplexType::LocationIdType& HeaderComplexType::
    getLocationId ()
    {
      return this->locationId_.get ();
    }

    void HeaderComplexType::
    setLocationId (const LocationIdType& x)
    {
      this->locationId_.set (x);
    }

    void HeaderComplexType::
    setLocationId (::std::auto_ptr< LocationIdType > x)
    {
      this->locationId_.set (x);
    }

    const HeaderComplexType::ParameterIdType& HeaderComplexType::
    getParameterId () const
    {
      return this->parameterId_.get ();
    }

    HeaderComplexType::ParameterIdType& HeaderComplexType::
    getParameterId ()
    {
      return this->parameterId_.get ();
    }

    void HeaderComplexType::
    setParameterId (const ParameterIdType& x)
    {
      this->parameterId_.set (x);
    }

    void HeaderComplexType::
    setParameterId (::std::auto_ptr< ParameterIdType > x)
    {
      this->parameterId_.set (x);
    }

    const HeaderComplexType::QualifierIdSequence& HeaderComplexType::
    getQualifierId () const
    {
      return this->qualifierId_;
    }

    HeaderComplexType::QualifierIdSequence& HeaderComplexType::
    getQualifierId ()
    {
      return this->qualifierId_;
    }

    void HeaderComplexType::
    setQualifierId (const QualifierIdSequence& s)
    {
      this->qualifierId_ = s;
    }

    const HeaderComplexType::EnsembleIdOptional& HeaderComplexType::
    getEnsembleId () const
    {
      return this->ensembleId_;
    }

    HeaderComplexType::EnsembleIdOptional& HeaderComplexType::
    getEnsembleId ()
    {
      return this->ensembleId_;
    }

    void HeaderComplexType::
    setEnsembleId (const EnsembleIdType& x)
    {
      this->ensembleId_.set (x);
    }

    void HeaderComplexType::
    setEnsembleId (const EnsembleIdOptional& x)
    {
      this->ensembleId_ = x;
    }

    void HeaderComplexType::
    setEnsembleId (::std::auto_ptr< EnsembleIdType > x)
    {
      this->ensembleId_.set (x);
    }

    const HeaderComplexType::EnsembleMemberIndexOptional& HeaderComplexType::
    getEnsembleMemberIndex () const
    {
      return this->ensembleMemberIndex_;
    }

    HeaderComplexType::EnsembleMemberIndexOptional& HeaderComplexType::
    getEnsembleMemberIndex ()
    {
      return this->ensembleMemberIndex_;
    }

    void HeaderComplexType::
    setEnsembleMemberIndex (const EnsembleMemberIndexType& x)
    {
      this->ensembleMemberIndex_.set (x);
    }

    void HeaderComplexType::
    setEnsembleMemberIndex (const EnsembleMemberIndexOptional& x)
    {
      this->ensembleMemberIndex_ = x;
    }

    const HeaderComplexType::EnsembleMemberIdOptional& HeaderComplexType::
    getEnsembleMemberId () const
    {
      return this->ensembleMemberId_;
    }

    HeaderComplexType::EnsembleMemberIdOptional& HeaderComplexType::
    getEnsembleMemberId ()
    {
      return this->ensembleMemberId_;
    }

    void HeaderComplexType::
    setEnsembleMemberId (const EnsembleMemberIdType& x)
    {
      this->ensembleMemberId_.set (x);
    }

    void HeaderComplexType::
    setEnsembleMemberId (const EnsembleMemberIdOptional& x)
    {
      this->ensembleMemberId_ = x;
    }

    void HeaderComplexType::
    setEnsembleMemberId (::std::auto_ptr< EnsembleMemberIdType > x)
    {
      this->ensembleMemberId_.set (x);
    }

    const HeaderComplexType::TimeStepType& HeaderComplexType::
    getTimeStep () const
    {
      return this->timeStep_.get ();
    }

    HeaderComplexType::TimeStepType& HeaderComplexType::
    getTimeStep ()
    {
      return this->timeStep_.get ();
    }

    void HeaderComplexType::
    setTimeStep (const TimeStepType& x)
    {
      this->timeStep_.set (x);
    }

    void HeaderComplexType::
    setTimeStep (::std::auto_ptr< TimeStepType > x)
    {
      this->timeStep_.set (x);
    }

    const HeaderComplexType::StartDateType& HeaderComplexType::
    getStartDate () const
    {
      return this->startDate_.get ();
    }

    HeaderComplexType::StartDateType& HeaderComplexType::
    getStartDate ()
    {
      return this->startDate_.get ();
    }

    void HeaderComplexType::
    setStartDate (const StartDateType& x)
    {
      this->startDate_.set (x);
    }

    void HeaderComplexType::
    setStartDate (::std::auto_ptr< StartDateType > x)
    {
      this->startDate_.set (x);
    }

    const HeaderComplexType::EndDateType& HeaderComplexType::
    getEndDate () const
    {
      return this->endDate_.get ();
    }

    HeaderComplexType::EndDateType& HeaderComplexType::
    getEndDate ()
    {
      return this->endDate_.get ();
    }

    void HeaderComplexType::
    setEndDate (const EndDateType& x)
    {
      this->endDate_.set (x);
    }

    void HeaderComplexType::
    setEndDate (::std::auto_ptr< EndDateType > x)
    {
      this->endDate_.set (x);
    }

    const HeaderComplexType::ForecastDateOptional& HeaderComplexType::
    getForecastDate () const
    {
      return this->forecastDate_;
    }

    HeaderComplexType::ForecastDateOptional& HeaderComplexType::
    getForecastDate ()
    {
      return this->forecastDate_;
    }

    void HeaderComplexType::
    setForecastDate (const ForecastDateType& x)
    {
      this->forecastDate_.set (x);
    }

    void HeaderComplexType::
    setForecastDate (const ForecastDateOptional& x)
    {
      this->forecastDate_ = x;
    }

    void HeaderComplexType::
    setForecastDate (::std::auto_ptr< ForecastDateType > x)
    {
      this->forecastDate_.set (x);
    }

    const HeaderComplexType::MissValType& HeaderComplexType::
    getMissVal () const
    {
      return this->missVal_.get ();
    }

    HeaderComplexType::MissValType& HeaderComplexType::
    getMissVal ()
    {
      return this->missVal_.get ();
    }

    void HeaderComplexType::
    setMissVal (const MissValType& x)
    {
      this->missVal_.set (x);
    }

    HeaderComplexType::MissValType HeaderComplexType::
    getMissValDefaultValue ()
    {
      return MissValType (::std::numeric_limits< ::xml_schema::Double >::quiet_NaN ());
    }

    const HeaderComplexType::LongNameOptional& HeaderComplexType::
    getLongName () const
    {
      return this->longName_;
    }

    HeaderComplexType::LongNameOptional& HeaderComplexType::
    getLongName ()
    {
      return this->longName_;
    }

    void HeaderComplexType::
    setLongName (const LongNameType& x)
    {
      this->longName_.set (x);
    }

    void HeaderComplexType::
    setLongName (const LongNameOptional& x)
    {
      this->longName_ = x;
    }

    void HeaderComplexType::
    setLongName (::std::auto_ptr< LongNameType > x)
    {
      this->longName_.set (x);
    }

    const HeaderComplexType::StationNameOptional& HeaderComplexType::
    getStationName () const
    {
      return this->stationName_;
    }

    HeaderComplexType::StationNameOptional& HeaderComplexType::
    getStationName ()
    {
      return this->stationName_;
    }

    void HeaderComplexType::
    setStationName (const StationNameType& x)
    {
      this->stationName_.set (x);
    }

    void HeaderComplexType::
    setStationName (const StationNameOptional& x)
    {
      this->stationName_ = x;
    }

    void HeaderComplexType::
    setStationName (::std::auto_ptr< StationNameType > x)
    {
      this->stationName_.set (x);
    }

    const HeaderComplexType::LatOptional& HeaderComplexType::
    getLat () const
    {
      return this->lat_;
    }

    HeaderComplexType::LatOptional& HeaderComplexType::
    getLat ()
    {
      return this->lat_;
    }

    void HeaderComplexType::
    setLat (const LatType& x)
    {
      this->lat_.set (x);
    }

    void HeaderComplexType::
    setLat (const LatOptional& x)
    {
      this->lat_ = x;
    }

    const HeaderComplexType::LonOptional& HeaderComplexType::
    getLon () const
    {
      return this->lon_;
    }

    HeaderComplexType::LonOptional& HeaderComplexType::
    getLon ()
    {
      return this->lon_;
    }

    void HeaderComplexType::
    setLon (const LonType& x)
    {
      this->lon_.set (x);
    }

    void HeaderComplexType::
    setLon (const LonOptional& x)
    {
      this->lon_ = x;
    }

    const HeaderComplexType::XOptional& HeaderComplexType::
    getX () const
    {
      return this->x_;
    }

    HeaderComplexType::XOptional& HeaderComplexType::
    getX ()
    {
      return this->x_;
    }

    void HeaderComplexType::
    setX (const XType& x)
    {
      this->x_.set (x);
    }

    void HeaderComplexType::
    setX (const XOptional& x)
    {
      this->x_ = x;
    }

    const HeaderComplexType::YOptional& HeaderComplexType::
    getY () const
    {
      return this->y_;
    }

    HeaderComplexType::YOptional& HeaderComplexType::
    getY ()
    {
      return this->y_;
    }

    void HeaderComplexType::
    setY (const YType& x)
    {
      this->y_.set (x);
    }

    void HeaderComplexType::
    setY (const YOptional& x)
    {
      this->y_ = x;
    }

    const HeaderComplexType::ZOptional& HeaderComplexType::
    getZ () const
    {
      return this->z_;
    }

    HeaderComplexType::ZOptional& HeaderComplexType::
    getZ ()
    {
      return this->z_;
    }

    void HeaderComplexType::
    setZ (const ZType& x)
    {
      this->z_.set (x);
    }

    void HeaderComplexType::
    setZ (const ZOptional& x)
    {
      this->z_ = x;
    }

    const HeaderComplexType::UnitsOptional& HeaderComplexType::
    getUnits () const
    {
      return this->units_;
    }

    HeaderComplexType::UnitsOptional& HeaderComplexType::
    getUnits ()
    {
      return this->units_;
    }

    void HeaderComplexType::
    setUnits (const UnitsType& x)
    {
      this->units_.set (x);
    }

    void HeaderComplexType::
    setUnits (const UnitsOptional& x)
    {
      this->units_ = x;
    }

    void HeaderComplexType::
    setUnits (::std::auto_ptr< UnitsType > x)
    {
      this->units_.set (x);
    }

    const HeaderComplexType::SourceOrganisationOptional& HeaderComplexType::
    getSourceOrganisation () const
    {
      return this->sourceOrganisation_;
    }

    HeaderComplexType::SourceOrganisationOptional& HeaderComplexType::
    getSourceOrganisation ()
    {
      return this->sourceOrganisation_;
    }

    void HeaderComplexType::
    setSourceOrganisation (const SourceOrganisationType& x)
    {
      this->sourceOrganisation_.set (x);
    }

    void HeaderComplexType::
    setSourceOrganisation (const SourceOrganisationOptional& x)
    {
      this->sourceOrganisation_ = x;
    }

    void HeaderComplexType::
    setSourceOrganisation (::std::auto_ptr< SourceOrganisationType > x)
    {
      this->sourceOrganisation_.set (x);
    }

    const HeaderComplexType::SourceSystemOptional& HeaderComplexType::
    getSourceSystem () const
    {
      return this->sourceSystem_;
    }

    HeaderComplexType::SourceSystemOptional& HeaderComplexType::
    getSourceSystem ()
    {
      return this->sourceSystem_;
    }

    void HeaderComplexType::
    setSourceSystem (const SourceSystemType& x)
    {
      this->sourceSystem_.set (x);
    }

    void HeaderComplexType::
    setSourceSystem (const SourceSystemOptional& x)
    {
      this->sourceSystem_ = x;
    }

    void HeaderComplexType::
    setSourceSystem (::std::auto_ptr< SourceSystemType > x)
    {
      this->sourceSystem_.set (x);
    }

    const HeaderComplexType::FileDescriptionOptional& HeaderComplexType::
    getFileDescription () const
    {
      return this->fileDescription_;
    }

    HeaderComplexType::FileDescriptionOptional& HeaderComplexType::
    getFileDescription ()
    {
      return this->fileDescription_;
    }

    void HeaderComplexType::
    setFileDescription (const FileDescriptionType& x)
    {
      this->fileDescription_.set (x);
    }

    void HeaderComplexType::
    setFileDescription (const FileDescriptionOptional& x)
    {
      this->fileDescription_ = x;
    }

    void HeaderComplexType::
    setFileDescription (::std::auto_ptr< FileDescriptionType > x)
    {
      this->fileDescription_.set (x);
    }

    const HeaderComplexType::CreationDateOptional& HeaderComplexType::
    getCreationDate () const
    {
      return this->creationDate_;
    }

    HeaderComplexType::CreationDateOptional& HeaderComplexType::
    getCreationDate ()
    {
      return this->creationDate_;
    }

    void HeaderComplexType::
    setCreationDate (const CreationDateType& x)
    {
      this->creationDate_.set (x);
    }

    void HeaderComplexType::
    setCreationDate (const CreationDateOptional& x)
    {
      this->creationDate_ = x;
    }

    void HeaderComplexType::
    setCreationDate (::std::auto_ptr< CreationDateType > x)
    {
      this->creationDate_.set (x);
    }

    const HeaderComplexType::CreationTimeOptional& HeaderComplexType::
    getCreationTime () const
    {
      return this->creationTime_;
    }

    HeaderComplexType::CreationTimeOptional& HeaderComplexType::
    getCreationTime ()
    {
      return this->creationTime_;
    }

    void HeaderComplexType::
    setCreationTime (const CreationTimeType& x)
    {
      this->creationTime_.set (x);
    }

    void HeaderComplexType::
    setCreationTime (const CreationTimeOptional& x)
    {
      this->creationTime_ = x;
    }

    void HeaderComplexType::
    setCreationTime (::std::auto_ptr< CreationTimeType > x)
    {
      this->creationTime_.set (x);
    }

    const HeaderComplexType::RegionOptional& HeaderComplexType::
    getRegion () const
    {
      return this->region_;
    }

    HeaderComplexType::RegionOptional& HeaderComplexType::
    getRegion ()
    {
      return this->region_;
    }

    void HeaderComplexType::
    setRegion (const RegionType& x)
    {
      this->region_.set (x);
    }

    void HeaderComplexType::
    setRegion (const RegionOptional& x)
    {
      this->region_ = x;
    }

    void HeaderComplexType::
    setRegion (::std::auto_ptr< RegionType > x)
    {
      this->region_.set (x);
    }

    const HeaderComplexType::ThresholdsOptional& HeaderComplexType::
    getThresholds () const
    {
      return this->thresholds_;
    }

    HeaderComplexType::ThresholdsOptional& HeaderComplexType::
    getThresholds ()
    {
      return this->thresholds_;
    }

    void HeaderComplexType::
    setThresholds (const ThresholdsType& x)
    {
      this->thresholds_.set (x);
    }

    void HeaderComplexType::
    setThresholds (const ThresholdsOptional& x)
    {
      this->thresholds_ = x;
    }

    void HeaderComplexType::
    setThresholds (::std::auto_ptr< ThresholdsType > x)
    {
      this->thresholds_.set (x);
    }


    // ThresholdComplexType
    // 

    const ThresholdComplexType::HighLevelThresholdSequence& ThresholdComplexType::
    getHighLevelThreshold () const
    {
      return this->highLevelThreshold_;
    }

    ThresholdComplexType::HighLevelThresholdSequence& ThresholdComplexType::
    getHighLevelThreshold ()
    {
      return this->highLevelThreshold_;
    }

    void ThresholdComplexType::
    setHighLevelThreshold (const HighLevelThresholdSequence& s)
    {
      this->highLevelThreshold_ = s;
    }


    // HighLevelThresholdsComplexType
    // 

    const HighLevelThresholdsComplexType::IdType& HighLevelThresholdsComplexType::
    getId () const
    {
      return this->id_.get ();
    }

    HighLevelThresholdsComplexType::IdType& HighLevelThresholdsComplexType::
    getId ()
    {
      return this->id_.get ();
    }

    void HighLevelThresholdsComplexType::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void HighLevelThresholdsComplexType::
    setId (::std::auto_ptr< IdType > x)
    {
      this->id_.set (x);
    }

    const HighLevelThresholdsComplexType::NameOptional& HighLevelThresholdsComplexType::
    getName () const
    {
      return this->name_;
    }

    HighLevelThresholdsComplexType::NameOptional& HighLevelThresholdsComplexType::
    getName ()
    {
      return this->name_;
    }

    void HighLevelThresholdsComplexType::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void HighLevelThresholdsComplexType::
    setName (const NameOptional& x)
    {
      this->name_ = x;
    }

    void HighLevelThresholdsComplexType::
    setName (::std::auto_ptr< NameType > x)
    {
      this->name_.set (x);
    }

    const HighLevelThresholdsComplexType::ValueType& HighLevelThresholdsComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    HighLevelThresholdsComplexType::ValueType& HighLevelThresholdsComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void HighLevelThresholdsComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }

    const HighLevelThresholdsComplexType::GroupIdOptional& HighLevelThresholdsComplexType::
    getGroupId () const
    {
      return this->groupId_;
    }

    HighLevelThresholdsComplexType::GroupIdOptional& HighLevelThresholdsComplexType::
    getGroupId ()
    {
      return this->groupId_;
    }

    void HighLevelThresholdsComplexType::
    setGroupId (const GroupIdType& x)
    {
      this->groupId_.set (x);
    }

    void HighLevelThresholdsComplexType::
    setGroupId (const GroupIdOptional& x)
    {
      this->groupId_ = x;
    }

    void HighLevelThresholdsComplexType::
    setGroupId (::std::auto_ptr< GroupIdType > x)
    {
      this->groupId_.set (x);
    }

    const HighLevelThresholdsComplexType::GroupNameOptional& HighLevelThresholdsComplexType::
    getGroupName () const
    {
      return this->groupName_;
    }

    HighLevelThresholdsComplexType::GroupNameOptional& HighLevelThresholdsComplexType::
    getGroupName ()
    {
      return this->groupName_;
    }

    void HighLevelThresholdsComplexType::
    setGroupName (const GroupNameType& x)
    {
      this->groupName_.set (x);
    }

    void HighLevelThresholdsComplexType::
    setGroupName (const GroupNameOptional& x)
    {
      this->groupName_ = x;
    }

    void HighLevelThresholdsComplexType::
    setGroupName (::std::auto_ptr< GroupNameType > x)
    {
      this->groupName_.set (x);
    }


    // EventComplexType
    // 

    const EventComplexType::DateType& EventComplexType::
    getDate () const
    {
      return this->date_.get ();
    }

    EventComplexType::DateType& EventComplexType::
    getDate ()
    {
      return this->date_.get ();
    }

    void EventComplexType::
    setDate (const DateType& x)
    {
      this->date_.set (x);
    }

    void EventComplexType::
    setDate (::std::auto_ptr< DateType > x)
    {
      this->date_.set (x);
    }

    const EventComplexType::TimeType& EventComplexType::
    getTime () const
    {
      return this->time_.get ();
    }

    EventComplexType::TimeType& EventComplexType::
    getTime ()
    {
      return this->time_.get ();
    }

    void EventComplexType::
    setTime (const TimeType& x)
    {
      this->time_.set (x);
    }

    void EventComplexType::
    setTime (::std::auto_ptr< TimeType > x)
    {
      this->time_.set (x);
    }

    const EventComplexType::ValueType& EventComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    EventComplexType::ValueType& EventComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void EventComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }

    const EventComplexType::FlagOptional& EventComplexType::
    getFlag () const
    {
      return this->flag_;
    }

    EventComplexType::FlagOptional& EventComplexType::
    getFlag ()
    {
      return this->flag_;
    }

    void EventComplexType::
    setFlag (const FlagType& x)
    {
      this->flag_.set (x);
    }

    void EventComplexType::
    setFlag (const FlagOptional& x)
    {
      this->flag_ = x;
    }

    const EventComplexType::FlagSourceOptional& EventComplexType::
    getFlagSource () const
    {
      return this->flagSource_;
    }

    EventComplexType::FlagSourceOptional& EventComplexType::
    getFlagSource ()
    {
      return this->flagSource_;
    }

    void EventComplexType::
    setFlagSource (const FlagSourceType& x)
    {
      this->flagSource_.set (x);
    }

    void EventComplexType::
    setFlagSource (const FlagSourceOptional& x)
    {
      this->flagSource_ = x;
    }

    void EventComplexType::
    setFlagSource (::std::auto_ptr< FlagSourceType > x)
    {
      this->flagSource_.set (x);
    }

    const EventComplexType::CommentOptional& EventComplexType::
    getComment () const
    {
      return this->comment_;
    }

    EventComplexType::CommentOptional& EventComplexType::
    getComment ()
    {
      return this->comment_;
    }

    void EventComplexType::
    setComment (const CommentType& x)
    {
      this->comment_.set (x);
    }

    void EventComplexType::
    setComment (const CommentOptional& x)
    {
      this->comment_ = x;
    }

    void EventComplexType::
    setComment (::std::auto_ptr< CommentType > x)
    {
      this->comment_.set (x);
    }

    const EventComplexType::UserOptional& EventComplexType::
    getUser () const
    {
      return this->user_;
    }

    EventComplexType::UserOptional& EventComplexType::
    getUser ()
    {
      return this->user_;
    }

    void EventComplexType::
    setUser (const UserType& x)
    {
      this->user_.set (x);
    }

    void EventComplexType::
    setUser (const UserOptional& x)
    {
      this->user_ = x;
    }

    void EventComplexType::
    setUser (::std::auto_ptr< UserType > x)
    {
      this->user_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace fews
{
  namespace PI
  {
    // TimeSeriesCollectionComplexType
    //

    const TimeSeriesCollectionComplexType::VersionType TimeSeriesCollectionComplexType::version_default_value_ (
      "1.2");

    TimeSeriesCollectionComplexType::
    TimeSeriesCollectionComplexType ()
    : ::xml_schema::Type (),
      timeZone_ (::xml_schema::Flags (), this),
      series_ (::xml_schema::Flags (), this),
      version_ (getVersionDefaultValue (), ::xml_schema::Flags (), this)
    {
    }

    TimeSeriesCollectionComplexType::
    TimeSeriesCollectionComplexType (const TimeSeriesCollectionComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      timeZone_ (x.timeZone_, f, this),
      series_ (x.series_, f, this),
      version_ (x.version_, f, this)
    {
    }

    TimeSeriesCollectionComplexType::
    TimeSeriesCollectionComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      timeZone_ (f, this),
      series_ (f, this),
      version_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TimeSeriesCollectionComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // timeZone
        //
        if (n.name () == "timeZone" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< TimeZoneType > r (
            TimeZoneTraits::create (i, f, this));

          if (!this->timeZone_)
          {
            this->timeZone_.set (r);
            continue;
          }
        }

        // series
        //
        if (n.name () == "series" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< SeriesType > r (
            SeriesTraits::create (i, f, this));

          this->series_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "version" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< VersionType > r (
            VersionTraits::create (i, f, this));

          this->version_.set (r);
          continue;
        }
      }

      if (!version_.present ())
      {
        this->version_.set (getVersionDefaultValue ());
      }
    }

    TimeSeriesCollectionComplexType* TimeSeriesCollectionComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeSeriesCollectionComplexType (*this, f, c);
    }

    TimeSeriesCollectionComplexType::
    ~TimeSeriesCollectionComplexType ()
    {
    }

    // TimeSeriesComplexType
    //

    TimeSeriesComplexType::
    TimeSeriesComplexType (const HeaderType& header)
    : ::xml_schema::Type (),
      header_ (header, ::xml_schema::Flags (), this),
      properties_ (::xml_schema::Flags (), this),
      event_ (::xml_schema::Flags (), this),
      comment_ (::xml_schema::Flags (), this)
    {
    }

    TimeSeriesComplexType::
    TimeSeriesComplexType (::std::auto_ptr< HeaderType >& header)
    : ::xml_schema::Type (),
      header_ (header, ::xml_schema::Flags (), this),
      properties_ (::xml_schema::Flags (), this),
      event_ (::xml_schema::Flags (), this),
      comment_ (::xml_schema::Flags (), this)
    {
    }

    TimeSeriesComplexType::
    TimeSeriesComplexType (const TimeSeriesComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      header_ (x.header_, f, this),
      properties_ (x.properties_, f, this),
      event_ (x.event_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    TimeSeriesComplexType::
    TimeSeriesComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      header_ (f, this),
      properties_ (f, this),
      event_ (f, this),
      comment_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TimeSeriesComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // header
        //
        if (n.name () == "header" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< HeaderType > r (
            HeaderTraits::create (i, f, this));

          if (!header_.present ())
          {
            this->header_.set (r);
            continue;
          }
        }

        // properties
        //
        if (n.name () == "properties" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< PropertiesType > r (
            PropertiesTraits::create (i, f, this));

          this->properties_.push_back (r);
          continue;
        }

        // event
        //
        if (n.name () == "event" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EventType > r (
            EventTraits::create (i, f, this));

          this->event_.push_back (r);
          continue;
        }

        // comment
        //
        if (n.name () == "comment" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< CommentType > r (
            CommentTraits::create (i, f, this));

          if (!this->comment_)
          {
            this->comment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!header_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "header",
          "http://www.wldelft.nl/fews/PI");
      }
    }

    TimeSeriesComplexType* TimeSeriesComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeSeriesComplexType (*this, f, c);
    }

    TimeSeriesComplexType::
    ~TimeSeriesComplexType ()
    {
    }

    // HeaderComplexType
    //

    HeaderComplexType::
    HeaderComplexType (const TypeType& type,
                       const LocationIdType& locationId,
                       const ParameterIdType& parameterId,
                       const TimeStepType& timeStep,
                       const StartDateType& startDate,
                       const EndDateType& endDate,
                       const MissValType& missVal)
    : ::xml_schema::Type (),
      type_ (type, ::xml_schema::Flags (), this),
      locationId_ (locationId, ::xml_schema::Flags (), this),
      parameterId_ (parameterId, ::xml_schema::Flags (), this),
      qualifierId_ (::xml_schema::Flags (), this),
      ensembleId_ (::xml_schema::Flags (), this),
      ensembleMemberIndex_ (::xml_schema::Flags (), this),
      ensembleMemberId_ (::xml_schema::Flags (), this),
      timeStep_ (timeStep, ::xml_schema::Flags (), this),
      startDate_ (startDate, ::xml_schema::Flags (), this),
      endDate_ (endDate, ::xml_schema::Flags (), this),
      forecastDate_ (::xml_schema::Flags (), this),
      missVal_ (missVal, ::xml_schema::Flags (), this),
      longName_ (::xml_schema::Flags (), this),
      stationName_ (::xml_schema::Flags (), this),
      lat_ (::xml_schema::Flags (), this),
      lon_ (::xml_schema::Flags (), this),
      x_ (::xml_schema::Flags (), this),
      y_ (::xml_schema::Flags (), this),
      z_ (::xml_schema::Flags (), this),
      units_ (::xml_schema::Flags (), this),
      sourceOrganisation_ (::xml_schema::Flags (), this),
      sourceSystem_ (::xml_schema::Flags (), this),
      fileDescription_ (::xml_schema::Flags (), this),
      creationDate_ (::xml_schema::Flags (), this),
      creationTime_ (::xml_schema::Flags (), this),
      region_ (::xml_schema::Flags (), this),
      thresholds_ (::xml_schema::Flags (), this)
    {
    }

    HeaderComplexType::
    HeaderComplexType (const TypeType& type,
                       const LocationIdType& locationId,
                       const ParameterIdType& parameterId,
                       ::std::auto_ptr< TimeStepType >& timeStep,
                       ::std::auto_ptr< StartDateType >& startDate,
                       ::std::auto_ptr< EndDateType >& endDate,
                       const MissValType& missVal)
    : ::xml_schema::Type (),
      type_ (type, ::xml_schema::Flags (), this),
      locationId_ (locationId, ::xml_schema::Flags (), this),
      parameterId_ (parameterId, ::xml_schema::Flags (), this),
      qualifierId_ (::xml_schema::Flags (), this),
      ensembleId_ (::xml_schema::Flags (), this),
      ensembleMemberIndex_ (::xml_schema::Flags (), this),
      ensembleMemberId_ (::xml_schema::Flags (), this),
      timeStep_ (timeStep, ::xml_schema::Flags (), this),
      startDate_ (startDate, ::xml_schema::Flags (), this),
      endDate_ (endDate, ::xml_schema::Flags (), this),
      forecastDate_ (::xml_schema::Flags (), this),
      missVal_ (missVal, ::xml_schema::Flags (), this),
      longName_ (::xml_schema::Flags (), this),
      stationName_ (::xml_schema::Flags (), this),
      lat_ (::xml_schema::Flags (), this),
      lon_ (::xml_schema::Flags (), this),
      x_ (::xml_schema::Flags (), this),
      y_ (::xml_schema::Flags (), this),
      z_ (::xml_schema::Flags (), this),
      units_ (::xml_schema::Flags (), this),
      sourceOrganisation_ (::xml_schema::Flags (), this),
      sourceSystem_ (::xml_schema::Flags (), this),
      fileDescription_ (::xml_schema::Flags (), this),
      creationDate_ (::xml_schema::Flags (), this),
      creationTime_ (::xml_schema::Flags (), this),
      region_ (::xml_schema::Flags (), this),
      thresholds_ (::xml_schema::Flags (), this)
    {
    }

    HeaderComplexType::
    HeaderComplexType (const HeaderComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      locationId_ (x.locationId_, f, this),
      parameterId_ (x.parameterId_, f, this),
      qualifierId_ (x.qualifierId_, f, this),
      ensembleId_ (x.ensembleId_, f, this),
      ensembleMemberIndex_ (x.ensembleMemberIndex_, f, this),
      ensembleMemberId_ (x.ensembleMemberId_, f, this),
      timeStep_ (x.timeStep_, f, this),
      startDate_ (x.startDate_, f, this),
      endDate_ (x.endDate_, f, this),
      forecastDate_ (x.forecastDate_, f, this),
      missVal_ (x.missVal_, f, this),
      longName_ (x.longName_, f, this),
      stationName_ (x.stationName_, f, this),
      lat_ (x.lat_, f, this),
      lon_ (x.lon_, f, this),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this),
      units_ (x.units_, f, this),
      sourceOrganisation_ (x.sourceOrganisation_, f, this),
      sourceSystem_ (x.sourceSystem_, f, this),
      fileDescription_ (x.fileDescription_, f, this),
      creationDate_ (x.creationDate_, f, this),
      creationTime_ (x.creationTime_, f, this),
      region_ (x.region_, f, this),
      thresholds_ (x.thresholds_, f, this)
    {
    }

    HeaderComplexType::
    HeaderComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (f, this),
      locationId_ (f, this),
      parameterId_ (f, this),
      qualifierId_ (f, this),
      ensembleId_ (f, this),
      ensembleMemberIndex_ (f, this),
      ensembleMemberId_ (f, this),
      timeStep_ (f, this),
      startDate_ (f, this),
      endDate_ (f, this),
      forecastDate_ (f, this),
      missVal_ (f, this),
      longName_ (f, this),
      stationName_ (f, this),
      lat_ (f, this),
      lon_ (f, this),
      x_ (f, this),
      y_ (f, this),
      z_ (f, this),
      units_ (f, this),
      sourceOrganisation_ (f, this),
      sourceSystem_ (f, this),
      fileDescription_ (f, this),
      creationDate_ (f, this),
      creationTime_ (f, this),
      region_ (f, this),
      thresholds_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void HeaderComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // type
        //
        if (n.name () == "type" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< TypeType > r (
            TypeTraits::create (i, f, this));

          if (!type_.present ())
          {
            this->type_.set (r);
            continue;
          }
        }

        // locationId
        //
        if (n.name () == "locationId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< LocationIdType > r (
            LocationIdTraits::create (i, f, this));

          if (!locationId_.present ())
          {
            this->locationId_.set (r);
            continue;
          }
        }

        // parameterId
        //
        if (n.name () == "parameterId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ParameterIdType > r (
            ParameterIdTraits::create (i, f, this));

          if (!parameterId_.present ())
          {
            this->parameterId_.set (r);
            continue;
          }
        }

        // qualifierId
        //
        if (n.name () == "qualifierId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< QualifierIdType > r (
            QualifierIdTraits::create (i, f, this));

          this->qualifierId_.push_back (r);
          continue;
        }

        // ensembleId
        //
        if (n.name () == "ensembleId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EnsembleIdType > r (
            EnsembleIdTraits::create (i, f, this));

          if (!this->ensembleId_)
          {
            this->ensembleId_.set (r);
            continue;
          }
        }

        // ensembleMemberIndex
        //
        if (n.name () == "ensembleMemberIndex" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!this->ensembleMemberIndex_)
          {
            this->ensembleMemberIndex_.set (EnsembleMemberIndexTraits::create (i, f, this));
            continue;
          }
        }

        // ensembleMemberId
        //
        if (n.name () == "ensembleMemberId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EnsembleMemberIdType > r (
            EnsembleMemberIdTraits::create (i, f, this));

          if (!this->ensembleMemberId_)
          {
            this->ensembleMemberId_.set (r);
            continue;
          }
        }

        // timeStep
        //
        if (n.name () == "timeStep" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< TimeStepType > r (
            TimeStepTraits::create (i, f, this));

          if (!timeStep_.present ())
          {
            this->timeStep_.set (r);
            continue;
          }
        }

        // startDate
        //
        if (n.name () == "startDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< StartDateType > r (
            StartDateTraits::create (i, f, this));

          if (!startDate_.present ())
          {
            this->startDate_.set (r);
            continue;
          }
        }

        // endDate
        //
        if (n.name () == "endDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EndDateType > r (
            EndDateTraits::create (i, f, this));

          if (!endDate_.present ())
          {
            this->endDate_.set (r);
            continue;
          }
        }

        // forecastDate
        //
        if (n.name () == "forecastDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ForecastDateType > r (
            ForecastDateTraits::create (i, f, this));

          if (!this->forecastDate_)
          {
            this->forecastDate_.set (r);
            continue;
          }
        }

        // missVal
        //
        if (n.name () == "missVal" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!missVal_.present ())
          {
            this->missVal_.set (MissValTraits::create (i, f, this));
            continue;
          }
        }

        // longName
        //
        if (n.name () == "longName" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< LongNameType > r (
            LongNameTraits::create (i, f, this));

          if (!this->longName_)
          {
            this->longName_.set (r);
            continue;
          }
        }

        // stationName
        //
        if (n.name () == "stationName" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< StationNameType > r (
            StationNameTraits::create (i, f, this));

          if (!this->stationName_)
          {
            this->stationName_.set (r);
            continue;
          }
        }

        // lat
        //
        if (n.name () == "lat" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!this->lat_)
          {
            this->lat_.set (LatTraits::create (i, f, this));
            continue;
          }
        }

        // lon
        //
        if (n.name () == "lon" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!this->lon_)
          {
            this->lon_.set (LonTraits::create (i, f, this));
            continue;
          }
        }

        // x
        //
        if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!this->x_)
          {
            this->x_.set (XTraits::create (i, f, this));
            continue;
          }
        }

        // y
        //
        if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!this->y_)
          {
            this->y_.set (YTraits::create (i, f, this));
            continue;
          }
        }

        // z
        //
        if (n.name () == "z" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          if (!this->z_)
          {
            this->z_.set (ZTraits::create (i, f, this));
            continue;
          }
        }

        // units
        //
        if (n.name () == "units" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< UnitsType > r (
            UnitsTraits::create (i, f, this));

          if (!this->units_)
          {
            this->units_.set (r);
            continue;
          }
        }

        // sourceOrganisation
        //
        if (n.name () == "sourceOrganisation" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< SourceOrganisationType > r (
            SourceOrganisationTraits::create (i, f, this));

          if (!this->sourceOrganisation_)
          {
            this->sourceOrganisation_.set (r);
            continue;
          }
        }

        // sourceSystem
        //
        if (n.name () == "sourceSystem" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< SourceSystemType > r (
            SourceSystemTraits::create (i, f, this));

          if (!this->sourceSystem_)
          {
            this->sourceSystem_.set (r);
            continue;
          }
        }

        // fileDescription
        //
        if (n.name () == "fileDescription" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< FileDescriptionType > r (
            FileDescriptionTraits::create (i, f, this));

          if (!this->fileDescription_)
          {
            this->fileDescription_.set (r);
            continue;
          }
        }

        // creationDate
        //
        if (n.name () == "creationDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< CreationDateType > r (
            CreationDateTraits::create (i, f, this));

          if (!this->creationDate_)
          {
            this->creationDate_.set (r);
            continue;
          }
        }

        // creationTime
        //
        if (n.name () == "creationTime" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< CreationTimeType > r (
            CreationTimeTraits::create (i, f, this));

          if (!this->creationTime_)
          {
            this->creationTime_.set (r);
            continue;
          }
        }

        // region
        //
        if (n.name () == "region" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< RegionType > r (
            RegionTraits::create (i, f, this));

          if (!this->region_)
          {
            this->region_.set (r);
            continue;
          }
        }

        // thresholds
        //
        if (n.name () == "thresholds" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ThresholdsType > r (
            ThresholdsTraits::create (i, f, this));

          if (!this->thresholds_)
          {
            this->thresholds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "type",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!locationId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "locationId",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!parameterId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "parameterId",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!timeStep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "timeStep",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!startDate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "startDate",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!endDate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "endDate",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!missVal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "missVal",
          "http://www.wldelft.nl/fews/PI");
      }
    }

    HeaderComplexType* HeaderComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HeaderComplexType (*this, f, c);
    }

    HeaderComplexType::
    ~HeaderComplexType ()
    {
    }

    // ThresholdComplexType
    //

    ThresholdComplexType::
    ThresholdComplexType ()
    : ::xml_schema::Type (),
      highLevelThreshold_ (::xml_schema::Flags (), this)
    {
    }

    ThresholdComplexType::
    ThresholdComplexType (const ThresholdComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      highLevelThreshold_ (x.highLevelThreshold_, f, this)
    {
    }

    ThresholdComplexType::
    ThresholdComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      highLevelThreshold_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThresholdComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // highLevelThreshold
        //
        if (n.name () == "highLevelThreshold" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< HighLevelThresholdType > r (
            HighLevelThresholdTraits::create (i, f, this));

          this->highLevelThreshold_.push_back (r);
          continue;
        }

        break;
      }
    }

    ThresholdComplexType* ThresholdComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ThresholdComplexType (*this, f, c);
    }

    ThresholdComplexType::
    ~ThresholdComplexType ()
    {
    }

    // HighLevelThresholdsComplexType
    //

    HighLevelThresholdsComplexType::
    HighLevelThresholdsComplexType (const IdType& id,
                                    const ValueType& value)
    : ::xml_schema::Type (),
      id_ (id, ::xml_schema::Flags (), this),
      name_ (::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this),
      groupId_ (::xml_schema::Flags (), this),
      groupName_ (::xml_schema::Flags (), this)
    {
    }

    HighLevelThresholdsComplexType::
    HighLevelThresholdsComplexType (const HighLevelThresholdsComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this),
      value_ (x.value_, f, this),
      groupId_ (x.groupId_, f, this),
      groupName_ (x.groupName_, f, this)
    {
    }

    HighLevelThresholdsComplexType::
    HighLevelThresholdsComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (f, this),
      name_ (f, this),
      value_ (f, this),
      groupId_ (f, this),
      groupName_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void HighLevelThresholdsComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->id_.set (r);
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameType > r (
            NameTraits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "groupId" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< GroupIdType > r (
            GroupIdTraits::create (i, f, this));

          this->groupId_.set (r);
          continue;
        }

        if (n.name () == "groupName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< GroupNameType > r (
            GroupNameTraits::create (i, f, this));

          this->groupName_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    HighLevelThresholdsComplexType* HighLevelThresholdsComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HighLevelThresholdsComplexType (*this, f, c);
    }

    HighLevelThresholdsComplexType::
    ~HighLevelThresholdsComplexType ()
    {
    }

    // EventComplexType
    //

    EventComplexType::
    EventComplexType (const DateType& date,
                      const TimeType& time,
                      const ValueType& value)
    : ::xml_schema::Type (),
      date_ (date, ::xml_schema::Flags (), this),
      time_ (time, ::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this),
      flag_ (::xml_schema::Flags (), this),
      flagSource_ (::xml_schema::Flags (), this),
      comment_ (::xml_schema::Flags (), this),
      user_ (::xml_schema::Flags (), this)
    {
    }

    EventComplexType::
    EventComplexType (const EventComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      date_ (x.date_, f, this),
      time_ (x.time_, f, this),
      value_ (x.value_, f, this),
      flag_ (x.flag_, f, this),
      flagSource_ (x.flagSource_, f, this),
      comment_ (x.comment_, f, this),
      user_ (x.user_, f, this)
    {
    }

    EventComplexType::
    EventComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      date_ (f, this),
      time_ (f, this),
      value_ (f, this),
      flag_ (f, this),
      flagSource_ (f, this),
      comment_ (f, this),
      user_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void EventComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "date" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DateType > r (
            DateTraits::create (i, f, this));

          this->date_.set (r);
          continue;
        }

        if (n.name () == "time" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TimeType > r (
            TimeTraits::create (i, f, this));

          this->time_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "flag" && n.namespace_ ().empty ())
        {
          this->flag_.set (FlagTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "flagSource" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< FlagSourceType > r (
            FlagSourceTraits::create (i, f, this));

          this->flagSource_.set (r);
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< CommentType > r (
            CommentTraits::create (i, f, this));

          this->comment_.set (r);
          continue;
        }

        if (n.name () == "user" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< UserType > r (
            UserTraits::create (i, f, this));

          this->user_.set (r);
          continue;
        }
      }

      if (!date_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "date",
          "");
      }

      if (!time_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "time",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    EventComplexType* EventComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EventComplexType (*this, f, c);
    }

    EventComplexType::
    ~EventComplexType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace fews
{
  namespace PI
  {
    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
        ::fews::PI::parseTimeSeries (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
        ::fews::PI::parseTimeSeries (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
        ::fews::PI::parseTimeSeries (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::fews::PI::parseTimeSeries (isrc, f, p);
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::fews::PI::parseTimeSeries (isrc, h, f, p);
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::fews::PI::parseTimeSeries (isrc, h, f, p);
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::fews::PI::parseTimeSeries (isrc, f, p);
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::fews::PI::parseTimeSeries (isrc, h, f, p);
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::fews::PI::parseTimeSeries (isrc, h, f, p);
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
        ::fews::PI::parseTimeSeries (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
        ::fews::PI::parseTimeSeries (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
        ::fews::PI::parseTimeSeries (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (const ::xercesc::DOMDocument& d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
          ::fews::PI::parseTimeSeries (
            c, f | ::xml_schema::Flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TimeSeries" &&
          n.namespace_ () == "http://www.wldelft.nl/fews/PI")
      {
        ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
          ::xsd::cxx::tree::traits< ::fews::PI::TimeSeriesCollectionComplexType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TimeSeries",
        "http://www.wldelft.nl/fews/PI");
    }

    ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType >
    parseTimeSeries (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TimeSeries" &&
          n.namespace_ () == "http://www.wldelft.nl/fews/PI")
      {
        ::std::auto_ptr< ::fews::PI::TimeSeriesCollectionComplexType > r (
          ::xsd::cxx::tree::traits< ::fews::PI::TimeSeriesCollectionComplexType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TimeSeries",
        "http://www.wldelft.nl/fews/PI");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

