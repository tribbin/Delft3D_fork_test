// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from treeVector.xsd.
 */

#ifndef TREE_VECTOR_HXX
#define TREE_VECTOR_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace openda
{
  class TreeVectorFileXML;
  class TreeVectorXML;
  class TreeVectorLeafXML;
  class DimensionsXML;
  class GridXML;
  class ComputationalSpaceXML;
  class ComputationalDimensionXML;
  class PhysicalSpaceXML;
  class PhysicalDimensionXML;
  class MetaInfoXML;
  class DateTimeXML;
  class DateXML;
  class TimeXML;
  class VectorXML;
  class TimeZoneXML;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief C++ namespace for the %http://www.openda.org
 * schema namespace.
 */
namespace openda
{
  /**
   * @brief Class corresponding to the %TreeVectorFileXML schema type.
   *
   * @nosubgrouping
   */
  class TreeVectorFileXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name timeStamp
     *
     * @brief Accessor and modifier functions for the %timeStamp
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::DateTimeXML TimeStampType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeStampType > TimeStampOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeStampType, char > TimeStampTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeStampOptional&
    getTimeStamp () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeStampOptional&
    getTimeStamp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeStamp (const TimeStampType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeStamp (const TimeStampOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeStamp (::std::auto_ptr< TimeStampType > p);

    //@}

    /**
     * @name treeVector
     *
     * @brief Accessor and modifier functions for the %treeVector
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::TreeVectorXML TreeVectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreeVectorType, char > TreeVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreeVectorType&
    getTreeVector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreeVectorType&
    getTreeVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreeVector (const TreeVectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTreeVector (::std::auto_ptr< TreeVectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TreeVectorFileXML (const TreeVectorType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TreeVectorFileXML (::std::auto_ptr< TreeVectorType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TreeVectorFileXML (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreeVectorFileXML (const TreeVectorFileXML& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TreeVectorFileXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TreeVectorFileXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimeStampOptional timeStamp_;
    ::xsd::cxx::tree::one< TreeVectorType > treeVector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TreeVectorXML schema type.
   *
   * @nosubgrouping
   */
  class TreeVectorXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String DescriptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DescriptionType > DescriptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DescriptionOptional&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DescriptionOptional&
    getDescription ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDescription (const DescriptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDescription (const DescriptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDescription (::std::auto_ptr< DescriptionType > p);

    //@}

    /**
     * @name treeVectorLeaf
     *
     * @brief Accessor and modifier functions for the %treeVectorLeaf
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::TreeVectorLeafXML TreeVectorLeafType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TreeVectorLeafType > TreeVectorLeafSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TreeVectorLeafSequence::iterator TreeVectorLeafIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TreeVectorLeafSequence::const_iterator TreeVectorLeafConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreeVectorLeafType, char > TreeVectorLeafTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TreeVectorLeafSequence&
    getTreeVectorLeaf () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TreeVectorLeafSequence&
    getTreeVectorLeaf ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTreeVectorLeaf (const TreeVectorLeafSequence& s);

    //@}

    /**
     * @name subTreeVector
     *
     * @brief Accessor and modifier functions for the %subTreeVector
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::TreeVectorXML SubTreeVectorType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SubTreeVectorType > SubTreeVectorSequence;

    /**
     * @brief Element iterator type.
     */
    typedef SubTreeVectorSequence::iterator SubTreeVectorIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SubTreeVectorSequence::const_iterator SubTreeVectorConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SubTreeVectorType, char > SubTreeVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SubTreeVectorSequence&
    getSubTreeVector () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SubTreeVectorSequence&
    getSubTreeVector ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSubTreeVector (const SubTreeVectorSequence& s);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdOptional&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    IdOptional&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setId (const IdOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name caption
     *
     * @brief Accessor and modifier functions for the %caption
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String CaptionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CaptionType > CaptionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CaptionType, char > CaptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CaptionOptional&
    getCaption () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CaptionOptional&
    getCaption ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCaption (const CaptionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCaption (const CaptionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCaption (::std::auto_ptr< CaptionType > p);

    //@}

    /**
     * @name excludeFromVector
     *
     * @brief Accessor and modifier functions for the %excludeFromVector
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ExcludeFromVectorType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExcludeFromVectorType > ExcludeFromVectorOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExcludeFromVectorType, char > ExcludeFromVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExcludeFromVectorOptional&
    getExcludeFromVector () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ExcludeFromVectorOptional&
    getExcludeFromVector ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setExcludeFromVector (const ExcludeFromVectorType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setExcludeFromVector (const ExcludeFromVectorOptional& x);

    //@}

    /**
     * @name className
     *
     * @brief Accessor and modifier functions for the %className
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String ClassNameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ClassNameType > ClassNameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClassNameType, char > ClassNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ClassNameOptional&
    getClassName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ClassNameOptional&
    getClassName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setClassName (const ClassNameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setClassName (const ClassNameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setClassName (::std::auto_ptr< ClassNameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TreeVectorXML ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TreeVectorXML (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreeVectorXML (const TreeVectorXML& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TreeVectorXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TreeVectorXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DescriptionOptional description_;
    TreeVectorLeafSequence treeVectorLeaf_;
    SubTreeVectorSequence subTreeVector_;
    IdOptional id_;
    CaptionOptional caption_;
    ExcludeFromVectorOptional excludeFromVector_;
    ClassNameOptional className_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TreeVectorLeafXML schema type.
   *
   * @nosubgrouping
   */
  class TreeVectorLeafXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name unit
     *
     * @brief Accessor and modifier functions for the %unit
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String UnitType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnitType > UnitOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitType, char > UnitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnitOptional&
    getUnit () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UnitOptional&
    getUnit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUnit (const UnitType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUnit (const UnitOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnit (::std::auto_ptr< UnitType > p);

    //@}

    /**
     * @name missingValue
     *
     * @brief Accessor and modifier functions for the %missingValue
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double MissingValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MissingValueType > MissingValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MissingValueType, char, ::xsd::cxx::tree::schema_type::double_ > MissingValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MissingValueOptional&
    getMissingValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MissingValueOptional&
    getMissingValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMissingValue (const MissingValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMissingValue (const MissingValueOptional& x);

    //@}

    /**
     * @name dimensions
     *
     * @brief Accessor and modifier functions for the %dimensions
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::DimensionsXML DimensionsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DimensionsType > DimensionsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DimensionsType, char > DimensionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DimensionsOptional&
    getDimensions () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DimensionsOptional&
    getDimensions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDimensions (const DimensionsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDimensions (const DimensionsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDimensions (::std::auto_ptr< DimensionsType > p);

    //@}

    /**
     * @name grid
     *
     * @brief Accessor and modifier functions for the %grid
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::GridXML GridType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GridType > GridOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GridType, char > GridTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GridOptional&
    getGrid () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GridOptional&
    getGrid ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGrid (const GridType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGrid (const GridOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGrid (::std::auto_ptr< GridType > p);

    //@}

    /**
     * @name vector
     *
     * @brief Accessor and modifier functions for the %vector
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::VectorXML VectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VectorType, char > VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const VectorType&
    getVector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    VectorType&
    getVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVector (const VectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setVector (::std::auto_ptr< VectorType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdOptional&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    IdOptional&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setId (const IdOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name caption
     *
     * @brief Accessor and modifier functions for the %caption
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String CaptionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CaptionType > CaptionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CaptionType, char > CaptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CaptionOptional&
    getCaption () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CaptionOptional&
    getCaption ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCaption (const CaptionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCaption (const CaptionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCaption (::std::auto_ptr< CaptionType > p);

    //@}

    /**
     * @name excludeFromVector
     *
     * @brief Accessor and modifier functions for the %excludeFromVector
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ExcludeFromVectorType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExcludeFromVectorType > ExcludeFromVectorOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExcludeFromVectorType, char > ExcludeFromVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExcludeFromVectorOptional&
    getExcludeFromVector () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ExcludeFromVectorOptional&
    getExcludeFromVector ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setExcludeFromVector (const ExcludeFromVectorType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setExcludeFromVector (const ExcludeFromVectorOptional& x);

    //@}

    /**
     * @name className
     *
     * @brief Accessor and modifier functions for the %className
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String ClassNameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ClassNameType > ClassNameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClassNameType, char > ClassNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ClassNameOptional&
    getClassName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ClassNameOptional&
    getClassName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setClassName (const ClassNameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setClassName (const ClassNameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setClassName (::std::auto_ptr< ClassNameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TreeVectorLeafXML (const VectorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TreeVectorLeafXML (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreeVectorLeafXML (const TreeVectorLeafXML& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TreeVectorLeafXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TreeVectorLeafXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UnitOptional unit_;
    MissingValueOptional missingValue_;
    DimensionsOptional dimensions_;
    GridOptional grid_;
    ::xsd::cxx::tree::one< VectorType > vector_;
    IdOptional id_;
    CaptionOptional caption_;
    ExcludeFromVectorOptional excludeFromVector_;
    ClassNameOptional className_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DimensionsXML schema type.
   *
   * @nosubgrouping
   */
  class DimensionsXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name dimSize1
     *
     * @brief Accessor and modifier functions for the %dimSize1
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DimSize1Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DimSize1Type, char > DimSize1Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DimSize1Type&
    getDimSize1 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DimSize1Type&
    getDimSize1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDimSize1 (const DimSize1Type& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDimSize1 (::std::auto_ptr< DimSize1Type > p);

    //@}

    /**
     * @name dimSize2
     *
     * @brief Accessor and modifier functions for the %dimSize2
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DimSize2Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DimSize2Type > DimSize2Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DimSize2Type, char > DimSize2Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DimSize2Optional&
    getDimSize2 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DimSize2Optional&
    getDimSize2 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDimSize2 (const DimSize2Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDimSize2 (const DimSize2Optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDimSize2 (::std::auto_ptr< DimSize2Type > p);

    //@}

    /**
     * @name dimSize3
     *
     * @brief Accessor and modifier functions for the %dimSize3
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DimSize3Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DimSize3Type > DimSize3Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DimSize3Type, char > DimSize3Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DimSize3Optional&
    getDimSize3 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DimSize3Optional&
    getDimSize3 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDimSize3 (const DimSize3Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDimSize3 (const DimSize3Optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDimSize3 (::std::auto_ptr< DimSize3Type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DimensionsXML (const DimSize1Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DimensionsXML (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DimensionsXML (const DimensionsXML& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DimensionsXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DimensionsXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DimSize1Type > dimSize1_;
    DimSize2Optional dimSize2_;
    DimSize3Optional dimSize3_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GridXML schema type.
   *
   * @nosubgrouping
   */
  class GridXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name computationalSpace
     *
     * @brief Accessor and modifier functions for the %computationalSpace
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::ComputationalSpaceXML ComputationalSpaceType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComputationalSpaceType, char > ComputationalSpaceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ComputationalSpaceType&
    getComputationalSpace () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ComputationalSpaceType&
    getComputationalSpace ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComputationalSpace (const ComputationalSpaceType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setComputationalSpace (::std::auto_ptr< ComputationalSpaceType > p);

    //@}

    /**
     * @name physicalSpace
     *
     * @brief Accessor and modifier functions for the %physicalSpace
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::PhysicalSpaceXML PhysicalSpaceType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PhysicalSpaceType > PhysicalSpaceOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PhysicalSpaceType, char > PhysicalSpaceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PhysicalSpaceOptional&
    getPhysicalSpace () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PhysicalSpaceOptional&
    getPhysicalSpace ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPhysicalSpace (const PhysicalSpaceType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPhysicalSpace (const PhysicalSpaceOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPhysicalSpace (::std::auto_ptr< PhysicalSpaceType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GridXML (const ComputationalSpaceType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GridXML (::std::auto_ptr< ComputationalSpaceType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GridXML (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GridXML (const GridXML& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GridXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GridXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ComputationalSpaceType > computationalSpace_;
    PhysicalSpaceOptional physicalSpace_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ComputationalSpaceXML schema type.
   *
   * @nosubgrouping
   */
  class ComputationalSpaceXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name dimension
     *
     * @brief Accessor and modifier functions for the %dimension
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::ComputationalDimensionXML DimensionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DimensionType > DimensionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DimensionSequence::iterator DimensionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DimensionSequence::const_iterator DimensionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DimensionType, char > DimensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DimensionSequence&
    getDimension () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DimensionSequence&
    getDimension ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDimension (const DimensionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ComputationalSpaceXML ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComputationalSpaceXML (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComputationalSpaceXML (const ComputationalSpaceXML& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ComputationalSpaceXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ComputationalSpaceXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DimensionSequence dimension_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ComputationalDimensionXML schema type.
   *
   * @nosubgrouping
   */
  class ComputationalDimensionXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name length
     *
     * @brief Accessor and modifier functions for the %length
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int LengthType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LengthType, char > LengthTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LengthType&
    getLength () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LengthType&
    getLength ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLength (const LengthType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ComputationalDimensionXML (const IdType&,
                               const LengthType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComputationalDimensionXML (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComputationalDimensionXML (const ComputationalDimensionXML& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ComputationalDimensionXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ComputationalDimensionXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< LengthType > length_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PhysicalSpaceXML schema type.
   *
   * @nosubgrouping
   */
  class PhysicalSpaceXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name dimension
     *
     * @brief Accessor and modifier functions for the %dimension
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::openda::PhysicalDimensionXML DimensionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DimensionType > DimensionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DimensionSequence::iterator DimensionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DimensionSequence::const_iterator DimensionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DimensionType, char > DimensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DimensionSequence&
    getDimension () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DimensionSequence&
    getDimension ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDimension (const DimensionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PhysicalSpaceXML ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PhysicalSpaceXML (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PhysicalSpaceXML (const PhysicalSpaceXML& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PhysicalSpaceXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PhysicalSpaceXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DimensionSequence dimension_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PhysicalDimensionXML schema type.
   *
   * @nosubgrouping
   */
  class PhysicalDimensionXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name axes
     *
     * @brief Accessor and modifier functions for the %axes
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String AxesType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AxesType, char > AxesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const AxesType&
    getAxes () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    AxesType&
    getAxes ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAxes (const AxesType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAxes (::std::auto_ptr< AxesType > p);

    //@}

    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PhysicalDimensionXML (const IdType&,
                          const AxesType&,
                          const RefType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PhysicalDimensionXML (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PhysicalDimensionXML (const PhysicalDimensionXML& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PhysicalDimensionXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PhysicalDimensionXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< AxesType > axes_;
    ::xsd::cxx::tree::one< RefType > ref_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MetaInfoXML schema type.
   *
   * @nosubgrouping
   */
  class MetaInfoXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdOptional&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    IdOptional&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setId (const IdOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MetaInfoXML ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetaInfoXML (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetaInfoXML (const MetaInfoXML& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MetaInfoXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MetaInfoXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    IdOptional id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateTimeXML schema type.
   *
   * @nosubgrouping
   */
  class DateTimeXML: public ::xml_schema::Type
  {
    public:
    /**
     * @name date
     *
     * @brief Accessor and modifier functions for the %date
     * required attribute.
     *
     * ISO 8601 (yyyy-mm-dd)
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::openda::DateXML DateType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateType, char > DateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DateType&
    getDate () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DateType&
    getDate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDate (const DateType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDate (::std::auto_ptr< DateType > p);

    //@}

    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * ISO 8601 (hh:mm:ss[.msec])
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::openda::TimeXML TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::auto_ptr< TimeType > p);

    //@}

    /**
     * @name timeZone
     *
     * @brief Accessor and modifier functions for the %timeZone
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::openda::TimeZoneXML TimeZoneType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeZoneType > TimeZoneOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeZoneType, char > TimeZoneTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeZoneOptional&
    getTimeZone () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TimeZoneOptional&
    getTimeZone ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTimeZone (const TimeZoneType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setTimeZone (const TimeZoneOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeZone (::std::auto_ptr< TimeZoneType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateTimeXML (const DateType&,
                 const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateTimeXML (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateTimeXML (const DateTimeXML& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateTimeXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateTimeXML ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DateType > date_;
    ::xsd::cxx::tree::one< TimeType > time_;
    TimeZoneOptional timeZone_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateXML schema type.
   *
   * @nosubgrouping
   */
  class DateXML: public ::xml_schema::Date
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateXML (const ::xml_schema::Date&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateXML (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateXML (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateXML (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateXML (const DateXML& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateXML ();
  };

  /**
   * @brief Class corresponding to the %TimeXML schema type.
   *
   * @nosubgrouping
   */
  class TimeXML: public ::xml_schema::Time
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeXML (const ::xml_schema::Time&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeXML (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeXML (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeXML (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeXML (const TimeXML& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeXML ();
  };

  /**
   * @brief Class corresponding to the %VectorXML schema type.
   *
   * @nosubgrouping
   */
  class VectorXML: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    VectorXML ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    VectorXML (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    VectorXML (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VectorXML (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorXML (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorXML (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorXML (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorXML (const VectorXML& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VectorXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VectorXML ();
  };

  /**
   * @brief Class corresponding to the %TimeZoneXML schema type.
   *
   * @nosubgrouping
   */
  class TimeZoneXML: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    TimeZoneXML ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    TimeZoneXML (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    TimeZoneXML (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeZoneXML (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeZoneXML (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeZoneXML (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeZoneXML (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeZoneXML (const TimeZoneXML& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeZoneXML*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeZoneXML ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace openda
{
  /**
   * @name Parsing functions for the %treeVectorFile document root.
   *
   * Costa / DATools Tree Vector File
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::std::string& uri,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::std::string& uri,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::std::string& uri,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       const ::std::string& id,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       const ::std::string& id,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       const ::std::string& id,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xercesc::InputSource& is,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xercesc::InputSource& is,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xercesc::InputSource& is,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::xercesc::DOMDocument& d,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace openda
{
  /**
   * @name Serialization functions for the %treeVectorFile document root.
   *
   * Costa / DATools Tree Vector File
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeTreeVectorFile (::std::ostream& os,
                           const ::openda::TreeVectorFileXML& x, 
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeTreeVectorFile (::std::ostream& os,
                           const ::openda::TreeVectorFileXML& x, 
                           ::xml_schema::ErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeTreeVectorFile (::std::ostream& os,
                           const ::openda::TreeVectorFileXML& x, 
                           ::xercesc::DOMErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeTreeVectorFile (::xercesc::XMLFormatTarget& ft,
                           const ::openda::TreeVectorFileXML& x, 
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeTreeVectorFile (::xercesc::XMLFormatTarget& ft,
                           const ::openda::TreeVectorFileXML& x, 
                           ::xml_schema::ErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeTreeVectorFile (::xercesc::XMLFormatTarget& ft,
                           const ::openda::TreeVectorFileXML& x, 
                           ::xercesc::DOMErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  serializeTreeVectorFile (::xercesc::DOMDocument& d,
                           const ::openda::TreeVectorFileXML& x,
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeTreeVectorFile (const ::openda::TreeVectorFileXML& x, 
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           ::xml_schema::Flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const TreeVectorFileXML&);

  void
  operator<< (::xercesc::DOMElement&, const TreeVectorXML&);

  void
  operator<< (::xercesc::DOMElement&, const TreeVectorLeafXML&);

  void
  operator<< (::xercesc::DOMElement&, const DimensionsXML&);

  void
  operator<< (::xercesc::DOMElement&, const GridXML&);

  void
  operator<< (::xercesc::DOMElement&, const ComputationalSpaceXML&);

  void
  operator<< (::xercesc::DOMElement&, const ComputationalDimensionXML&);

  void
  operator<< (::xercesc::DOMElement&, const PhysicalSpaceXML&);

  void
  operator<< (::xercesc::DOMElement&, const PhysicalDimensionXML&);

  void
  operator<< (::xercesc::DOMElement&, const MetaInfoXML&);

  void
  operator<< (::xercesc::DOMElement&, const DateTimeXML&);

  void
  operator<< (::xercesc::DOMElement&, const DateXML&);

  void
  operator<< (::xercesc::DOMAttr&, const DateXML&);

  void
  operator<< (::xml_schema::ListStream&,
              const DateXML&);

  void
  operator<< (::xercesc::DOMElement&, const TimeXML&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeXML&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeXML&);

  void
  operator<< (::xercesc::DOMElement&, const VectorXML&);

  void
  operator<< (::xercesc::DOMAttr&, const VectorXML&);

  void
  operator<< (::xml_schema::ListStream&,
              const VectorXML&);

  void
  operator<< (::xercesc::DOMElement&, const TimeZoneXML&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeZoneXML&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeZoneXML&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // TREE_VECTOR_HXX
