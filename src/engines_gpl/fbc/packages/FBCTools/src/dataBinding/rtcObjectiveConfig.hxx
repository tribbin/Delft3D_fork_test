// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from rtcObjectiveConfig.xsd.
 */

#ifndef RTC_OBJECTIVE_CONFIG_HXX
#define RTC_OBJECTIVE_CONFIG_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace fews
{
  class RtcObjectiveConfigComplexType;
  class VariablesComplexType;
  class VariableComplexType;
  class AggregationComplexType;
  class AggregationEquidistantComplexType;
  class AggregationNonEquidistantComplexType;
  class ConstraintsComplexType;
  class ConstraintChoiceComplexType;
  class BoundVariableComplexType;
  class BoundVariableRateOfChangeComplexType;
  class BoundVariableAverageComplexType;
  class BoundAverageComplexType;
  class MultipleDelayComplexType;
  class BoundStateComplexType;
  class StateAverageComplexType;
  class BoundStateStepIndicesComplexType;
  class BoundStateComponentsComplexType;
  class BoundStateVariablesComplexType;
  class ChanceVariableComplexType;
  class TermComplexType;
  class TermEnsembleComplexType;
  class TermChoiceComplexType;
  class TermEnsembleChoiceComplexType;
  class TermAbsoluteComplexType;
  class ChanceConstraintComplexType;
  class AverageComplexType;
  class TermLinearComplexType;
  class TermRateOfChangeComplexType;
  class TermMaxComplexType;
  class TermMSEComplexType;
  class TermRMSEComplexType;
  class TermNSEComplexType;
  class TermRelativeVolumeComplexType;
  class TermRVComplexType;
  class TermSumComplexType;
  class OutputComplexType;
  class NStepModeEnum;
  class NStep;
  class NStep1;
  class NStep2;
  class NStep3;
  class StepIndex;
  class NStep4;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "rtcSharedTypes.hxx"

/**
 * @brief C++ namespace for the %http://www.wldelft.nl/fews
 * schema namespace.
 */
namespace fews
{
  /**
   * @brief Class corresponding to the %RtcObjectiveConfigComplexType schema type.
   *
   * @nosubgrouping
   */
  class RtcObjectiveConfigComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variables
     *
     * @brief Accessor and modifier functions for the %variables
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::VariablesComplexType VariablesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VariablesType > VariablesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariablesType, char > VariablesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VariablesOptional&
    getVariables () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VariablesOptional&
    getVariables ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariables (const VariablesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVariables (const VariablesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVariables (::std::auto_ptr< VariablesType > p);

    //@}

    /**
     * @name constraints
     *
     * @brief Accessor and modifier functions for the %constraints
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ConstraintsComplexType ConstraintsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConstraintsType > ConstraintsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstraintsType, char > ConstraintsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConstraintsOptional&
    getConstraints () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ConstraintsOptional&
    getConstraints ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstraints (const ConstraintsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstraints (const ConstraintsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConstraints (::std::auto_ptr< ConstraintsType > p);

    //@}

    /**
     * @name terms
     *
     * @brief Accessor and modifier functions for the %terms
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermComplexType TermsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TermsType > TermsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TermsType, char > TermsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TermsOptional&
    getTerms () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TermsOptional&
    getTerms ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTerms (const TermsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTerms (const TermsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTerms (::std::auto_ptr< TermsType > p);

    //@}

    /**
     * @name termsEnsemble
     *
     * @brief Accessor and modifier functions for the %termsEnsemble
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermEnsembleComplexType TermsEnsembleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TermsEnsembleType > TermsEnsembleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TermsEnsembleType, char > TermsEnsembleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TermsEnsembleOptional&
    getTermsEnsemble () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TermsEnsembleOptional&
    getTermsEnsemble ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTermsEnsemble (const TermsEnsembleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTermsEnsemble (const TermsEnsembleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTermsEnsemble (::std::auto_ptr< TermsEnsembleType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputComplexType OutputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OutputType > OutputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OutputOptional&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OutputOptional&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOutput (const OutputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RtcObjectiveConfigComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RtcObjectiveConfigComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RtcObjectiveConfigComplexType (const RtcObjectiveConfigComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RtcObjectiveConfigComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RtcObjectiveConfigComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariablesOptional variables_;
    ConstraintsOptional constraints_;
    TermsOptional terms_;
    TermsEnsembleOptional termsEnsemble_;
    OutputOptional output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VariablesComplexType schema type.
   *
   * @nosubgrouping
   */
  class VariablesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::VariableComplexType VariableType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;

    /**
     * @brief Element iterator type.
     */
    typedef VariableSequence::iterator VariableIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef VariableSequence::const_iterator VariableConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const VariableSequence&
    getVariable () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    VariableSequence&
    getVariable ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setVariable (const VariableSequence& s);

    //@}

    /**
     * @name aggregation
     *
     * @brief Accessor and modifier functions for the %aggregation
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AggregationComplexType AggregationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AggregationType > AggregationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AggregationType, char > AggregationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AggregationOptional&
    getAggregation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AggregationOptional&
    getAggregation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAggregation (const AggregationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAggregation (const AggregationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAggregation (::std::auto_ptr< AggregationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VariablesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VariablesComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VariablesComplexType (const VariablesComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VariablesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VariablesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariableSequence variable_;
    AggregationOptional aggregation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VariableComplexType schema type.
   *
   * @nosubgrouping
   */
  class VariableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name aggregation
     *
     * @brief Accessor and modifier functions for the %aggregation
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AggregationComplexType AggregationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AggregationType > AggregationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AggregationType, char > AggregationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AggregationOptional&
    getAggregation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AggregationOptional&
    getAggregation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAggregation (const AggregationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAggregation (const AggregationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAggregation (::std::auto_ptr< AggregationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::TimeSeriesSimpleType IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::VariableTypeEnumStringType TypeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TypeType&
    getType () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TypeType&
    getType ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setType (::std::auto_ptr< TypeType > p);

    //@}

    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalBooleanSimpleType ActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ActiveType&
    getActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ActiveType&
    getActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActive (const ActiveType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setActive (::std::auto_ptr< ActiveType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const ActiveType&
    getActiveDefaultValue ();

    //@}

    /**
     * @name min
     *
     * @brief Accessor and modifier functions for the %min
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalParameterSimpleType MinType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MinType > MinOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MinOptional&
    getMin () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MinOptional&
    getMin ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMin (const MinType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMin (const MinOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMin (::std::auto_ptr< MinType > p);

    //@}

    /**
     * @name max
     *
     * @brief Accessor and modifier functions for the %max
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalParameterSimpleType MaxType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxType > MaxOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxOptional&
    getMax () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxOptional&
    getMax ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMax (const MaxType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMax (const MaxOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMax (::std::auto_ptr< MaxType > p);

    //@}

    /**
     * @name scalingFactor
     *
     * @brief Accessor and modifier functions for the %scalingFactor
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ScalingFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ScalingFactorType, char, ::xsd::cxx::tree::schema_type::double_ > ScalingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ScalingFactorType&
    getScalingFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ScalingFactorType&
    getScalingFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setScalingFactor (const ScalingFactorType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static ScalingFactorType
    getScalingFactorDefaultValue ();

    //@}

    /**
     * @name ensembleMode
     *
     * @brief Accessor and modifier functions for the %ensembleMode
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::EnsembleModeEnumStringType EnsembleModeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< EnsembleModeType, char > EnsembleModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const EnsembleModeType&
    getEnsembleMode () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    EnsembleModeType&
    getEnsembleMode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEnsembleMode (const EnsembleModeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEnsembleMode (::std::auto_ptr< EnsembleModeType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const EnsembleModeType&
    getEnsembleModeDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VariableComplexType (const IdType&,
                         const TypeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VariableComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VariableComplexType (const VariableComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VariableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VariableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AggregationOptional aggregation_;
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< ActiveType > active_;
    static const ActiveType active_default_value_;
    MinOptional min_;
    MaxOptional max_;
    ::xsd::cxx::tree::one< ScalingFactorType > scalingFactor_;
    ::xsd::cxx::tree::one< EnsembleModeType > ensembleMode_;
    static const EnsembleModeType ensembleMode_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AggregationComplexType schema type.
   *
   * @nosubgrouping
   */
  class AggregationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name constant
     *
     * @brief Accessor and modifier functions for the %constant
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::SimpleType ConstantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConstantType > ConstantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstantType, char > ConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConstantOptional&
    getConstant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ConstantOptional&
    getConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstant (const ConstantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstant (const ConstantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConstant (::std::auto_ptr< ConstantType > p);

    //@}

    /**
     * @name equidistant
     *
     * @brief Accessor and modifier functions for the %equidistant
     * optional element.
     *
     * aggregation with equidistent steps, note that the number of time steps
     * in the model needs to be a multiple of the aggregation step, i.e.
     * 2,4,6,8 steps in case of an aggregation step of 2
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AggregationEquidistantComplexType EquidistantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EquidistantType > EquidistantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EquidistantType, char > EquidistantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EquidistantOptional&
    getEquidistant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EquidistantOptional&
    getEquidistant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEquidistant (const EquidistantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEquidistant (const EquidistantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEquidistant (::std::auto_ptr< EquidistantType > p);

    //@}

    /**
     * @name non-equidistant
     *
     * @brief Accessor and modifier functions for the %non-equidistant
     * optional element.
     *
     * still not implemented
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AggregationNonEquidistantComplexType Non_equidistantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Non_equidistantType > Non_equidistantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Non_equidistantType, char > Non_equidistantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Non_equidistantOptional&
    getNon_equidistant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Non_equidistantOptional&
    getNon_equidistant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNon_equidistant (const Non_equidistantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNon_equidistant (const Non_equidistantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNon_equidistant (::std::auto_ptr< Non_equidistantType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AggregationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AggregationComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AggregationComplexType (const AggregationComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AggregationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AggregationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ConstantOptional constant_;
    EquidistantOptional equidistant_;
    Non_equidistantOptional non_equidistant_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AggregationEquidistantComplexType schema type.
   *
   * @nosubgrouping
   */
  class AggregationEquidistantComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required element.
     *
     * interpolation type: block or linear
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AggregationTypeEnumStringType TypeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TypeType&
    getType () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TypeType&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setType (::std::auto_ptr< TypeType > p);

    //@}

    /**
     * @name nAggregationSteps
     *
     * @brief Accessor and modifier functions for the %nAggregationSteps
     * required element.
     *
     * aggregation, simulation time nOutputSteps (simulation) = nInputSteps
     * (optimizer) * nAggregationSteps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer NAggregationStepsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NAggregationStepsType, char > NAggregationStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NAggregationStepsType&
    getNAggregationSteps () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NAggregationStepsType&
    getNAggregationSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNAggregationSteps (const NAggregationStepsType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AggregationEquidistantComplexType (const TypeType&,
                                       const NAggregationStepsType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AggregationEquidistantComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AggregationEquidistantComplexType (const AggregationEquidistantComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AggregationEquidistantComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AggregationEquidistantComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< NAggregationStepsType > nAggregationSteps_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AggregationNonEquidistantComplexType schema type.
   *
   * @nosubgrouping
   */
  class AggregationNonEquidistantComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required element.
     *
     * interpolation type: block or linear
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AggregationTypeEnumStringType TypeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TypeType&
    getType () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TypeType&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setType (::std::auto_ptr< TypeType > p);

    //@}

    /**
     * @name nInputSteps
     *
     * @brief Accessor and modifier functions for the %nInputSteps
     * required element.
     *
     * number of input time steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer NInputStepsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NInputStepsType, char > NInputStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NInputStepsType&
    getNInputSteps () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NInputStepsType&
    getNInputSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNInputSteps (const NInputStepsType& x);

    //@}

    /**
     * @name nOutputSteps
     *
     * @brief Accessor and modifier functions for the %nOutputSteps
     * required element.
     *
     * number of output time steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer NOutputStepsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NOutputStepsType, char > NOutputStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NOutputStepsType&
    getNOutputSteps () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NOutputStepsType&
    getNOutputSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNOutputSteps (const NOutputStepsType& x);

    //@}

    /**
     * @name stepIndex
     *
     * @brief Accessor and modifier functions for the %stepIndex
     * sequence element.
     *
     * time step indices (indexing starts from 1) on which input data is
     * located, the has to be data on the last time step!
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer StepIndexType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< StepIndexType > StepIndexSequence;

    /**
     * @brief Element iterator type.
     */
    typedef StepIndexSequence::iterator StepIndexIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef StepIndexSequence::const_iterator StepIndexConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StepIndexType, char > StepIndexTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const StepIndexSequence&
    getStepIndex () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    StepIndexSequence&
    getStepIndex ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setStepIndex (const StepIndexSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AggregationNonEquidistantComplexType (const TypeType&,
                                          const NInputStepsType&,
                                          const NOutputStepsType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AggregationNonEquidistantComplexType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AggregationNonEquidistantComplexType (const AggregationNonEquidistantComplexType& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AggregationNonEquidistantComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AggregationNonEquidistantComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< NInputStepsType > nInputSteps_;
    ::xsd::cxx::tree::one< NOutputStepsType > nOutputSteps_;
    StepIndexSequence stepIndex_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConstraintsComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConstraintsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name constraint
     *
     * @brief Accessor and modifier functions for the %constraint
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ConstraintChoiceComplexType ConstraintType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ConstraintType > ConstraintSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ConstraintSequence::iterator ConstraintIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ConstraintSequence::const_iterator ConstraintConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstraintType, char > ConstraintTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ConstraintSequence&
    getConstraint () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ConstraintSequence&
    getConstraint ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setConstraint (const ConstraintSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConstraintsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConstraintsComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConstraintsComplexType (const ConstraintsComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConstraintsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConstraintsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ConstraintSequence constraint_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConstraintChoiceComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConstraintChoiceComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name boundVariable
     *
     * @brief Accessor and modifier functions for the %boundVariable
     * optional element.
     *
     * implement bounds on the optimization variable
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundVariableComplexType BoundVariableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BoundVariableType > BoundVariableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BoundVariableType, char > BoundVariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BoundVariableOptional&
    getBoundVariable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BoundVariableOptional&
    getBoundVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBoundVariable (const BoundVariableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBoundVariable (const BoundVariableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBoundVariable (::std::auto_ptr< BoundVariableType > p);

    //@}

    /**
     * @name boundVariableAverage
     *
     * @brief Accessor and modifier functions for the %boundVariableAverage
     * optional element.
     *
     * defines a bound on an average value of an optimization variable for
     * example to enable min/max bounds on aggregated time series
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundVariableAverageComplexType BoundVariableAverageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BoundVariableAverageType > BoundVariableAverageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BoundVariableAverageType, char > BoundVariableAverageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BoundVariableAverageOptional&
    getBoundVariableAverage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BoundVariableAverageOptional&
    getBoundVariableAverage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBoundVariableAverage (const BoundVariableAverageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBoundVariableAverage (const BoundVariableAverageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBoundVariableAverage (::std::auto_ptr< BoundVariableAverageType > p);

    //@}

    /**
     * @name boundVariableRateOfChange
     *
     * @brief Accessor and modifier functions for the %boundVariableRateOfChange
     * optional element.
     *
     * implements bounds on the rate-of-change of an optimization variable
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundVariableRateOfChangeComplexType BoundVariableRateOfChangeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BoundVariableRateOfChangeType > BoundVariableRateOfChangeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BoundVariableRateOfChangeType, char > BoundVariableRateOfChangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BoundVariableRateOfChangeOptional&
    getBoundVariableRateOfChange () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BoundVariableRateOfChangeOptional&
    getBoundVariableRateOfChange ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBoundVariableRateOfChange (const BoundVariableRateOfChangeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBoundVariableRateOfChange (const BoundVariableRateOfChangeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBoundVariableRateOfChange (::std::auto_ptr< BoundVariableRateOfChangeType > p);

    //@}

    /**
     * @name boundState
     *
     * @brief Accessor and modifier functions for the %boundState
     * optional element.
     *
     * implements bounds on states or model outputs
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundStateComplexType BoundStateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BoundStateType > BoundStateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BoundStateType, char > BoundStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BoundStateOptional&
    getBoundState () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BoundStateOptional&
    getBoundState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBoundState (const BoundStateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBoundState (const BoundStateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBoundState (::std::auto_ptr< BoundStateType > p);

    //@}

    /**
     * @name chanceBoundVariable
     *
     * @brief Accessor and modifier functions for the %chanceBoundVariable
     * optional element.
     *
     * implement chance constraints on the optimization variable
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ChanceVariableComplexType ChanceBoundVariableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChanceBoundVariableType > ChanceBoundVariableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChanceBoundVariableType, char > ChanceBoundVariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChanceBoundVariableOptional&
    getChanceBoundVariable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ChanceBoundVariableOptional&
    getChanceBoundVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setChanceBoundVariable (const ChanceBoundVariableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setChanceBoundVariable (const ChanceBoundVariableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setChanceBoundVariable (::std::auto_ptr< ChanceBoundVariableType > p);

    //@}

    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalBooleanSimpleType ActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ActiveType&
    getActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ActiveType&
    getActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActive (const ActiveType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setActive (::std::auto_ptr< ActiveType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const ActiveType&
    getActiveDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConstraintChoiceComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConstraintChoiceComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConstraintChoiceComplexType (const ConstraintChoiceComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConstraintChoiceComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConstraintChoiceComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    BoundVariableOptional boundVariable_;
    BoundVariableAverageOptional boundVariableAverage_;
    BoundVariableRateOfChangeOptional boundVariableRateOfChange_;
    BoundStateOptional boundState_;
    ChanceBoundVariableOptional chanceBoundVariable_;
    ::xsd::cxx::tree::one< ActiveType > active_;
    static const ActiveType active_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundVariableComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundVariableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * required element.
     *
     * reference to the time series in the time series database (refers to
     * the file 'rtcDataConfig.xml')
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const VariableType&
    getVariable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    VariableType&
    getVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariable (const VariableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setVariable (::std::auto_ptr< VariableType > p);

    //@}

    /**
     * @name upperBound
     *
     * @brief Accessor and modifier functions for the %upperBound
     * optional element.
     *
     * upper bound as a scalar value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType UpperBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundType > UpperBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundType, char > UpperBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundOptional&
    getUpperBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundOptional&
    getUpperBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBound (const UpperBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBound (const UpperBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBound (::std::auto_ptr< UpperBoundType > p);

    //@}

    /**
     * @name upperBoundSeries
     *
     * @brief Accessor and modifier functions for the %upperBoundSeries
     * optional element.
     *
     * upper bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpperBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundSeriesType > UpperBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundSeriesType, char > UpperBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundSeriesOptional&
    getUpperBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundSeriesOptional&
    getUpperBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > p);

    //@}

    /**
     * @name lowerBound
     *
     * @brief Accessor and modifier functions for the %lowerBound
     * optional element.
     *
     * lower bound as a scalar
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LowerBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundType > LowerBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundType, char > LowerBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundOptional&
    getLowerBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundOptional&
    getLowerBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBound (const LowerBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBound (const LowerBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBound (::std::auto_ptr< LowerBoundType > p);

    //@}

    /**
     * @name lowerBoundSeries
     *
     * @brief Accessor and modifier functions for the %lowerBoundSeries
     * optional element.
     *
     * lower bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LowerBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundSeriesType > LowerBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundSeriesType, char > LowerBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundSeriesOptional&
    getLowerBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundSeriesOptional&
    getLowerBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundVariableComplexType (const VariableType&,
                              const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundVariableComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundVariableComplexType (const BoundVariableComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundVariableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundVariableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< VariableType > variable_;
    UpperBoundOptional upperBound_;
    UpperBoundSeriesOptional upperBoundSeries_;
    LowerBoundOptional lowerBound_;
    LowerBoundSeriesOptional lowerBoundSeries_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundVariableRateOfChangeComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundVariableRateOfChangeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * required element.
     *
     * reference to the time series in the time series database (refers to
     * the file 'rtcDataConfig.xml')
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const VariableType&
    getVariable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    VariableType&
    getVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariable (const VariableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setVariable (::std::auto_ptr< VariableType > p);

    //@}

    /**
     * @name multipleDelay
     *
     * @brief Accessor and modifier functions for the %multipleDelay
     * optional element.
     *
     * option to look back more than a single time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MultipleDelayComplexType MultipleDelayType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MultipleDelayType > MultipleDelayOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultipleDelayType, char > MultipleDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MultipleDelayOptional&
    getMultipleDelay () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MultipleDelayOptional&
    getMultipleDelay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMultipleDelay (const MultipleDelayType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMultipleDelay (const MultipleDelayOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMultipleDelay (::std::auto_ptr< MultipleDelayType > p);

    //@}

    /**
     * @name upperBound
     *
     * @brief Accessor and modifier functions for the %upperBound
     * optional element.
     *
     * upper bound as a scalar value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType UpperBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundType > UpperBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundType, char > UpperBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundOptional&
    getUpperBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundOptional&
    getUpperBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBound (const UpperBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBound (const UpperBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBound (::std::auto_ptr< UpperBoundType > p);

    //@}

    /**
     * @name upperBoundSeries
     *
     * @brief Accessor and modifier functions for the %upperBoundSeries
     * optional element.
     *
     * upper bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpperBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundSeriesType > UpperBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundSeriesType, char > UpperBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundSeriesOptional&
    getUpperBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundSeriesOptional&
    getUpperBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > p);

    //@}

    /**
     * @name lowerBound
     *
     * @brief Accessor and modifier functions for the %lowerBound
     * optional element.
     *
     * lower bound as a scalar
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LowerBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundType > LowerBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundType, char > LowerBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundOptional&
    getLowerBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundOptional&
    getLowerBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBound (const LowerBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBound (const LowerBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBound (::std::auto_ptr< LowerBoundType > p);

    //@}

    /**
     * @name lowerBoundSeries
     *
     * @brief Accessor and modifier functions for the %lowerBoundSeries
     * optional element.
     *
     * lower bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LowerBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundSeriesType > LowerBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundSeriesType, char > LowerBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundSeriesOptional&
    getLowerBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundSeriesOptional&
    getLowerBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundVariableRateOfChangeComplexType (const VariableType&,
                                          const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundVariableRateOfChangeComplexType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundVariableRateOfChangeComplexType (const BoundVariableRateOfChangeComplexType& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundVariableRateOfChangeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundVariableRateOfChangeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< VariableType > variable_;
    MultipleDelayOptional multipleDelay_;
    UpperBoundOptional upperBound_;
    UpperBoundSeriesOptional upperBoundSeries_;
    LowerBoundOptional lowerBound_;
    LowerBoundSeriesOptional lowerBoundSeries_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundVariableAverageComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundVariableAverageComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * required element.
     *
     * reference to the time series in the time series database (refers to
     * the file 'rtcDataConfig.xml')
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const VariableType&
    getVariable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    VariableType&
    getVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariable (const VariableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setVariable (::std::auto_ptr< VariableType > p);

    //@}

    /**
     * @name average
     *
     * @brief Accessor and modifier functions for the %average
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundAverageComplexType AverageType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AverageType, char > AverageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AverageType&
    getAverage () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AverageType&
    getAverage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAverage (const AverageType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAverage (::std::auto_ptr< AverageType > p);

    //@}

    /**
     * @name upperBound
     *
     * @brief Accessor and modifier functions for the %upperBound
     * optional element.
     *
     * upper bound as a scalar value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType UpperBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundType > UpperBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundType, char > UpperBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundOptional&
    getUpperBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundOptional&
    getUpperBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBound (const UpperBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBound (const UpperBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBound (::std::auto_ptr< UpperBoundType > p);

    //@}

    /**
     * @name upperBoundSeries
     *
     * @brief Accessor and modifier functions for the %upperBoundSeries
     * optional element.
     *
     * upper bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpperBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundSeriesType > UpperBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundSeriesType, char > UpperBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundSeriesOptional&
    getUpperBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundSeriesOptional&
    getUpperBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > p);

    //@}

    /**
     * @name lowerBound
     *
     * @brief Accessor and modifier functions for the %lowerBound
     * optional element.
     *
     * lower bound as a scalar
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LowerBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundType > LowerBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundType, char > LowerBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundOptional&
    getLowerBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundOptional&
    getLowerBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBound (const LowerBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBound (const LowerBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBound (::std::auto_ptr< LowerBoundType > p);

    //@}

    /**
     * @name lowerBoundSeries
     *
     * @brief Accessor and modifier functions for the %lowerBoundSeries
     * optional element.
     *
     * lower bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LowerBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundSeriesType > LowerBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundSeriesType, char > LowerBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundSeriesOptional&
    getLowerBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundSeriesOptional&
    getLowerBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundVariableAverageComplexType (const VariableType&,
                                     const AverageType&,
                                     const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    BoundVariableAverageComplexType (const VariableType&,
                                     ::std::auto_ptr< AverageType >&,
                                     const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundVariableAverageComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundVariableAverageComplexType (const BoundVariableAverageComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundVariableAverageComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundVariableAverageComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< VariableType > variable_;
    ::xsd::cxx::tree::one< AverageType > average_;
    UpperBoundOptional upperBound_;
    UpperBoundSeriesOptional upperBoundSeries_;
    LowerBoundOptional lowerBound_;
    LowerBoundSeriesOptional lowerBoundSeries_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundAverageComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundAverageComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nStep
     *
     * @brief Accessor and modifier functions for the %nStep
     * optional element.
     *
     * fixed value for nStep
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NStep NStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepType > NStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepType, char > NStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepOptional&
    getNStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepOptional&
    getNStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStep (const NStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStep (const NStepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStep (::std::auto_ptr< NStepType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NStepType
    getNStepDefaultValue ();

    //@}

    /**
     * @name nStepSeries
     *
     * @brief Accessor and modifier functions for the %nStepSeries
     * optional element.
     *
     * nStep value is provided as a time series, the rate-of-change is
     * computed if the value is a positive integer
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NStepSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepSeriesType > NStepSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepSeriesType, char > NStepSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepSeriesOptional&
    getNStepSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepSeriesOptional&
    getNStepSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStepSeries (const NStepSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStepSeries (const NStepSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepSeries (::std::auto_ptr< NStepSeriesType > p);

    //@}

    /**
     * @name variableDelayVector
     *
     * @brief Accessor and modifier functions for the %variableDelayVector
     * optional element.
     *
     * optional vector with historical values (t less T0) to look into the
     * past, it is required for nStep>1, in case of the nStepSeries the user
     * may ensure to not refer to historical value and omit this element
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableDelayVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VariableDelayVectorType > VariableDelayVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableDelayVectorType, char > VariableDelayVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VariableDelayVectorOptional&
    getVariableDelayVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VariableDelayVectorOptional&
    getVariableDelayVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariableDelayVector (const VariableDelayVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVariableDelayVector (const VariableDelayVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVariableDelayVector (::std::auto_ptr< VariableDelayVectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundAverageComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundAverageComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundAverageComplexType (const BoundAverageComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundAverageComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundAverageComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NStepOptional nStep_;
    NStepSeriesOptional nStepSeries_;
    VariableDelayVectorOptional variableDelayVector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MultipleDelayComplexType schema type.
   *
   * @nosubgrouping
   */
  class MultipleDelayComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variableDelayVector
     *
     * @brief Accessor and modifier functions for the %variableDelayVector
     * optional element.
     *
     * optional vector with historical values (t less T0) to look into the
     * past, it is required for nStep>1, in case of the nStepSeries the user
     * may ensure to not refer to historical value and omit this element
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableDelayVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VariableDelayVectorType > VariableDelayVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableDelayVectorType, char > VariableDelayVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VariableDelayVectorOptional&
    getVariableDelayVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VariableDelayVectorOptional&
    getVariableDelayVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariableDelayVector (const VariableDelayVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVariableDelayVector (const VariableDelayVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVariableDelayVector (::std::auto_ptr< VariableDelayVectorType > p);

    //@}

    /**
     * @name nStep
     *
     * @brief Accessor and modifier functions for the %nStep
     * optional element.
     *
     * fixed value for nStep
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NStep1 NStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepType > NStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepType, char > NStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepOptional&
    getNStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepOptional&
    getNStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStep (const NStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStep (const NStepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStep (::std::auto_ptr< NStepType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NStepType
    getNStepDefaultValue ();

    //@}

    /**
     * @name nStepSeries
     *
     * @brief Accessor and modifier functions for the %nStepSeries
     * optional element.
     *
     * nStep value is provided as a time series, the rate-of-change is
     * computed if the value is a positive integer
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NStepSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepSeriesType > NStepSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepSeriesType, char > NStepSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepSeriesOptional&
    getNStepSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepSeriesOptional&
    getNStepSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStepSeries (const NStepSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStepSeries (const NStepSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepSeries (::std::auto_ptr< NStepSeriesType > p);

    //@}

    /**
     * @name nStepMode
     *
     * @brief Accessor and modifier functions for the %nStepMode
     * optional element.
     *
     * STEP only computes the difference between T0-nStep and T0, CONTINUOUS
     * computes the differences also at all intermediate steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NStepModeEnum NStepModeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepModeType > NStepModeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepModeType, char > NStepModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepModeOptional&
    getNStepMode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepModeOptional&
    getNStepMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStepMode (const NStepModeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStepMode (const NStepModeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepMode (::std::auto_ptr< NStepModeType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const NStepModeType&
    getNStepModeDefaultValue ();

    //@}

    /**
     * @name nStepCorrection
     *
     * @brief Accessor and modifier functions for the %nStepCorrection
     * optional element.
     *
     * if TRUE, the rate-of-change bounds are given as change per time step,
     * if FALSE, the bounds represent the total change over all time steps,
     * default is FALSE
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean NStepCorrectionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepCorrectionType > NStepCorrectionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepCorrectionType, char > NStepCorrectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepCorrectionOptional&
    getNStepCorrection () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepCorrectionOptional&
    getNStepCorrection ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStepCorrection (const NStepCorrectionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStepCorrection (const NStepCorrectionOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NStepCorrectionType
    getNStepCorrectionDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MultipleDelayComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MultipleDelayComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MultipleDelayComplexType (const MultipleDelayComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MultipleDelayComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MultipleDelayComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariableDelayVectorOptional variableDelayVector_;
    NStepOptional nStep_;
    NStepSeriesOptional nStepSeries_;
    NStepModeOptional nStepMode_;
    static const NStepModeType nStepMode_default_value_;
    NStepCorrectionOptional nStepCorrection_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundStateComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundStateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name components
     *
     * @brief Accessor and modifier functions for the %components
     * required element.
     *
     * simulation components (in the order of the simulation model) which
     * compute the state based on the variables (both defined below)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundStateComponentsComplexType ComponentsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentsType, char > ComponentsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ComponentsType&
    getComponents () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ComponentsType&
    getComponents ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComponents (const ComponentsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setComponents (::std::auto_ptr< ComponentsType > p);

    //@}

    /**
     * @name nStep
     *
     * @brief Accessor and modifier functions for the %nStep
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NStep2 NStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepType > NStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepType, char > NStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepOptional&
    getNStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepOptional&
    getNStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStep (const NStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStep (const NStepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStep (::std::auto_ptr< NStepType > p);

    //@}

    /**
     * @name stepIndices
     *
     * @brief Accessor and modifier functions for the %stepIndices
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundStateStepIndicesComplexType StepIndicesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StepIndicesType > StepIndicesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StepIndicesType, char > StepIndicesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StepIndicesOptional&
    getStepIndices () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StepIndicesOptional&
    getStepIndices ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStepIndices (const StepIndicesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStepIndices (const StepIndicesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStepIndices (::std::auto_ptr< StepIndicesType > p);

    //@}

    /**
     * @name variables
     *
     * @brief Accessor and modifier functions for the %variables
     * required element.
     *
     * references to the optimization variable which contribute to the
     * computation of the state
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BoundStateVariablesComplexType VariablesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariablesType, char > VariablesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const VariablesType&
    getVariables () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    VariablesType&
    getVariables ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariables (const VariablesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setVariables (::std::auto_ptr< VariablesType > p);

    //@}

    /**
     * @name state
     *
     * @brief Accessor and modifier functions for the %state
     * required element.
     *
     * reference to the state to constrain
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StateType&
    getState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StateType&
    getState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setState (::std::auto_ptr< StateType > p);

    //@}

    /**
     * @name average
     *
     * @brief Accessor and modifier functions for the %average
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StateAverageComplexType AverageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AverageType > AverageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AverageType, char > AverageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AverageOptional&
    getAverage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AverageOptional&
    getAverage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAverage (const AverageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAverage (const AverageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAverage (::std::auto_ptr< AverageType > p);

    //@}

    /**
     * @name upperBound
     *
     * @brief Accessor and modifier functions for the %upperBound
     * optional element.
     *
     * upper bound as a scalar value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType UpperBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundType > UpperBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundType, char > UpperBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundOptional&
    getUpperBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundOptional&
    getUpperBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBound (const UpperBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBound (const UpperBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBound (::std::auto_ptr< UpperBoundType > p);

    //@}

    /**
     * @name upperBoundSeries
     *
     * @brief Accessor and modifier functions for the %upperBoundSeries
     * optional element.
     *
     * upper bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpperBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundSeriesType > UpperBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundSeriesType, char > UpperBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundSeriesOptional&
    getUpperBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundSeriesOptional&
    getUpperBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > p);

    //@}

    /**
     * @name lowerBound
     *
     * @brief Accessor and modifier functions for the %lowerBound
     * optional element.
     *
     * lower bound as a scalar
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LowerBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundType > LowerBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundType, char > LowerBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundOptional&
    getLowerBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundOptional&
    getLowerBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBound (const LowerBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBound (const LowerBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBound (::std::auto_ptr< LowerBoundType > p);

    //@}

    /**
     * @name lowerBoundSeries
     *
     * @brief Accessor and modifier functions for the %lowerBoundSeries
     * optional element.
     *
     * lower bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LowerBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundSeriesType > LowerBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundSeriesType, char > LowerBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundSeriesOptional&
    getLowerBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundSeriesOptional&
    getLowerBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name scalingFactor
     *
     * @brief Accessor and modifier functions for the %scalingFactor
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ScalingFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ScalingFactorType, char, ::xsd::cxx::tree::schema_type::double_ > ScalingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ScalingFactorType&
    getScalingFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ScalingFactorType&
    getScalingFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setScalingFactor (const ScalingFactorType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static ScalingFactorType
    getScalingFactorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundStateComplexType (const ComponentsType&,
                           const VariablesType&,
                           const StateType&,
                           const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    BoundStateComplexType (::std::auto_ptr< ComponentsType >&,
                           ::std::auto_ptr< VariablesType >&,
                           const StateType&,
                           const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundStateComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundStateComplexType (const BoundStateComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundStateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundStateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ComponentsType > components_;
    NStepOptional nStep_;
    StepIndicesOptional stepIndices_;
    ::xsd::cxx::tree::one< VariablesType > variables_;
    ::xsd::cxx::tree::one< StateType > state_;
    AverageOptional average_;
    UpperBoundOptional upperBound_;
    UpperBoundSeriesOptional upperBoundSeries_;
    LowerBoundOptional lowerBound_;
    LowerBoundSeriesOptional lowerBoundSeries_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;
    ::xsd::cxx::tree::one< ScalingFactorType > scalingFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StateAverageComplexType schema type.
   *
   * @nosubgrouping
   */
  class StateAverageComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nStep
     *
     * @brief Accessor and modifier functions for the %nStep
     * optional element.
     *
     * fixed value for nStep
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NStep3 NStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepType > NStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepType, char > NStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepOptional&
    getNStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepOptional&
    getNStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStep (const NStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStep (const NStepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStep (::std::auto_ptr< NStepType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NStepType
    getNStepDefaultValue ();

    //@}

    /**
     * @name nStepSeries
     *
     * @brief Accessor and modifier functions for the %nStepSeries
     * optional element.
     *
     * nStep value is provided as a time series, the rate-of-change is
     * computed if the value is a positive integer
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NStepSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepSeriesType > NStepSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepSeriesType, char > NStepSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepSeriesOptional&
    getNStepSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepSeriesOptional&
    getNStepSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStepSeries (const NStepSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStepSeries (const NStepSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepSeries (::std::auto_ptr< NStepSeriesType > p);

    //@}

    /**
     * @name stateDelayVector
     *
     * @brief Accessor and modifier functions for the %stateDelayVector
     * required element.
     *
     * optional vector with historical values (t less T0) to look into the
     * past, it is required for nStep>1, in case of the nStepSeries the user
     * may ensure to not refer to historical value and omit this element
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StateDelayVectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateDelayVectorType, char > StateDelayVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StateDelayVectorType&
    getStateDelayVector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StateDelayVectorType&
    getStateDelayVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateDelayVector (const StateDelayVectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStateDelayVector (::std::auto_ptr< StateDelayVectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StateAverageComplexType (const StateDelayVectorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StateAverageComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StateAverageComplexType (const StateAverageComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StateAverageComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StateAverageComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NStepOptional nStep_;
    NStepSeriesOptional nStepSeries_;
    ::xsd::cxx::tree::one< StateDelayVectorType > stateDelayVector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundStateStepIndicesComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundStateStepIndicesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name stepIndex
     *
     * @brief Accessor and modifier functions for the %stepIndex
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StepIndex StepIndexType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< StepIndexType > StepIndexSequence;

    /**
     * @brief Element iterator type.
     */
    typedef StepIndexSequence::iterator StepIndexIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef StepIndexSequence::const_iterator StepIndexConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StepIndexType, char > StepIndexTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const StepIndexSequence&
    getStepIndex () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    StepIndexSequence&
    getStepIndex ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setStepIndex (const StepIndexSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundStateStepIndicesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundStateStepIndicesComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundStateStepIndicesComplexType (const BoundStateStepIndicesComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundStateStepIndicesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundStateStepIndicesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    StepIndexSequence stepIndex_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundStateComponentsComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundStateComponentsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ComponentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ComponentType > ComponentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ComponentSequence::iterator ComponentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ComponentSequence::const_iterator ComponentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ComponentSequence&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ComponentSequence&
    getComponent ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setComponent (const ComponentSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundStateComponentsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundStateComponentsComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundStateComponentsComplexType (const BoundStateComponentsComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundStateComponentsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundStateComponentsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ComponentSequence component_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BoundStateVariablesComplexType schema type.
   *
   * @nosubgrouping
   */
  class BoundStateVariablesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;

    /**
     * @brief Element iterator type.
     */
    typedef VariableSequence::iterator VariableIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef VariableSequence::const_iterator VariableConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const VariableSequence&
    getVariable () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    VariableSequence&
    getVariable ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setVariable (const VariableSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BoundStateVariablesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BoundStateVariablesComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BoundStateVariablesComplexType (const BoundStateVariablesComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BoundStateVariablesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BoundStateVariablesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariableSequence variable_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ChanceVariableComplexType schema type.
   *
   * @nosubgrouping
   */
  class ChanceVariableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name variable
     *
     * @brief Accessor and modifier functions for the %variable
     * required element.
     *
     * reference to the time series in the time series database (refers to
     * the file 'rtcDataConfig.xml')
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType VariableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const VariableType&
    getVariable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    VariableType&
    getVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVariable (const VariableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setVariable (::std::auto_ptr< VariableType > p);

    //@}

    /**
     * @name f
     *
     * @brief Accessor and modifier functions for the %f
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double FType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FType, char, ::xsd::cxx::tree::schema_type::double_ > FTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FType&
    getF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FType&
    getF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setF (const FType& x);

    //@}

    /**
     * @name upperBound
     *
     * @brief Accessor and modifier functions for the %upperBound
     * optional element.
     *
     * upper bound as a scalar value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType UpperBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundType > UpperBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundType, char > UpperBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundOptional&
    getUpperBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundOptional&
    getUpperBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBound (const UpperBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBound (const UpperBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBound (::std::auto_ptr< UpperBoundType > p);

    //@}

    /**
     * @name upperBoundSeries
     *
     * @brief Accessor and modifier functions for the %upperBoundSeries
     * optional element.
     *
     * upper bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpperBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundSeriesType > UpperBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundSeriesType, char > UpperBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundSeriesOptional&
    getUpperBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundSeriesOptional&
    getUpperBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > p);

    //@}

    /**
     * @name lowerBound
     *
     * @brief Accessor and modifier functions for the %lowerBound
     * optional element.
     *
     * lower bound as a scalar
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LowerBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundType > LowerBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundType, char > LowerBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundOptional&
    getLowerBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundOptional&
    getLowerBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBound (const LowerBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBound (const LowerBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBound (::std::auto_ptr< LowerBoundType > p);

    //@}

    /**
     * @name lowerBoundSeries
     *
     * @brief Accessor and modifier functions for the %lowerBoundSeries
     * optional element.
     *
     * lower bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LowerBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundSeriesType > LowerBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundSeriesType, char > LowerBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundSeriesOptional&
    getLowerBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundSeriesOptional&
    getLowerBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChanceVariableComplexType (const VariableType&,
                               const FType&,
                               const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChanceVariableComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChanceVariableComplexType (const ChanceVariableComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChanceVariableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChanceVariableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< VariableType > variable_;
    ::xsd::cxx::tree::one< FType > f_;
    UpperBoundOptional upperBound_;
    UpperBoundSeriesOptional upperBoundSeries_;
    LowerBoundOptional lowerBound_;
    LowerBoundSeriesOptional lowerBoundSeries_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name term
     *
     * @brief Accessor and modifier functions for the %term
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermChoiceComplexType TermType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TermType > TermSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TermSequence::iterator TermIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TermSequence::const_iterator TermConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TermType, char > TermTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TermSequence&
    getTerm () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TermSequence&
    getTerm ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTerm (const TermSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermComplexType (const TermComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TermSequence term_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermEnsembleComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermEnsembleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name termEnsemble
     *
     * @brief Accessor and modifier functions for the %termEnsemble
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermEnsembleChoiceComplexType TermEnsembleType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TermEnsembleType > TermEnsembleSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TermEnsembleSequence::iterator TermEnsembleIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TermEnsembleSequence::const_iterator TermEnsembleConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TermEnsembleType, char > TermEnsembleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TermEnsembleSequence&
    getTermEnsemble () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TermEnsembleSequence&
    getTermEnsemble ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTermEnsemble (const TermEnsembleSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermEnsembleComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermEnsembleComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermEnsembleComplexType (const TermEnsembleComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermEnsembleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermEnsembleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TermEnsembleSequence termEnsemble_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermChoiceComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermChoiceComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name absolute
     *
     * @brief Accessor and modifier functions for the %absolute
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermAbsoluteComplexType AbsoluteType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AbsoluteType > AbsoluteOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AbsoluteType, char > AbsoluteTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AbsoluteOptional&
    getAbsolute () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AbsoluteOptional&
    getAbsolute ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAbsolute (const AbsoluteType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAbsolute (const AbsoluteOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAbsolute (::std::auto_ptr< AbsoluteType > p);

    //@}

    /**
     * @name linear
     *
     * @brief Accessor and modifier functions for the %linear
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermLinearComplexType LinearType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LinearType > LinearOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LinearType, char > LinearTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LinearOptional&
    getLinear () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LinearOptional&
    getLinear ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLinear (const LinearType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLinear (const LinearOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLinear (::std::auto_ptr< LinearType > p);

    //@}

    /**
     * @name rateOfChange
     *
     * @brief Accessor and modifier functions for the %rateOfChange
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermRateOfChangeComplexType RateOfChangeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RateOfChangeType > RateOfChangeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RateOfChangeType, char > RateOfChangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RateOfChangeOptional&
    getRateOfChange () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RateOfChangeOptional&
    getRateOfChange ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRateOfChange (const RateOfChangeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRateOfChange (const RateOfChangeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRateOfChange (::std::auto_ptr< RateOfChangeType > p);

    //@}

    /**
     * @name max
     *
     * @brief Accessor and modifier functions for the %max
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermMaxComplexType MaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxType > MaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxOptional&
    getMax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MaxOptional&
    getMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax (const MaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax (const MaxOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMax (::std::auto_ptr< MaxType > p);

    //@}

    /**
     * @name mse
     *
     * @brief Accessor and modifier functions for the %mse
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermMSEComplexType MseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MseType > MseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MseType, char > MseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MseOptional&
    getMse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MseOptional&
    getMse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMse (const MseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMse (const MseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMse (::std::auto_ptr< MseType > p);

    //@}

    /**
     * @name nse
     *
     * @brief Accessor and modifier functions for the %nse
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermNSEComplexType NseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NseType > NseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NseType, char > NseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NseOptional&
    getNse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NseOptional&
    getNse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNse (const NseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNse (const NseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNse (::std::auto_ptr< NseType > p);

    //@}

    /**
     * @name relativeVolume
     *
     * @brief Accessor and modifier functions for the %relativeVolume
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermRelativeVolumeComplexType RelativeVolumeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RelativeVolumeType > RelativeVolumeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelativeVolumeType, char > RelativeVolumeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RelativeVolumeOptional&
    getRelativeVolume () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RelativeVolumeOptional&
    getRelativeVolume ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelativeVolume (const RelativeVolumeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRelativeVolume (const RelativeVolumeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRelativeVolume (::std::auto_ptr< RelativeVolumeType > p);

    //@}

    /**
     * @name rmse
     *
     * @brief Accessor and modifier functions for the %rmse
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermRMSEComplexType RmseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RmseType > RmseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RmseType, char > RmseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RmseOptional&
    getRmse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RmseOptional&
    getRmse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRmse (const RmseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRmse (const RmseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRmse (::std::auto_ptr< RmseType > p);

    //@}

    /**
     * @name rv
     *
     * @brief Accessor and modifier functions for the %rv
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermRVComplexType RvType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RvType > RvOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RvType, char > RvTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RvOptional&
    getRv () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RvOptional&
    getRv ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRv (const RvType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRv (const RvOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRv (::std::auto_ptr< RvType > p);

    //@}

    /**
     * @name sum
     *
     * @brief Accessor and modifier functions for the %sum
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TermSumComplexType SumType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SumType > SumOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SumType, char > SumTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SumOptional&
    getSum () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SumOptional&
    getSum ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSum (const SumType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSum (const SumOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSum (::std::auto_ptr< SumType > p);

    //@}

    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalBooleanSimpleType ActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ActiveType&
    getActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ActiveType&
    getActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActive (const ActiveType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setActive (::std::auto_ptr< ActiveType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const ActiveType&
    getActiveDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermChoiceComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermChoiceComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermChoiceComplexType (const TermChoiceComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermChoiceComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermChoiceComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AbsoluteOptional absolute_;
    LinearOptional linear_;
    RateOfChangeOptional rateOfChange_;
    MaxOptional max_;
    MseOptional mse_;
    NseOptional nse_;
    RelativeVolumeOptional relativeVolume_;
    RmseOptional rmse_;
    RvOptional rv_;
    SumOptional sum_;
    ::xsd::cxx::tree::one< ActiveType > active_;
    static const ActiveType active_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermEnsembleChoiceComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermEnsembleChoiceComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name chanceConstraint
     *
     * @brief Accessor and modifier functions for the %chanceConstraint
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ChanceConstraintComplexType ChanceConstraintType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChanceConstraintType, char > ChanceConstraintTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ChanceConstraintType&
    getChanceConstraint () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ChanceConstraintType&
    getChanceConstraint ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setChanceConstraint (const ChanceConstraintType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setChanceConstraint (::std::auto_ptr< ChanceConstraintType > p);

    //@}

    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalBooleanSimpleType ActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ActiveType&
    getActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ActiveType&
    getActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActive (const ActiveType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setActive (::std::auto_ptr< ActiveType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const ActiveType&
    getActiveDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermEnsembleChoiceComplexType (const ChanceConstraintType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TermEnsembleChoiceComplexType (::std::auto_ptr< ChanceConstraintType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermEnsembleChoiceComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermEnsembleChoiceComplexType (const TermEnsembleChoiceComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermEnsembleChoiceComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermEnsembleChoiceComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ChanceConstraintType > chanceConstraint_;
    ::xsd::cxx::tree::one< ActiveType > active_;
    static const ActiveType active_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermAbsoluteComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermAbsoluteComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name weightingFactorSeries
     *
     * @brief Accessor and modifier functions for the %weightingFactorSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType WeightingFactorSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeightingFactorSeriesType > WeightingFactorSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorSeriesType, char > WeightingFactorSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeightingFactorSeriesOptional&
    getWeightingFactorSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeightingFactorSeriesOptional&
    getWeightingFactorSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > p);

    //@}

    /**
     * @name weightingFactor
     *
     * @brief Accessor and modifier functions for the %weightingFactor
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorType > WeightingFactorSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorSequence::iterator WeightingFactorIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorSequence::const_iterator WeightingFactorConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorType, char > WeightingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorSequence&
    getWeightingFactor () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorSequence&
    getWeightingFactor ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactor (const WeightingFactorSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorType&
    getWeightingFactorDefaultValue ();

    //@}

    /**
     * @name weightingFactorFinal
     *
     * @brief Accessor and modifier functions for the %weightingFactorFinal
     * sequence element.
     *
     * optional final weighting factor, only considered if a weighting factor
     * is defined, works NOT in combination with the weighting factor time
     * series
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorFinalType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorFinalType > WeightingFactorFinalSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorFinalSequence::iterator WeightingFactorFinalIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorFinalSequence::const_iterator WeightingFactorFinalConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorFinalType, char > WeightingFactorFinalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorFinalSequence&
    getWeightingFactorFinal () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorFinalSequence&
    getWeightingFactorFinal ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactorFinal (const WeightingFactorFinalSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorFinalType&
    getWeightingFactorFinalDefaultValue ();

    //@}

    /**
     * @name order
     *
     * @brief Accessor and modifier functions for the %order
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double OrderType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OrderType, char, ::xsd::cxx::tree::schema_type::double_ > OrderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OrderType&
    getOrder () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OrderType&
    getOrder ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOrder (const OrderType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static OrderType
    getOrderDefaultValue ();

    //@}

    /**
     * @name setPoint
     *
     * @brief Accessor and modifier functions for the %setPoint
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType SetPointType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetPointType > SetPointOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetPointType, char > SetPointTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetPointOptional&
    getSetPoint () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetPointOptional&
    getSetPoint ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetPoint (const SetPointType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetPoint (const SetPointOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSetPoint (::std::auto_ptr< SetPointType > p);

    //@}

    /**
     * @name setPointSeries
     *
     * @brief Accessor and modifier functions for the %setPointSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SetPointSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetPointSeriesType > SetPointSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetPointSeriesType, char > SetPointSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetPointSeriesOptional&
    getSetPointSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetPointSeriesOptional&
    getSetPointSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetPointSeries (const SetPointSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetPointSeries (const SetPointSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSetPointSeries (::std::auto_ptr< SetPointSeriesType > p);

    //@}

    /**
     * @name upperBranch
     *
     * @brief Accessor and modifier functions for the %upperBranch
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean UpperBranchType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBranchType > UpperBranchOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBranchType, char > UpperBranchTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBranchOptional&
    getUpperBranch () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBranchOptional&
    getUpperBranch ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBranch (const UpperBranchType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBranch (const UpperBranchOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static UpperBranchType
    getUpperBranchDefaultValue ();

    //@}

    /**
     * @name lowerBranch
     *
     * @brief Accessor and modifier functions for the %lowerBranch
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean LowerBranchType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBranchType > LowerBranchOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBranchType, char > LowerBranchTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBranchOptional&
    getLowerBranch () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBranchOptional&
    getLowerBranch ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBranch (const LowerBranchType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBranch (const LowerBranchOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static LowerBranchType
    getLowerBranchDefaultValue ();

    //@}

    /**
     * @name average
     *
     * @brief Accessor and modifier functions for the %average
     * optional element.
     *
     * optional definition of an aggregation period over several time steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AverageComplexType AverageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AverageType > AverageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AverageType, char > AverageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AverageOptional&
    getAverage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AverageOptional&
    getAverage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAverage (const AverageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAverage (const AverageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAverage (::std::auto_ptr< AverageType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermAbsoluteComplexType (const OrderType&,
                             const InputType&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermAbsoluteComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermAbsoluteComplexType (const TermAbsoluteComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermAbsoluteComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermAbsoluteComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WeightingFactorSeriesOptional weightingFactorSeries_;
    WeightingFactorSequence weightingFactor_;
    static const WeightingFactorType weightingFactor_default_value_;
    WeightingFactorFinalSequence weightingFactorFinal_;
    static const WeightingFactorFinalType weightingFactorFinal_default_value_;
    ::xsd::cxx::tree::one< OrderType > order_;
    SetPointOptional setPoint_;
    SetPointSeriesOptional setPointSeries_;
    UpperBranchOptional upperBranch_;
    LowerBranchOptional lowerBranch_;
    AverageOptional average_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ChanceConstraintComplexType schema type.
   *
   * @nosubgrouping
   */
  class ChanceConstraintComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name weightingFactorSeries
     *
     * @brief Accessor and modifier functions for the %weightingFactorSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType WeightingFactorSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeightingFactorSeriesType > WeightingFactorSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorSeriesType, char > WeightingFactorSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeightingFactorSeriesOptional&
    getWeightingFactorSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeightingFactorSeriesOptional&
    getWeightingFactorSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > p);

    //@}

    /**
     * @name weightingFactor
     *
     * @brief Accessor and modifier functions for the %weightingFactor
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorType > WeightingFactorSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorSequence::iterator WeightingFactorIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorSequence::const_iterator WeightingFactorConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorType, char > WeightingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorSequence&
    getWeightingFactor () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorSequence&
    getWeightingFactor ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactor (const WeightingFactorSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorType&
    getWeightingFactorDefaultValue ();

    //@}

    /**
     * @name weightingFactorFinal
     *
     * @brief Accessor and modifier functions for the %weightingFactorFinal
     * sequence element.
     *
     * optional final weighting factor, only considered if a weighting factor
     * is defined, works NOT in combination with the weighting factor time
     * series
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorFinalType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorFinalType > WeightingFactorFinalSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorFinalSequence::iterator WeightingFactorFinalIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorFinalSequence::const_iterator WeightingFactorFinalConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorFinalType, char > WeightingFactorFinalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorFinalSequence&
    getWeightingFactorFinal () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorFinalSequence&
    getWeightingFactorFinal ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactorFinal (const WeightingFactorFinalSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorFinalType&
    getWeightingFactorFinalDefaultValue ();

    //@}

    /**
     * @name order
     *
     * @brief Accessor and modifier functions for the %order
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double OrderType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OrderType, char, ::xsd::cxx::tree::schema_type::double_ > OrderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OrderType&
    getOrder () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OrderType&
    getOrder ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOrder (const OrderType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static OrderType
    getOrderDefaultValue ();

    //@}

    /**
     * @name f
     *
     * @brief Accessor and modifier functions for the %f
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double FType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FType, char, ::xsd::cxx::tree::schema_type::double_ > FTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FType&
    getF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FType&
    getF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setF (const FType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static FType
    getFDefaultValue ();

    //@}

    /**
     * @name upperBound
     *
     * @brief Accessor and modifier functions for the %upperBound
     * optional element.
     *
     * upper bound as a scalar value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType UpperBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundType > UpperBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundType, char > UpperBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundOptional&
    getUpperBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundOptional&
    getUpperBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBound (const UpperBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBound (const UpperBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBound (::std::auto_ptr< UpperBoundType > p);

    //@}

    /**
     * @name upperBoundSeries
     *
     * @brief Accessor and modifier functions for the %upperBoundSeries
     * optional element.
     *
     * upper bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpperBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBoundSeriesType > UpperBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBoundSeriesType, char > UpperBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBoundSeriesOptional&
    getUpperBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBoundSeriesOptional&
    getUpperBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBoundSeries (const UpperBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > p);

    //@}

    /**
     * @name lowerBound
     *
     * @brief Accessor and modifier functions for the %lowerBound
     * optional element.
     *
     * lower bound as a scalar
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LowerBoundType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundType > LowerBoundOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundType, char > LowerBoundTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundOptional&
    getLowerBound () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundOptional&
    getLowerBound ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBound (const LowerBoundType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBound (const LowerBoundOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBound (::std::auto_ptr< LowerBoundType > p);

    //@}

    /**
     * @name lowerBoundSeries
     *
     * @brief Accessor and modifier functions for the %lowerBoundSeries
     * optional element.
     *
     * lower bound from a times series, a missing value will switch out the
     * constraint for this specific time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LowerBoundSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBoundSeriesType > LowerBoundSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBoundSeriesType, char > LowerBoundSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBoundSeriesOptional&
    getLowerBoundSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBoundSeriesOptional&
    getLowerBoundSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBoundSeries (const LowerBoundSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChanceConstraintComplexType (const OrderType&,
                                 const FType&,
                                 const InputType&,
                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChanceConstraintComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChanceConstraintComplexType (const ChanceConstraintComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChanceConstraintComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChanceConstraintComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WeightingFactorSeriesOptional weightingFactorSeries_;
    WeightingFactorSequence weightingFactor_;
    static const WeightingFactorType weightingFactor_default_value_;
    WeightingFactorFinalSequence weightingFactorFinal_;
    static const WeightingFactorFinalType weightingFactorFinal_default_value_;
    ::xsd::cxx::tree::one< OrderType > order_;
    ::xsd::cxx::tree::one< FType > f_;
    UpperBoundOptional upperBound_;
    UpperBoundSeriesOptional upperBoundSeries_;
    LowerBoundOptional lowerBound_;
    LowerBoundSeriesOptional lowerBoundSeries_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AverageComplexType schema type.
   *
   * @nosubgrouping
   */
  class AverageComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nStep
     *
     * @brief Accessor and modifier functions for the %nStep
     * optional element.
     *
     * fixed value for nStep
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NStep4 NStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepType > NStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepType, char > NStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepOptional&
    getNStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepOptional&
    getNStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStep (const NStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStep (const NStepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStep (::std::auto_ptr< NStepType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NStepType
    getNStepDefaultValue ();

    //@}

    /**
     * @name nStepSeries
     *
     * @brief Accessor and modifier functions for the %nStepSeries
     * optional element.
     *
     * nStep value is provided as a time series, the average is computed if
     * the value is a positive integer
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NStepSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepSeriesType > NStepSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepSeriesType, char > NStepSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepSeriesOptional&
    getNStepSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepSeriesOptional&
    getNStepSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStepSeries (const NStepSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStepSeries (const NStepSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepSeries (::std::auto_ptr< NStepSeriesType > p);

    //@}

    /**
     * @name inputDelayVector
     *
     * @brief Accessor and modifier functions for the %inputDelayVector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String InputDelayVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InputDelayVectorType > InputDelayVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputDelayVectorType, char > InputDelayVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InputDelayVectorOptional&
    getInputDelayVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InputDelayVectorOptional&
    getInputDelayVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInputDelayVector (const InputDelayVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInputDelayVector (const InputDelayVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInputDelayVector (::std::auto_ptr< InputDelayVectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AverageComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AverageComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AverageComplexType (const AverageComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AverageComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AverageComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NStepOptional nStep_;
    NStepSeriesOptional nStepSeries_;
    InputDelayVectorOptional inputDelayVector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermLinearComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermLinearComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name weightingFactorSeries
     *
     * @brief Accessor and modifier functions for the %weightingFactorSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType WeightingFactorSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeightingFactorSeriesType > WeightingFactorSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorSeriesType, char > WeightingFactorSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeightingFactorSeriesOptional&
    getWeightingFactorSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeightingFactorSeriesOptional&
    getWeightingFactorSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > p);

    //@}

    /**
     * @name weightingFactor
     *
     * @brief Accessor and modifier functions for the %weightingFactor
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorType > WeightingFactorSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorSequence::iterator WeightingFactorIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorSequence::const_iterator WeightingFactorConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorType, char > WeightingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorSequence&
    getWeightingFactor () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorSequence&
    getWeightingFactor ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactor (const WeightingFactorSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorType&
    getWeightingFactorDefaultValue ();

    //@}

    /**
     * @name weightingFactorFinal
     *
     * @brief Accessor and modifier functions for the %weightingFactorFinal
     * sequence element.
     *
     * optional final weighting factor, only considered if a weighting factor
     * is defined, works NOT in combination with the weighting factor time
     * series
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorFinalType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorFinalType > WeightingFactorFinalSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorFinalSequence::iterator WeightingFactorFinalIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorFinalSequence::const_iterator WeightingFactorFinalConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorFinalType, char > WeightingFactorFinalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorFinalSequence&
    getWeightingFactorFinal () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorFinalSequence&
    getWeightingFactorFinal ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactorFinal (const WeightingFactorFinalSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorFinalType&
    getWeightingFactorFinalDefaultValue ();

    //@}

    /**
     * @name setPoint
     *
     * @brief Accessor and modifier functions for the %setPoint
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType SetPointType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetPointType > SetPointOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetPointType, char > SetPointTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetPointOptional&
    getSetPoint () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetPointOptional&
    getSetPoint ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetPoint (const SetPointType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetPoint (const SetPointOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSetPoint (::std::auto_ptr< SetPointType > p);

    //@}

    /**
     * @name setPointSeries
     *
     * @brief Accessor and modifier functions for the %setPointSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SetPointSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetPointSeriesType > SetPointSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetPointSeriesType, char > SetPointSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetPointSeriesOptional&
    getSetPointSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetPointSeriesOptional&
    getSetPointSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetPointSeries (const SetPointSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetPointSeries (const SetPointSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSetPointSeries (::std::auto_ptr< SetPointSeriesType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermLinearComplexType (const InputType&,
                           const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermLinearComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermLinearComplexType (const TermLinearComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermLinearComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermLinearComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WeightingFactorSeriesOptional weightingFactorSeries_;
    WeightingFactorSequence weightingFactor_;
    static const WeightingFactorType weightingFactor_default_value_;
    WeightingFactorFinalSequence weightingFactorFinal_;
    static const WeightingFactorFinalType weightingFactorFinal_default_value_;
    SetPointOptional setPoint_;
    SetPointSeriesOptional setPointSeries_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermRateOfChangeComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermRateOfChangeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name weightingFactorSeries
     *
     * @brief Accessor and modifier functions for the %weightingFactorSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType WeightingFactorSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeightingFactorSeriesType > WeightingFactorSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorSeriesType, char > WeightingFactorSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeightingFactorSeriesOptional&
    getWeightingFactorSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeightingFactorSeriesOptional&
    getWeightingFactorSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeightingFactorSeries (const WeightingFactorSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > p);

    //@}

    /**
     * @name weightingFactor
     *
     * @brief Accessor and modifier functions for the %weightingFactor
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightingFactorType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightingFactorType > WeightingFactorSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightingFactorSequence::iterator WeightingFactorIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightingFactorSequence::const_iterator WeightingFactorConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightingFactorType, char > WeightingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightingFactorSequence&
    getWeightingFactor () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightingFactorSequence&
    getWeightingFactor ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeightingFactor (const WeightingFactorSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const WeightingFactorType&
    getWeightingFactorDefaultValue ();

    //@}

    /**
     * @name order
     *
     * @brief Accessor and modifier functions for the %order
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double OrderType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OrderType, char, ::xsd::cxx::tree::schema_type::double_ > OrderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OrderType&
    getOrder () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OrderType&
    getOrder ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOrder (const OrderType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static OrderType
    getOrderDefaultValue ();

    //@}

    /**
     * @name setPoint
     *
     * @brief Accessor and modifier functions for the %setPoint
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SetPointType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetPointType > SetPointOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetPointType, char, ::xsd::cxx::tree::schema_type::double_ > SetPointTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetPointOptional&
    getSetPoint () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetPointOptional&
    getSetPoint ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetPoint (const SetPointType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetPoint (const SetPointOptional& x);

    //@}

    /**
     * @name setPointSeries
     *
     * @brief Accessor and modifier functions for the %setPointSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SetPointSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetPointSeriesType > SetPointSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetPointSeriesType, char > SetPointSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetPointSeriesOptional&
    getSetPointSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetPointSeriesOptional&
    getSetPointSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetPointSeries (const SetPointSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetPointSeries (const SetPointSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSetPointSeries (::std::auto_ptr< SetPointSeriesType > p);

    //@}

    /**
     * @name multipleDelay
     *
     * @brief Accessor and modifier functions for the %multipleDelay
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MultipleDelayComplexType MultipleDelayType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MultipleDelayType > MultipleDelayOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultipleDelayType, char > MultipleDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MultipleDelayOptional&
    getMultipleDelay () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MultipleDelayOptional&
    getMultipleDelay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMultipleDelay (const MultipleDelayType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMultipleDelay (const MultipleDelayOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMultipleDelay (::std::auto_ptr< MultipleDelayType > p);

    //@}

    /**
     * @name upperBranch
     *
     * @brief Accessor and modifier functions for the %upperBranch
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean UpperBranchType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperBranchType > UpperBranchOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperBranchType, char > UpperBranchTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperBranchOptional&
    getUpperBranch () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperBranchOptional&
    getUpperBranch ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperBranch (const UpperBranchType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperBranch (const UpperBranchOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static UpperBranchType
    getUpperBranchDefaultValue ();

    //@}

    /**
     * @name lowerBranch
     *
     * @brief Accessor and modifier functions for the %lowerBranch
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean LowerBranchType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerBranchType > LowerBranchOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerBranchType, char > LowerBranchTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerBranchOptional&
    getLowerBranch () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerBranchOptional&
    getLowerBranch ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerBranch (const LowerBranchType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerBranch (const LowerBranchOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static LowerBranchType
    getLowerBranchDefaultValue ();

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermRateOfChangeComplexType (const OrderType&,
                                 const InputType&,
                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermRateOfChangeComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermRateOfChangeComplexType (const TermRateOfChangeComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermRateOfChangeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermRateOfChangeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WeightingFactorSeriesOptional weightingFactorSeries_;
    WeightingFactorSequence weightingFactor_;
    static const WeightingFactorType weightingFactor_default_value_;
    ::xsd::cxx::tree::one< OrderType > order_;
    SetPointOptional setPoint_;
    SetPointSeriesOptional setPointSeries_;
    MultipleDelayOptional multipleDelay_;
    UpperBranchOptional upperBranch_;
    LowerBranchOptional lowerBranch_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermMaxComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermMaxComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermMaxComplexType (const InputType&,
                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermMaxComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermMaxComplexType (const TermMaxComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermMaxComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermMaxComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermMSEComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermMSEComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flag
     *
     * @brief Accessor and modifier functions for the %flag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlagType > FlagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlagType, char > FlagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlagOptional&
    getFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlagOptional&
    getFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlag (const FlagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlag (const FlagOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlag (::std::auto_ptr< FlagType > p);

    //@}

    /**
     * @name observation
     *
     * @brief Accessor and modifier functions for the %observation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ObservationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ObservationType, char > ObservationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ObservationType&
    getObservation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ObservationType&
    getObservation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObservation (const ObservationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setObservation (::std::auto_ptr< ObservationType > p);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimulationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimulationType&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimulationType&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermMSEComplexType (const ObservationType&,
                        const SimulationType&,
                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermMSEComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermMSEComplexType (const TermMSEComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermMSEComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermMSEComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FlagOptional flag_;
    ::xsd::cxx::tree::one< ObservationType > observation_;
    ::xsd::cxx::tree::one< SimulationType > simulation_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermRMSEComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermRMSEComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flag
     *
     * @brief Accessor and modifier functions for the %flag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlagType > FlagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlagType, char > FlagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlagOptional&
    getFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlagOptional&
    getFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlag (const FlagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlag (const FlagOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlag (::std::auto_ptr< FlagType > p);

    //@}

    /**
     * @name observation
     *
     * @brief Accessor and modifier functions for the %observation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ObservationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ObservationType, char > ObservationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ObservationType&
    getObservation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ObservationType&
    getObservation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObservation (const ObservationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setObservation (::std::auto_ptr< ObservationType > p);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimulationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimulationType&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimulationType&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermRMSEComplexType (const ObservationType&,
                         const SimulationType&,
                         const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermRMSEComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermRMSEComplexType (const TermRMSEComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermRMSEComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermRMSEComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FlagOptional flag_;
    ::xsd::cxx::tree::one< ObservationType > observation_;
    ::xsd::cxx::tree::one< SimulationType > simulation_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermNSEComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermNSEComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flag
     *
     * @brief Accessor and modifier functions for the %flag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlagType > FlagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlagType, char > FlagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlagOptional&
    getFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlagOptional&
    getFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlag (const FlagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlag (const FlagOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlag (::std::auto_ptr< FlagType > p);

    //@}

    /**
     * @name skipNFirstSteps
     *
     * @brief Accessor and modifier functions for the %skipNFirstSteps
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int SkipNFirstStepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SkipNFirstStepsType > SkipNFirstStepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SkipNFirstStepsType, char > SkipNFirstStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SkipNFirstStepsOptional&
    getSkipNFirstSteps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SkipNFirstStepsOptional&
    getSkipNFirstSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSkipNFirstSteps (const SkipNFirstStepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSkipNFirstSteps (const SkipNFirstStepsOptional& x);

    //@}

    /**
     * @name observation
     *
     * @brief Accessor and modifier functions for the %observation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ObservationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ObservationType, char > ObservationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ObservationType&
    getObservation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ObservationType&
    getObservation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObservation (const ObservationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setObservation (::std::auto_ptr< ObservationType > p);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimulationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimulationType&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimulationType&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermNSEComplexType (const ObservationType&,
                        const SimulationType&,
                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermNSEComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermNSEComplexType (const TermNSEComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermNSEComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermNSEComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FlagOptional flag_;
    SkipNFirstStepsOptional skipNFirstSteps_;
    ::xsd::cxx::tree::one< ObservationType > observation_;
    ::xsd::cxx::tree::one< SimulationType > simulation_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermRelativeVolumeComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermRelativeVolumeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flag
     *
     * @brief Accessor and modifier functions for the %flag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlagType > FlagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlagType, char > FlagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlagOptional&
    getFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlagOptional&
    getFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlag (const FlagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlag (const FlagOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlag (::std::auto_ptr< FlagType > p);

    //@}

    /**
     * @name skipNFirstSteps
     *
     * @brief Accessor and modifier functions for the %skipNFirstSteps
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int SkipNFirstStepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SkipNFirstStepsType > SkipNFirstStepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SkipNFirstStepsType, char > SkipNFirstStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SkipNFirstStepsOptional&
    getSkipNFirstSteps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SkipNFirstStepsOptional&
    getSkipNFirstSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSkipNFirstSteps (const SkipNFirstStepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSkipNFirstSteps (const SkipNFirstStepsOptional& x);

    //@}

    /**
     * @name observation
     *
     * @brief Accessor and modifier functions for the %observation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ObservationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ObservationType, char > ObservationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ObservationType&
    getObservation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ObservationType&
    getObservation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObservation (const ObservationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setObservation (::std::auto_ptr< ObservationType > p);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimulationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimulationType&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimulationType&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermRelativeVolumeComplexType (const ObservationType&,
                                   const SimulationType&,
                                   const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermRelativeVolumeComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermRelativeVolumeComplexType (const TermRelativeVolumeComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermRelativeVolumeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermRelativeVolumeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FlagOptional flag_;
    SkipNFirstStepsOptional skipNFirstSteps_;
    ::xsd::cxx::tree::one< ObservationType > observation_;
    ::xsd::cxx::tree::one< SimulationType > simulation_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermRVComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermRVComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flag
     *
     * @brief Accessor and modifier functions for the %flag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlagType > FlagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlagType, char > FlagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlagOptional&
    getFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlagOptional&
    getFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlag (const FlagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlag (const FlagOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlag (::std::auto_ptr< FlagType > p);

    //@}

    /**
     * @name w
     *
     * @brief Accessor and modifier functions for the %w
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double WType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WType, char, ::xsd::cxx::tree::schema_type::double_ > WTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WType&
    getW () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WType&
    getW ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setW (const WType& x);

    //@}

    /**
     * @name skipNFirstSteps
     *
     * @brief Accessor and modifier functions for the %skipNFirstSteps
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int SkipNFirstStepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SkipNFirstStepsType > SkipNFirstStepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SkipNFirstStepsType, char > SkipNFirstStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SkipNFirstStepsOptional&
    getSkipNFirstSteps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SkipNFirstStepsOptional&
    getSkipNFirstSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSkipNFirstSteps (const SkipNFirstStepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSkipNFirstSteps (const SkipNFirstStepsOptional& x);

    //@}

    /**
     * @name observation
     *
     * @brief Accessor and modifier functions for the %observation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ObservationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ObservationType, char > ObservationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ObservationType&
    getObservation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ObservationType&
    getObservation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObservation (const ObservationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setObservation (::std::auto_ptr< ObservationType > p);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimulationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimulationType&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimulationType&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermRVComplexType (const WType&,
                       const ObservationType&,
                       const SimulationType&,
                       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermRVComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermRVComplexType (const TermRVComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermRVComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermRVComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FlagOptional flag_;
    ::xsd::cxx::tree::one< WType > w_;
    SkipNFirstStepsOptional skipNFirstSteps_;
    ::xsd::cxx::tree::one< ObservationType > observation_;
    ::xsd::cxx::tree::one< SimulationType > simulation_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TermSumComplexType schema type.
   *
   * @nosubgrouping
   */
  class TermSumComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flag
     *
     * @brief Accessor and modifier functions for the %flag
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlagType > FlagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlagType, char > FlagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlagOptional&
    getFlag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlagOptional&
    getFlag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlag (const FlagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlag (const FlagOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlag (::std::auto_ptr< FlagType > p);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimulationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimulationType&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimulationType&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TermSumComplexType (const SimulationType&,
                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TermSumComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TermSumComplexType (const TermSumComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TermSumComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TermSumComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FlagOptional flag_;
    ::xsd::cxx::tree::one< SimulationType > simulation_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name JInc
     *
     * @brief Accessor and modifier functions for the %JInc
     * required element.
     *
     * time series reference for incremental objective function value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType JIncType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< JIncType, char > JIncTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const JIncType&
    getJInc () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    JIncType&
    getJInc ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJInc (const JIncType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setJInc (::std::auto_ptr< JIncType > p);

    //@}

    /**
     * @name JAcc
     *
     * @brief Accessor and modifier functions for the %JAcc
     * required element.
     *
     * time series reference for accumulating objective function value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType JAccType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< JAccType, char > JAccTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const JAccType&
    getJAcc () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    JAccType&
    getJAcc ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJAcc (const JAccType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setJAcc (::std::auto_ptr< JAccType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputComplexType (const JIncType&,
                       const JAccType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputComplexType (const OutputComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< JIncType > JInc_;
    ::xsd::cxx::tree::one< JAccType > JAcc_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %nStepModeEnum
   * schema type.
   */
  class NStepModeEnum: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      CONTINUOUS,
      STEP
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    NStepModeEnum (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    NStepModeEnum (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    NStepModeEnum (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    NStepModeEnum (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStepModeEnum (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStepModeEnum (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStepModeEnum (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NStepModeEnum (const NStepModeEnum& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NStepModeEnum*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    NStepModeEnum&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_NStepModeEnum_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_NStepModeEnum_convert () const;

    public:
    static const char* const _xsd_NStepModeEnum_literals_[2];
    static const Value _xsd_NStepModeEnum_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %nStep schema type.
   *
   * @nosubgrouping
   */
  class NStep: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NStep (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NStep (const NStep& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NStep*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NStep ();
  };

  /**
   * @brief Class corresponding to the %nStep1 schema type.
   *
   * @nosubgrouping
   */
  class NStep1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NStep1 (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep1 (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep1 (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep1 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NStep1 (const NStep1& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NStep1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NStep1 ();
  };

  /**
   * @brief Class corresponding to the %nStep2 schema type.
   *
   * @nosubgrouping
   */
  class NStep2: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NStep2 (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep2 (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep2 (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep2 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NStep2 (const NStep2& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NStep2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NStep2 ();
  };

  /**
   * @brief Class corresponding to the %nStep3 schema type.
   *
   * @nosubgrouping
   */
  class NStep3: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NStep3 (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep3 (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep3 (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep3 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NStep3 (const NStep3& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NStep3*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NStep3 ();
  };

  /**
   * @brief Class corresponding to the %stepIndex schema type.
   *
   * @nosubgrouping
   */
  class StepIndex: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StepIndex (const ::xml_schema::Int&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StepIndex (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StepIndex (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StepIndex (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StepIndex (const StepIndex& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StepIndex*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StepIndex ();
  };

  /**
   * @brief Class corresponding to the %nStep4 schema type.
   *
   * @nosubgrouping
   */
  class NStep4: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NStep4 (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep4 (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep4 (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NStep4 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NStep4 (const NStep4& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NStep4*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NStep4 ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace fews
{
  /**
   * @name Parsing functions for the %rtcObjectiveConfig document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::std::string& uri,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::std::string& uri,
                           ::xml_schema::ErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::std::string& uri,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           ::xml_schema::ErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           const ::std::string& id,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           const ::std::string& id,
                           ::xml_schema::ErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           const ::std::string& id,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xercesc::InputSource& is,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xercesc::InputSource& is,
                           ::xml_schema::ErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xercesc::InputSource& is,
                           ::xercesc::DOMErrorHandler& eh,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::xercesc::DOMDocument& d,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::Flags f = 0,
                           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace fews
{
  /**
   * @name Serialization functions for the %rtcObjectiveConfig document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeRtcObjectiveConfig (::std::ostream& os,
                               const ::fews::RtcObjectiveConfigComplexType& x, 
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               const ::std::string& e = "UTF-8",
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcObjectiveConfig (::std::ostream& os,
                               const ::fews::RtcObjectiveConfigComplexType& x, 
                               ::xml_schema::ErrorHandler& eh,
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               const ::std::string& e = "UTF-8",
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcObjectiveConfig (::std::ostream& os,
                               const ::fews::RtcObjectiveConfigComplexType& x, 
                               ::xercesc::DOMErrorHandler& eh,
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               const ::std::string& e = "UTF-8",
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeRtcObjectiveConfig (::xercesc::XMLFormatTarget& ft,
                               const ::fews::RtcObjectiveConfigComplexType& x, 
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               const ::std::string& e = "UTF-8",
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcObjectiveConfig (::xercesc::XMLFormatTarget& ft,
                               const ::fews::RtcObjectiveConfigComplexType& x, 
                               ::xml_schema::ErrorHandler& eh,
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               const ::std::string& e = "UTF-8",
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcObjectiveConfig (::xercesc::XMLFormatTarget& ft,
                               const ::fews::RtcObjectiveConfigComplexType& x, 
                               ::xercesc::DOMErrorHandler& eh,
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               const ::std::string& e = "UTF-8",
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  serializeRtcObjectiveConfig (::xercesc::DOMDocument& d,
                               const ::fews::RtcObjectiveConfigComplexType& x,
                               ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeRtcObjectiveConfig (const ::fews::RtcObjectiveConfigComplexType& x, 
                               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                               ::xml_schema::Flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const RtcObjectiveConfigComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const VariablesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const VariableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AggregationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AggregationEquidistantComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AggregationNonEquidistantComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConstraintsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConstraintChoiceComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundVariableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundVariableRateOfChangeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundVariableAverageComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundAverageComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MultipleDelayComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundStateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const StateAverageComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundStateStepIndicesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundStateComponentsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BoundStateVariablesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ChanceVariableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermEnsembleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermChoiceComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermEnsembleChoiceComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermAbsoluteComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ChanceConstraintComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AverageComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermLinearComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermRateOfChangeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermMaxComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermMSEComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermRMSEComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermNSEComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermRelativeVolumeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermRVComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TermSumComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NStepModeEnum&);

  void
  operator<< (::xercesc::DOMAttr&, const NStepModeEnum&);

  void
  operator<< (::xml_schema::ListStream&,
              const NStepModeEnum&);

  void
  operator<< (::xercesc::DOMElement&, const NStep&);

  void
  operator<< (::xercesc::DOMAttr&, const NStep&);

  void
  operator<< (::xml_schema::ListStream&,
              const NStep&);

  void
  operator<< (::xercesc::DOMElement&, const NStep1&);

  void
  operator<< (::xercesc::DOMAttr&, const NStep1&);

  void
  operator<< (::xml_schema::ListStream&,
              const NStep1&);

  void
  operator<< (::xercesc::DOMElement&, const NStep2&);

  void
  operator<< (::xercesc::DOMAttr&, const NStep2&);

  void
  operator<< (::xml_schema::ListStream&,
              const NStep2&);

  void
  operator<< (::xercesc::DOMElement&, const NStep3&);

  void
  operator<< (::xercesc::DOMAttr&, const NStep3&);

  void
  operator<< (::xml_schema::ListStream&,
              const NStep3&);

  void
  operator<< (::xercesc::DOMElement&, const StepIndex&);

  void
  operator<< (::xercesc::DOMAttr&, const StepIndex&);

  void
  operator<< (::xml_schema::ListStream&,
              const StepIndex&);

  void
  operator<< (::xercesc::DOMElement&, const NStep4&);

  void
  operator<< (::xercesc::DOMAttr&, const NStep4&);

  void
  operator<< (::xml_schema::ListStream&,
              const NStep4&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // RTC_OBJECTIVE_CONFIG_HXX
