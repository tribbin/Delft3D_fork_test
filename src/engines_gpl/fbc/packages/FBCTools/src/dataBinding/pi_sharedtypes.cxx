// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pi_sharedtypes.hxx"

namespace fews
{
  namespace PI
  {
    // PropertyReferenceString
    // 


    // IdString
    // 


    // IntStringType
    //

    IntStringType::
    IntStringType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    IntStringType::
    IntStringType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    IntStringType::
    IntStringType (const IntStringType& o,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // BooleanStringType
    //

    BooleanStringType::
    BooleanStringType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    BooleanStringType::
    BooleanStringType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    BooleanStringType::
    BooleanStringType (const BooleanStringType& o,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DoubleStringType
    //

    DoubleStringType::
    DoubleStringType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DoubleStringType::
    DoubleStringType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DoubleStringType::
    DoubleStringType (const DoubleStringType& o,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // VersionString
    // 

    VersionString::
    VersionString (Value v)
    : ::xml_schema::String (_xsd_VersionString_literals_[v])
    {
    }

    VersionString::
    VersionString (const char* v)
    : ::xml_schema::String (v)
    {
    }

    VersionString::
    VersionString (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    VersionString::
    VersionString (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    VersionString::
    VersionString (const VersionString& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    VersionString& VersionString::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_VersionString_literals_[v]);

      return *this;
    }


    // NameString
    // 


    // CommentString
    // 


    // EventCodeString
    // 


    // TimeStepComplexType
    // 

    const TimeStepComplexType::UnitType& TimeStepComplexType::
    getUnit () const
    {
      return this->unit_.get ();
    }

    TimeStepComplexType::UnitType& TimeStepComplexType::
    getUnit ()
    {
      return this->unit_.get ();
    }

    void TimeStepComplexType::
    setUnit (const UnitType& x)
    {
      this->unit_.set (x);
    }

    void TimeStepComplexType::
    setUnit (::std::auto_ptr< UnitType > x)
    {
      this->unit_.set (x);
    }

    const TimeStepComplexType::DividerType& TimeStepComplexType::
    getDivider () const
    {
      return this->divider_.get ();
    }

    TimeStepComplexType::DividerType& TimeStepComplexType::
    getDivider ()
    {
      return this->divider_.get ();
    }

    void TimeStepComplexType::
    setDivider (const DividerType& x)
    {
      this->divider_.set (x);
    }

    TimeStepComplexType::DividerType TimeStepComplexType::
    getDividerDefaultValue ()
    {
      return DividerType (1ULL);
    }

    const TimeStepComplexType::MultiplierType& TimeStepComplexType::
    getMultiplier () const
    {
      return this->multiplier_.get ();
    }

    TimeStepComplexType::MultiplierType& TimeStepComplexType::
    getMultiplier ()
    {
      return this->multiplier_.get ();
    }

    void TimeStepComplexType::
    setMultiplier (const MultiplierType& x)
    {
      this->multiplier_.set (x);
    }

    TimeStepComplexType::MultiplierType TimeStepComplexType::
    getMultiplierDefaultValue ()
    {
      return MultiplierType (1ULL);
    }


    // TimeStepUnitEnumStringType
    // 

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (Value v)
    : ::xml_schema::String (_xsd_TimeStepUnitEnumStringType_literals_[v])
    {
    }

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const char* v)
    : ::xml_schema::String (v)
    {
    }

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const TimeStepUnitEnumStringType& v,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    TimeStepUnitEnumStringType& TimeStepUnitEnumStringType::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_TimeStepUnitEnumStringType_literals_[v]);

      return *this;
    }


    // TimeStepUnitComplexType
    // 

    const TimeStepUnitComplexType::UnitType& TimeStepUnitComplexType::
    getUnit () const
    {
      return this->unit_.get ();
    }

    TimeStepUnitComplexType::UnitType& TimeStepUnitComplexType::
    getUnit ()
    {
      return this->unit_.get ();
    }

    void TimeStepUnitComplexType::
    setUnit (const UnitType& x)
    {
      this->unit_.set (x);
    }

    void TimeStepUnitComplexType::
    setUnit (::std::auto_ptr< UnitType > x)
    {
      this->unit_.set (x);
    }

    const TimeStepUnitComplexType::DividerType& TimeStepUnitComplexType::
    getDivider () const
    {
      return this->divider_.get ();
    }

    TimeStepUnitComplexType::DividerType& TimeStepUnitComplexType::
    getDivider ()
    {
      return this->divider_.get ();
    }

    void TimeStepUnitComplexType::
    setDivider (const DividerType& x)
    {
      this->divider_.set (x);
    }

    TimeStepUnitComplexType::DividerType TimeStepUnitComplexType::
    getDividerDefaultValue ()
    {
      return DividerType (1);
    }


    // GeoDatumEnumStringType
    // 

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (Value v)
    : ::xml_schema::String (_xsd_GeoDatumEnumStringType_literals_[v])
    {
    }

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const char* v)
    : ::xml_schema::String (v)
    {
    }

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const GeoDatumEnumStringType& v,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    GeoDatumEnumStringType& GeoDatumEnumStringType::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_GeoDatumEnumStringType_literals_[v]);

      return *this;
    }


    // UtmGeoDatumStringType
    // 


    // GeoDatumStringType
    //

    GeoDatumStringType::
    GeoDatumStringType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    GeoDatumStringType::
    GeoDatumStringType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    GeoDatumStringType::
    GeoDatumStringType (const GeoDatumStringType& o,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // LocationIdSimpleType
    // 


    // ParameterSimpleType
    // 


    // TimeZoneSimpleType
    // 


    // DateType
    // 


    // TimeType
    // 


    // DateTimeComplexType
    // 

    const DateTimeComplexType::DateType& DateTimeComplexType::
    getDate () const
    {
      return this->date_.get ();
    }

    DateTimeComplexType::DateType& DateTimeComplexType::
    getDate ()
    {
      return this->date_.get ();
    }

    void DateTimeComplexType::
    setDate (const DateType& x)
    {
      this->date_.set (x);
    }

    void DateTimeComplexType::
    setDate (::std::auto_ptr< DateType > x)
    {
      this->date_.set (x);
    }

    const DateTimeComplexType::TimeType& DateTimeComplexType::
    getTime () const
    {
      return this->time_.get ();
    }

    DateTimeComplexType::TimeType& DateTimeComplexType::
    getTime ()
    {
      return this->time_.get ();
    }

    void DateTimeComplexType::
    setTime (const TimeType& x)
    {
      this->time_.set (x);
    }

    void DateTimeComplexType::
    setTime (::std::auto_ptr< TimeType > x)
    {
      this->time_.set (x);
    }


    // TimeSeriesType
    // 

    TimeSeriesType::
    TimeSeriesType (Value v)
    : ::xml_schema::String (_xsd_TimeSeriesType_literals_[v])
    {
    }

    TimeSeriesType::
    TimeSeriesType (const char* v)
    : ::xml_schema::String (v)
    {
    }

    TimeSeriesType::
    TimeSeriesType (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    TimeSeriesType::
    TimeSeriesType (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    TimeSeriesType::
    TimeSeriesType (const TimeSeriesType& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    TimeSeriesType& TimeSeriesType::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_TimeSeriesType_literals_[v]);

      return *this;
    }


    // PropertiesComplexType
    // 

    const PropertiesComplexType::DescriptionOptional& PropertiesComplexType::
    getDescription () const
    {
      return this->description_;
    }

    PropertiesComplexType::DescriptionOptional& PropertiesComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void PropertiesComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void PropertiesComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void PropertiesComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const PropertiesComplexType::StringSequence& PropertiesComplexType::
    getString () const
    {
      return this->string_;
    }

    PropertiesComplexType::StringSequence& PropertiesComplexType::
    getString ()
    {
      return this->string_;
    }

    void PropertiesComplexType::
    setString (const StringSequence& s)
    {
      this->string_ = s;
    }

    const PropertiesComplexType::IntSequence& PropertiesComplexType::
    getInt () const
    {
      return this->int__;
    }

    PropertiesComplexType::IntSequence& PropertiesComplexType::
    getInt ()
    {
      return this->int__;
    }

    void PropertiesComplexType::
    setInt (const IntSequence& s)
    {
      this->int__ = s;
    }

    const PropertiesComplexType::FloatSequence& PropertiesComplexType::
    getFloat () const
    {
      return this->float__;
    }

    PropertiesComplexType::FloatSequence& PropertiesComplexType::
    getFloat ()
    {
      return this->float__;
    }

    void PropertiesComplexType::
    setFloat (const FloatSequence& s)
    {
      this->float__ = s;
    }

    const PropertiesComplexType::DoubleSequence& PropertiesComplexType::
    getDouble () const
    {
      return this->double__;
    }

    PropertiesComplexType::DoubleSequence& PropertiesComplexType::
    getDouble ()
    {
      return this->double__;
    }

    void PropertiesComplexType::
    setDouble (const DoubleSequence& s)
    {
      this->double__ = s;
    }

    const PropertiesComplexType::BoolSequence& PropertiesComplexType::
    getBool () const
    {
      return this->bool__;
    }

    PropertiesComplexType::BoolSequence& PropertiesComplexType::
    getBool ()
    {
      return this->bool__;
    }

    void PropertiesComplexType::
    setBool (const BoolSequence& s)
    {
      this->bool__ = s;
    }

    const PropertiesComplexType::DateTimeSequence& PropertiesComplexType::
    getDateTime () const
    {
      return this->dateTime_;
    }

    PropertiesComplexType::DateTimeSequence& PropertiesComplexType::
    getDateTime ()
    {
      return this->dateTime_;
    }

    void PropertiesComplexType::
    setDateTime (const DateTimeSequence& s)
    {
      this->dateTime_ = s;
    }


    // StringPropertyComplexType
    // 

    const StringPropertyComplexType::DescriptionOptional& StringPropertyComplexType::
    getDescription () const
    {
      return this->description_;
    }

    StringPropertyComplexType::DescriptionOptional& StringPropertyComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void StringPropertyComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void StringPropertyComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void StringPropertyComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const StringPropertyComplexType::KeyType& StringPropertyComplexType::
    getKey () const
    {
      return this->key_.get ();
    }

    StringPropertyComplexType::KeyType& StringPropertyComplexType::
    getKey ()
    {
      return this->key_.get ();
    }

    void StringPropertyComplexType::
    setKey (const KeyType& x)
    {
      this->key_.set (x);
    }

    void StringPropertyComplexType::
    setKey (::std::auto_ptr< KeyType > x)
    {
      this->key_.set (x);
    }

    const StringPropertyComplexType::ValueType& StringPropertyComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    StringPropertyComplexType::ValueType& StringPropertyComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void StringPropertyComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }

    void StringPropertyComplexType::
    setValue (::std::auto_ptr< ValueType > x)
    {
      this->value_.set (x);
    }


    // IntPropertyComplexType
    // 

    const IntPropertyComplexType::DescriptionOptional& IntPropertyComplexType::
    getDescription () const
    {
      return this->description_;
    }

    IntPropertyComplexType::DescriptionOptional& IntPropertyComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void IntPropertyComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void IntPropertyComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void IntPropertyComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const IntPropertyComplexType::KeyType& IntPropertyComplexType::
    getKey () const
    {
      return this->key_.get ();
    }

    IntPropertyComplexType::KeyType& IntPropertyComplexType::
    getKey ()
    {
      return this->key_.get ();
    }

    void IntPropertyComplexType::
    setKey (const KeyType& x)
    {
      this->key_.set (x);
    }

    void IntPropertyComplexType::
    setKey (::std::auto_ptr< KeyType > x)
    {
      this->key_.set (x);
    }

    const IntPropertyComplexType::ValueType& IntPropertyComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    IntPropertyComplexType::ValueType& IntPropertyComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void IntPropertyComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }


    // FloatPropertyComplexType
    // 

    const FloatPropertyComplexType::DescriptionOptional& FloatPropertyComplexType::
    getDescription () const
    {
      return this->description_;
    }

    FloatPropertyComplexType::DescriptionOptional& FloatPropertyComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void FloatPropertyComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void FloatPropertyComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void FloatPropertyComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const FloatPropertyComplexType::KeyType& FloatPropertyComplexType::
    getKey () const
    {
      return this->key_.get ();
    }

    FloatPropertyComplexType::KeyType& FloatPropertyComplexType::
    getKey ()
    {
      return this->key_.get ();
    }

    void FloatPropertyComplexType::
    setKey (const KeyType& x)
    {
      this->key_.set (x);
    }

    void FloatPropertyComplexType::
    setKey (::std::auto_ptr< KeyType > x)
    {
      this->key_.set (x);
    }

    const FloatPropertyComplexType::ValueType& FloatPropertyComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    FloatPropertyComplexType::ValueType& FloatPropertyComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void FloatPropertyComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }


    // DoublePropertyComplexType
    // 

    const DoublePropertyComplexType::DescriptionOptional& DoublePropertyComplexType::
    getDescription () const
    {
      return this->description_;
    }

    DoublePropertyComplexType::DescriptionOptional& DoublePropertyComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void DoublePropertyComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void DoublePropertyComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void DoublePropertyComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const DoublePropertyComplexType::KeyType& DoublePropertyComplexType::
    getKey () const
    {
      return this->key_.get ();
    }

    DoublePropertyComplexType::KeyType& DoublePropertyComplexType::
    getKey ()
    {
      return this->key_.get ();
    }

    void DoublePropertyComplexType::
    setKey (const KeyType& x)
    {
      this->key_.set (x);
    }

    void DoublePropertyComplexType::
    setKey (::std::auto_ptr< KeyType > x)
    {
      this->key_.set (x);
    }

    const DoublePropertyComplexType::ValueType& DoublePropertyComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    DoublePropertyComplexType::ValueType& DoublePropertyComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void DoublePropertyComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }


    // DateTimePropertyComplexType
    // 

    const DateTimePropertyComplexType::DescriptionOptional& DateTimePropertyComplexType::
    getDescription () const
    {
      return this->description_;
    }

    DateTimePropertyComplexType::DescriptionOptional& DateTimePropertyComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void DateTimePropertyComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void DateTimePropertyComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void DateTimePropertyComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const DateTimePropertyComplexType::KeyType& DateTimePropertyComplexType::
    getKey () const
    {
      return this->key_.get ();
    }

    DateTimePropertyComplexType::KeyType& DateTimePropertyComplexType::
    getKey ()
    {
      return this->key_.get ();
    }

    void DateTimePropertyComplexType::
    setKey (const KeyType& x)
    {
      this->key_.set (x);
    }

    void DateTimePropertyComplexType::
    setKey (::std::auto_ptr< KeyType > x)
    {
      this->key_.set (x);
    }

    const DateTimePropertyComplexType::DateType& DateTimePropertyComplexType::
    getDate () const
    {
      return this->date_.get ();
    }

    DateTimePropertyComplexType::DateType& DateTimePropertyComplexType::
    getDate ()
    {
      return this->date_.get ();
    }

    void DateTimePropertyComplexType::
    setDate (const DateType& x)
    {
      this->date_.set (x);
    }

    void DateTimePropertyComplexType::
    setDate (::std::auto_ptr< DateType > x)
    {
      this->date_.set (x);
    }

    const DateTimePropertyComplexType::TimeType& DateTimePropertyComplexType::
    getTime () const
    {
      return this->time_.get ();
    }

    DateTimePropertyComplexType::TimeType& DateTimePropertyComplexType::
    getTime ()
    {
      return this->time_.get ();
    }

    void DateTimePropertyComplexType::
    setTime (const TimeType& x)
    {
      this->time_.set (x);
    }

    void DateTimePropertyComplexType::
    setTime (::std::auto_ptr< TimeType > x)
    {
      this->time_.set (x);
    }


    // BoolPropertyComplexType
    // 

    const BoolPropertyComplexType::DescriptionOptional& BoolPropertyComplexType::
    getDescription () const
    {
      return this->description_;
    }

    BoolPropertyComplexType::DescriptionOptional& BoolPropertyComplexType::
    getDescription ()
    {
      return this->description_;
    }

    void BoolPropertyComplexType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void BoolPropertyComplexType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void BoolPropertyComplexType::
    setDescription (::std::auto_ptr< DescriptionType > x)
    {
      this->description_.set (x);
    }

    const BoolPropertyComplexType::KeyType& BoolPropertyComplexType::
    getKey () const
    {
      return this->key_.get ();
    }

    BoolPropertyComplexType::KeyType& BoolPropertyComplexType::
    getKey ()
    {
      return this->key_.get ();
    }

    void BoolPropertyComplexType::
    setKey (const KeyType& x)
    {
      this->key_.set (x);
    }

    void BoolPropertyComplexType::
    setKey (::std::auto_ptr< KeyType > x)
    {
      this->key_.set (x);
    }

    const BoolPropertyComplexType::ValueType& BoolPropertyComplexType::
    getValue () const
    {
      return this->value_.get ();
    }

    BoolPropertyComplexType::ValueType& BoolPropertyComplexType::
    getValue ()
    {
      return this->value_.get ();
    }

    void BoolPropertyComplexType::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }


    // ValueTypeEnumStringType
    // 

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (Value v)
    : ::xml_schema::String (_xsd_ValueTypeEnumStringType_literals_[v])
    {
    }

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const char* v)
    : ::xml_schema::String (v)
    {
    }

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const ValueTypeEnumStringType& v,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    ValueTypeEnumStringType& ValueTypeEnumStringType::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_ValueTypeEnumStringType_literals_[v]);

      return *this;
    }


    // PeriodConditionComplexType
    // 

    const PeriodConditionComplexType::TimeZoneOptional& PeriodConditionComplexType::
    getTimeZone () const
    {
      return this->timeZone_;
    }

    PeriodConditionComplexType::TimeZoneOptional& PeriodConditionComplexType::
    getTimeZone ()
    {
      return this->timeZone_;
    }

    void PeriodConditionComplexType::
    setTimeZone (const TimeZoneType& x)
    {
      this->timeZone_.set (x);
    }

    void PeriodConditionComplexType::
    setTimeZone (const TimeZoneOptional& x)
    {
      this->timeZone_ = x;
    }

    void PeriodConditionComplexType::
    setTimeZone (::std::auto_ptr< TimeZoneType > x)
    {
      this->timeZone_.set (x);
    }

    const PeriodConditionComplexType::StartDateOptional& PeriodConditionComplexType::
    getStartDate () const
    {
      return this->startDate_;
    }

    PeriodConditionComplexType::StartDateOptional& PeriodConditionComplexType::
    getStartDate ()
    {
      return this->startDate_;
    }

    void PeriodConditionComplexType::
    setStartDate (const StartDateType& x)
    {
      this->startDate_.set (x);
    }

    void PeriodConditionComplexType::
    setStartDate (const StartDateOptional& x)
    {
      this->startDate_ = x;
    }

    void PeriodConditionComplexType::
    setStartDate (::std::auto_ptr< StartDateType > x)
    {
      this->startDate_.set (x);
    }

    const PeriodConditionComplexType::EndDateOptional& PeriodConditionComplexType::
    getEndDate () const
    {
      return this->endDate_;
    }

    PeriodConditionComplexType::EndDateOptional& PeriodConditionComplexType::
    getEndDate ()
    {
      return this->endDate_;
    }

    void PeriodConditionComplexType::
    setEndDate (const EndDateType& x)
    {
      this->endDate_.set (x);
    }

    void PeriodConditionComplexType::
    setEndDate (const EndDateOptional& x)
    {
      this->endDate_ = x;
    }

    void PeriodConditionComplexType::
    setEndDate (::std::auto_ptr< EndDateType > x)
    {
      this->endDate_.set (x);
    }

    const PeriodConditionComplexType::ValidBeforeDateOptional& PeriodConditionComplexType::
    getValidBeforeDate () const
    {
      return this->validBeforeDate_;
    }

    PeriodConditionComplexType::ValidBeforeDateOptional& PeriodConditionComplexType::
    getValidBeforeDate ()
    {
      return this->validBeforeDate_;
    }

    void PeriodConditionComplexType::
    setValidBeforeDate (const ValidBeforeDateType& x)
    {
      this->validBeforeDate_.set (x);
    }

    void PeriodConditionComplexType::
    setValidBeforeDate (const ValidBeforeDateOptional& x)
    {
      this->validBeforeDate_ = x;
    }

    void PeriodConditionComplexType::
    setValidBeforeDate (::std::auto_ptr< ValidBeforeDateType > x)
    {
      this->validBeforeDate_.set (x);
    }

    const PeriodConditionComplexType::ValidAfterDateOptional& PeriodConditionComplexType::
    getValidAfterDate () const
    {
      return this->validAfterDate_;
    }

    PeriodConditionComplexType::ValidAfterDateOptional& PeriodConditionComplexType::
    getValidAfterDate ()
    {
      return this->validAfterDate_;
    }

    void PeriodConditionComplexType::
    setValidAfterDate (const ValidAfterDateType& x)
    {
      this->validAfterDate_.set (x);
    }

    void PeriodConditionComplexType::
    setValidAfterDate (const ValidAfterDateOptional& x)
    {
      this->validAfterDate_ = x;
    }

    void PeriodConditionComplexType::
    setValidAfterDate (::std::auto_ptr< ValidAfterDateType > x)
    {
      this->validAfterDate_.set (x);
    }

    const PeriodConditionComplexType::StartMonthDayOptional& PeriodConditionComplexType::
    getStartMonthDay () const
    {
      return this->startMonthDay_;
    }

    PeriodConditionComplexType::StartMonthDayOptional& PeriodConditionComplexType::
    getStartMonthDay ()
    {
      return this->startMonthDay_;
    }

    void PeriodConditionComplexType::
    setStartMonthDay (const StartMonthDayType& x)
    {
      this->startMonthDay_.set (x);
    }

    void PeriodConditionComplexType::
    setStartMonthDay (const StartMonthDayOptional& x)
    {
      this->startMonthDay_ = x;
    }

    void PeriodConditionComplexType::
    setStartMonthDay (::std::auto_ptr< StartMonthDayType > x)
    {
      this->startMonthDay_.set (x);
    }

    const PeriodConditionComplexType::EndMonthDayOptional& PeriodConditionComplexType::
    getEndMonthDay () const
    {
      return this->endMonthDay_;
    }

    PeriodConditionComplexType::EndMonthDayOptional& PeriodConditionComplexType::
    getEndMonthDay ()
    {
      return this->endMonthDay_;
    }

    void PeriodConditionComplexType::
    setEndMonthDay (const EndMonthDayType& x)
    {
      this->endMonthDay_.set (x);
    }

    void PeriodConditionComplexType::
    setEndMonthDay (const EndMonthDayOptional& x)
    {
      this->endMonthDay_ = x;
    }

    void PeriodConditionComplexType::
    setEndMonthDay (::std::auto_ptr< EndMonthDayType > x)
    {
      this->endMonthDay_.set (x);
    }

    const PeriodConditionComplexType::MonthDaySequence& PeriodConditionComplexType::
    getMonthDay () const
    {
      return this->monthDay_;
    }

    PeriodConditionComplexType::MonthDaySequence& PeriodConditionComplexType::
    getMonthDay ()
    {
      return this->monthDay_;
    }

    void PeriodConditionComplexType::
    setMonthDay (const MonthDaySequence& s)
    {
      this->monthDay_ = s;
    }

    const PeriodConditionComplexType::MonthSequence& PeriodConditionComplexType::
    getMonth () const
    {
      return this->month_;
    }

    PeriodConditionComplexType::MonthSequence& PeriodConditionComplexType::
    getMonth ()
    {
      return this->month_;
    }

    void PeriodConditionComplexType::
    setMonth (const MonthSequence& s)
    {
      this->month_ = s;
    }

    const PeriodConditionComplexType::DaySequence& PeriodConditionComplexType::
    getDay () const
    {
      return this->day_;
    }

    PeriodConditionComplexType::DaySequence& PeriodConditionComplexType::
    getDay ()
    {
      return this->day_;
    }

    void PeriodConditionComplexType::
    setDay (const DaySequence& s)
    {
      this->day_ = s;
    }


    // EnsembleMemberComplexType
    // 

    const EnsembleMemberComplexType::IndexType& EnsembleMemberComplexType::
    getIndex () const
    {
      return this->index_.get ();
    }

    EnsembleMemberComplexType::IndexType& EnsembleMemberComplexType::
    getIndex ()
    {
      return this->index_.get ();
    }

    void EnsembleMemberComplexType::
    setIndex (const IndexType& x)
    {
      this->index_.set (x);
    }

    const EnsembleMemberComplexType::WeightOptional& EnsembleMemberComplexType::
    getWeight () const
    {
      return this->weight_;
    }

    EnsembleMemberComplexType::WeightOptional& EnsembleMemberComplexType::
    getWeight ()
    {
      return this->weight_;
    }

    void EnsembleMemberComplexType::
    setWeight (const WeightType& x)
    {
      this->weight_.set (x);
    }

    void EnsembleMemberComplexType::
    setWeight (const WeightOptional& x)
    {
      this->weight_ = x;
    }


    // EnsembleMemberRangeComplexType
    // 

    const EnsembleMemberRangeComplexType::StartType& EnsembleMemberRangeComplexType::
    getStart () const
    {
      return this->start_.get ();
    }

    EnsembleMemberRangeComplexType::StartType& EnsembleMemberRangeComplexType::
    getStart ()
    {
      return this->start_.get ();
    }

    void EnsembleMemberRangeComplexType::
    setStart (const StartType& x)
    {
      this->start_.set (x);
    }

    const EnsembleMemberRangeComplexType::EndOptional& EnsembleMemberRangeComplexType::
    getEnd () const
    {
      return this->end_;
    }

    EnsembleMemberRangeComplexType::EndOptional& EnsembleMemberRangeComplexType::
    getEnd ()
    {
      return this->end_;
    }

    void EnsembleMemberRangeComplexType::
    setEnd (const EndType& x)
    {
      this->end_.set (x);
    }

    void EnsembleMemberRangeComplexType::
    setEnd (const EndOptional& x)
    {
      this->end_ = x;
    }

    const EnsembleMemberRangeComplexType::WeightOptional& EnsembleMemberRangeComplexType::
    getWeight () const
    {
      return this->weight_;
    }

    EnsembleMemberRangeComplexType::WeightOptional& EnsembleMemberRangeComplexType::
    getWeight ()
    {
      return this->weight_;
    }

    void EnsembleMemberRangeComplexType::
    setWeight (const WeightType& x)
    {
      this->weight_.set (x);
    }

    void EnsembleMemberRangeComplexType::
    setWeight (const WeightOptional& x)
    {
      this->weight_ = x;
    }


    // GlobalTableComplexType
    // 

    const GlobalTableComplexType::ColumnIdsOptional& GlobalTableComplexType::
    getColumnIds () const
    {
      return this->columnIds_;
    }

    GlobalTableComplexType::ColumnIdsOptional& GlobalTableComplexType::
    getColumnIds ()
    {
      return this->columnIds_;
    }

    void GlobalTableComplexType::
    setColumnIds (const ColumnIdsType& x)
    {
      this->columnIds_.set (x);
    }

    void GlobalTableComplexType::
    setColumnIds (const ColumnIdsOptional& x)
    {
      this->columnIds_ = x;
    }

    void GlobalTableComplexType::
    setColumnIds (::std::auto_ptr< ColumnIdsType > x)
    {
      this->columnIds_.set (x);
    }

    const GlobalTableComplexType::ColumnTypesOptional& GlobalTableComplexType::
    getColumnTypes () const
    {
      return this->columnTypes_;
    }

    GlobalTableComplexType::ColumnTypesOptional& GlobalTableComplexType::
    getColumnTypes ()
    {
      return this->columnTypes_;
    }

    void GlobalTableComplexType::
    setColumnTypes (const ColumnTypesType& x)
    {
      this->columnTypes_.set (x);
    }

    void GlobalTableComplexType::
    setColumnTypes (const ColumnTypesOptional& x)
    {
      this->columnTypes_ = x;
    }

    void GlobalTableComplexType::
    setColumnTypes (::std::auto_ptr< ColumnTypesType > x)
    {
      this->columnTypes_.set (x);
    }

    const GlobalTableComplexType::ColumnUnitsOptional& GlobalTableComplexType::
    getColumnUnits () const
    {
      return this->columnUnits_;
    }

    GlobalTableComplexType::ColumnUnitsOptional& GlobalTableComplexType::
    getColumnUnits ()
    {
      return this->columnUnits_;
    }

    void GlobalTableComplexType::
    setColumnUnits (const ColumnUnitsType& x)
    {
      this->columnUnits_.set (x);
    }

    void GlobalTableComplexType::
    setColumnUnits (const ColumnUnitsOptional& x)
    {
      this->columnUnits_ = x;
    }

    void GlobalTableComplexType::
    setColumnUnits (::std::auto_ptr< ColumnUnitsType > x)
    {
      this->columnUnits_.set (x);
    }

    const GlobalTableComplexType::ColumnMetaDataSequence& GlobalTableComplexType::
    getColumnMetaData () const
    {
      return this->columnMetaData_;
    }

    GlobalTableComplexType::ColumnMetaDataSequence& GlobalTableComplexType::
    getColumnMetaData ()
    {
      return this->columnMetaData_;
    }

    void GlobalTableComplexType::
    setColumnMetaData (const ColumnMetaDataSequence& s)
    {
      this->columnMetaData_ = s;
    }

    const GlobalTableComplexType::RowSequence& GlobalTableComplexType::
    getRow () const
    {
      return this->row_;
    }

    GlobalTableComplexType::RowSequence& GlobalTableComplexType::
    getRow ()
    {
      return this->row_;
    }

    void GlobalTableComplexType::
    setRow (const RowSequence& s)
    {
      this->row_ = s;
    }


    // ColumnIdsComplexType
    // 

    const ColumnIdsComplexType::AType& ColumnIdsComplexType::
    getA () const
    {
      return this->A_.get ();
    }

    ColumnIdsComplexType::AType& ColumnIdsComplexType::
    getA ()
    {
      return this->A_.get ();
    }

    void ColumnIdsComplexType::
    setA (const AType& x)
    {
      this->A_.set (x);
    }

    void ColumnIdsComplexType::
    setA (::std::auto_ptr< AType > x)
    {
      this->A_.set (x);
    }

    const ColumnIdsComplexType::BOptional& ColumnIdsComplexType::
    getB () const
    {
      return this->B_;
    }

    ColumnIdsComplexType::BOptional& ColumnIdsComplexType::
    getB ()
    {
      return this->B_;
    }

    void ColumnIdsComplexType::
    setB (const BType& x)
    {
      this->B_.set (x);
    }

    void ColumnIdsComplexType::
    setB (const BOptional& x)
    {
      this->B_ = x;
    }

    void ColumnIdsComplexType::
    setB (::std::auto_ptr< BType > x)
    {
      this->B_.set (x);
    }

    const ColumnIdsComplexType::COptional& ColumnIdsComplexType::
    getC () const
    {
      return this->C_;
    }

    ColumnIdsComplexType::COptional& ColumnIdsComplexType::
    getC ()
    {
      return this->C_;
    }

    void ColumnIdsComplexType::
    setC (const CType& x)
    {
      this->C_.set (x);
    }

    void ColumnIdsComplexType::
    setC (const COptional& x)
    {
      this->C_ = x;
    }

    void ColumnIdsComplexType::
    setC (::std::auto_ptr< CType > x)
    {
      this->C_.set (x);
    }

    const ColumnIdsComplexType::DOptional& ColumnIdsComplexType::
    getD () const
    {
      return this->D_;
    }

    ColumnIdsComplexType::DOptional& ColumnIdsComplexType::
    getD ()
    {
      return this->D_;
    }

    void ColumnIdsComplexType::
    setD (const DType& x)
    {
      this->D_.set (x);
    }

    void ColumnIdsComplexType::
    setD (const DOptional& x)
    {
      this->D_ = x;
    }

    void ColumnIdsComplexType::
    setD (::std::auto_ptr< DType > x)
    {
      this->D_.set (x);
    }

    const ColumnIdsComplexType::EOptional& ColumnIdsComplexType::
    getE () const
    {
      return this->E_;
    }

    ColumnIdsComplexType::EOptional& ColumnIdsComplexType::
    getE ()
    {
      return this->E_;
    }

    void ColumnIdsComplexType::
    setE (const EType& x)
    {
      this->E_.set (x);
    }

    void ColumnIdsComplexType::
    setE (const EOptional& x)
    {
      this->E_ = x;
    }

    void ColumnIdsComplexType::
    setE (::std::auto_ptr< EType > x)
    {
      this->E_.set (x);
    }

    const ColumnIdsComplexType::FOptional& ColumnIdsComplexType::
    getF () const
    {
      return this->F_;
    }

    ColumnIdsComplexType::FOptional& ColumnIdsComplexType::
    getF ()
    {
      return this->F_;
    }

    void ColumnIdsComplexType::
    setF (const FType& x)
    {
      this->F_.set (x);
    }

    void ColumnIdsComplexType::
    setF (const FOptional& x)
    {
      this->F_ = x;
    }

    void ColumnIdsComplexType::
    setF (::std::auto_ptr< FType > x)
    {
      this->F_.set (x);
    }

    const ColumnIdsComplexType::GOptional& ColumnIdsComplexType::
    getG () const
    {
      return this->G_;
    }

    ColumnIdsComplexType::GOptional& ColumnIdsComplexType::
    getG ()
    {
      return this->G_;
    }

    void ColumnIdsComplexType::
    setG (const GType& x)
    {
      this->G_.set (x);
    }

    void ColumnIdsComplexType::
    setG (const GOptional& x)
    {
      this->G_ = x;
    }

    void ColumnIdsComplexType::
    setG (::std::auto_ptr< GType > x)
    {
      this->G_.set (x);
    }

    const ColumnIdsComplexType::HOptional& ColumnIdsComplexType::
    getH () const
    {
      return this->H_;
    }

    ColumnIdsComplexType::HOptional& ColumnIdsComplexType::
    getH ()
    {
      return this->H_;
    }

    void ColumnIdsComplexType::
    setH (const HType& x)
    {
      this->H_.set (x);
    }

    void ColumnIdsComplexType::
    setH (const HOptional& x)
    {
      this->H_ = x;
    }

    void ColumnIdsComplexType::
    setH (::std::auto_ptr< HType > x)
    {
      this->H_.set (x);
    }

    const ColumnIdsComplexType::IOptional& ColumnIdsComplexType::
    getI () const
    {
      return this->I_;
    }

    ColumnIdsComplexType::IOptional& ColumnIdsComplexType::
    getI ()
    {
      return this->I_;
    }

    void ColumnIdsComplexType::
    setI (const IType& x)
    {
      this->I_.set (x);
    }

    void ColumnIdsComplexType::
    setI (const IOptional& x)
    {
      this->I_ = x;
    }

    void ColumnIdsComplexType::
    setI (::std::auto_ptr< IType > x)
    {
      this->I_.set (x);
    }

    const ColumnIdsComplexType::JOptional& ColumnIdsComplexType::
    getJ () const
    {
      return this->J_;
    }

    ColumnIdsComplexType::JOptional& ColumnIdsComplexType::
    getJ ()
    {
      return this->J_;
    }

    void ColumnIdsComplexType::
    setJ (const JType& x)
    {
      this->J_.set (x);
    }

    void ColumnIdsComplexType::
    setJ (const JOptional& x)
    {
      this->J_ = x;
    }

    void ColumnIdsComplexType::
    setJ (::std::auto_ptr< JType > x)
    {
      this->J_.set (x);
    }

    const ColumnIdsComplexType::KOptional& ColumnIdsComplexType::
    getK () const
    {
      return this->K_;
    }

    ColumnIdsComplexType::KOptional& ColumnIdsComplexType::
    getK ()
    {
      return this->K_;
    }

    void ColumnIdsComplexType::
    setK (const KType& x)
    {
      this->K_.set (x);
    }

    void ColumnIdsComplexType::
    setK (const KOptional& x)
    {
      this->K_ = x;
    }

    void ColumnIdsComplexType::
    setK (::std::auto_ptr< KType > x)
    {
      this->K_.set (x);
    }

    const ColumnIdsComplexType::LOptional& ColumnIdsComplexType::
    getL () const
    {
      return this->L_;
    }

    ColumnIdsComplexType::LOptional& ColumnIdsComplexType::
    getL ()
    {
      return this->L_;
    }

    void ColumnIdsComplexType::
    setL (const LType& x)
    {
      this->L_.set (x);
    }

    void ColumnIdsComplexType::
    setL (const LOptional& x)
    {
      this->L_ = x;
    }

    void ColumnIdsComplexType::
    setL (::std::auto_ptr< LType > x)
    {
      this->L_.set (x);
    }

    const ColumnIdsComplexType::MOptional& ColumnIdsComplexType::
    getM () const
    {
      return this->M_;
    }

    ColumnIdsComplexType::MOptional& ColumnIdsComplexType::
    getM ()
    {
      return this->M_;
    }

    void ColumnIdsComplexType::
    setM (const MType& x)
    {
      this->M_.set (x);
    }

    void ColumnIdsComplexType::
    setM (const MOptional& x)
    {
      this->M_ = x;
    }

    void ColumnIdsComplexType::
    setM (::std::auto_ptr< MType > x)
    {
      this->M_.set (x);
    }

    const ColumnIdsComplexType::NOptional& ColumnIdsComplexType::
    getN () const
    {
      return this->N_;
    }

    ColumnIdsComplexType::NOptional& ColumnIdsComplexType::
    getN ()
    {
      return this->N_;
    }

    void ColumnIdsComplexType::
    setN (const NType& x)
    {
      this->N_.set (x);
    }

    void ColumnIdsComplexType::
    setN (const NOptional& x)
    {
      this->N_ = x;
    }

    void ColumnIdsComplexType::
    setN (::std::auto_ptr< NType > x)
    {
      this->N_.set (x);
    }

    const ColumnIdsComplexType::OOptional& ColumnIdsComplexType::
    getO () const
    {
      return this->O_;
    }

    ColumnIdsComplexType::OOptional& ColumnIdsComplexType::
    getO ()
    {
      return this->O_;
    }

    void ColumnIdsComplexType::
    setO (const OType& x)
    {
      this->O_.set (x);
    }

    void ColumnIdsComplexType::
    setO (const OOptional& x)
    {
      this->O_ = x;
    }

    void ColumnIdsComplexType::
    setO (::std::auto_ptr< OType > x)
    {
      this->O_.set (x);
    }

    const ColumnIdsComplexType::POptional& ColumnIdsComplexType::
    getP () const
    {
      return this->P_;
    }

    ColumnIdsComplexType::POptional& ColumnIdsComplexType::
    getP ()
    {
      return this->P_;
    }

    void ColumnIdsComplexType::
    setP (const PType& x)
    {
      this->P_.set (x);
    }

    void ColumnIdsComplexType::
    setP (const POptional& x)
    {
      this->P_ = x;
    }

    void ColumnIdsComplexType::
    setP (::std::auto_ptr< PType > x)
    {
      this->P_.set (x);
    }

    const ColumnIdsComplexType::QOptional& ColumnIdsComplexType::
    getQ () const
    {
      return this->Q_;
    }

    ColumnIdsComplexType::QOptional& ColumnIdsComplexType::
    getQ ()
    {
      return this->Q_;
    }

    void ColumnIdsComplexType::
    setQ (const QType& x)
    {
      this->Q_.set (x);
    }

    void ColumnIdsComplexType::
    setQ (const QOptional& x)
    {
      this->Q_ = x;
    }

    void ColumnIdsComplexType::
    setQ (::std::auto_ptr< QType > x)
    {
      this->Q_.set (x);
    }

    const ColumnIdsComplexType::ROptional& ColumnIdsComplexType::
    getR () const
    {
      return this->R_;
    }

    ColumnIdsComplexType::ROptional& ColumnIdsComplexType::
    getR ()
    {
      return this->R_;
    }

    void ColumnIdsComplexType::
    setR (const RType& x)
    {
      this->R_.set (x);
    }

    void ColumnIdsComplexType::
    setR (const ROptional& x)
    {
      this->R_ = x;
    }

    void ColumnIdsComplexType::
    setR (::std::auto_ptr< RType > x)
    {
      this->R_.set (x);
    }

    const ColumnIdsComplexType::SOptional& ColumnIdsComplexType::
    getS () const
    {
      return this->S_;
    }

    ColumnIdsComplexType::SOptional& ColumnIdsComplexType::
    getS ()
    {
      return this->S_;
    }

    void ColumnIdsComplexType::
    setS (const SType& x)
    {
      this->S_.set (x);
    }

    void ColumnIdsComplexType::
    setS (const SOptional& x)
    {
      this->S_ = x;
    }

    void ColumnIdsComplexType::
    setS (::std::auto_ptr< SType > x)
    {
      this->S_.set (x);
    }

    const ColumnIdsComplexType::TOptional& ColumnIdsComplexType::
    getT () const
    {
      return this->T_;
    }

    ColumnIdsComplexType::TOptional& ColumnIdsComplexType::
    getT ()
    {
      return this->T_;
    }

    void ColumnIdsComplexType::
    setT (const TType& x)
    {
      this->T_.set (x);
    }

    void ColumnIdsComplexType::
    setT (const TOptional& x)
    {
      this->T_ = x;
    }

    void ColumnIdsComplexType::
    setT (::std::auto_ptr< TType > x)
    {
      this->T_.set (x);
    }

    const ColumnIdsComplexType::UOptional& ColumnIdsComplexType::
    getU () const
    {
      return this->U_;
    }

    ColumnIdsComplexType::UOptional& ColumnIdsComplexType::
    getU ()
    {
      return this->U_;
    }

    void ColumnIdsComplexType::
    setU (const UType& x)
    {
      this->U_.set (x);
    }

    void ColumnIdsComplexType::
    setU (const UOptional& x)
    {
      this->U_ = x;
    }

    void ColumnIdsComplexType::
    setU (::std::auto_ptr< UType > x)
    {
      this->U_.set (x);
    }

    const ColumnIdsComplexType::VOptional& ColumnIdsComplexType::
    getV () const
    {
      return this->V_;
    }

    ColumnIdsComplexType::VOptional& ColumnIdsComplexType::
    getV ()
    {
      return this->V_;
    }

    void ColumnIdsComplexType::
    setV (const VType& x)
    {
      this->V_.set (x);
    }

    void ColumnIdsComplexType::
    setV (const VOptional& x)
    {
      this->V_ = x;
    }

    void ColumnIdsComplexType::
    setV (::std::auto_ptr< VType > x)
    {
      this->V_.set (x);
    }

    const ColumnIdsComplexType::WOptional& ColumnIdsComplexType::
    getW () const
    {
      return this->W_;
    }

    ColumnIdsComplexType::WOptional& ColumnIdsComplexType::
    getW ()
    {
      return this->W_;
    }

    void ColumnIdsComplexType::
    setW (const WType& x)
    {
      this->W_.set (x);
    }

    void ColumnIdsComplexType::
    setW (const WOptional& x)
    {
      this->W_ = x;
    }

    void ColumnIdsComplexType::
    setW (::std::auto_ptr< WType > x)
    {
      this->W_.set (x);
    }

    const ColumnIdsComplexType::XOptional& ColumnIdsComplexType::
    getX () const
    {
      return this->X_;
    }

    ColumnIdsComplexType::XOptional& ColumnIdsComplexType::
    getX ()
    {
      return this->X_;
    }

    void ColumnIdsComplexType::
    setX (const XType& x)
    {
      this->X_.set (x);
    }

    void ColumnIdsComplexType::
    setX (const XOptional& x)
    {
      this->X_ = x;
    }

    void ColumnIdsComplexType::
    setX (::std::auto_ptr< XType > x)
    {
      this->X_.set (x);
    }

    const ColumnIdsComplexType::YOptional& ColumnIdsComplexType::
    getY () const
    {
      return this->Y_;
    }

    ColumnIdsComplexType::YOptional& ColumnIdsComplexType::
    getY ()
    {
      return this->Y_;
    }

    void ColumnIdsComplexType::
    setY (const YType& x)
    {
      this->Y_.set (x);
    }

    void ColumnIdsComplexType::
    setY (const YOptional& x)
    {
      this->Y_ = x;
    }

    void ColumnIdsComplexType::
    setY (::std::auto_ptr< YType > x)
    {
      this->Y_.set (x);
    }

    const ColumnIdsComplexType::ZOptional& ColumnIdsComplexType::
    getZ () const
    {
      return this->Z_;
    }

    ColumnIdsComplexType::ZOptional& ColumnIdsComplexType::
    getZ ()
    {
      return this->Z_;
    }

    void ColumnIdsComplexType::
    setZ (const ZType& x)
    {
      this->Z_.set (x);
    }

    void ColumnIdsComplexType::
    setZ (const ZOptional& x)
    {
      this->Z_ = x;
    }

    void ColumnIdsComplexType::
    setZ (::std::auto_ptr< ZType > x)
    {
      this->Z_.set (x);
    }


    // ColumnMetaDataComplexType
    // 

    const ColumnMetaDataComplexType::IdOptional& ColumnMetaDataComplexType::
    getId () const
    {
      return this->id_;
    }

    ColumnMetaDataComplexType::IdOptional& ColumnMetaDataComplexType::
    getId ()
    {
      return this->id_;
    }

    void ColumnMetaDataComplexType::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void ColumnMetaDataComplexType::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void ColumnMetaDataComplexType::
    setId (::std::auto_ptr< IdType > x)
    {
      this->id_.set (x);
    }

    const ColumnMetaDataComplexType::TypeOptional& ColumnMetaDataComplexType::
    getType () const
    {
      return this->type_;
    }

    ColumnMetaDataComplexType::TypeOptional& ColumnMetaDataComplexType::
    getType ()
    {
      return this->type_;
    }

    void ColumnMetaDataComplexType::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void ColumnMetaDataComplexType::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void ColumnMetaDataComplexType::
    setType (::std::auto_ptr< TypeType > x)
    {
      this->type_.set (x);
    }


    // ColumnTypesComplexType
    // 

    const ColumnTypesComplexType::AType& ColumnTypesComplexType::
    getA () const
    {
      return this->A_.get ();
    }

    ColumnTypesComplexType::AType& ColumnTypesComplexType::
    getA ()
    {
      return this->A_.get ();
    }

    void ColumnTypesComplexType::
    setA (const AType& x)
    {
      this->A_.set (x);
    }

    void ColumnTypesComplexType::
    setA (::std::auto_ptr< AType > x)
    {
      this->A_.set (x);
    }

    const ColumnTypesComplexType::BOptional& ColumnTypesComplexType::
    getB () const
    {
      return this->B_;
    }

    ColumnTypesComplexType::BOptional& ColumnTypesComplexType::
    getB ()
    {
      return this->B_;
    }

    void ColumnTypesComplexType::
    setB (const BType& x)
    {
      this->B_.set (x);
    }

    void ColumnTypesComplexType::
    setB (const BOptional& x)
    {
      this->B_ = x;
    }

    void ColumnTypesComplexType::
    setB (::std::auto_ptr< BType > x)
    {
      this->B_.set (x);
    }

    const ColumnTypesComplexType::COptional& ColumnTypesComplexType::
    getC () const
    {
      return this->C_;
    }

    ColumnTypesComplexType::COptional& ColumnTypesComplexType::
    getC ()
    {
      return this->C_;
    }

    void ColumnTypesComplexType::
    setC (const CType& x)
    {
      this->C_.set (x);
    }

    void ColumnTypesComplexType::
    setC (const COptional& x)
    {
      this->C_ = x;
    }

    void ColumnTypesComplexType::
    setC (::std::auto_ptr< CType > x)
    {
      this->C_.set (x);
    }

    const ColumnTypesComplexType::DOptional& ColumnTypesComplexType::
    getD () const
    {
      return this->D_;
    }

    ColumnTypesComplexType::DOptional& ColumnTypesComplexType::
    getD ()
    {
      return this->D_;
    }

    void ColumnTypesComplexType::
    setD (const DType& x)
    {
      this->D_.set (x);
    }

    void ColumnTypesComplexType::
    setD (const DOptional& x)
    {
      this->D_ = x;
    }

    void ColumnTypesComplexType::
    setD (::std::auto_ptr< DType > x)
    {
      this->D_.set (x);
    }

    const ColumnTypesComplexType::EOptional& ColumnTypesComplexType::
    getE () const
    {
      return this->E_;
    }

    ColumnTypesComplexType::EOptional& ColumnTypesComplexType::
    getE ()
    {
      return this->E_;
    }

    void ColumnTypesComplexType::
    setE (const EType& x)
    {
      this->E_.set (x);
    }

    void ColumnTypesComplexType::
    setE (const EOptional& x)
    {
      this->E_ = x;
    }

    void ColumnTypesComplexType::
    setE (::std::auto_ptr< EType > x)
    {
      this->E_.set (x);
    }

    const ColumnTypesComplexType::FOptional& ColumnTypesComplexType::
    getF () const
    {
      return this->F_;
    }

    ColumnTypesComplexType::FOptional& ColumnTypesComplexType::
    getF ()
    {
      return this->F_;
    }

    void ColumnTypesComplexType::
    setF (const FType& x)
    {
      this->F_.set (x);
    }

    void ColumnTypesComplexType::
    setF (const FOptional& x)
    {
      this->F_ = x;
    }

    void ColumnTypesComplexType::
    setF (::std::auto_ptr< FType > x)
    {
      this->F_.set (x);
    }

    const ColumnTypesComplexType::GOptional& ColumnTypesComplexType::
    getG () const
    {
      return this->G_;
    }

    ColumnTypesComplexType::GOptional& ColumnTypesComplexType::
    getG ()
    {
      return this->G_;
    }

    void ColumnTypesComplexType::
    setG (const GType& x)
    {
      this->G_.set (x);
    }

    void ColumnTypesComplexType::
    setG (const GOptional& x)
    {
      this->G_ = x;
    }

    void ColumnTypesComplexType::
    setG (::std::auto_ptr< GType > x)
    {
      this->G_.set (x);
    }

    const ColumnTypesComplexType::HOptional& ColumnTypesComplexType::
    getH () const
    {
      return this->H_;
    }

    ColumnTypesComplexType::HOptional& ColumnTypesComplexType::
    getH ()
    {
      return this->H_;
    }

    void ColumnTypesComplexType::
    setH (const HType& x)
    {
      this->H_.set (x);
    }

    void ColumnTypesComplexType::
    setH (const HOptional& x)
    {
      this->H_ = x;
    }

    void ColumnTypesComplexType::
    setH (::std::auto_ptr< HType > x)
    {
      this->H_.set (x);
    }

    const ColumnTypesComplexType::IOptional& ColumnTypesComplexType::
    getI () const
    {
      return this->I_;
    }

    ColumnTypesComplexType::IOptional& ColumnTypesComplexType::
    getI ()
    {
      return this->I_;
    }

    void ColumnTypesComplexType::
    setI (const IType& x)
    {
      this->I_.set (x);
    }

    void ColumnTypesComplexType::
    setI (const IOptional& x)
    {
      this->I_ = x;
    }

    void ColumnTypesComplexType::
    setI (::std::auto_ptr< IType > x)
    {
      this->I_.set (x);
    }

    const ColumnTypesComplexType::JOptional& ColumnTypesComplexType::
    getJ () const
    {
      return this->J_;
    }

    ColumnTypesComplexType::JOptional& ColumnTypesComplexType::
    getJ ()
    {
      return this->J_;
    }

    void ColumnTypesComplexType::
    setJ (const JType& x)
    {
      this->J_.set (x);
    }

    void ColumnTypesComplexType::
    setJ (const JOptional& x)
    {
      this->J_ = x;
    }

    void ColumnTypesComplexType::
    setJ (::std::auto_ptr< JType > x)
    {
      this->J_.set (x);
    }

    const ColumnTypesComplexType::KOptional& ColumnTypesComplexType::
    getK () const
    {
      return this->K_;
    }

    ColumnTypesComplexType::KOptional& ColumnTypesComplexType::
    getK ()
    {
      return this->K_;
    }

    void ColumnTypesComplexType::
    setK (const KType& x)
    {
      this->K_.set (x);
    }

    void ColumnTypesComplexType::
    setK (const KOptional& x)
    {
      this->K_ = x;
    }

    void ColumnTypesComplexType::
    setK (::std::auto_ptr< KType > x)
    {
      this->K_.set (x);
    }

    const ColumnTypesComplexType::LOptional& ColumnTypesComplexType::
    getL () const
    {
      return this->L_;
    }

    ColumnTypesComplexType::LOptional& ColumnTypesComplexType::
    getL ()
    {
      return this->L_;
    }

    void ColumnTypesComplexType::
    setL (const LType& x)
    {
      this->L_.set (x);
    }

    void ColumnTypesComplexType::
    setL (const LOptional& x)
    {
      this->L_ = x;
    }

    void ColumnTypesComplexType::
    setL (::std::auto_ptr< LType > x)
    {
      this->L_.set (x);
    }

    const ColumnTypesComplexType::MOptional& ColumnTypesComplexType::
    getM () const
    {
      return this->M_;
    }

    ColumnTypesComplexType::MOptional& ColumnTypesComplexType::
    getM ()
    {
      return this->M_;
    }

    void ColumnTypesComplexType::
    setM (const MType& x)
    {
      this->M_.set (x);
    }

    void ColumnTypesComplexType::
    setM (const MOptional& x)
    {
      this->M_ = x;
    }

    void ColumnTypesComplexType::
    setM (::std::auto_ptr< MType > x)
    {
      this->M_.set (x);
    }

    const ColumnTypesComplexType::NOptional& ColumnTypesComplexType::
    getN () const
    {
      return this->N_;
    }

    ColumnTypesComplexType::NOptional& ColumnTypesComplexType::
    getN ()
    {
      return this->N_;
    }

    void ColumnTypesComplexType::
    setN (const NType& x)
    {
      this->N_.set (x);
    }

    void ColumnTypesComplexType::
    setN (const NOptional& x)
    {
      this->N_ = x;
    }

    void ColumnTypesComplexType::
    setN (::std::auto_ptr< NType > x)
    {
      this->N_.set (x);
    }

    const ColumnTypesComplexType::OOptional& ColumnTypesComplexType::
    getO () const
    {
      return this->O_;
    }

    ColumnTypesComplexType::OOptional& ColumnTypesComplexType::
    getO ()
    {
      return this->O_;
    }

    void ColumnTypesComplexType::
    setO (const OType& x)
    {
      this->O_.set (x);
    }

    void ColumnTypesComplexType::
    setO (const OOptional& x)
    {
      this->O_ = x;
    }

    void ColumnTypesComplexType::
    setO (::std::auto_ptr< OType > x)
    {
      this->O_.set (x);
    }

    const ColumnTypesComplexType::POptional& ColumnTypesComplexType::
    getP () const
    {
      return this->P_;
    }

    ColumnTypesComplexType::POptional& ColumnTypesComplexType::
    getP ()
    {
      return this->P_;
    }

    void ColumnTypesComplexType::
    setP (const PType& x)
    {
      this->P_.set (x);
    }

    void ColumnTypesComplexType::
    setP (const POptional& x)
    {
      this->P_ = x;
    }

    void ColumnTypesComplexType::
    setP (::std::auto_ptr< PType > x)
    {
      this->P_.set (x);
    }

    const ColumnTypesComplexType::QOptional& ColumnTypesComplexType::
    getQ () const
    {
      return this->Q_;
    }

    ColumnTypesComplexType::QOptional& ColumnTypesComplexType::
    getQ ()
    {
      return this->Q_;
    }

    void ColumnTypesComplexType::
    setQ (const QType& x)
    {
      this->Q_.set (x);
    }

    void ColumnTypesComplexType::
    setQ (const QOptional& x)
    {
      this->Q_ = x;
    }

    void ColumnTypesComplexType::
    setQ (::std::auto_ptr< QType > x)
    {
      this->Q_.set (x);
    }

    const ColumnTypesComplexType::ROptional& ColumnTypesComplexType::
    getR () const
    {
      return this->R_;
    }

    ColumnTypesComplexType::ROptional& ColumnTypesComplexType::
    getR ()
    {
      return this->R_;
    }

    void ColumnTypesComplexType::
    setR (const RType& x)
    {
      this->R_.set (x);
    }

    void ColumnTypesComplexType::
    setR (const ROptional& x)
    {
      this->R_ = x;
    }

    void ColumnTypesComplexType::
    setR (::std::auto_ptr< RType > x)
    {
      this->R_.set (x);
    }

    const ColumnTypesComplexType::SOptional& ColumnTypesComplexType::
    getS () const
    {
      return this->S_;
    }

    ColumnTypesComplexType::SOptional& ColumnTypesComplexType::
    getS ()
    {
      return this->S_;
    }

    void ColumnTypesComplexType::
    setS (const SType& x)
    {
      this->S_.set (x);
    }

    void ColumnTypesComplexType::
    setS (const SOptional& x)
    {
      this->S_ = x;
    }

    void ColumnTypesComplexType::
    setS (::std::auto_ptr< SType > x)
    {
      this->S_.set (x);
    }

    const ColumnTypesComplexType::TOptional& ColumnTypesComplexType::
    getT () const
    {
      return this->T_;
    }

    ColumnTypesComplexType::TOptional& ColumnTypesComplexType::
    getT ()
    {
      return this->T_;
    }

    void ColumnTypesComplexType::
    setT (const TType& x)
    {
      this->T_.set (x);
    }

    void ColumnTypesComplexType::
    setT (const TOptional& x)
    {
      this->T_ = x;
    }

    void ColumnTypesComplexType::
    setT (::std::auto_ptr< TType > x)
    {
      this->T_.set (x);
    }

    const ColumnTypesComplexType::UOptional& ColumnTypesComplexType::
    getU () const
    {
      return this->U_;
    }

    ColumnTypesComplexType::UOptional& ColumnTypesComplexType::
    getU ()
    {
      return this->U_;
    }

    void ColumnTypesComplexType::
    setU (const UType& x)
    {
      this->U_.set (x);
    }

    void ColumnTypesComplexType::
    setU (const UOptional& x)
    {
      this->U_ = x;
    }

    void ColumnTypesComplexType::
    setU (::std::auto_ptr< UType > x)
    {
      this->U_.set (x);
    }

    const ColumnTypesComplexType::VOptional& ColumnTypesComplexType::
    getV () const
    {
      return this->V_;
    }

    ColumnTypesComplexType::VOptional& ColumnTypesComplexType::
    getV ()
    {
      return this->V_;
    }

    void ColumnTypesComplexType::
    setV (const VType& x)
    {
      this->V_.set (x);
    }

    void ColumnTypesComplexType::
    setV (const VOptional& x)
    {
      this->V_ = x;
    }

    void ColumnTypesComplexType::
    setV (::std::auto_ptr< VType > x)
    {
      this->V_.set (x);
    }

    const ColumnTypesComplexType::WOptional& ColumnTypesComplexType::
    getW () const
    {
      return this->W_;
    }

    ColumnTypesComplexType::WOptional& ColumnTypesComplexType::
    getW ()
    {
      return this->W_;
    }

    void ColumnTypesComplexType::
    setW (const WType& x)
    {
      this->W_.set (x);
    }

    void ColumnTypesComplexType::
    setW (const WOptional& x)
    {
      this->W_ = x;
    }

    void ColumnTypesComplexType::
    setW (::std::auto_ptr< WType > x)
    {
      this->W_.set (x);
    }

    const ColumnTypesComplexType::XOptional& ColumnTypesComplexType::
    getX () const
    {
      return this->X_;
    }

    ColumnTypesComplexType::XOptional& ColumnTypesComplexType::
    getX ()
    {
      return this->X_;
    }

    void ColumnTypesComplexType::
    setX (const XType& x)
    {
      this->X_.set (x);
    }

    void ColumnTypesComplexType::
    setX (const XOptional& x)
    {
      this->X_ = x;
    }

    void ColumnTypesComplexType::
    setX (::std::auto_ptr< XType > x)
    {
      this->X_.set (x);
    }

    const ColumnTypesComplexType::YOptional& ColumnTypesComplexType::
    getY () const
    {
      return this->Y_;
    }

    ColumnTypesComplexType::YOptional& ColumnTypesComplexType::
    getY ()
    {
      return this->Y_;
    }

    void ColumnTypesComplexType::
    setY (const YType& x)
    {
      this->Y_.set (x);
    }

    void ColumnTypesComplexType::
    setY (const YOptional& x)
    {
      this->Y_ = x;
    }

    void ColumnTypesComplexType::
    setY (::std::auto_ptr< YType > x)
    {
      this->Y_.set (x);
    }

    const ColumnTypesComplexType::ZOptional& ColumnTypesComplexType::
    getZ () const
    {
      return this->Z_;
    }

    ColumnTypesComplexType::ZOptional& ColumnTypesComplexType::
    getZ ()
    {
      return this->Z_;
    }

    void ColumnTypesComplexType::
    setZ (const ZType& x)
    {
      this->Z_.set (x);
    }

    void ColumnTypesComplexType::
    setZ (const ZOptional& x)
    {
      this->Z_ = x;
    }

    void ColumnTypesComplexType::
    setZ (::std::auto_ptr< ZType > x)
    {
      this->Z_.set (x);
    }


    // RowComplexType
    // 

    const RowComplexType::AType& RowComplexType::
    getA () const
    {
      return this->A_.get ();
    }

    RowComplexType::AType& RowComplexType::
    getA ()
    {
      return this->A_.get ();
    }

    void RowComplexType::
    setA (const AType& x)
    {
      this->A_.set (x);
    }

    void RowComplexType::
    setA (::std::auto_ptr< AType > x)
    {
      this->A_.set (x);
    }

    const RowComplexType::BOptional& RowComplexType::
    getB () const
    {
      return this->B_;
    }

    RowComplexType::BOptional& RowComplexType::
    getB ()
    {
      return this->B_;
    }

    void RowComplexType::
    setB (const BType& x)
    {
      this->B_.set (x);
    }

    void RowComplexType::
    setB (const BOptional& x)
    {
      this->B_ = x;
    }

    void RowComplexType::
    setB (::std::auto_ptr< BType > x)
    {
      this->B_.set (x);
    }

    const RowComplexType::COptional& RowComplexType::
    getC () const
    {
      return this->C_;
    }

    RowComplexType::COptional& RowComplexType::
    getC ()
    {
      return this->C_;
    }

    void RowComplexType::
    setC (const CType& x)
    {
      this->C_.set (x);
    }

    void RowComplexType::
    setC (const COptional& x)
    {
      this->C_ = x;
    }

    void RowComplexType::
    setC (::std::auto_ptr< CType > x)
    {
      this->C_.set (x);
    }

    const RowComplexType::DOptional& RowComplexType::
    getD () const
    {
      return this->D_;
    }

    RowComplexType::DOptional& RowComplexType::
    getD ()
    {
      return this->D_;
    }

    void RowComplexType::
    setD (const DType& x)
    {
      this->D_.set (x);
    }

    void RowComplexType::
    setD (const DOptional& x)
    {
      this->D_ = x;
    }

    void RowComplexType::
    setD (::std::auto_ptr< DType > x)
    {
      this->D_.set (x);
    }

    const RowComplexType::EOptional& RowComplexType::
    getE () const
    {
      return this->E_;
    }

    RowComplexType::EOptional& RowComplexType::
    getE ()
    {
      return this->E_;
    }

    void RowComplexType::
    setE (const EType& x)
    {
      this->E_.set (x);
    }

    void RowComplexType::
    setE (const EOptional& x)
    {
      this->E_ = x;
    }

    void RowComplexType::
    setE (::std::auto_ptr< EType > x)
    {
      this->E_.set (x);
    }

    const RowComplexType::FOptional& RowComplexType::
    getF () const
    {
      return this->F_;
    }

    RowComplexType::FOptional& RowComplexType::
    getF ()
    {
      return this->F_;
    }

    void RowComplexType::
    setF (const FType& x)
    {
      this->F_.set (x);
    }

    void RowComplexType::
    setF (const FOptional& x)
    {
      this->F_ = x;
    }

    void RowComplexType::
    setF (::std::auto_ptr< FType > x)
    {
      this->F_.set (x);
    }

    const RowComplexType::GOptional& RowComplexType::
    getG () const
    {
      return this->G_;
    }

    RowComplexType::GOptional& RowComplexType::
    getG ()
    {
      return this->G_;
    }

    void RowComplexType::
    setG (const GType& x)
    {
      this->G_.set (x);
    }

    void RowComplexType::
    setG (const GOptional& x)
    {
      this->G_ = x;
    }

    void RowComplexType::
    setG (::std::auto_ptr< GType > x)
    {
      this->G_.set (x);
    }

    const RowComplexType::HOptional& RowComplexType::
    getH () const
    {
      return this->H_;
    }

    RowComplexType::HOptional& RowComplexType::
    getH ()
    {
      return this->H_;
    }

    void RowComplexType::
    setH (const HType& x)
    {
      this->H_.set (x);
    }

    void RowComplexType::
    setH (const HOptional& x)
    {
      this->H_ = x;
    }

    void RowComplexType::
    setH (::std::auto_ptr< HType > x)
    {
      this->H_.set (x);
    }

    const RowComplexType::IOptional& RowComplexType::
    getI () const
    {
      return this->I_;
    }

    RowComplexType::IOptional& RowComplexType::
    getI ()
    {
      return this->I_;
    }

    void RowComplexType::
    setI (const IType& x)
    {
      this->I_.set (x);
    }

    void RowComplexType::
    setI (const IOptional& x)
    {
      this->I_ = x;
    }

    void RowComplexType::
    setI (::std::auto_ptr< IType > x)
    {
      this->I_.set (x);
    }

    const RowComplexType::JOptional& RowComplexType::
    getJ () const
    {
      return this->J_;
    }

    RowComplexType::JOptional& RowComplexType::
    getJ ()
    {
      return this->J_;
    }

    void RowComplexType::
    setJ (const JType& x)
    {
      this->J_.set (x);
    }

    void RowComplexType::
    setJ (const JOptional& x)
    {
      this->J_ = x;
    }

    void RowComplexType::
    setJ (::std::auto_ptr< JType > x)
    {
      this->J_.set (x);
    }

    const RowComplexType::KOptional& RowComplexType::
    getK () const
    {
      return this->K_;
    }

    RowComplexType::KOptional& RowComplexType::
    getK ()
    {
      return this->K_;
    }

    void RowComplexType::
    setK (const KType& x)
    {
      this->K_.set (x);
    }

    void RowComplexType::
    setK (const KOptional& x)
    {
      this->K_ = x;
    }

    void RowComplexType::
    setK (::std::auto_ptr< KType > x)
    {
      this->K_.set (x);
    }

    const RowComplexType::LOptional& RowComplexType::
    getL () const
    {
      return this->L_;
    }

    RowComplexType::LOptional& RowComplexType::
    getL ()
    {
      return this->L_;
    }

    void RowComplexType::
    setL (const LType& x)
    {
      this->L_.set (x);
    }

    void RowComplexType::
    setL (const LOptional& x)
    {
      this->L_ = x;
    }

    void RowComplexType::
    setL (::std::auto_ptr< LType > x)
    {
      this->L_.set (x);
    }

    const RowComplexType::MOptional& RowComplexType::
    getM () const
    {
      return this->M_;
    }

    RowComplexType::MOptional& RowComplexType::
    getM ()
    {
      return this->M_;
    }

    void RowComplexType::
    setM (const MType& x)
    {
      this->M_.set (x);
    }

    void RowComplexType::
    setM (const MOptional& x)
    {
      this->M_ = x;
    }

    void RowComplexType::
    setM (::std::auto_ptr< MType > x)
    {
      this->M_.set (x);
    }

    const RowComplexType::NOptional& RowComplexType::
    getN () const
    {
      return this->N_;
    }

    RowComplexType::NOptional& RowComplexType::
    getN ()
    {
      return this->N_;
    }

    void RowComplexType::
    setN (const NType& x)
    {
      this->N_.set (x);
    }

    void RowComplexType::
    setN (const NOptional& x)
    {
      this->N_ = x;
    }

    void RowComplexType::
    setN (::std::auto_ptr< NType > x)
    {
      this->N_.set (x);
    }

    const RowComplexType::OOptional& RowComplexType::
    getO () const
    {
      return this->O_;
    }

    RowComplexType::OOptional& RowComplexType::
    getO ()
    {
      return this->O_;
    }

    void RowComplexType::
    setO (const OType& x)
    {
      this->O_.set (x);
    }

    void RowComplexType::
    setO (const OOptional& x)
    {
      this->O_ = x;
    }

    void RowComplexType::
    setO (::std::auto_ptr< OType > x)
    {
      this->O_.set (x);
    }

    const RowComplexType::POptional& RowComplexType::
    getP () const
    {
      return this->P_;
    }

    RowComplexType::POptional& RowComplexType::
    getP ()
    {
      return this->P_;
    }

    void RowComplexType::
    setP (const PType& x)
    {
      this->P_.set (x);
    }

    void RowComplexType::
    setP (const POptional& x)
    {
      this->P_ = x;
    }

    void RowComplexType::
    setP (::std::auto_ptr< PType > x)
    {
      this->P_.set (x);
    }

    const RowComplexType::QOptional& RowComplexType::
    getQ () const
    {
      return this->Q_;
    }

    RowComplexType::QOptional& RowComplexType::
    getQ ()
    {
      return this->Q_;
    }

    void RowComplexType::
    setQ (const QType& x)
    {
      this->Q_.set (x);
    }

    void RowComplexType::
    setQ (const QOptional& x)
    {
      this->Q_ = x;
    }

    void RowComplexType::
    setQ (::std::auto_ptr< QType > x)
    {
      this->Q_.set (x);
    }

    const RowComplexType::ROptional& RowComplexType::
    getR () const
    {
      return this->R_;
    }

    RowComplexType::ROptional& RowComplexType::
    getR ()
    {
      return this->R_;
    }

    void RowComplexType::
    setR (const RType& x)
    {
      this->R_.set (x);
    }

    void RowComplexType::
    setR (const ROptional& x)
    {
      this->R_ = x;
    }

    void RowComplexType::
    setR (::std::auto_ptr< RType > x)
    {
      this->R_.set (x);
    }

    const RowComplexType::SOptional& RowComplexType::
    getS () const
    {
      return this->S_;
    }

    RowComplexType::SOptional& RowComplexType::
    getS ()
    {
      return this->S_;
    }

    void RowComplexType::
    setS (const SType& x)
    {
      this->S_.set (x);
    }

    void RowComplexType::
    setS (const SOptional& x)
    {
      this->S_ = x;
    }

    void RowComplexType::
    setS (::std::auto_ptr< SType > x)
    {
      this->S_.set (x);
    }

    const RowComplexType::TOptional& RowComplexType::
    getT () const
    {
      return this->T_;
    }

    RowComplexType::TOptional& RowComplexType::
    getT ()
    {
      return this->T_;
    }

    void RowComplexType::
    setT (const TType& x)
    {
      this->T_.set (x);
    }

    void RowComplexType::
    setT (const TOptional& x)
    {
      this->T_ = x;
    }

    void RowComplexType::
    setT (::std::auto_ptr< TType > x)
    {
      this->T_.set (x);
    }

    const RowComplexType::UOptional& RowComplexType::
    getU () const
    {
      return this->U_;
    }

    RowComplexType::UOptional& RowComplexType::
    getU ()
    {
      return this->U_;
    }

    void RowComplexType::
    setU (const UType& x)
    {
      this->U_.set (x);
    }

    void RowComplexType::
    setU (const UOptional& x)
    {
      this->U_ = x;
    }

    void RowComplexType::
    setU (::std::auto_ptr< UType > x)
    {
      this->U_.set (x);
    }

    const RowComplexType::VOptional& RowComplexType::
    getV () const
    {
      return this->V_;
    }

    RowComplexType::VOptional& RowComplexType::
    getV ()
    {
      return this->V_;
    }

    void RowComplexType::
    setV (const VType& x)
    {
      this->V_.set (x);
    }

    void RowComplexType::
    setV (const VOptional& x)
    {
      this->V_ = x;
    }

    void RowComplexType::
    setV (::std::auto_ptr< VType > x)
    {
      this->V_.set (x);
    }

    const RowComplexType::WOptional& RowComplexType::
    getW () const
    {
      return this->W_;
    }

    RowComplexType::WOptional& RowComplexType::
    getW ()
    {
      return this->W_;
    }

    void RowComplexType::
    setW (const WType& x)
    {
      this->W_.set (x);
    }

    void RowComplexType::
    setW (const WOptional& x)
    {
      this->W_ = x;
    }

    void RowComplexType::
    setW (::std::auto_ptr< WType > x)
    {
      this->W_.set (x);
    }

    const RowComplexType::XOptional& RowComplexType::
    getX () const
    {
      return this->X_;
    }

    RowComplexType::XOptional& RowComplexType::
    getX ()
    {
      return this->X_;
    }

    void RowComplexType::
    setX (const XType& x)
    {
      this->X_.set (x);
    }

    void RowComplexType::
    setX (const XOptional& x)
    {
      this->X_ = x;
    }

    void RowComplexType::
    setX (::std::auto_ptr< XType > x)
    {
      this->X_.set (x);
    }

    const RowComplexType::YOptional& RowComplexType::
    getY () const
    {
      return this->Y_;
    }

    RowComplexType::YOptional& RowComplexType::
    getY ()
    {
      return this->Y_;
    }

    void RowComplexType::
    setY (const YType& x)
    {
      this->Y_.set (x);
    }

    void RowComplexType::
    setY (const YOptional& x)
    {
      this->Y_ = x;
    }

    void RowComplexType::
    setY (::std::auto_ptr< YType > x)
    {
      this->Y_.set (x);
    }

    const RowComplexType::ZOptional& RowComplexType::
    getZ () const
    {
      return this->Z_;
    }

    RowComplexType::ZOptional& RowComplexType::
    getZ ()
    {
      return this->Z_;
    }

    void RowComplexType::
    setZ (const ZType& x)
    {
      this->Z_.set (x);
    }

    void RowComplexType::
    setZ (const ZOptional& x)
    {
      this->Z_ = x;
    }

    void RowComplexType::
    setZ (::std::auto_ptr< ZType > x)
    {
      this->Z_.set (x);
    }


    // TimeSeriesTypeEnumStringType
    // 

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (Value v)
    : ::xml_schema::String (_xsd_TimeSeriesTypeEnumStringType_literals_[v])
    {
    }

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const char* v)
    : ::xml_schema::String (v)
    {
    }

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const TimeSeriesTypeEnumStringType& v,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    TimeSeriesTypeEnumStringType& TimeSeriesTypeEnumStringType::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_TimeSeriesTypeEnumStringType_literals_[v]);

      return *this;
    }


    // IdStringType
    // 


    // NonEmptyStringType
    // 


    // ArchiveTimeSeriesSetComplexType
    // 

    const ArchiveTimeSeriesSetComplexType::ModuleInstanceIdType& ArchiveTimeSeriesSetComplexType::
    getModuleInstanceId () const
    {
      return this->moduleInstanceId_.get ();
    }

    ArchiveTimeSeriesSetComplexType::ModuleInstanceIdType& ArchiveTimeSeriesSetComplexType::
    getModuleInstanceId ()
    {
      return this->moduleInstanceId_.get ();
    }

    void ArchiveTimeSeriesSetComplexType::
    setModuleInstanceId (const ModuleInstanceIdType& x)
    {
      this->moduleInstanceId_.set (x);
    }

    void ArchiveTimeSeriesSetComplexType::
    setModuleInstanceId (::std::auto_ptr< ModuleInstanceIdType > x)
    {
      this->moduleInstanceId_.set (x);
    }

    const ArchiveTimeSeriesSetComplexType::ParameterIdType& ArchiveTimeSeriesSetComplexType::
    getParameterId () const
    {
      return this->parameterId_.get ();
    }

    ArchiveTimeSeriesSetComplexType::ParameterIdType& ArchiveTimeSeriesSetComplexType::
    getParameterId ()
    {
      return this->parameterId_.get ();
    }

    void ArchiveTimeSeriesSetComplexType::
    setParameterId (const ParameterIdType& x)
    {
      this->parameterId_.set (x);
    }

    void ArchiveTimeSeriesSetComplexType::
    setParameterId (::std::auto_ptr< ParameterIdType > x)
    {
      this->parameterId_.set (x);
    }

    const ArchiveTimeSeriesSetComplexType::QualifierIdSequence& ArchiveTimeSeriesSetComplexType::
    getQualifierId () const
    {
      return this->qualifierId_;
    }

    ArchiveTimeSeriesSetComplexType::QualifierIdSequence& ArchiveTimeSeriesSetComplexType::
    getQualifierId ()
    {
      return this->qualifierId_;
    }

    void ArchiveTimeSeriesSetComplexType::
    setQualifierId (const QualifierIdSequence& s)
    {
      this->qualifierId_ = s;
    }

    const ArchiveTimeSeriesSetComplexType::LocationIdSequence& ArchiveTimeSeriesSetComplexType::
    getLocationId () const
    {
      return this->locationId_;
    }

    ArchiveTimeSeriesSetComplexType::LocationIdSequence& ArchiveTimeSeriesSetComplexType::
    getLocationId ()
    {
      return this->locationId_;
    }

    void ArchiveTimeSeriesSetComplexType::
    setLocationId (const LocationIdSequence& s)
    {
      this->locationId_ = s;
    }

    const ArchiveTimeSeriesSetComplexType::TimeSeriesTypeType& ArchiveTimeSeriesSetComplexType::
    getTimeSeriesType () const
    {
      return this->timeSeriesType_.get ();
    }

    ArchiveTimeSeriesSetComplexType::TimeSeriesTypeType& ArchiveTimeSeriesSetComplexType::
    getTimeSeriesType ()
    {
      return this->timeSeriesType_.get ();
    }

    void ArchiveTimeSeriesSetComplexType::
    setTimeSeriesType (const TimeSeriesTypeType& x)
    {
      this->timeSeriesType_.set (x);
    }

    void ArchiveTimeSeriesSetComplexType::
    setTimeSeriesType (::std::auto_ptr< TimeSeriesTypeType > x)
    {
      this->timeSeriesType_.set (x);
    }

    const ArchiveTimeSeriesSetComplexType::TimeStepType& ArchiveTimeSeriesSetComplexType::
    getTimeStep () const
    {
      return this->timeStep_.get ();
    }

    ArchiveTimeSeriesSetComplexType::TimeStepType& ArchiveTimeSeriesSetComplexType::
    getTimeStep ()
    {
      return this->timeStep_.get ();
    }

    void ArchiveTimeSeriesSetComplexType::
    setTimeStep (const TimeStepType& x)
    {
      this->timeStep_.set (x);
    }

    void ArchiveTimeSeriesSetComplexType::
    setTimeStep (::std::auto_ptr< TimeStepType > x)
    {
      this->timeStep_.set (x);
    }

    const ArchiveTimeSeriesSetComplexType::EnsembleIdOptional& ArchiveTimeSeriesSetComplexType::
    getEnsembleId () const
    {
      return this->ensembleId_;
    }

    ArchiveTimeSeriesSetComplexType::EnsembleIdOptional& ArchiveTimeSeriesSetComplexType::
    getEnsembleId ()
    {
      return this->ensembleId_;
    }

    void ArchiveTimeSeriesSetComplexType::
    setEnsembleId (const EnsembleIdType& x)
    {
      this->ensembleId_.set (x);
    }

    void ArchiveTimeSeriesSetComplexType::
    setEnsembleId (const EnsembleIdOptional& x)
    {
      this->ensembleId_ = x;
    }

    void ArchiveTimeSeriesSetComplexType::
    setEnsembleId (::std::auto_ptr< EnsembleIdType > x)
    {
      this->ensembleId_.set (x);
    }


    // Unit
    // 

    Unit::
    Unit (::xml_schema::Int v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (v)
    {
    }

    Unit::
    Unit (const Unit& v,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (v, f, c)
    {
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace fews
{
  namespace PI
  {
    // PropertyReferenceString
    //

    PropertyReferenceString::
    PropertyReferenceString ()
    : ::xml_schema::String ()
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const PropertyReferenceString& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    PropertyReferenceString::
    PropertyReferenceString (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    PropertyReferenceString* PropertyReferenceString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PropertyReferenceString (*this, f, c);
    }

    PropertyReferenceString::
    ~PropertyReferenceString ()
    {
    }

    // IdString
    //

    IdString::
    IdString ()
    : ::xml_schema::String ()
    {
    }

    IdString::
    IdString (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    IdString::
    IdString (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    IdString::
    IdString (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    IdString::
    IdString (const IdString& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    IdString::
    IdString (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    IdString::
    IdString (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    IdString::
    IdString (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    IdString* IdString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IdString (*this, f, c);
    }

    IdString::
    ~IdString ()
    {
    }

    // IntStringType
    //

    IntStringType::
    IntStringType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    IntStringType::
    IntStringType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    IntStringType::
    IntStringType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    IntStringType* IntStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntStringType (*this, f, c);
    }

    // BooleanStringType
    //

    BooleanStringType::
    BooleanStringType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    BooleanStringType::
    BooleanStringType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    BooleanStringType::
    BooleanStringType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    BooleanStringType* BooleanStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BooleanStringType (*this, f, c);
    }

    // DoubleStringType
    //

    DoubleStringType::
    DoubleStringType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DoubleStringType::
    DoubleStringType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DoubleStringType::
    DoubleStringType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DoubleStringType* DoubleStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DoubleStringType (*this, f, c);
    }

    // VersionString
    //

    VersionString::
    VersionString (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_VersionString_convert ();
    }

    VersionString::
    VersionString (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_VersionString_convert ();
    }

    VersionString::
    VersionString (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_VersionString_convert ();
    }

    VersionString* VersionString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class VersionString (*this, f, c);
    }

    VersionString::Value VersionString::
    _xsd_VersionString_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_VersionString_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_VersionString_indexes_,
                        _xsd_VersionString_indexes_ + 13,
                        *this,
                        c));

      if (i == _xsd_VersionString_indexes_ + 13 || _xsd_VersionString_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const VersionString::
    _xsd_VersionString_literals_[13] =
    {
      "1.2",
      "1.3",
      "1.4",
      "1.5",
      "1.6",
      "1.7",
      "1.8",
      "1.9",
      "1.10",
      "1.11",
      "1.12",
      "1.13",
      "1.14"
    };

    const VersionString::Value VersionString::
    _xsd_VersionString_indexes_[13] =
    {
      ::fews::PI::VersionString::cxx_1_10,
      ::fews::PI::VersionString::cxx_1_11,
      ::fews::PI::VersionString::cxx_1_12,
      ::fews::PI::VersionString::cxx_1_13,
      ::fews::PI::VersionString::cxx_1_14,
      ::fews::PI::VersionString::cxx_1_2,
      ::fews::PI::VersionString::cxx_1_3,
      ::fews::PI::VersionString::cxx_1_4,
      ::fews::PI::VersionString::cxx_1_5,
      ::fews::PI::VersionString::cxx_1_6,
      ::fews::PI::VersionString::cxx_1_7,
      ::fews::PI::VersionString::cxx_1_8,
      ::fews::PI::VersionString::cxx_1_9
    };

    // NameString
    //

    NameString::
    NameString ()
    : ::xml_schema::String ()
    {
    }

    NameString::
    NameString (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NameString::
    NameString (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NameString::
    NameString (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NameString::
    NameString (const NameString& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    NameString::
    NameString (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    NameString::
    NameString (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    NameString::
    NameString (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    NameString* NameString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NameString (*this, f, c);
    }

    NameString::
    ~NameString ()
    {
    }

    // CommentString
    //

    CommentString::
    CommentString ()
    : ::xml_schema::String ()
    {
    }

    CommentString::
    CommentString (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    CommentString::
    CommentString (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    CommentString::
    CommentString (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    CommentString::
    CommentString (const CommentString& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    CommentString::
    CommentString (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    CommentString::
    CommentString (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    CommentString::
    CommentString (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    CommentString* CommentString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CommentString (*this, f, c);
    }

    CommentString::
    ~CommentString ()
    {
    }

    // EventCodeString
    //

    EventCodeString::
    EventCodeString ()
    : ::xml_schema::String ()
    {
    }

    EventCodeString::
    EventCodeString (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    EventCodeString::
    EventCodeString (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    EventCodeString::
    EventCodeString (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    EventCodeString::
    EventCodeString (const EventCodeString& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    EventCodeString::
    EventCodeString (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    EventCodeString::
    EventCodeString (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    EventCodeString::
    EventCodeString (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    EventCodeString* EventCodeString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EventCodeString (*this, f, c);
    }

    EventCodeString::
    ~EventCodeString ()
    {
    }

    // TimeStepComplexType
    //

    TimeStepComplexType::
    TimeStepComplexType (const UnitType& unit)
    : ::xml_schema::Type (),
      unit_ (unit, ::xml_schema::Flags (), this),
      divider_ (getDividerDefaultValue (), ::xml_schema::Flags (), this),
      multiplier_ (getMultiplierDefaultValue (), ::xml_schema::Flags (), this)
    {
    }

    TimeStepComplexType::
    TimeStepComplexType (const TimeStepComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      unit_ (x.unit_, f, this),
      divider_ (x.divider_, f, this),
      multiplier_ (x.multiplier_, f, this)
    {
    }

    TimeStepComplexType::
    TimeStepComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      unit_ (f, this),
      divider_ (f, this),
      multiplier_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void TimeStepComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< UnitType > r (
            UnitTraits::create (i, f, this));

          this->unit_.set (r);
          continue;
        }

        if (n.name () == "divider" && n.namespace_ ().empty ())
        {
          this->divider_.set (DividerTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "multiplier" && n.namespace_ ().empty ())
        {
          this->multiplier_.set (MultiplierTraits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unit",
          "");
      }

      if (!divider_.present ())
      {
        this->divider_.set (getDividerDefaultValue ());
      }

      if (!multiplier_.present ())
      {
        this->multiplier_.set (getMultiplierDefaultValue ());
      }
    }

    TimeStepComplexType* TimeStepComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeStepComplexType (*this, f, c);
    }

    TimeStepComplexType::
    ~TimeStepComplexType ()
    {
    }

    // TimeStepUnitEnumStringType
    //

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_TimeStepUnitEnumStringType_convert ();
    }

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_TimeStepUnitEnumStringType_convert ();
    }

    TimeStepUnitEnumStringType::
    TimeStepUnitEnumStringType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_TimeStepUnitEnumStringType_convert ();
    }

    TimeStepUnitEnumStringType* TimeStepUnitEnumStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeStepUnitEnumStringType (*this, f, c);
    }

    TimeStepUnitEnumStringType::Value TimeStepUnitEnumStringType::
    _xsd_TimeStepUnitEnumStringType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TimeStepUnitEnumStringType_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_TimeStepUnitEnumStringType_indexes_,
                        _xsd_TimeStepUnitEnumStringType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_TimeStepUnitEnumStringType_indexes_ + 8 || _xsd_TimeStepUnitEnumStringType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const TimeStepUnitEnumStringType::
    _xsd_TimeStepUnitEnumStringType_literals_[8] =
    {
      "second",
      "minute",
      "hour",
      "day",
      "week",
      "month",
      "year",
      "nonequidistant"
    };

    const TimeStepUnitEnumStringType::Value TimeStepUnitEnumStringType::
    _xsd_TimeStepUnitEnumStringType_indexes_[8] =
    {
      ::fews::PI::TimeStepUnitEnumStringType::day,
      ::fews::PI::TimeStepUnitEnumStringType::hour,
      ::fews::PI::TimeStepUnitEnumStringType::minute,
      ::fews::PI::TimeStepUnitEnumStringType::month,
      ::fews::PI::TimeStepUnitEnumStringType::nonequidistant,
      ::fews::PI::TimeStepUnitEnumStringType::second,
      ::fews::PI::TimeStepUnitEnumStringType::week,
      ::fews::PI::TimeStepUnitEnumStringType::year
    };

    // TimeStepUnitComplexType
    //

    TimeStepUnitComplexType::
    TimeStepUnitComplexType (const UnitType& unit)
    : ::xml_schema::Type (),
      unit_ (unit, ::xml_schema::Flags (), this),
      divider_ (getDividerDefaultValue (), ::xml_schema::Flags (), this)
    {
    }

    TimeStepUnitComplexType::
    TimeStepUnitComplexType (const TimeStepUnitComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      unit_ (x.unit_, f, this),
      divider_ (x.divider_, f, this)
    {
    }

    TimeStepUnitComplexType::
    TimeStepUnitComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      unit_ (f, this),
      divider_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void TimeStepUnitComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< UnitType > r (
            UnitTraits::create (i, f, this));

          this->unit_.set (r);
          continue;
        }

        if (n.name () == "divider" && n.namespace_ ().empty ())
        {
          this->divider_.set (DividerTraits::create (i, f, this));
          continue;
        }
      }

      if (!unit_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unit",
          "");
      }

      if (!divider_.present ())
      {
        this->divider_.set (getDividerDefaultValue ());
      }
    }

    TimeStepUnitComplexType* TimeStepUnitComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeStepUnitComplexType (*this, f, c);
    }

    TimeStepUnitComplexType::
    ~TimeStepUnitComplexType ()
    {
    }

    // GeoDatumEnumStringType
    //

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_GeoDatumEnumStringType_convert ();
    }

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_GeoDatumEnumStringType_convert ();
    }

    GeoDatumEnumStringType::
    GeoDatumEnumStringType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_GeoDatumEnumStringType_convert ();
    }

    GeoDatumEnumStringType* GeoDatumEnumStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GeoDatumEnumStringType (*this, f, c);
    }

    GeoDatumEnumStringType::Value GeoDatumEnumStringType::
    _xsd_GeoDatumEnumStringType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_GeoDatumEnumStringType_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_GeoDatumEnumStringType_indexes_,
                        _xsd_GeoDatumEnumStringType_indexes_ + 16,
                        *this,
                        c));

      if (i == _xsd_GeoDatumEnumStringType_indexes_ + 16 || _xsd_GeoDatumEnumStringType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const GeoDatumEnumStringType::
    _xsd_GeoDatumEnumStringType_literals_[16] =
    {
      "LOCAL",
      "WGS 1984",
      "Ordnance Survey Great Britain 1936",
      "TWD 1967",
      "Gauss Krueger Meridian2",
      "Gauss Krueger Meridian3",
      "Gauss Krueger Austria M34",
      "Gauss Krueger Austria M31",
      "Rijks Driehoekstelsel",
      "JRC",
      "DWD",
      "KNMI Radar",
      "CH1903",
      "PAK1",
      "PAK2",
      "SVY21"
    };

    const GeoDatumEnumStringType::Value GeoDatumEnumStringType::
    _xsd_GeoDatumEnumStringType_indexes_[16] =
    {
      ::fews::PI::GeoDatumEnumStringType::CH1903,
      ::fews::PI::GeoDatumEnumStringType::DWD,
      ::fews::PI::GeoDatumEnumStringType::Gauss_Krueger_Austria_M31,
      ::fews::PI::GeoDatumEnumStringType::Gauss_Krueger_Austria_M34,
      ::fews::PI::GeoDatumEnumStringType::Gauss_Krueger_Meridian2,
      ::fews::PI::GeoDatumEnumStringType::Gauss_Krueger_Meridian3,
      ::fews::PI::GeoDatumEnumStringType::JRC,
      ::fews::PI::GeoDatumEnumStringType::KNMI_Radar,
      ::fews::PI::GeoDatumEnumStringType::LOCAL,
      ::fews::PI::GeoDatumEnumStringType::Ordnance_Survey_Great_Britain_1936,
      ::fews::PI::GeoDatumEnumStringType::PAK1,
      ::fews::PI::GeoDatumEnumStringType::PAK2,
      ::fews::PI::GeoDatumEnumStringType::Rijks_Driehoekstelsel,
      ::fews::PI::GeoDatumEnumStringType::SVY21,
      ::fews::PI::GeoDatumEnumStringType::TWD_1967,
      ::fews::PI::GeoDatumEnumStringType::WGS_1984
    };

    // UtmGeoDatumStringType
    //

    UtmGeoDatumStringType::
    UtmGeoDatumStringType ()
    : ::xml_schema::String ()
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const UtmGeoDatumStringType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    UtmGeoDatumStringType::
    UtmGeoDatumStringType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    UtmGeoDatumStringType* UtmGeoDatumStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UtmGeoDatumStringType (*this, f, c);
    }

    UtmGeoDatumStringType::
    ~UtmGeoDatumStringType ()
    {
    }

    // GeoDatumStringType
    //

    GeoDatumStringType::
    GeoDatumStringType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    GeoDatumStringType::
    GeoDatumStringType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    GeoDatumStringType::
    GeoDatumStringType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    GeoDatumStringType* GeoDatumStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GeoDatumStringType (*this, f, c);
    }

    // LocationIdSimpleType
    //

    LocationIdSimpleType::
    LocationIdSimpleType ()
    : ::xml_schema::String ()
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const LocationIdSimpleType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    LocationIdSimpleType::
    LocationIdSimpleType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    LocationIdSimpleType* LocationIdSimpleType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LocationIdSimpleType (*this, f, c);
    }

    LocationIdSimpleType::
    ~LocationIdSimpleType ()
    {
    }

    // ParameterSimpleType
    //

    ParameterSimpleType::
    ParameterSimpleType ()
    : ::xml_schema::String ()
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const ParameterSimpleType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    ParameterSimpleType::
    ParameterSimpleType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    ParameterSimpleType* ParameterSimpleType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ParameterSimpleType (*this, f, c);
    }

    ParameterSimpleType::
    ~ParameterSimpleType ()
    {
    }

    // TimeZoneSimpleType
    //

    TimeZoneSimpleType::
    TimeZoneSimpleType (const ::xml_schema::Double& _xsd_Double_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (_xsd_Double_base)
    {
    }

    TimeZoneSimpleType::
    TimeZoneSimpleType (const TimeZoneSimpleType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    TimeZoneSimpleType::
    TimeZoneSimpleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    TimeZoneSimpleType::
    TimeZoneSimpleType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    TimeZoneSimpleType::
    TimeZoneSimpleType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    TimeZoneSimpleType* TimeZoneSimpleType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeZoneSimpleType (*this, f, c);
    }

    TimeZoneSimpleType::
    ~TimeZoneSimpleType ()
    {
    }

    // DateType
    //

    DateType::
    DateType (const ::xml_schema::Date& _xsd_Date_base)
    : ::xml_schema::Date (_xsd_Date_base)
    {
    }

    DateType::
    DateType (const DateType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Date (x, f, c)
    {
    }

    DateType::
    DateType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Date (e, f, c)
    {
    }

    DateType::
    DateType (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Date (a, f, c)
    {
    }

    DateType::
    DateType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Date (s, e, f, c)
    {
    }

    DateType* DateType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DateType (*this, f, c);
    }

    DateType::
    ~DateType ()
    {
    }

    // TimeType
    //

    TimeType::
    TimeType (const ::xml_schema::Time& _xsd_Time_base)
    : ::xml_schema::Time (_xsd_Time_base)
    {
    }

    TimeType::
    TimeType (const TimeType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Time (x, f, c)
    {
    }

    TimeType::
    TimeType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Time (e, f, c)
    {
    }

    TimeType::
    TimeType (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Time (a, f, c)
    {
    }

    TimeType::
    TimeType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Time (s, e, f, c)
    {
    }

    TimeType* TimeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeType (*this, f, c);
    }

    TimeType::
    ~TimeType ()
    {
    }

    // DateTimeComplexType
    //

    DateTimeComplexType::
    DateTimeComplexType (const DateType& date,
                         const TimeType& time)
    : ::xml_schema::Type (),
      date_ (date, ::xml_schema::Flags (), this),
      time_ (time, ::xml_schema::Flags (), this)
    {
    }

    DateTimeComplexType::
    DateTimeComplexType (const DateTimeComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      date_ (x.date_, f, this),
      time_ (x.time_, f, this)
    {
    }

    DateTimeComplexType::
    DateTimeComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      date_ (f, this),
      time_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void DateTimeComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "date" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DateType > r (
            DateTraits::create (i, f, this));

          this->date_.set (r);
          continue;
        }

        if (n.name () == "time" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TimeType > r (
            TimeTraits::create (i, f, this));

          this->time_.set (r);
          continue;
        }
      }

      if (!date_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "date",
          "");
      }

      if (!time_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "time",
          "");
      }
    }

    DateTimeComplexType* DateTimeComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DateTimeComplexType (*this, f, c);
    }

    DateTimeComplexType::
    ~DateTimeComplexType ()
    {
    }

    // TimeSeriesType
    //

    TimeSeriesType::
    TimeSeriesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_TimeSeriesType_convert ();
    }

    TimeSeriesType::
    TimeSeriesType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_TimeSeriesType_convert ();
    }

    TimeSeriesType::
    TimeSeriesType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_TimeSeriesType_convert ();
    }

    TimeSeriesType* TimeSeriesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeSeriesType (*this, f, c);
    }

    TimeSeriesType::Value TimeSeriesType::
    _xsd_TimeSeriesType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TimeSeriesType_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_TimeSeriesType_indexes_,
                        _xsd_TimeSeriesType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_TimeSeriesType_indexes_ + 3 || _xsd_TimeSeriesType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const TimeSeriesType::
    _xsd_TimeSeriesType_literals_[3] =
    {
      "accumulative",
      "instantaneous",
      "mean"
    };

    const TimeSeriesType::Value TimeSeriesType::
    _xsd_TimeSeriesType_indexes_[3] =
    {
      ::fews::PI::TimeSeriesType::accumulative,
      ::fews::PI::TimeSeriesType::instantaneous,
      ::fews::PI::TimeSeriesType::mean
    };

    // PropertiesComplexType
    //

    PropertiesComplexType::
    PropertiesComplexType ()
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      string_ (::xml_schema::Flags (), this),
      int__ (::xml_schema::Flags (), this),
      float__ (::xml_schema::Flags (), this),
      double__ (::xml_schema::Flags (), this),
      bool__ (::xml_schema::Flags (), this),
      dateTime_ (::xml_schema::Flags (), this)
    {
    }

    PropertiesComplexType::
    PropertiesComplexType (const PropertiesComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      string_ (x.string_, f, this),
      int__ (x.int__, f, this),
      float__ (x.float__, f, this),
      double__ (x.double__, f, this),
      bool__ (x.bool__, f, this),
      dateTime_ (x.dateTime_, f, this)
    {
    }

    PropertiesComplexType::
    PropertiesComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      string_ (f, this),
      int__ (f, this),
      float__ (f, this),
      double__ (f, this),
      bool__ (f, this),
      dateTime_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PropertiesComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        // string
        //
        if (n.name () == "string" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< StringType > r (
            StringTraits::create (i, f, this));

          this->string_.push_back (r);
          continue;
        }

        // int
        //
        if (n.name () == "int" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< IntType > r (
            IntTraits::create (i, f, this));

          this->int__.push_back (r);
          continue;
        }

        // float
        //
        if (n.name () == "float" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< FloatType > r (
            FloatTraits::create (i, f, this));

          this->float__.push_back (r);
          continue;
        }

        // double
        //
        if (n.name () == "double" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DoubleType > r (
            DoubleTraits::create (i, f, this));

          this->double__.push_back (r);
          continue;
        }

        // bool
        //
        if (n.name () == "bool" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< BoolType > r (
            BoolTraits::create (i, f, this));

          this->bool__.push_back (r);
          continue;
        }

        // dateTime
        //
        if (n.name () == "dateTime" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DateTimeType > r (
            DateTimeTraits::create (i, f, this));

          this->dateTime_.push_back (r);
          continue;
        }

        break;
      }
    }

    PropertiesComplexType* PropertiesComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PropertiesComplexType (*this, f, c);
    }

    PropertiesComplexType::
    ~PropertiesComplexType ()
    {
    }

    // StringPropertyComplexType
    //

    StringPropertyComplexType::
    StringPropertyComplexType (const KeyType& key,
                               const ValueType& value)
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      key_ (key, ::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this)
    {
    }

    StringPropertyComplexType::
    StringPropertyComplexType (const StringPropertyComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      key_ (x.key_, f, this),
      value_ (x.value_, f, this)
    {
    }

    StringPropertyComplexType::
    StringPropertyComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      key_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void StringPropertyComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ValueType > r (
            ValueTraits::create (i, f, this));

          this->value_.set (r);
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    StringPropertyComplexType* StringPropertyComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class StringPropertyComplexType (*this, f, c);
    }

    StringPropertyComplexType::
    ~StringPropertyComplexType ()
    {
    }

    // IntPropertyComplexType
    //

    IntPropertyComplexType::
    IntPropertyComplexType (const KeyType& key,
                            const ValueType& value)
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      key_ (key, ::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this)
    {
    }

    IntPropertyComplexType::
    IntPropertyComplexType (const IntPropertyComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      key_ (x.key_, f, this),
      value_ (x.value_, f, this)
    {
    }

    IntPropertyComplexType::
    IntPropertyComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      key_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IntPropertyComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    IntPropertyComplexType* IntPropertyComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntPropertyComplexType (*this, f, c);
    }

    IntPropertyComplexType::
    ~IntPropertyComplexType ()
    {
    }

    // FloatPropertyComplexType
    //

    FloatPropertyComplexType::
    FloatPropertyComplexType (const KeyType& key,
                              const ValueType& value)
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      key_ (key, ::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this)
    {
    }

    FloatPropertyComplexType::
    FloatPropertyComplexType (const FloatPropertyComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      key_ (x.key_, f, this),
      value_ (x.value_, f, this)
    {
    }

    FloatPropertyComplexType::
    FloatPropertyComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      key_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FloatPropertyComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    FloatPropertyComplexType* FloatPropertyComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FloatPropertyComplexType (*this, f, c);
    }

    FloatPropertyComplexType::
    ~FloatPropertyComplexType ()
    {
    }

    // DoublePropertyComplexType
    //

    DoublePropertyComplexType::
    DoublePropertyComplexType (const KeyType& key,
                               const ValueType& value)
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      key_ (key, ::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this)
    {
    }

    DoublePropertyComplexType::
    DoublePropertyComplexType (const DoublePropertyComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      key_ (x.key_, f, this),
      value_ (x.value_, f, this)
    {
    }

    DoublePropertyComplexType::
    DoublePropertyComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      key_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DoublePropertyComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    DoublePropertyComplexType* DoublePropertyComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DoublePropertyComplexType (*this, f, c);
    }

    DoublePropertyComplexType::
    ~DoublePropertyComplexType ()
    {
    }

    // DateTimePropertyComplexType
    //

    DateTimePropertyComplexType::
    DateTimePropertyComplexType (const KeyType& key,
                                 const DateType& date,
                                 const TimeType& time)
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      key_ (key, ::xml_schema::Flags (), this),
      date_ (date, ::xml_schema::Flags (), this),
      time_ (time, ::xml_schema::Flags (), this)
    {
    }

    DateTimePropertyComplexType::
    DateTimePropertyComplexType (const DateTimePropertyComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      key_ (x.key_, f, this),
      date_ (x.date_, f, this),
      time_ (x.time_, f, this)
    {
    }

    DateTimePropertyComplexType::
    DateTimePropertyComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      key_ (f, this),
      date_ (f, this),
      time_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DateTimePropertyComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }

        if (n.name () == "date" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DateType > r (
            DateTraits::create (i, f, this));

          this->date_.set (r);
          continue;
        }

        if (n.name () == "time" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TimeType > r (
            TimeTraits::create (i, f, this));

          this->time_.set (r);
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }

      if (!date_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "date",
          "");
      }

      if (!time_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "time",
          "");
      }
    }

    DateTimePropertyComplexType* DateTimePropertyComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DateTimePropertyComplexType (*this, f, c);
    }

    DateTimePropertyComplexType::
    ~DateTimePropertyComplexType ()
    {
    }

    // BoolPropertyComplexType
    //

    BoolPropertyComplexType::
    BoolPropertyComplexType (const KeyType& key,
                             const ValueType& value)
    : ::xml_schema::Type (),
      description_ (::xml_schema::Flags (), this),
      key_ (key, ::xml_schema::Flags (), this),
      value_ (value, ::xml_schema::Flags (), this)
    {
    }

    BoolPropertyComplexType::
    BoolPropertyComplexType (const BoolPropertyComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      description_ (x.description_, f, this),
      key_ (x.key_, f, this),
      value_ (x.value_, f, this)
    {
    }

    BoolPropertyComplexType::
    BoolPropertyComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      description_ (f, this),
      key_ (f, this),
      value_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void BoolPropertyComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DescriptionType > r (
            DescriptionTraits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    BoolPropertyComplexType* BoolPropertyComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BoolPropertyComplexType (*this, f, c);
    }

    BoolPropertyComplexType::
    ~BoolPropertyComplexType ()
    {
    }

    // ValueTypeEnumStringType
    //

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_ValueTypeEnumStringType_convert ();
    }

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_ValueTypeEnumStringType_convert ();
    }

    ValueTypeEnumStringType::
    ValueTypeEnumStringType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_ValueTypeEnumStringType_convert ();
    }

    ValueTypeEnumStringType* ValueTypeEnumStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ValueTypeEnumStringType (*this, f, c);
    }

    ValueTypeEnumStringType::Value ValueTypeEnumStringType::
    _xsd_ValueTypeEnumStringType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ValueTypeEnumStringType_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_ValueTypeEnumStringType_indexes_,
                        _xsd_ValueTypeEnumStringType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ValueTypeEnumStringType_indexes_ + 5 || _xsd_ValueTypeEnumStringType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ValueTypeEnumStringType::
    _xsd_ValueTypeEnumStringType_literals_[5] =
    {
      "boolean",
      "int",
      "float",
      "double",
      "string"
    };

    const ValueTypeEnumStringType::Value ValueTypeEnumStringType::
    _xsd_ValueTypeEnumStringType_indexes_[5] =
    {
      ::fews::PI::ValueTypeEnumStringType::boolean,
      ::fews::PI::ValueTypeEnumStringType::double_,
      ::fews::PI::ValueTypeEnumStringType::float_,
      ::fews::PI::ValueTypeEnumStringType::int_,
      ::fews::PI::ValueTypeEnumStringType::string
    };

    // PeriodConditionComplexType
    //

    PeriodConditionComplexType::
    PeriodConditionComplexType ()
    : ::xml_schema::Type (),
      timeZone_ (::xml_schema::Flags (), this),
      startDate_ (::xml_schema::Flags (), this),
      endDate_ (::xml_schema::Flags (), this),
      validBeforeDate_ (::xml_schema::Flags (), this),
      validAfterDate_ (::xml_schema::Flags (), this),
      startMonthDay_ (::xml_schema::Flags (), this),
      endMonthDay_ (::xml_schema::Flags (), this),
      monthDay_ (::xml_schema::Flags (), this),
      month_ (::xml_schema::Flags (), this),
      day_ (::xml_schema::Flags (), this)
    {
    }

    PeriodConditionComplexType::
    PeriodConditionComplexType (const PeriodConditionComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      timeZone_ (x.timeZone_, f, this),
      startDate_ (x.startDate_, f, this),
      endDate_ (x.endDate_, f, this),
      validBeforeDate_ (x.validBeforeDate_, f, this),
      validAfterDate_ (x.validAfterDate_, f, this),
      startMonthDay_ (x.startMonthDay_, f, this),
      endMonthDay_ (x.endMonthDay_, f, this),
      monthDay_ (x.monthDay_, f, this),
      month_ (x.month_, f, this),
      day_ (x.day_, f, this)
    {
    }

    PeriodConditionComplexType::
    PeriodConditionComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      timeZone_ (f, this),
      startDate_ (f, this),
      endDate_ (f, this),
      validBeforeDate_ (f, this),
      validAfterDate_ (f, this),
      startMonthDay_ (f, this),
      endMonthDay_ (f, this),
      monthDay_ (f, this),
      month_ (f, this),
      day_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PeriodConditionComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // timeZone
        //
        if (n.name () == "timeZone" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< TimeZoneType > r (
            TimeZoneTraits::create (i, f, this));

          if (!this->timeZone_)
          {
            this->timeZone_.set (r);
            continue;
          }
        }

        // startDate
        //
        if (n.name () == "startDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< StartDateType > r (
            StartDateTraits::create (i, f, this));

          if (!this->startDate_)
          {
            this->startDate_.set (r);
            continue;
          }
        }

        // endDate
        //
        if (n.name () == "endDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EndDateType > r (
            EndDateTraits::create (i, f, this));

          if (!this->endDate_)
          {
            this->endDate_.set (r);
            continue;
          }
        }

        // validBeforeDate
        //
        if (n.name () == "validBeforeDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ValidBeforeDateType > r (
            ValidBeforeDateTraits::create (i, f, this));

          if (!this->validBeforeDate_)
          {
            this->validBeforeDate_.set (r);
            continue;
          }
        }

        // validAfterDate
        //
        if (n.name () == "validAfterDate" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ValidAfterDateType > r (
            ValidAfterDateTraits::create (i, f, this));

          if (!this->validAfterDate_)
          {
            this->validAfterDate_.set (r);
            continue;
          }
        }

        // startMonthDay
        //
        if (n.name () == "startMonthDay" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< StartMonthDayType > r (
            StartMonthDayTraits::create (i, f, this));

          if (!this->startMonthDay_)
          {
            this->startMonthDay_.set (r);
            continue;
          }
        }

        // endMonthDay
        //
        if (n.name () == "endMonthDay" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EndMonthDayType > r (
            EndMonthDayTraits::create (i, f, this));

          if (!this->endMonthDay_)
          {
            this->endMonthDay_.set (r);
            continue;
          }
        }

        // monthDay
        //
        if (n.name () == "monthDay" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< MonthDayType > r (
            MonthDayTraits::create (i, f, this));

          this->monthDay_.push_back (r);
          continue;
        }

        // month
        //
        if (n.name () == "month" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< MonthType > r (
            MonthTraits::create (i, f, this));

          this->month_.push_back (r);
          continue;
        }

        // day
        //
        if (n.name () == "day" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< DayType > r (
            DayTraits::create (i, f, this));

          this->day_.push_back (r);
          continue;
        }

        break;
      }
    }

    PeriodConditionComplexType* PeriodConditionComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PeriodConditionComplexType (*this, f, c);
    }

    PeriodConditionComplexType::
    ~PeriodConditionComplexType ()
    {
    }

    // EnsembleMemberComplexType
    //

    EnsembleMemberComplexType::
    EnsembleMemberComplexType (const IndexType& index)
    : ::xml_schema::Type (),
      index_ (index, ::xml_schema::Flags (), this),
      weight_ (::xml_schema::Flags (), this)
    {
    }

    EnsembleMemberComplexType::
    EnsembleMemberComplexType (const EnsembleMemberComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      index_ (x.index_, f, this),
      weight_ (x.weight_, f, this)
    {
    }

    EnsembleMemberComplexType::
    EnsembleMemberComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      index_ (f, this),
      weight_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void EnsembleMemberComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "index" && n.namespace_ ().empty ())
        {
          this->index_.set (IndexTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "weight" && n.namespace_ ().empty ())
        {
          this->weight_.set (WeightTraits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "index",
          "");
      }
    }

    EnsembleMemberComplexType* EnsembleMemberComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EnsembleMemberComplexType (*this, f, c);
    }

    EnsembleMemberComplexType::
    ~EnsembleMemberComplexType ()
    {
    }

    // EnsembleMemberRangeComplexType
    //

    EnsembleMemberRangeComplexType::
    EnsembleMemberRangeComplexType (const StartType& start)
    : ::xml_schema::Type (),
      start_ (start, ::xml_schema::Flags (), this),
      end_ (::xml_schema::Flags (), this),
      weight_ (::xml_schema::Flags (), this)
    {
    }

    EnsembleMemberRangeComplexType::
    EnsembleMemberRangeComplexType (const EnsembleMemberRangeComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      start_ (x.start_, f, this),
      end_ (x.end_, f, this),
      weight_ (x.weight_, f, this)
    {
    }

    EnsembleMemberRangeComplexType::
    EnsembleMemberRangeComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      start_ (f, this),
      end_ (f, this),
      weight_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void EnsembleMemberRangeComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "start" && n.namespace_ ().empty ())
        {
          this->start_.set (StartTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "end" && n.namespace_ ().empty ())
        {
          this->end_.set (EndTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "weight" && n.namespace_ ().empty ())
        {
          this->weight_.set (WeightTraits::create (i, f, this));
          continue;
        }
      }

      if (!start_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "start",
          "");
      }
    }

    EnsembleMemberRangeComplexType* EnsembleMemberRangeComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EnsembleMemberRangeComplexType (*this, f, c);
    }

    EnsembleMemberRangeComplexType::
    ~EnsembleMemberRangeComplexType ()
    {
    }

    // GlobalTableComplexType
    //

    GlobalTableComplexType::
    GlobalTableComplexType ()
    : ::xml_schema::Type (),
      columnIds_ (::xml_schema::Flags (), this),
      columnTypes_ (::xml_schema::Flags (), this),
      columnUnits_ (::xml_schema::Flags (), this),
      columnMetaData_ (::xml_schema::Flags (), this),
      row_ (::xml_schema::Flags (), this)
    {
    }

    GlobalTableComplexType::
    GlobalTableComplexType (const GlobalTableComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      columnIds_ (x.columnIds_, f, this),
      columnTypes_ (x.columnTypes_, f, this),
      columnUnits_ (x.columnUnits_, f, this),
      columnMetaData_ (x.columnMetaData_, f, this),
      row_ (x.row_, f, this)
    {
    }

    GlobalTableComplexType::
    GlobalTableComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      columnIds_ (f, this),
      columnTypes_ (f, this),
      columnUnits_ (f, this),
      columnMetaData_ (f, this),
      row_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void GlobalTableComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // columnIds
        //
        if (n.name () == "columnIds" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ColumnIdsType > r (
            ColumnIdsTraits::create (i, f, this));

          if (!this->columnIds_)
          {
            this->columnIds_.set (r);
            continue;
          }
        }

        // columnTypes
        //
        if (n.name () == "columnTypes" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ColumnTypesType > r (
            ColumnTypesTraits::create (i, f, this));

          if (!this->columnTypes_)
          {
            this->columnTypes_.set (r);
            continue;
          }
        }

        // columnUnits
        //
        if (n.name () == "columnUnits" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ColumnUnitsType > r (
            ColumnUnitsTraits::create (i, f, this));

          if (!this->columnUnits_)
          {
            this->columnUnits_.set (r);
            continue;
          }
        }

        // columnMetaData
        //
        if (n.name () == "columnMetaData" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ColumnMetaDataType > r (
            ColumnMetaDataTraits::create (i, f, this));

          this->columnMetaData_.push_back (r);
          continue;
        }

        // row
        //
        if (n.name () == "row" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< RowType > r (
            RowTraits::create (i, f, this));

          this->row_.push_back (r);
          continue;
        }

        break;
      }
    }

    GlobalTableComplexType* GlobalTableComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GlobalTableComplexType (*this, f, c);
    }

    GlobalTableComplexType::
    ~GlobalTableComplexType ()
    {
    }

    // ColumnIdsComplexType
    //

    ColumnIdsComplexType::
    ColumnIdsComplexType (const AType& A)
    : ::xml_schema::Type (),
      A_ (A, ::xml_schema::Flags (), this),
      B_ (::xml_schema::Flags (), this),
      C_ (::xml_schema::Flags (), this),
      D_ (::xml_schema::Flags (), this),
      E_ (::xml_schema::Flags (), this),
      F_ (::xml_schema::Flags (), this),
      G_ (::xml_schema::Flags (), this),
      H_ (::xml_schema::Flags (), this),
      I_ (::xml_schema::Flags (), this),
      J_ (::xml_schema::Flags (), this),
      K_ (::xml_schema::Flags (), this),
      L_ (::xml_schema::Flags (), this),
      M_ (::xml_schema::Flags (), this),
      N_ (::xml_schema::Flags (), this),
      O_ (::xml_schema::Flags (), this),
      P_ (::xml_schema::Flags (), this),
      Q_ (::xml_schema::Flags (), this),
      R_ (::xml_schema::Flags (), this),
      S_ (::xml_schema::Flags (), this),
      T_ (::xml_schema::Flags (), this),
      U_ (::xml_schema::Flags (), this),
      V_ (::xml_schema::Flags (), this),
      W_ (::xml_schema::Flags (), this),
      X_ (::xml_schema::Flags (), this),
      Y_ (::xml_schema::Flags (), this),
      Z_ (::xml_schema::Flags (), this)
    {
    }

    ColumnIdsComplexType::
    ColumnIdsComplexType (const ColumnIdsComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      A_ (x.A_, f, this),
      B_ (x.B_, f, this),
      C_ (x.C_, f, this),
      D_ (x.D_, f, this),
      E_ (x.E_, f, this),
      F_ (x.F_, f, this),
      G_ (x.G_, f, this),
      H_ (x.H_, f, this),
      I_ (x.I_, f, this),
      J_ (x.J_, f, this),
      K_ (x.K_, f, this),
      L_ (x.L_, f, this),
      M_ (x.M_, f, this),
      N_ (x.N_, f, this),
      O_ (x.O_, f, this),
      P_ (x.P_, f, this),
      Q_ (x.Q_, f, this),
      R_ (x.R_, f, this),
      S_ (x.S_, f, this),
      T_ (x.T_, f, this),
      U_ (x.U_, f, this),
      V_ (x.V_, f, this),
      W_ (x.W_, f, this),
      X_ (x.X_, f, this),
      Y_ (x.Y_, f, this),
      Z_ (x.Z_, f, this)
    {
    }

    ColumnIdsComplexType::
    ColumnIdsComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      A_ (f, this),
      B_ (f, this),
      C_ (f, this),
      D_ (f, this),
      E_ (f, this),
      F_ (f, this),
      G_ (f, this),
      H_ (f, this),
      I_ (f, this),
      J_ (f, this),
      K_ (f, this),
      L_ (f, this),
      M_ (f, this),
      N_ (f, this),
      O_ (f, this),
      P_ (f, this),
      Q_ (f, this),
      R_ (f, this),
      S_ (f, this),
      T_ (f, this),
      U_ (f, this),
      V_ (f, this),
      W_ (f, this),
      X_ (f, this),
      Y_ (f, this),
      Z_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ColumnIdsComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "A" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AType > r (
            ATraits::create (i, f, this));

          this->A_.set (r);
          continue;
        }

        if (n.name () == "B" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< BType > r (
            BTraits::create (i, f, this));

          this->B_.set (r);
          continue;
        }

        if (n.name () == "C" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< CType > r (
            CTraits::create (i, f, this));

          this->C_.set (r);
          continue;
        }

        if (n.name () == "D" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DType > r (
            DTraits::create (i, f, this));

          this->D_.set (r);
          continue;
        }

        if (n.name () == "E" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< EType > r (
            ETraits::create (i, f, this));

          this->E_.set (r);
          continue;
        }

        if (n.name () == "F" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< FType > r (
            FTraits::create (i, f, this));

          this->F_.set (r);
          continue;
        }

        if (n.name () == "G" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< GType > r (
            GTraits::create (i, f, this));

          this->G_.set (r);
          continue;
        }

        if (n.name () == "H" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< HType > r (
            HTraits::create (i, f, this));

          this->H_.set (r);
          continue;
        }

        if (n.name () == "I" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IType > r (
            ITraits::create (i, f, this));

          this->I_.set (r);
          continue;
        }

        if (n.name () == "J" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< JType > r (
            JTraits::create (i, f, this));

          this->J_.set (r);
          continue;
        }

        if (n.name () == "K" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KType > r (
            KTraits::create (i, f, this));

          this->K_.set (r);
          continue;
        }

        if (n.name () == "L" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< LType > r (
            LTraits::create (i, f, this));

          this->L_.set (r);
          continue;
        }

        if (n.name () == "M" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< MType > r (
            MTraits::create (i, f, this));

          this->M_.set (r);
          continue;
        }

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NType > r (
            NTraits::create (i, f, this));

          this->N_.set (r);
          continue;
        }

        if (n.name () == "O" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< OType > r (
            OTraits::create (i, f, this));

          this->O_.set (r);
          continue;
        }

        if (n.name () == "P" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PType > r (
            PTraits::create (i, f, this));

          this->P_.set (r);
          continue;
        }

        if (n.name () == "Q" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< QType > r (
            QTraits::create (i, f, this));

          this->Q_.set (r);
          continue;
        }

        if (n.name () == "R" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< RType > r (
            RTraits::create (i, f, this));

          this->R_.set (r);
          continue;
        }

        if (n.name () == "S" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SType > r (
            STraits::create (i, f, this));

          this->S_.set (r);
          continue;
        }

        if (n.name () == "T" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TType > r (
            TTraits::create (i, f, this));

          this->T_.set (r);
          continue;
        }

        if (n.name () == "U" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< UType > r (
            UTraits::create (i, f, this));

          this->U_.set (r);
          continue;
        }

        if (n.name () == "V" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< VType > r (
            VTraits::create (i, f, this));

          this->V_.set (r);
          continue;
        }

        if (n.name () == "W" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< WType > r (
            WTraits::create (i, f, this));

          this->W_.set (r);
          continue;
        }

        if (n.name () == "X" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< XType > r (
            XTraits::create (i, f, this));

          this->X_.set (r);
          continue;
        }

        if (n.name () == "Y" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< YType > r (
            YTraits::create (i, f, this));

          this->Y_.set (r);
          continue;
        }

        if (n.name () == "Z" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ZType > r (
            ZTraits::create (i, f, this));

          this->Z_.set (r);
          continue;
        }
      }

      if (!A_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "A",
          "");
      }
    }

    ColumnIdsComplexType* ColumnIdsComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ColumnIdsComplexType (*this, f, c);
    }

    ColumnIdsComplexType::
    ~ColumnIdsComplexType ()
    {
    }

    // ColumnMetaDataComplexType
    //

    ColumnMetaDataComplexType::
    ColumnMetaDataComplexType (const AType& A)
    : ::fews::PI::ColumnIdsComplexType (A),
      id_ (::xml_schema::Flags (), this),
      type_ (::xml_schema::Flags (), this)
    {
    }

    ColumnMetaDataComplexType::
    ColumnMetaDataComplexType (const ColumnMetaDataComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::fews::PI::ColumnIdsComplexType (x, f, c),
      id_ (x.id_, f, this),
      type_ (x.type_, f, this)
    {
    }

    ColumnMetaDataComplexType::
    ColumnMetaDataComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::fews::PI::ColumnIdsComplexType (e, f | ::xml_schema::Flags::base, c),
      id_ (f, this),
      type_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ColumnMetaDataComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::fews::PI::ColumnIdsComplexType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IdType > r (
            IdTraits::create (i, f, this));

          this->id_.set (r);
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TypeType > r (
            TypeTraits::create (i, f, this));

          this->type_.set (r);
          continue;
        }
      }
    }

    ColumnMetaDataComplexType* ColumnMetaDataComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ColumnMetaDataComplexType (*this, f, c);
    }

    ColumnMetaDataComplexType::
    ~ColumnMetaDataComplexType ()
    {
    }

    // ColumnTypesComplexType
    //

    ColumnTypesComplexType::
    ColumnTypesComplexType (const AType& A)
    : ::xml_schema::Type (),
      A_ (A, ::xml_schema::Flags (), this),
      B_ (::xml_schema::Flags (), this),
      C_ (::xml_schema::Flags (), this),
      D_ (::xml_schema::Flags (), this),
      E_ (::xml_schema::Flags (), this),
      F_ (::xml_schema::Flags (), this),
      G_ (::xml_schema::Flags (), this),
      H_ (::xml_schema::Flags (), this),
      I_ (::xml_schema::Flags (), this),
      J_ (::xml_schema::Flags (), this),
      K_ (::xml_schema::Flags (), this),
      L_ (::xml_schema::Flags (), this),
      M_ (::xml_schema::Flags (), this),
      N_ (::xml_schema::Flags (), this),
      O_ (::xml_schema::Flags (), this),
      P_ (::xml_schema::Flags (), this),
      Q_ (::xml_schema::Flags (), this),
      R_ (::xml_schema::Flags (), this),
      S_ (::xml_schema::Flags (), this),
      T_ (::xml_schema::Flags (), this),
      U_ (::xml_schema::Flags (), this),
      V_ (::xml_schema::Flags (), this),
      W_ (::xml_schema::Flags (), this),
      X_ (::xml_schema::Flags (), this),
      Y_ (::xml_schema::Flags (), this),
      Z_ (::xml_schema::Flags (), this)
    {
    }

    ColumnTypesComplexType::
    ColumnTypesComplexType (const ColumnTypesComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      A_ (x.A_, f, this),
      B_ (x.B_, f, this),
      C_ (x.C_, f, this),
      D_ (x.D_, f, this),
      E_ (x.E_, f, this),
      F_ (x.F_, f, this),
      G_ (x.G_, f, this),
      H_ (x.H_, f, this),
      I_ (x.I_, f, this),
      J_ (x.J_, f, this),
      K_ (x.K_, f, this),
      L_ (x.L_, f, this),
      M_ (x.M_, f, this),
      N_ (x.N_, f, this),
      O_ (x.O_, f, this),
      P_ (x.P_, f, this),
      Q_ (x.Q_, f, this),
      R_ (x.R_, f, this),
      S_ (x.S_, f, this),
      T_ (x.T_, f, this),
      U_ (x.U_, f, this),
      V_ (x.V_, f, this),
      W_ (x.W_, f, this),
      X_ (x.X_, f, this),
      Y_ (x.Y_, f, this),
      Z_ (x.Z_, f, this)
    {
    }

    ColumnTypesComplexType::
    ColumnTypesComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      A_ (f, this),
      B_ (f, this),
      C_ (f, this),
      D_ (f, this),
      E_ (f, this),
      F_ (f, this),
      G_ (f, this),
      H_ (f, this),
      I_ (f, this),
      J_ (f, this),
      K_ (f, this),
      L_ (f, this),
      M_ (f, this),
      N_ (f, this),
      O_ (f, this),
      P_ (f, this),
      Q_ (f, this),
      R_ (f, this),
      S_ (f, this),
      T_ (f, this),
      U_ (f, this),
      V_ (f, this),
      W_ (f, this),
      X_ (f, this),
      Y_ (f, this),
      Z_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ColumnTypesComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "A" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AType > r (
            ATraits::create (i, f, this));

          this->A_.set (r);
          continue;
        }

        if (n.name () == "B" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< BType > r (
            BTraits::create (i, f, this));

          this->B_.set (r);
          continue;
        }

        if (n.name () == "C" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< CType > r (
            CTraits::create (i, f, this));

          this->C_.set (r);
          continue;
        }

        if (n.name () == "D" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DType > r (
            DTraits::create (i, f, this));

          this->D_.set (r);
          continue;
        }

        if (n.name () == "E" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< EType > r (
            ETraits::create (i, f, this));

          this->E_.set (r);
          continue;
        }

        if (n.name () == "F" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< FType > r (
            FTraits::create (i, f, this));

          this->F_.set (r);
          continue;
        }

        if (n.name () == "G" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< GType > r (
            GTraits::create (i, f, this));

          this->G_.set (r);
          continue;
        }

        if (n.name () == "H" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< HType > r (
            HTraits::create (i, f, this));

          this->H_.set (r);
          continue;
        }

        if (n.name () == "I" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IType > r (
            ITraits::create (i, f, this));

          this->I_.set (r);
          continue;
        }

        if (n.name () == "J" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< JType > r (
            JTraits::create (i, f, this));

          this->J_.set (r);
          continue;
        }

        if (n.name () == "K" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KType > r (
            KTraits::create (i, f, this));

          this->K_.set (r);
          continue;
        }

        if (n.name () == "L" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< LType > r (
            LTraits::create (i, f, this));

          this->L_.set (r);
          continue;
        }

        if (n.name () == "M" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< MType > r (
            MTraits::create (i, f, this));

          this->M_.set (r);
          continue;
        }

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NType > r (
            NTraits::create (i, f, this));

          this->N_.set (r);
          continue;
        }

        if (n.name () == "O" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< OType > r (
            OTraits::create (i, f, this));

          this->O_.set (r);
          continue;
        }

        if (n.name () == "P" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PType > r (
            PTraits::create (i, f, this));

          this->P_.set (r);
          continue;
        }

        if (n.name () == "Q" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< QType > r (
            QTraits::create (i, f, this));

          this->Q_.set (r);
          continue;
        }

        if (n.name () == "R" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< RType > r (
            RTraits::create (i, f, this));

          this->R_.set (r);
          continue;
        }

        if (n.name () == "S" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SType > r (
            STraits::create (i, f, this));

          this->S_.set (r);
          continue;
        }

        if (n.name () == "T" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TType > r (
            TTraits::create (i, f, this));

          this->T_.set (r);
          continue;
        }

        if (n.name () == "U" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< UType > r (
            UTraits::create (i, f, this));

          this->U_.set (r);
          continue;
        }

        if (n.name () == "V" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< VType > r (
            VTraits::create (i, f, this));

          this->V_.set (r);
          continue;
        }

        if (n.name () == "W" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< WType > r (
            WTraits::create (i, f, this));

          this->W_.set (r);
          continue;
        }

        if (n.name () == "X" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< XType > r (
            XTraits::create (i, f, this));

          this->X_.set (r);
          continue;
        }

        if (n.name () == "Y" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< YType > r (
            YTraits::create (i, f, this));

          this->Y_.set (r);
          continue;
        }

        if (n.name () == "Z" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ZType > r (
            ZTraits::create (i, f, this));

          this->Z_.set (r);
          continue;
        }
      }

      if (!A_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "A",
          "");
      }
    }

    ColumnTypesComplexType* ColumnTypesComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ColumnTypesComplexType (*this, f, c);
    }

    ColumnTypesComplexType::
    ~ColumnTypesComplexType ()
    {
    }

    // RowComplexType
    //

    RowComplexType::
    RowComplexType (const AType& A)
    : ::xml_schema::Type (),
      A_ (A, ::xml_schema::Flags (), this),
      B_ (::xml_schema::Flags (), this),
      C_ (::xml_schema::Flags (), this),
      D_ (::xml_schema::Flags (), this),
      E_ (::xml_schema::Flags (), this),
      F_ (::xml_schema::Flags (), this),
      G_ (::xml_schema::Flags (), this),
      H_ (::xml_schema::Flags (), this),
      I_ (::xml_schema::Flags (), this),
      J_ (::xml_schema::Flags (), this),
      K_ (::xml_schema::Flags (), this),
      L_ (::xml_schema::Flags (), this),
      M_ (::xml_schema::Flags (), this),
      N_ (::xml_schema::Flags (), this),
      O_ (::xml_schema::Flags (), this),
      P_ (::xml_schema::Flags (), this),
      Q_ (::xml_schema::Flags (), this),
      R_ (::xml_schema::Flags (), this),
      S_ (::xml_schema::Flags (), this),
      T_ (::xml_schema::Flags (), this),
      U_ (::xml_schema::Flags (), this),
      V_ (::xml_schema::Flags (), this),
      W_ (::xml_schema::Flags (), this),
      X_ (::xml_schema::Flags (), this),
      Y_ (::xml_schema::Flags (), this),
      Z_ (::xml_schema::Flags (), this)
    {
    }

    RowComplexType::
    RowComplexType (const RowComplexType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      A_ (x.A_, f, this),
      B_ (x.B_, f, this),
      C_ (x.C_, f, this),
      D_ (x.D_, f, this),
      E_ (x.E_, f, this),
      F_ (x.F_, f, this),
      G_ (x.G_, f, this),
      H_ (x.H_, f, this),
      I_ (x.I_, f, this),
      J_ (x.J_, f, this),
      K_ (x.K_, f, this),
      L_ (x.L_, f, this),
      M_ (x.M_, f, this),
      N_ (x.N_, f, this),
      O_ (x.O_, f, this),
      P_ (x.P_, f, this),
      Q_ (x.Q_, f, this),
      R_ (x.R_, f, this),
      S_ (x.S_, f, this),
      T_ (x.T_, f, this),
      U_ (x.U_, f, this),
      V_ (x.V_, f, this),
      W_ (x.W_, f, this),
      X_ (x.X_, f, this),
      Y_ (x.Y_, f, this),
      Z_ (x.Z_, f, this)
    {
    }

    RowComplexType::
    RowComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      A_ (f, this),
      B_ (f, this),
      C_ (f, this),
      D_ (f, this),
      E_ (f, this),
      F_ (f, this),
      G_ (f, this),
      H_ (f, this),
      I_ (f, this),
      J_ (f, this),
      K_ (f, this),
      L_ (f, this),
      M_ (f, this),
      N_ (f, this),
      O_ (f, this),
      P_ (f, this),
      Q_ (f, this),
      R_ (f, this),
      S_ (f, this),
      T_ (f, this),
      U_ (f, this),
      V_ (f, this),
      W_ (f, this),
      X_ (f, this),
      Y_ (f, this),
      Z_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void RowComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "A" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AType > r (
            ATraits::create (i, f, this));

          this->A_.set (r);
          continue;
        }

        if (n.name () == "B" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< BType > r (
            BTraits::create (i, f, this));

          this->B_.set (r);
          continue;
        }

        if (n.name () == "C" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< CType > r (
            CTraits::create (i, f, this));

          this->C_.set (r);
          continue;
        }

        if (n.name () == "D" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DType > r (
            DTraits::create (i, f, this));

          this->D_.set (r);
          continue;
        }

        if (n.name () == "E" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< EType > r (
            ETraits::create (i, f, this));

          this->E_.set (r);
          continue;
        }

        if (n.name () == "F" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< FType > r (
            FTraits::create (i, f, this));

          this->F_.set (r);
          continue;
        }

        if (n.name () == "G" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< GType > r (
            GTraits::create (i, f, this));

          this->G_.set (r);
          continue;
        }

        if (n.name () == "H" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< HType > r (
            HTraits::create (i, f, this));

          this->H_.set (r);
          continue;
        }

        if (n.name () == "I" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IType > r (
            ITraits::create (i, f, this));

          this->I_.set (r);
          continue;
        }

        if (n.name () == "J" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< JType > r (
            JTraits::create (i, f, this));

          this->J_.set (r);
          continue;
        }

        if (n.name () == "K" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KType > r (
            KTraits::create (i, f, this));

          this->K_.set (r);
          continue;
        }

        if (n.name () == "L" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< LType > r (
            LTraits::create (i, f, this));

          this->L_.set (r);
          continue;
        }

        if (n.name () == "M" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< MType > r (
            MTraits::create (i, f, this));

          this->M_.set (r);
          continue;
        }

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NType > r (
            NTraits::create (i, f, this));

          this->N_.set (r);
          continue;
        }

        if (n.name () == "O" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< OType > r (
            OTraits::create (i, f, this));

          this->O_.set (r);
          continue;
        }

        if (n.name () == "P" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PType > r (
            PTraits::create (i, f, this));

          this->P_.set (r);
          continue;
        }

        if (n.name () == "Q" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< QType > r (
            QTraits::create (i, f, this));

          this->Q_.set (r);
          continue;
        }

        if (n.name () == "R" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< RType > r (
            RTraits::create (i, f, this));

          this->R_.set (r);
          continue;
        }

        if (n.name () == "S" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SType > r (
            STraits::create (i, f, this));

          this->S_.set (r);
          continue;
        }

        if (n.name () == "T" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< TType > r (
            TTraits::create (i, f, this));

          this->T_.set (r);
          continue;
        }

        if (n.name () == "U" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< UType > r (
            UTraits::create (i, f, this));

          this->U_.set (r);
          continue;
        }

        if (n.name () == "V" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< VType > r (
            VTraits::create (i, f, this));

          this->V_.set (r);
          continue;
        }

        if (n.name () == "W" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< WType > r (
            WTraits::create (i, f, this));

          this->W_.set (r);
          continue;
        }

        if (n.name () == "X" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< XType > r (
            XTraits::create (i, f, this));

          this->X_.set (r);
          continue;
        }

        if (n.name () == "Y" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< YType > r (
            YTraits::create (i, f, this));

          this->Y_.set (r);
          continue;
        }

        if (n.name () == "Z" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ZType > r (
            ZTraits::create (i, f, this));

          this->Z_.set (r);
          continue;
        }
      }

      if (!A_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "A",
          "");
      }
    }

    RowComplexType* RowComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RowComplexType (*this, f, c);
    }

    RowComplexType::
    ~RowComplexType ()
    {
    }

    // TimeSeriesTypeEnumStringType
    //

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_TimeSeriesTypeEnumStringType_convert ();
    }

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_TimeSeriesTypeEnumStringType_convert ();
    }

    TimeSeriesTypeEnumStringType::
    TimeSeriesTypeEnumStringType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_TimeSeriesTypeEnumStringType_convert ();
    }

    TimeSeriesTypeEnumStringType* TimeSeriesTypeEnumStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TimeSeriesTypeEnumStringType (*this, f, c);
    }

    TimeSeriesTypeEnumStringType::Value TimeSeriesTypeEnumStringType::
    _xsd_TimeSeriesTypeEnumStringType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TimeSeriesTypeEnumStringType_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_TimeSeriesTypeEnumStringType_indexes_,
                        _xsd_TimeSeriesTypeEnumStringType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_TimeSeriesTypeEnumStringType_indexes_ + 5 || _xsd_TimeSeriesTypeEnumStringType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const TimeSeriesTypeEnumStringType::
    _xsd_TimeSeriesTypeEnumStringType_literals_[5] =
    {
      "external historical",
      "external forecasting",
      "simulated historical",
      "simulated forecasting",
      "temporary"
    };

    const TimeSeriesTypeEnumStringType::Value TimeSeriesTypeEnumStringType::
    _xsd_TimeSeriesTypeEnumStringType_indexes_[5] =
    {
      ::fews::PI::TimeSeriesTypeEnumStringType::external_forecasting,
      ::fews::PI::TimeSeriesTypeEnumStringType::external_historical,
      ::fews::PI::TimeSeriesTypeEnumStringType::simulated_forecasting,
      ::fews::PI::TimeSeriesTypeEnumStringType::simulated_historical,
      ::fews::PI::TimeSeriesTypeEnumStringType::temporary
    };

    // IdStringType
    //

    IdStringType::
    IdStringType ()
    : ::xml_schema::String ()
    {
    }

    IdStringType::
    IdStringType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    IdStringType::
    IdStringType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    IdStringType::
    IdStringType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    IdStringType::
    IdStringType (const IdStringType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    IdStringType::
    IdStringType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    IdStringType::
    IdStringType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    IdStringType::
    IdStringType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    IdStringType* IdStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IdStringType (*this, f, c);
    }

    IdStringType::
    ~IdStringType ()
    {
    }

    // NonEmptyStringType
    //

    NonEmptyStringType::
    NonEmptyStringType ()
    : ::xml_schema::String ()
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const NonEmptyStringType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    NonEmptyStringType::
    NonEmptyStringType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    NonEmptyStringType* NonEmptyStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NonEmptyStringType (*this, f, c);
    }

    NonEmptyStringType::
    ~NonEmptyStringType ()
    {
    }

    // ArchiveTimeSeriesSetComplexType
    //

    ArchiveTimeSeriesSetComplexType::
    ArchiveTimeSeriesSetComplexType (const ModuleInstanceIdType& moduleInstanceId,
                                     const ParameterIdType& parameterId,
                                     const TimeSeriesTypeType& timeSeriesType,
                                     const TimeStepType& timeStep)
    : ::xml_schema::Type (),
      moduleInstanceId_ (moduleInstanceId, ::xml_schema::Flags (), this),
      parameterId_ (parameterId, ::xml_schema::Flags (), this),
      qualifierId_ (::xml_schema::Flags (), this),
      locationId_ (::xml_schema::Flags (), this),
      timeSeriesType_ (timeSeriesType, ::xml_schema::Flags (), this),
      timeStep_ (timeStep, ::xml_schema::Flags (), this),
      ensembleId_ (::xml_schema::Flags (), this)
    {
    }

    ArchiveTimeSeriesSetComplexType::
    ArchiveTimeSeriesSetComplexType (const ModuleInstanceIdType& moduleInstanceId,
                                     const ParameterIdType& parameterId,
                                     const TimeSeriesTypeType& timeSeriesType,
                                     ::std::auto_ptr< TimeStepType >& timeStep)
    : ::xml_schema::Type (),
      moduleInstanceId_ (moduleInstanceId, ::xml_schema::Flags (), this),
      parameterId_ (parameterId, ::xml_schema::Flags (), this),
      qualifierId_ (::xml_schema::Flags (), this),
      locationId_ (::xml_schema::Flags (), this),
      timeSeriesType_ (timeSeriesType, ::xml_schema::Flags (), this),
      timeStep_ (timeStep, ::xml_schema::Flags (), this),
      ensembleId_ (::xml_schema::Flags (), this)
    {
    }

    ArchiveTimeSeriesSetComplexType::
    ArchiveTimeSeriesSetComplexType (const ArchiveTimeSeriesSetComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      moduleInstanceId_ (x.moduleInstanceId_, f, this),
      parameterId_ (x.parameterId_, f, this),
      qualifierId_ (x.qualifierId_, f, this),
      locationId_ (x.locationId_, f, this),
      timeSeriesType_ (x.timeSeriesType_, f, this),
      timeStep_ (x.timeStep_, f, this),
      ensembleId_ (x.ensembleId_, f, this)
    {
    }

    ArchiveTimeSeriesSetComplexType::
    ArchiveTimeSeriesSetComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      moduleInstanceId_ (f, this),
      parameterId_ (f, this),
      qualifierId_ (f, this),
      locationId_ (f, this),
      timeSeriesType_ (f, this),
      timeStep_ (f, this),
      ensembleId_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArchiveTimeSeriesSetComplexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // moduleInstanceId
        //
        if (n.name () == "moduleInstanceId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ModuleInstanceIdType > r (
            ModuleInstanceIdTraits::create (i, f, this));

          if (!moduleInstanceId_.present ())
          {
            this->moduleInstanceId_.set (r);
            continue;
          }
        }

        // parameterId
        //
        if (n.name () == "parameterId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< ParameterIdType > r (
            ParameterIdTraits::create (i, f, this));

          if (!parameterId_.present ())
          {
            this->parameterId_.set (r);
            continue;
          }
        }

        // qualifierId
        //
        if (n.name () == "qualifierId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< QualifierIdType > r (
            QualifierIdTraits::create (i, f, this));

          this->qualifierId_.push_back (r);
          continue;
        }

        // locationId
        //
        if (n.name () == "locationId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< LocationIdType > r (
            LocationIdTraits::create (i, f, this));

          this->locationId_.push_back (r);
          continue;
        }

        // timeSeriesType
        //
        if (n.name () == "timeSeriesType" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< TimeSeriesTypeType > r (
            TimeSeriesTypeTraits::create (i, f, this));

          if (!timeSeriesType_.present ())
          {
            this->timeSeriesType_.set (r);
            continue;
          }
        }

        // timeStep
        //
        if (n.name () == "timeStep" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< TimeStepType > r (
            TimeStepTraits::create (i, f, this));

          if (!timeStep_.present ())
          {
            this->timeStep_.set (r);
            continue;
          }
        }

        // ensembleId
        //
        if (n.name () == "ensembleId" && n.namespace_ () == "http://www.wldelft.nl/fews/PI")
        {
          ::std::auto_ptr< EnsembleIdType > r (
            EnsembleIdTraits::create (i, f, this));

          if (!this->ensembleId_)
          {
            this->ensembleId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!moduleInstanceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "moduleInstanceId",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!parameterId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "parameterId",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!timeSeriesType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "timeSeriesType",
          "http://www.wldelft.nl/fews/PI");
      }

      if (!timeStep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "timeStep",
          "http://www.wldelft.nl/fews/PI");
      }
    }

    ArchiveTimeSeriesSetComplexType* ArchiveTimeSeriesSetComplexType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ArchiveTimeSeriesSetComplexType (*this, f, c);
    }

    ArchiveTimeSeriesSetComplexType::
    ~ArchiveTimeSeriesSetComplexType ()
    {
    }

    // Unit
    //

    Unit::
    Unit (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (e, f, c)
    {
    }

    Unit::
    Unit (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (a, f, c)
    {
    }

    Unit::
    Unit (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (s, e, f, c)
    {
    }

    Unit* Unit::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Unit (*this, f, c);
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace fews
{
  namespace PI
  {
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

