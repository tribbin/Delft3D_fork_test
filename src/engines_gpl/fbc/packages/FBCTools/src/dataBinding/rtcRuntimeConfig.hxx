// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from rtcRuntimeConfig.xsd.
 */

#ifndef RTC_RUNTIME_CONFIG_HXX
#define RTC_RUNTIME_CONFIG_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace fews
{
  class RtcRuntimeConfigComplexType;
  class FileComplexType;
  class FileDataComplexType;
  class FileObjectiveComplexType;
  class FileParameterComplexType;
  class FileScenarioTreeComplexType;
  class FileToolsComplexType;
  class PeriodComplexType;
  class UserDefinedRuntimeComplexType;
  class PIInputRuntimeComplexType;
  class PIRunFileRuntimeComplexType;
  class ModesComplexType;
  class ModeComplexType;
  class ModeSimulationComplexType;
  class ModeOptimizationComplexType;
  class OptimizerComplexType;
  class GAMSComplexType;
  class IPOPTComplexType;
  class IPOPTOutputComplexType;
  class IPOPTTerminationComplexType;
  class IPOPTNLPScalingComplexType;
  class IPOPTNLPComplexType;
  class IPOPTLinearSolverComplexType;
  class MA27ComplexType;
  class MA57ComplexType;
  class MA86ComplexType;
  class MA77ComplexType;
  class MA97ComplexType;
  class MUMPSComplexType;
  class PardisoComplexType;
  class IPOPTQuasiNewtonComplexType;
  class IPOPTDerivativeCheckerComplexType;
  class IPOPTHessianPermutationComplexType;
  class IPOPTRestorationPhaseComplexType;
  class IPOPTMultiplierUpdatesComplexType;
  class IPOPTLineSearchComplexType;
  class IPOPTWarmStartComplexType;
  class IPOPTInitializationComplexType;
  class IPOPTBarrierParameterComplexType;
  class SAComplexType;
  class LoggingComplexType;
  class UserDefinedStateExportComplexType;
  class ModeClosedLoopComplexType;
  class ParallelizationComplexType;
  class ParallelModeEnumStringType;
  class OptimizerModeEnumStringType;
  class ParameterFileTypeEnumStringType;
  class ParameterFilePrefixEnumStringType;
  class PeriodEnumStringType;
  class FunctionOutputEnumStringType;
  class Algorithm;
  class Print_level;
  class Print_user_options;
  class Print_options_documentation;
  class Print_timing_statistics;
  class File_print_level;
  class Nlp_scaling_method;
  class Nlp_scaling_max_gradient;
  class Nlp_scaling_min_value;
  class Bound_relax_factor;
  class Honor_original_bounds;
  class Check_derivatives_for_naninf;
  class Fixed_variable_treatment;
  class Jac_c_constant;
  class Jac_d_constant;
  class Linear_solver;
  class Linear_system_scaling;
  class Linear_scaling_on_demand;
  class Ma57_automatic_scaling;
  class Ma86_order;
  class Ma86_scaling;
  class Ma77_order;
  class Ma97_order;
  class Ma97_scaling;
  class Ma97_scaling1;
  class Ma97_scaling2;
  class Ma97_scaling3;
  class Ma97_solve_blas3;
  class Ma97_switch1;
  class Ma97_switch2;
  class Ma97_switch3;
  class Pardiso_matching_strategy;
  class Pardiso_order;
  class Derivative_test;
  class Derivative_test_perturbation;
  class Derivative_test_tol;
  class Derivative_test_print_all;
  class Jacobian_approximation;
  class Findiff_perturbation;
  class Expect_infeasible_problem;
  class Start_with_resto;
  class Evaluate_orig_obj_at_resto_trial;
  class Alpha_for_y;
  class Recalc_y;
  class Accept_every_trial_step;
  class Warm_start_init_point;
  class Bound_mult_init_method;
  class Mehrotra_algorithm;
  class Mu_strategy;
  class Mu_oracle;
  class Fixed_mu_oracle;
  class Adaptive_mu_globalization;
  class ReportConstraintViolation;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "rtcSharedTypes.hxx"

/**
 * @brief C++ namespace for the %http://www.wldelft.nl/fews
 * schema namespace.
 */
namespace fews
{
  /**
   * @brief Class corresponding to the %RtcRuntimeConfigComplexType schema type.
   *
   * @nosubgrouping
   */
  class RtcRuntimeConfigComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name files
     *
     * @brief Accessor and modifier functions for the %files
     * optional element.
     *
     * Optional provision of input files, if provided ALL relevant input
     * files needs to be defined, if not, the program will check for files
     * with default naming in the current working folder
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FileComplexType FilesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FilesType > FilesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FilesType, char > FilesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FilesOptional&
    getFiles () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FilesOptional&
    getFiles ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFiles (const FilesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFiles (const FilesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFiles (::std::auto_ptr< FilesType > p);

    //@}

    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * required element.
     *
     * Execution period of the simulation or optimization
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PeriodComplexType PeriodType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PeriodType&
    getPeriod () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PeriodType&
    getPeriod ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPeriod (const PeriodType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPeriod (::std::auto_ptr< PeriodType > p);

    //@}

    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * optional element.
     *
     * Optional definition of the execution mode of the application, default
     * = simulation if not provided
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModeComplexType ModeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModeType > ModeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModeOptional&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ModeOptional&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMode (const ModeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    //@}

    /**
     * @name modes
     *
     * @brief Accessor and modifier functions for the %modes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModesComplexType ModesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModesType > ModesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModesType, char > ModesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModesOptional&
    getModes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ModesOptional&
    getModes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setModes (const ModesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setModes (const ModesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setModes (::std::auto_ptr< ModesType > p);

    //@}

    /**
     * @name parallelization
     *
     * @brief Accessor and modifier functions for the %parallelization
     * optional element.
     *
     * Optional parallelization settings
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParallelizationComplexType ParallelizationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ParallelizationType > ParallelizationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParallelizationType, char > ParallelizationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ParallelizationOptional&
    getParallelization () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ParallelizationOptional&
    getParallelization ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParallelization (const ParallelizationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setParallelization (const ParallelizationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setParallelization (::std::auto_ptr< ParallelizationType > p);

    //@}

    /**
     * @name logging
     *
     * @brief Accessor and modifier functions for the %logging
     * optional element.
     *
     * Logging
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LoggingComplexType LoggingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LoggingType > LoggingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LoggingType, char > LoggingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LoggingOptional&
    getLogging () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LoggingOptional&
    getLogging ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLogging (const LoggingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLogging (const LoggingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLogging (::std::auto_ptr< LoggingType > p);

    //@}

    /**
     * @name stateFiles
     *
     * @brief Accessor and modifier functions for the %stateFiles
     * optional element.
     *
     * Optional definition for saving periodic state files
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UserDefinedStateExportComplexType StateFilesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateFilesType > StateFilesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateFilesType, char > StateFilesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateFilesOptional&
    getStateFiles () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateFilesOptional&
    getStateFiles ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateFiles (const StateFilesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStateFiles (const StateFilesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateFiles (::std::auto_ptr< StateFilesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RtcRuntimeConfigComplexType (const PeriodType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    RtcRuntimeConfigComplexType (::std::auto_ptr< PeriodType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RtcRuntimeConfigComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RtcRuntimeConfigComplexType (const RtcRuntimeConfigComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RtcRuntimeConfigComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RtcRuntimeConfigComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FilesOptional files_;
    ::xsd::cxx::tree::one< PeriodType > period_;
    ModeOptional mode_;
    ModesOptional modes_;
    ParallelizationOptional parallelization_;
    LoggingOptional logging_;
    StateFilesOptional stateFiles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %FileComplexType schema type.
   *
   * @nosubgrouping
   */
  class FileComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name rtcDataConfig
     *
     * @brief Accessor and modifier functions for the %rtcDataConfig
     * required element.
     *
     * File with the time series model definition
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FileDataComplexType RtcDataConfigType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RtcDataConfigType, char > RtcDataConfigTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RtcDataConfigType&
    getRtcDataConfig () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RtcDataConfigType&
    getRtcDataConfig ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRtcDataConfig (const RtcDataConfigType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRtcDataConfig (::std::auto_ptr< RtcDataConfigType > p);

    //@}

    /**
     * @name rtcObjectiveConfig
     *
     * @brief Accessor and modifier functions for the %rtcObjectiveConfig
     * optional element.
     *
     * Optional file with the definition of an optimization problem including
     * optimization variables, constraints and objective function terms
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FileObjectiveComplexType RtcObjectiveConfigType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RtcObjectiveConfigType > RtcObjectiveConfigOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RtcObjectiveConfigType, char > RtcObjectiveConfigTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RtcObjectiveConfigOptional&
    getRtcObjectiveConfig () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RtcObjectiveConfigOptional&
    getRtcObjectiveConfig ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRtcObjectiveConfig (const RtcObjectiveConfigType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRtcObjectiveConfig (const RtcObjectiveConfigOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRtcObjectiveConfig (::std::auto_ptr< RtcObjectiveConfigType > p);

    //@}

    /**
     * @name rtcParameterConfig
     *
     * @brief Accessor and modifier functions for the %rtcParameterConfig
     * sequence element.
     *
     * Optional file with externalized (scalar) parameters
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FileParameterComplexType RtcParameterConfigType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RtcParameterConfigType > RtcParameterConfigSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RtcParameterConfigSequence::iterator RtcParameterConfigIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RtcParameterConfigSequence::const_iterator RtcParameterConfigConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RtcParameterConfigType, char > RtcParameterConfigTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RtcParameterConfigSequence&
    getRtcParameterConfig () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RtcParameterConfigSequence&
    getRtcParameterConfig ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRtcParameterConfig (const RtcParameterConfigSequence& s);

    //@}

    /**
     * @name rtcScenarioTreeConfig
     *
     * @brief Accessor and modifier functions for the %rtcScenarioTreeConfig
     * optional element.
     *
     * Optional file with the definition of a scenario tree for the control
     * trajectory in case of multi-stage stochastic optimization problems
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FileScenarioTreeComplexType RtcScenarioTreeConfigType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RtcScenarioTreeConfigType > RtcScenarioTreeConfigOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RtcScenarioTreeConfigType, char > RtcScenarioTreeConfigTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RtcScenarioTreeConfigOptional&
    getRtcScenarioTreeConfig () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RtcScenarioTreeConfigOptional&
    getRtcScenarioTreeConfig ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRtcScenarioTreeConfig (const RtcScenarioTreeConfigType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRtcScenarioTreeConfig (const RtcScenarioTreeConfigOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRtcScenarioTreeConfig (::std::auto_ptr< RtcScenarioTreeConfigType > p);

    //@}

    /**
     * @name rtcToolsConfig
     *
     * @brief Accessor and modifier functions for the %rtcToolsConfig
     * required element.
     *
     * File with the schematization of the process model, i.e. the model of
     * the water resources systems
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FileToolsComplexType RtcToolsConfigType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RtcToolsConfigType, char > RtcToolsConfigTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RtcToolsConfigType&
    getRtcToolsConfig () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RtcToolsConfigType&
    getRtcToolsConfig ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRtcToolsConfig (const RtcToolsConfigType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRtcToolsConfig (::std::auto_ptr< RtcToolsConfigType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FileComplexType (const RtcDataConfigType&,
                     const RtcToolsConfigType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    FileComplexType (::std::auto_ptr< RtcDataConfigType >&,
                     ::std::auto_ptr< RtcToolsConfigType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FileComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FileComplexType (const FileComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FileComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FileComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RtcDataConfigType > rtcDataConfig_;
    RtcObjectiveConfigOptional rtcObjectiveConfig_;
    RtcParameterConfigSequence rtcParameterConfig_;
    RtcScenarioTreeConfigOptional rtcScenarioTreeConfig_;
    ::xsd::cxx::tree::one< RtcToolsConfigType > rtcToolsConfig_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %FileDataComplexType schema type.
   *
   * @nosubgrouping
   */
  class FileDataComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FileDataComplexType (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FileDataComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FileDataComplexType (const FileDataComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FileDataComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FileDataComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %FileObjectiveComplexType schema type.
   *
   * @nosubgrouping
   */
  class FileObjectiveComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FileObjectiveComplexType (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FileObjectiveComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FileObjectiveComplexType (const FileObjectiveComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FileObjectiveComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FileObjectiveComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %FileParameterComplexType schema type.
   *
   * @nosubgrouping
   */
  class FileParameterComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name type
     *
     * @brief Accessor and modifier functions for the %type
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ParameterFileTypeEnumStringType TypeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TypeType&
    getType () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TypeType&
    getType ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setType (::std::auto_ptr< TypeType > p);

    //@}

    /**
     * @name prefix
     *
     * @brief Accessor and modifier functions for the %prefix
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ParameterFilePrefixEnumStringType PrefixType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PrefixType, char > PrefixTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PrefixType&
    getPrefix () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PrefixType&
    getPrefix ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPrefix (const PrefixType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPrefix (::std::auto_ptr< PrefixType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const PrefixType&
    getPrefixDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FileParameterComplexType (const NameType&,
                              const TypeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FileParameterComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FileParameterComplexType (const FileParameterComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FileParameterComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FileParameterComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< PrefixType > prefix_;
    static const PrefixType prefix_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %FileScenarioTreeComplexType schema type.
   *
   * @nosubgrouping
   */
  class FileScenarioTreeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FileScenarioTreeComplexType (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FileScenarioTreeComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FileScenarioTreeComplexType (const FileScenarioTreeComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FileScenarioTreeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FileScenarioTreeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %FileToolsComplexType schema type.
   *
   * @nosubgrouping
   */
  class FileToolsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FileToolsComplexType (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FileToolsComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FileToolsComplexType (const FileToolsComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FileToolsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FileToolsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PeriodComplexType schema type.
   *
   * @nosubgrouping
   */
  class PeriodComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name userDefined
     *
     * @brief Accessor and modifier functions for the %userDefined
     * optional element.
     *
     * The execution period is user-defined by start and end time, time step
     * and optionally the number of ensembles.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UserDefinedRuntimeComplexType UserDefinedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UserDefinedType > UserDefinedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UserDefinedType, char > UserDefinedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UserDefinedOptional&
    getUserDefined () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UserDefinedOptional&
    getUserDefined ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUserDefined (const UserDefinedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUserDefined (const UserDefinedOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUserDefined (::std::auto_ptr< UserDefinedType > p);

    //@}

    /**
     * @name PIInput
     *
     * @brief Accessor and modifier functions for the %PIInput
     * optional element.
     *
     * The execution period is defined by the first time series of the
     * referred PI-XML file.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PIInputRuntimeComplexType PIInputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PIInputType > PIInputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PIInputType, char > PIInputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PIInputOptional&
    getPIInput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PIInputOptional&
    getPIInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPIInput (const PIInputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPIInput (const PIInputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPIInput (::std::auto_ptr< PIInputType > p);

    //@}

    /**
     * @name PIRunFile
     *
     * @brief Accessor and modifier functions for the %PIRunFile
     * optional element.
     *
     * The execution period is defined in the PI-XML run file.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PIRunFileRuntimeComplexType PIRunFileType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PIRunFileType > PIRunFileOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PIRunFileType, char > PIRunFileTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PIRunFileOptional&
    getPIRunFile () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PIRunFileOptional&
    getPIRunFile ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPIRunFile (const PIRunFileType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPIRunFile (const PIRunFileOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPIRunFile (::std::auto_ptr< PIRunFileType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PeriodComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PeriodComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PeriodComplexType (const PeriodComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PeriodComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PeriodComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UserDefinedOptional userDefined_;
    PIInputOptional PIInput_;
    PIRunFileOptional PIRunFile_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UserDefinedRuntimeComplexType schema type.
   *
   * @nosubgrouping
   */
  class UserDefinedRuntimeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name startDate
     *
     * @brief Accessor and modifier functions for the %startDate
     * required element.
     *
     * Start date and time of the similation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTimeComplexType StartDateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StartDateType, char > StartDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StartDateType&
    getStartDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StartDateType&
    getStartDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStartDate (const StartDateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStartDate (::std::auto_ptr< StartDateType > p);

    //@}

    /**
     * @name endDate
     *
     * @brief Accessor and modifier functions for the %endDate
     * required element.
     *
     * End date and time of the simulation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTimeComplexType EndDateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EndDateType, char > EndDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EndDateType&
    getEndDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EndDateType&
    getEndDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEndDate (const EndDateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEndDate (::std::auto_ptr< EndDateType > p);

    //@}

    /**
     * @name forecastDate
     *
     * @brief Accessor and modifier functions for the %forecastDate
     * optional element.
     *
     * Forecast date and time of the simulation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTimeComplexType ForecastDateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ForecastDateType > ForecastDateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ForecastDateType, char > ForecastDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ForecastDateOptional&
    getForecastDate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ForecastDateOptional&
    getForecastDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setForecastDate (const ForecastDateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setForecastDate (const ForecastDateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setForecastDate (::std::auto_ptr< ForecastDateType > p);

    //@}

    /**
     * @name timeStep
     *
     * @brief Accessor and modifier functions for the %timeStep
     * required element.
     *
     * Time step of the simulation (till now, the model supports only
     * equidistant time steps)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeStepComplexType TimeStepType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeStepType, char > TimeStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TimeStepType&
    getTimeStep () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TimeStepType&
    getTimeStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeStep (const TimeStepType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTimeStep (::std::auto_ptr< TimeStepType > p);

    //@}

    /**
     * @name numberEnsembles
     *
     * @brief Accessor and modifier functions for the %numberEnsembles
     * optional element.
     *
     * Optional number of ensemble of the simulation. If not provided, one
     * ensemble member is assumed.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int NumberEnsemblesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NumberEnsemblesType > NumberEnsemblesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberEnsemblesType, char > NumberEnsemblesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NumberEnsemblesOptional&
    getNumberEnsembles () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NumberEnsemblesOptional&
    getNumberEnsembles ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumberEnsembles (const NumberEnsemblesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNumberEnsembles (const NumberEnsemblesOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NumberEnsemblesType
    getNumberEnsemblesDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UserDefinedRuntimeComplexType (const StartDateType&,
                                   const EndDateType&,
                                   const TimeStepType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    UserDefinedRuntimeComplexType (::std::auto_ptr< StartDateType >&,
                                   ::std::auto_ptr< EndDateType >&,
                                   ::std::auto_ptr< TimeStepType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UserDefinedRuntimeComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UserDefinedRuntimeComplexType (const UserDefinedRuntimeComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UserDefinedRuntimeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UserDefinedRuntimeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StartDateType > startDate_;
    ::xsd::cxx::tree::one< EndDateType > endDate_;
    ForecastDateOptional forecastDate_;
    ::xsd::cxx::tree::one< TimeStepType > timeStep_;
    NumberEnsemblesOptional numberEnsembles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PIInputRuntimeComplexType schema type.
   *
   * @nosubgrouping
   */
  class PIInputRuntimeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name file
     *
     * @brief Accessor and modifier functions for the %file
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String FileType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FileType, char > FileTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FileType&
    getFile () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FileType&
    getFile ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFile (const FileType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFile (::std::auto_ptr< FileType > p);

    //@}

    /**
     * @name numberEnsembles
     *
     * @brief Accessor and modifier functions for the %numberEnsembles
     * optional element.
     *
     * optional number of ensemble, if not provides one ensemble member is
     * assumed
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int NumberEnsemblesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NumberEnsemblesType > NumberEnsemblesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberEnsemblesType, char > NumberEnsemblesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NumberEnsemblesOptional&
    getNumberEnsembles () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NumberEnsemblesOptional&
    getNumberEnsembles ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumberEnsembles (const NumberEnsemblesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNumberEnsembles (const NumberEnsemblesOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NumberEnsemblesType
    getNumberEnsemblesDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PIInputRuntimeComplexType (const FileType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PIInputRuntimeComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PIInputRuntimeComplexType (const PIInputRuntimeComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PIInputRuntimeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PIInputRuntimeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FileType > file_;
    NumberEnsemblesOptional numberEnsembles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PIRunFileRuntimeComplexType schema type.
   *
   * @nosubgrouping
   */
  class PIRunFileRuntimeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name file
     *
     * @brief Accessor and modifier functions for the %file
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String FileType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FileType, char > FileTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FileType&
    getFile () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FileType&
    getFile ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFile (const FileType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFile (::std::auto_ptr< FileType > p);

    //@}

    /**
     * @name timeStep
     *
     * @brief Accessor and modifier functions for the %timeStep
     * required element.
     *
     * Time step of the simulation (till now, the model supports only
     * equidistant time steps)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeStepComplexType TimeStepType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeStepType, char > TimeStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TimeStepType&
    getTimeStep () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TimeStepType&
    getTimeStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeStep (const TimeStepType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTimeStep (::std::auto_ptr< TimeStepType > p);

    //@}

    /**
     * @name numberEnsembles
     *
     * @brief Accessor and modifier functions for the %numberEnsembles
     * optional element.
     *
     * optional number of ensemble, if not provides one ensemble member is
     * assumed
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int NumberEnsemblesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NumberEnsemblesType > NumberEnsemblesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberEnsemblesType, char > NumberEnsemblesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NumberEnsemblesOptional&
    getNumberEnsembles () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NumberEnsemblesOptional&
    getNumberEnsembles ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumberEnsembles (const NumberEnsemblesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNumberEnsembles (const NumberEnsemblesOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NumberEnsemblesType
    getNumberEnsemblesDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PIRunFileRuntimeComplexType (const FileType&,
                                 const TimeStepType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PIRunFileRuntimeComplexType (const FileType&,
                                 ::std::auto_ptr< TimeStepType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PIRunFileRuntimeComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PIRunFileRuntimeComplexType (const PIRunFileRuntimeComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PIRunFileRuntimeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PIRunFileRuntimeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FileType > file_;
    ::xsd::cxx::tree::one< TimeStepType > timeStep_;
    NumberEnsemblesOptional numberEnsembles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ModesComplexType schema type.
   *
   * @nosubgrouping
   */
  class ModesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModeComplexType ModeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ModeType > ModeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ModeSequence::iterator ModeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ModeSequence::const_iterator ModeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ModeSequence&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ModeSequence&
    getMode ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setMode (const ModeSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ModesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ModesComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ModesComplexType (const ModesComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ModesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ModesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ModeSequence mode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ModeComplexType schema type.
   *
   * @nosubgrouping
   */
  class ModeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * optional element.
     *
     * Simulation mode (default)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModeSimulationComplexType SimulationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SimulationType > SimulationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SimulationOptional&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SimulationOptional&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSimulation (const SimulationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    //@}

    /**
     * @name firstOrderSensitivity
     *
     * @brief Accessor and modifier functions for the %firstOrderSensitivity
     * optional element.
     *
     * Calculation of first-order model sensitivities of an objective
     * function value with respect to inputs, states and outputs (requires
     * the definition of an objective function in the rtcObjectiveConfig.xml)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String FirstOrderSensitivityType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FirstOrderSensitivityType > FirstOrderSensitivityOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FirstOrderSensitivityType, char > FirstOrderSensitivityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FirstOrderSensitivityOptional&
    getFirstOrderSensitivity () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FirstOrderSensitivityOptional&
    getFirstOrderSensitivity ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFirstOrderSensitivity (const FirstOrderSensitivityType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFirstOrderSensitivity (const FirstOrderSensitivityOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFirstOrderSensitivity (::std::auto_ptr< FirstOrderSensitivityType > p);

    //@}

    /**
     * @name optimization
     *
     * @brief Accessor and modifier functions for the %optimization
     * optional element.
     *
     * Optimization mode (requires the definition of an optimization problem
     * in the rtcObjectiveConfig.xml)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModeOptimizationComplexType OptimizationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OptimizationType > OptimizationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OptimizationType, char > OptimizationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OptimizationOptional&
    getOptimization () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OptimizationOptional&
    getOptimization ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOptimization (const OptimizationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOptimization (const OptimizationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOptimization (::std::auto_ptr< OptimizationType > p);

    //@}

    /**
     * @name closedLoop
     *
     * @brief Accessor and modifier functions for the %closedLoop
     * optional element.
     *
     * Closed loop mode with an alternating switch between simulation and
     * optimization
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModeClosedLoopComplexType ClosedLoopType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ClosedLoopType > ClosedLoopOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClosedLoopType, char > ClosedLoopTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ClosedLoopOptional&
    getClosedLoop () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ClosedLoopOptional&
    getClosedLoop ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setClosedLoop (const ClosedLoopType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setClosedLoop (const ClosedLoopOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setClosedLoop (::std::auto_ptr< ClosedLoopType > p);

    //@}

    /**
     * @name postprocessing
     *
     * @brief Accessor and modifier functions for the %postprocessing
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String PostprocessingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PostprocessingType > PostprocessingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PostprocessingType, char > PostprocessingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PostprocessingOptional&
    getPostprocessing () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PostprocessingOptional&
    getPostprocessing ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPostprocessing (const PostprocessingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPostprocessing (const PostprocessingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPostprocessing (::std::auto_ptr< PostprocessingType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ModeComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ModeComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ModeComplexType (const ModeComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ModeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ModeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SimulationOptional simulation_;
    FirstOrderSensitivityOptional firstOrderSensitivity_;
    OptimizationOptional optimization_;
    ClosedLoopOptional closedLoop_;
    PostprocessingOptional postprocessing_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ModeSimulationComplexType schema type.
   *
   * @nosubgrouping
   */
  class ModeSimulationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PeriodEnumStringType PeriodType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PeriodType > PeriodOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PeriodOptional&
    getPeriod () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PeriodOptional&
    getPeriod ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPeriod (const PeriodType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPeriod (const PeriodOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPeriod (::std::auto_ptr< PeriodType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const PeriodType&
    getPeriodDefaultValue ();

    //@}

    /**
     * @name limitedMemory
     *
     * @brief Accessor and modifier functions for the %limitedMemory
     * optional element.
     *
     * limited-memory option for time series matrix
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean LimitedMemoryType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LimitedMemoryType > LimitedMemoryOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LimitedMemoryType, char > LimitedMemoryTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LimitedMemoryOptional&
    getLimitedMemory () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LimitedMemoryOptional&
    getLimitedMemory ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLimitedMemory (const LimitedMemoryType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLimitedMemory (const LimitedMemoryOptional& x);

    //@}

    /**
     * @name executeObjectiveFunction
     *
     * @brief Accessor and modifier functions for the %executeObjectiveFunction
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean ExecuteObjectiveFunctionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExecuteObjectiveFunctionType > ExecuteObjectiveFunctionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExecuteObjectiveFunctionType, char > ExecuteObjectiveFunctionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExecuteObjectiveFunctionOptional&
    getExecuteObjectiveFunction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExecuteObjectiveFunctionOptional&
    getExecuteObjectiveFunction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExecuteObjectiveFunction (const ExecuteObjectiveFunctionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExecuteObjectiveFunction (const ExecuteObjectiveFunctionOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ExecuteObjectiveFunctionType
    getExecuteObjectiveFunctionDefaultValue ();

    //@}

    /**
     * @name executeConstraints
     *
     * @brief Accessor and modifier functions for the %executeConstraints
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean ExecuteConstraintsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExecuteConstraintsType > ExecuteConstraintsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExecuteConstraintsType, char > ExecuteConstraintsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExecuteConstraintsOptional&
    getExecuteConstraints () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExecuteConstraintsOptional&
    getExecuteConstraints ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExecuteConstraints (const ExecuteConstraintsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExecuteConstraints (const ExecuteConstraintsOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ExecuteConstraintsType
    getExecuteConstraintsDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ModeSimulationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ModeSimulationComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ModeSimulationComplexType (const ModeSimulationComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ModeSimulationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ModeSimulationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PeriodOptional period_;
    static const PeriodType period_default_value_;
    LimitedMemoryOptional limitedMemory_;
    ExecuteObjectiveFunctionOptional executeObjectiveFunction_;
    ExecuteConstraintsOptional executeConstraints_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ModeOptimizationComplexType schema type.
   *
   * @nosubgrouping
   */
  class ModeOptimizationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PeriodEnumStringType PeriodType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PeriodType > PeriodOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PeriodOptional&
    getPeriod () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PeriodOptional&
    getPeriod ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPeriod (const PeriodType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPeriod (const PeriodOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPeriod (::std::auto_ptr< PeriodType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const PeriodType&
    getPeriodDefaultValue ();

    //@}

    /**
     * @name optimizer
     *
     * @brief Accessor and modifier functions for the %optimizer
     * sequence element.
     *
     * Selection of one or more optimizer settings for solving the
     * optimization problem
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OptimizerComplexType OptimizerType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OptimizerType > OptimizerSequence;

    /**
     * @brief Element iterator type.
     */
    typedef OptimizerSequence::iterator OptimizerIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef OptimizerSequence::const_iterator OptimizerConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OptimizerType, char > OptimizerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OptimizerSequence&
    getOptimizer () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OptimizerSequence&
    getOptimizer ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOptimizer (const OptimizerSequence& s);

    //@}

    /**
     * @name optimizerMode
     *
     * @brief Accessor and modifier functions for the %optimizerMode
     * optional element.
     *
     * Mode for defining more robust hybrid optimizer settings for running
     * optimizations sequentially (optimimum of the first is input for the
     * next) or parallel (independent optimization, best one is returned),
     * STILL NOT IMPLEMENTED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OptimizerModeEnumStringType OptimizerModeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OptimizerModeType > OptimizerModeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OptimizerModeType, char > OptimizerModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OptimizerModeOptional&
    getOptimizerMode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OptimizerModeOptional&
    getOptimizerMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOptimizerMode (const OptimizerModeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOptimizerMode (const OptimizerModeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOptimizerMode (::std::auto_ptr< OptimizerModeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ModeOptimizationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ModeOptimizationComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ModeOptimizationComplexType (const ModeOptimizationComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ModeOptimizationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ModeOptimizationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PeriodOptional period_;
    static const PeriodType period_default_value_;
    OptimizerSequence optimizer_;
    OptimizerModeOptional optimizerMode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OptimizerComplexType schema type.
   *
   * @nosubgrouping
   */
  class OptimizerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name GAMS
     *
     * @brief Accessor and modifier functions for the %GAMS
     * optional element.
     *
     * This option generates a GAMS optimization problem with an external
     * model in RTC-Tools. Note that you need to run the optimization in GAMS
     * after executing the stand alone RTC-Tools.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GAMSComplexType GAMSType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GAMSType > GAMSOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GAMSType, char > GAMSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GAMSOptional&
    getGAMS () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GAMSOptional&
    getGAMS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGAMS (const GAMSType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGAMS (const GAMSOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGAMS (::std::auto_ptr< GAMSType > p);

    //@}

    /**
     * @name IPOPT
     *
     * @brief Accessor and modifier functions for the %IPOPT
     * optional element.
     *
     * Optimization by the IPOPT optimizer, check also the related
     * documentation on the COIN-OR website
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTComplexType IPOPTType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IPOPTType > IPOPTOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IPOPTType, char > IPOPTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IPOPTOptional&
    getIPOPT () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IPOPTOptional&
    getIPOPT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIPOPT (const IPOPTType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIPOPT (const IPOPTOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIPOPT (::std::auto_ptr< IPOPTType > p);

    //@}

    /**
     * @name SA
     *
     * @brief Accessor and modifier functions for the %SA
     * optional element.
     *
     * Optimization by a simulated annealing optimizer (NOT FULLY IMPLEMENTED
     * right now)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SAComplexType SAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SAType > SAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SAType, char > SATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SAOptional&
    getSA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SAOptional&
    getSA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSA (const SAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSA (const SAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSA (::std::auto_ptr< SAType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OptimizerComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OptimizerComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OptimizerComplexType (const OptimizerComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OptimizerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OptimizerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GAMSOptional GAMS_;
    IPOPTOptional IPOPT_;
    SAOptional SA_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GAMSComplexType schema type.
   *
   * @nosubgrouping
   */
  class GAMSComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name algorithm
     *
     * @brief Accessor and modifier functions for the %algorithm
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Algorithm AlgorithmType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AlgorithmType > AlgorithmOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AlgorithmType, char > AlgorithmTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AlgorithmOptional&
    getAlgorithm () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AlgorithmOptional&
    getAlgorithm ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAlgorithm (const AlgorithmType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAlgorithm (const AlgorithmOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAlgorithm (::std::auto_ptr< AlgorithmType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const AlgorithmType&
    getAlgorithmDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GAMSComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GAMSComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GAMSComplexType (const GAMSComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GAMSComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GAMSComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlgorithmOptional algorithm_;
    static const AlgorithmType algorithm_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     *
     * Output options
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name termination
     *
     * @brief Accessor and modifier functions for the %termination
     * required element.
     *
     * Termination criteria
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTTerminationComplexType TerminationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TerminationType, char > TerminationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TerminationType&
    getTermination () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TerminationType&
    getTermination ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTermination (const TerminationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTermination (::std::auto_ptr< TerminationType > p);

    //@}

    /**
     * @name nlpScaling
     *
     * @brief Accessor and modifier functions for the %nlpScaling
     * required element.
     *
     * Scaling options for the optimization problem
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTNLPScalingComplexType NlpScalingType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NlpScalingType, char > NlpScalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NlpScalingType&
    getNlpScaling () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NlpScalingType&
    getNlpScaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNlpScaling (const NlpScalingType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNlpScaling (::std::auto_ptr< NlpScalingType > p);

    //@}

    /**
     * @name nlp
     *
     * @brief Accessor and modifier functions for the %nlp
     * required element.
     *
     * Settings of the nonlinear optimizer
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTNLPComplexType NlpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NlpType, char > NlpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NlpType&
    getNlp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NlpType&
    getNlp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNlp (const NlpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNlp (::std::auto_ptr< NlpType > p);

    //@}

    /**
     * @name initialization
     *
     * @brief Accessor and modifier functions for the %initialization
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTInitializationComplexType InitializationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitializationType, char > InitializationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InitializationType&
    getInitialization () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InitializationType&
    getInitialization ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInitialization (const InitializationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInitialization (::std::auto_ptr< InitializationType > p);

    //@}

    /**
     * @name barrierParameter
     *
     * @brief Accessor and modifier functions for the %barrierParameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTBarrierParameterComplexType BarrierParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BarrierParameterType, char > BarrierParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BarrierParameterType&
    getBarrierParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BarrierParameterType&
    getBarrierParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBarrierParameter (const BarrierParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBarrierParameter (::std::auto_ptr< BarrierParameterType > p);

    //@}

    /**
     * @name multiplierUpdates
     *
     * @brief Accessor and modifier functions for the %multiplierUpdates
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTMultiplierUpdatesComplexType MultiplierUpdatesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultiplierUpdatesType, char > MultiplierUpdatesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MultiplierUpdatesType&
    getMultiplierUpdates () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MultiplierUpdatesType&
    getMultiplierUpdates ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMultiplierUpdates (const MultiplierUpdatesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMultiplierUpdates (::std::auto_ptr< MultiplierUpdatesType > p);

    //@}

    /**
     * @name lineSearch
     *
     * @brief Accessor and modifier functions for the %lineSearch
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTLineSearchComplexType LineSearchType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LineSearchType, char > LineSearchTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LineSearchType&
    getLineSearch () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LineSearchType&
    getLineSearch ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLineSearch (const LineSearchType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLineSearch (::std::auto_ptr< LineSearchType > p);

    //@}

    /**
     * @name warmStart
     *
     * @brief Accessor and modifier functions for the %warmStart
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTWarmStartComplexType WarmStartType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WarmStartType, char > WarmStartTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WarmStartType&
    getWarmStart () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WarmStartType&
    getWarmStart ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarmStart (const WarmStartType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWarmStart (::std::auto_ptr< WarmStartType > p);

    //@}

    /**
     * @name restorationPhase
     *
     * @brief Accessor and modifier functions for the %restorationPhase
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTRestorationPhaseComplexType RestorationPhaseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RestorationPhaseType, char > RestorationPhaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RestorationPhaseType&
    getRestorationPhase () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RestorationPhaseType&
    getRestorationPhase ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRestorationPhase (const RestorationPhaseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRestorationPhase (::std::auto_ptr< RestorationPhaseType > p);

    //@}

    /**
     * @name linearSolver
     *
     * @brief Accessor and modifier functions for the %linearSolver
     * required element.
     *
     * Settings and selection of the integrated linear equation solver
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTLinearSolverComplexType LinearSolverType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LinearSolverType, char > LinearSolverTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LinearSolverType&
    getLinearSolver () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LinearSolverType&
    getLinearSolver ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLinearSolver (const LinearSolverType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLinearSolver (::std::auto_ptr< LinearSolverType > p);

    //@}

    /**
     * @name hessianPermutation
     *
     * @brief Accessor and modifier functions for the %hessianPermutation
     * required element.
     *
     * Optional hessian settings
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTHessianPermutationComplexType HessianPermutationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HessianPermutationType, char > HessianPermutationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HessianPermutationType&
    getHessianPermutation () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HessianPermutationType&
    getHessianPermutation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHessianPermutation (const HessianPermutationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHessianPermutation (::std::auto_ptr< HessianPermutationType > p);

    //@}

    /**
     * @name quasiNewton
     *
     * @brief Accessor and modifier functions for the %quasiNewton
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTQuasiNewtonComplexType QuasiNewtonType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QuasiNewtonType, char > QuasiNewtonTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QuasiNewtonType&
    getQuasiNewton () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QuasiNewtonType&
    getQuasiNewton ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQuasiNewton (const QuasiNewtonType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQuasiNewton (::std::auto_ptr< QuasiNewtonType > p);

    //@}

    /**
     * @name derivativeChecker
     *
     * @brief Accessor and modifier functions for the %derivativeChecker
     * required element.
     *
     * Optional derivative checker
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IPOPTDerivativeCheckerComplexType DerivativeCheckerType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DerivativeCheckerType, char > DerivativeCheckerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DerivativeCheckerType&
    getDerivativeChecker () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DerivativeCheckerType&
    getDerivativeChecker ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDerivativeChecker (const DerivativeCheckerType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDerivativeChecker (::std::auto_ptr< DerivativeCheckerType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTComplexType (const OutputType&,
                      const TerminationType&,
                      const NlpScalingType&,
                      const NlpType&,
                      const InitializationType&,
                      const BarrierParameterType&,
                      const MultiplierUpdatesType&,
                      const LineSearchType&,
                      const WarmStartType&,
                      const RestorationPhaseType&,
                      const LinearSolverType&,
                      const HessianPermutationType&,
                      const QuasiNewtonType&,
                      const DerivativeCheckerType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    IPOPTComplexType (::std::auto_ptr< OutputType >&,
                      ::std::auto_ptr< TerminationType >&,
                      ::std::auto_ptr< NlpScalingType >&,
                      ::std::auto_ptr< NlpType >&,
                      ::std::auto_ptr< InitializationType >&,
                      ::std::auto_ptr< BarrierParameterType >&,
                      ::std::auto_ptr< MultiplierUpdatesType >&,
                      ::std::auto_ptr< LineSearchType >&,
                      ::std::auto_ptr< WarmStartType >&,
                      ::std::auto_ptr< RestorationPhaseType >&,
                      ::std::auto_ptr< LinearSolverType >&,
                      ::std::auto_ptr< HessianPermutationType >&,
                      ::std::auto_ptr< QuasiNewtonType >&,
                      ::std::auto_ptr< DerivativeCheckerType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTComplexType (const IPOPTComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< TerminationType > termination_;
    ::xsd::cxx::tree::one< NlpScalingType > nlpScaling_;
    ::xsd::cxx::tree::one< NlpType > nlp_;
    ::xsd::cxx::tree::one< InitializationType > initialization_;
    ::xsd::cxx::tree::one< BarrierParameterType > barrierParameter_;
    ::xsd::cxx::tree::one< MultiplierUpdatesType > multiplierUpdates_;
    ::xsd::cxx::tree::one< LineSearchType > lineSearch_;
    ::xsd::cxx::tree::one< WarmStartType > warmStart_;
    ::xsd::cxx::tree::one< RestorationPhaseType > restorationPhase_;
    ::xsd::cxx::tree::one< LinearSolverType > linearSolver_;
    ::xsd::cxx::tree::one< HessianPermutationType > hessianPermutation_;
    ::xsd::cxx::tree::one< QuasiNewtonType > quasiNewton_;
    ::xsd::cxx::tree::one< DerivativeCheckerType > derivativeChecker_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name print_level
     *
     * @brief Accessor and modifier functions for the %print_level
     * optional element.
     *
     * Output verbosity level 0-12,      NONE=0
     * ERROR=1
     * STRONGWARNING=2
     * SUMMARY=3
     * WARNING=4
     * ITERSUMMARY=5
     * DETAILED=6
     * MOREDETAILED=7
     * VECTOR=8
     * MOREVECTOR=9
     * MATRIX=10
     * MOREMATRIX=11
     * ALL=12
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Print_level Print_levelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Print_levelType > Print_levelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Print_levelType, char > Print_levelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Print_levelOptional&
    getPrint_level () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Print_levelOptional&
    getPrint_level ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrint_level (const Print_levelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrint_level (const Print_levelOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrint_level (::std::auto_ptr< Print_levelType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Print_levelType
    getPrint_levelDefaultValue ();

    //@}

    /**
     * @name print_user_options
     *
     * @brief Accessor and modifier functions for the %print_user_options
     * optional element.
     *
     * Print all options set by the user [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Print_user_options Print_user_optionsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Print_user_optionsType > Print_user_optionsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Print_user_optionsType, char > Print_user_optionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Print_user_optionsOptional&
    getPrint_user_options () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Print_user_optionsOptional&
    getPrint_user_options ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrint_user_options (const Print_user_optionsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrint_user_options (const Print_user_optionsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrint_user_options (::std::auto_ptr< Print_user_optionsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Print_user_optionsType&
    getPrint_user_optionsDefaultValue ();

    //@}

    /**
     * @name print_options_documentation
     *
     * @brief Accessor and modifier functions for the %print_options_documentation
     * optional element.
     *
     * Switch to print all algorithmic options [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Print_options_documentation Print_options_documentationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Print_options_documentationType > Print_options_documentationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Print_options_documentationType, char > Print_options_documentationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Print_options_documentationOptional&
    getPrint_options_documentation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Print_options_documentationOptional&
    getPrint_options_documentation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrint_options_documentation (const Print_options_documentationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrint_options_documentation (const Print_options_documentationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrint_options_documentation (::std::auto_ptr< Print_options_documentationType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Print_options_documentationType&
    getPrint_options_documentationDefaultValue ();

    //@}

    /**
     * @name print_timing_statistics
     *
     * @brief Accessor and modifier functions for the %print_timing_statistics
     * optional element.
     *
     * Switch to print timing statistics [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Print_timing_statistics Print_timing_statisticsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Print_timing_statisticsType > Print_timing_statisticsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Print_timing_statisticsType, char > Print_timing_statisticsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Print_timing_statisticsOptional&
    getPrint_timing_statistics () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Print_timing_statisticsOptional&
    getPrint_timing_statistics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrint_timing_statistics (const Print_timing_statisticsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrint_timing_statistics (const Print_timing_statisticsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrint_timing_statistics (::std::auto_ptr< Print_timing_statisticsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Print_timing_statisticsType&
    getPrint_timing_statisticsDefaultValue ();

    //@}

    /**
     * @name file_print_level
     *
     * @brief Accessor and modifier functions for the %file_print_level
     * optional element.
     *
     * Verbosity level for output file 0-12                                  
     * NONE=0
     * ERROR=1
     * STRONGWARNING=2
     * SUMMARY=3
     * WARNING=4
     * ITERSUMMARY=5
     * DETAILED=6
     * MOREDETAILED=7
     * VECTOR=8
     * MOREVECTOR=9
     * MATRIX=10
     * MOREMATRIX=11
     * ALL=12
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::File_print_level File_print_levelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< File_print_levelType > File_print_levelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< File_print_levelType, char > File_print_levelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const File_print_levelOptional&
    getFile_print_level () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    File_print_levelOptional&
    getFile_print_level ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFile_print_level (const File_print_levelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFile_print_level (const File_print_levelOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFile_print_level (::std::auto_ptr< File_print_levelType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static File_print_levelType
    getFile_print_levelDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTOutputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTOutputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTOutputComplexType (const IPOPTOutputComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Print_levelOptional print_level_;
    Print_user_optionsOptional print_user_options_;
    static const Print_user_optionsType print_user_options_default_value_;
    Print_options_documentationOptional print_options_documentation_;
    static const Print_options_documentationType print_options_documentation_default_value_;
    Print_timing_statisticsOptional print_timing_statistics_;
    static const Print_timing_statisticsType print_timing_statistics_default_value_;
    File_print_levelOptional file_print_level_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTTerminationComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTTerminationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name tol
     *
     * @brief Accessor and modifier functions for the %tol
     * optional element.
     *
     * Desired convergence tolerance (relative)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TolType > TolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TolType, char > TolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TolOptional&
    getTol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TolOptional&
    getTol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTol (const TolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTol (const TolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTol (::std::auto_ptr< TolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const TolType&
    getTolDefaultValue ();

    //@}

    /**
     * @name max_iter
     *
     * @brief Accessor and modifier functions for the %max_iter
     * optional element.
     *
     * Maximum number of iterations
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalIntegerSimpleType Max_iterType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_iterType > Max_iterOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_iterType, char > Max_iterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_iterOptional&
    getMax_iter () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_iterOptional&
    getMax_iter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_iter (const Max_iterType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_iter (const Max_iterOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMax_iter (::std::auto_ptr< Max_iterType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Max_iterType&
    getMax_iterDefaultValue ();

    //@}

    /**
     * @name max_cpu_time
     *
     * @brief Accessor and modifier functions for the %max_cpu_time
     * optional element.
     *
     * Maximum number of CPU seconds
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Max_cpu_timeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_cpu_timeType > Max_cpu_timeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_cpu_timeType, char > Max_cpu_timeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_cpu_timeOptional&
    getMax_cpu_time () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_cpu_timeOptional&
    getMax_cpu_time ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_cpu_time (const Max_cpu_timeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_cpu_time (const Max_cpu_timeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMax_cpu_time (::std::auto_ptr< Max_cpu_timeType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Max_cpu_timeType&
    getMax_cpu_timeDefaultValue ();

    //@}

    /**
     * @name dual_inf_tol
     *
     * @brief Accessor and modifier functions for the %dual_inf_tol
     * optional element.
     *
     * Desired threshold for the dual infeasibility
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Dual_inf_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Dual_inf_tolType > Dual_inf_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Dual_inf_tolType, char > Dual_inf_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Dual_inf_tolOptional&
    getDual_inf_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Dual_inf_tolOptional&
    getDual_inf_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDual_inf_tol (const Dual_inf_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDual_inf_tol (const Dual_inf_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDual_inf_tol (::std::auto_ptr< Dual_inf_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Dual_inf_tolType&
    getDual_inf_tolDefaultValue ();

    //@}

    /**
     * @name constr_viol_tol
     *
     * @brief Accessor and modifier functions for the %constr_viol_tol
     * optional element.
     *
     * Desired threshold for the constraint violation
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Constr_viol_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Constr_viol_tolType > Constr_viol_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Constr_viol_tolType, char > Constr_viol_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Constr_viol_tolOptional&
    getConstr_viol_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Constr_viol_tolOptional&
    getConstr_viol_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstr_viol_tol (const Constr_viol_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstr_viol_tol (const Constr_viol_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConstr_viol_tol (::std::auto_ptr< Constr_viol_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Constr_viol_tolType&
    getConstr_viol_tolDefaultValue ();

    //@}

    /**
     * @name compl_inf_tol
     *
     * @brief Accessor and modifier functions for the %compl_inf_tol
     * optional element.
     *
     * Desired threshold for the complementarity conditions
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Compl_inf_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Compl_inf_tolType > Compl_inf_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Compl_inf_tolType, char > Compl_inf_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Compl_inf_tolOptional&
    getCompl_inf_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Compl_inf_tolOptional&
    getCompl_inf_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCompl_inf_tol (const Compl_inf_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCompl_inf_tol (const Compl_inf_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCompl_inf_tol (::std::auto_ptr< Compl_inf_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Compl_inf_tolType&
    getCompl_inf_tolDefaultValue ();

    //@}

    /**
     * @name acceptable_tol
     *
     * @brief Accessor and modifier functions for the %acceptable_tol
     * optional element.
     *
     * "Acceptable" convergence tolerance (relative)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Acceptable_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Acceptable_tolType > Acceptable_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Acceptable_tolType, char > Acceptable_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Acceptable_tolOptional&
    getAcceptable_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Acceptable_tolOptional&
    getAcceptable_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptable_tol (const Acceptable_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptable_tol (const Acceptable_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcceptable_tol (::std::auto_ptr< Acceptable_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Acceptable_tolType&
    getAcceptable_tolDefaultValue ();

    //@}

    /**
     * @name acceptable_iter
     *
     * @brief Accessor and modifier functions for the %acceptable_iter
     * optional element.
     *
     * Number of "acceptable" iterates before triggering termination
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalIntegerSimpleType Acceptable_iterType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Acceptable_iterType > Acceptable_iterOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Acceptable_iterType, char > Acceptable_iterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Acceptable_iterOptional&
    getAcceptable_iter () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Acceptable_iterOptional&
    getAcceptable_iter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptable_iter (const Acceptable_iterType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptable_iter (const Acceptable_iterOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcceptable_iter (::std::auto_ptr< Acceptable_iterType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Acceptable_iterType&
    getAcceptable_iterDefaultValue ();

    //@}

    /**
     * @name acceptable_constr_viol_tol
     *
     * @brief Accessor and modifier functions for the %acceptable_constr_viol_tol
     * optional element.
     *
     * "Acceptance" threshold for the constraint violation
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Acceptable_constr_viol_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Acceptable_constr_viol_tolType > Acceptable_constr_viol_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Acceptable_constr_viol_tolType, char > Acceptable_constr_viol_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Acceptable_constr_viol_tolOptional&
    getAcceptable_constr_viol_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Acceptable_constr_viol_tolOptional&
    getAcceptable_constr_viol_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptable_constr_viol_tol (const Acceptable_constr_viol_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptable_constr_viol_tol (const Acceptable_constr_viol_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcceptable_constr_viol_tol (::std::auto_ptr< Acceptable_constr_viol_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Acceptable_constr_viol_tolType&
    getAcceptable_constr_viol_tolDefaultValue ();

    //@}

    /**
     * @name acceptable_dual_inf_tol
     *
     * @brief Accessor and modifier functions for the %acceptable_dual_inf_tol
     * optional element.
     *
     * "Acceptance" threshold for the dual infeasibility
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Acceptable_dual_inf_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Acceptable_dual_inf_tolType > Acceptable_dual_inf_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Acceptable_dual_inf_tolType, char > Acceptable_dual_inf_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Acceptable_dual_inf_tolOptional&
    getAcceptable_dual_inf_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Acceptable_dual_inf_tolOptional&
    getAcceptable_dual_inf_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptable_dual_inf_tol (const Acceptable_dual_inf_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptable_dual_inf_tol (const Acceptable_dual_inf_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcceptable_dual_inf_tol (::std::auto_ptr< Acceptable_dual_inf_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Acceptable_dual_inf_tolType&
    getAcceptable_dual_inf_tolDefaultValue ();

    //@}

    /**
     * @name acceptable_compl_inf_tol
     *
     * @brief Accessor and modifier functions for the %acceptable_compl_inf_tol
     * optional element.
     *
     * "Acceptance" threshold for the complementarity conditions
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Acceptable_compl_inf_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Acceptable_compl_inf_tolType > Acceptable_compl_inf_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Acceptable_compl_inf_tolType, char > Acceptable_compl_inf_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Acceptable_compl_inf_tolOptional&
    getAcceptable_compl_inf_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Acceptable_compl_inf_tolOptional&
    getAcceptable_compl_inf_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptable_compl_inf_tol (const Acceptable_compl_inf_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptable_compl_inf_tol (const Acceptable_compl_inf_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcceptable_compl_inf_tol (::std::auto_ptr< Acceptable_compl_inf_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Acceptable_compl_inf_tolType&
    getAcceptable_compl_inf_tolDefaultValue ();

    //@}

    /**
     * @name acceptable_obj_change_tol
     *
     * @brief Accessor and modifier functions for the %acceptable_obj_change_tol
     * optional element.
     *
     * "Acceptance" stopping criterion based on objective function change
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Acceptable_obj_change_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Acceptable_obj_change_tolType > Acceptable_obj_change_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Acceptable_obj_change_tolType, char > Acceptable_obj_change_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Acceptable_obj_change_tolOptional&
    getAcceptable_obj_change_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Acceptable_obj_change_tolOptional&
    getAcceptable_obj_change_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptable_obj_change_tol (const Acceptable_obj_change_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptable_obj_change_tol (const Acceptable_obj_change_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcceptable_obj_change_tol (::std::auto_ptr< Acceptable_obj_change_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Acceptable_obj_change_tolType&
    getAcceptable_obj_change_tolDefaultValue ();

    //@}

    /**
     * @name diverging_iterates_tol
     *
     * @brief Accessor and modifier functions for the %diverging_iterates_tol
     * optional element.
     *
     * Threshold for maximal value of primal iterates
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Diverging_iterates_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Diverging_iterates_tolType > Diverging_iterates_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Diverging_iterates_tolType, char > Diverging_iterates_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Diverging_iterates_tolOptional&
    getDiverging_iterates_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Diverging_iterates_tolOptional&
    getDiverging_iterates_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDiverging_iterates_tol (const Diverging_iterates_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDiverging_iterates_tol (const Diverging_iterates_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDiverging_iterates_tol (::std::auto_ptr< Diverging_iterates_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Diverging_iterates_tolType&
    getDiverging_iterates_tolDefaultValue ();

    //@}

    /**
     * @name treat_unsuccess_as_error
     *
     * @brief Accessor and modifier functions for the %treat_unsuccess_as_error
     * optional element.
     *
     * Other return codes than SUCESS are treated as error message
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalBooleanSimpleType Treat_unsuccess_as_errorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Treat_unsuccess_as_errorType > Treat_unsuccess_as_errorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Treat_unsuccess_as_errorType, char > Treat_unsuccess_as_errorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Treat_unsuccess_as_errorOptional&
    getTreat_unsuccess_as_error () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Treat_unsuccess_as_errorOptional&
    getTreat_unsuccess_as_error ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreat_unsuccess_as_error (const Treat_unsuccess_as_errorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTreat_unsuccess_as_error (const Treat_unsuccess_as_errorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTreat_unsuccess_as_error (::std::auto_ptr< Treat_unsuccess_as_errorType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Treat_unsuccess_as_errorType&
    getTreat_unsuccess_as_errorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTTerminationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTTerminationComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTTerminationComplexType (const IPOPTTerminationComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTTerminationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTTerminationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TolOptional tol_;
    static const TolType tol_default_value_;
    Max_iterOptional max_iter_;
    static const Max_iterType max_iter_default_value_;
    Max_cpu_timeOptional max_cpu_time_;
    static const Max_cpu_timeType max_cpu_time_default_value_;
    Dual_inf_tolOptional dual_inf_tol_;
    static const Dual_inf_tolType dual_inf_tol_default_value_;
    Constr_viol_tolOptional constr_viol_tol_;
    static const Constr_viol_tolType constr_viol_tol_default_value_;
    Compl_inf_tolOptional compl_inf_tol_;
    static const Compl_inf_tolType compl_inf_tol_default_value_;
    Acceptable_tolOptional acceptable_tol_;
    static const Acceptable_tolType acceptable_tol_default_value_;
    Acceptable_iterOptional acceptable_iter_;
    static const Acceptable_iterType acceptable_iter_default_value_;
    Acceptable_constr_viol_tolOptional acceptable_constr_viol_tol_;
    static const Acceptable_constr_viol_tolType acceptable_constr_viol_tol_default_value_;
    Acceptable_dual_inf_tolOptional acceptable_dual_inf_tol_;
    static const Acceptable_dual_inf_tolType acceptable_dual_inf_tol_default_value_;
    Acceptable_compl_inf_tolOptional acceptable_compl_inf_tol_;
    static const Acceptable_compl_inf_tolType acceptable_compl_inf_tol_default_value_;
    Acceptable_obj_change_tolOptional acceptable_obj_change_tol_;
    static const Acceptable_obj_change_tolType acceptable_obj_change_tol_default_value_;
    Diverging_iterates_tolOptional diverging_iterates_tol_;
    static const Diverging_iterates_tolType diverging_iterates_tol_default_value_;
    Treat_unsuccess_as_errorOptional treat_unsuccess_as_error_;
    static const Treat_unsuccess_as_errorType treat_unsuccess_as_error_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTNLPScalingComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTNLPScalingComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name obj_scaling_factor
     *
     * @brief Accessor and modifier functions for the %obj_scaling_factor
     * optional element.
     *
     * Scaling factor for the objective function
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Obj_scaling_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Obj_scaling_factorType > Obj_scaling_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Obj_scaling_factorType, char > Obj_scaling_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Obj_scaling_factorOptional&
    getObj_scaling_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Obj_scaling_factorOptional&
    getObj_scaling_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObj_scaling_factor (const Obj_scaling_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setObj_scaling_factor (const Obj_scaling_factorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setObj_scaling_factor (::std::auto_ptr< Obj_scaling_factorType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Obj_scaling_factorType&
    getObj_scaling_factorDefaultValue ();

    //@}

    /**
     * @name nlp_scaling_method
     *
     * @brief Accessor and modifier functions for the %nlp_scaling_method
     * optional element.
     *
     * Select the technique used for scaling the NLP
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Nlp_scaling_method Nlp_scaling_methodType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Nlp_scaling_methodType > Nlp_scaling_methodOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Nlp_scaling_methodType, char > Nlp_scaling_methodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Nlp_scaling_methodOptional&
    getNlp_scaling_method () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Nlp_scaling_methodOptional&
    getNlp_scaling_method ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNlp_scaling_method (const Nlp_scaling_methodType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNlp_scaling_method (const Nlp_scaling_methodOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNlp_scaling_method (::std::auto_ptr< Nlp_scaling_methodType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Nlp_scaling_methodType&
    getNlp_scaling_methodDefaultValue ();

    //@}

    /**
     * @name nlp_scaling_max_gradient
     *
     * @brief Accessor and modifier functions for the %nlp_scaling_max_gradient
     * optional element.
     *
     * Maximum gradient after NLP scaling
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Nlp_scaling_max_gradient Nlp_scaling_max_gradientType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Nlp_scaling_max_gradientType > Nlp_scaling_max_gradientOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Nlp_scaling_max_gradientType, char > Nlp_scaling_max_gradientTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Nlp_scaling_max_gradientOptional&
    getNlp_scaling_max_gradient () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Nlp_scaling_max_gradientOptional&
    getNlp_scaling_max_gradient ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNlp_scaling_max_gradient (const Nlp_scaling_max_gradientType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNlp_scaling_max_gradient (const Nlp_scaling_max_gradientOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNlp_scaling_max_gradient (::std::auto_ptr< Nlp_scaling_max_gradientType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Nlp_scaling_max_gradientType
    getNlp_scaling_max_gradientDefaultValue ();

    //@}

    /**
     * @name nlp_scaling_min_value
     *
     * @brief Accessor and modifier functions for the %nlp_scaling_min_value
     * optional element.
     *
     * Maximum gradient after NLP scaling
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Nlp_scaling_min_value Nlp_scaling_min_valueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Nlp_scaling_min_valueType > Nlp_scaling_min_valueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Nlp_scaling_min_valueType, char > Nlp_scaling_min_valueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Nlp_scaling_min_valueOptional&
    getNlp_scaling_min_value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Nlp_scaling_min_valueOptional&
    getNlp_scaling_min_value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNlp_scaling_min_value (const Nlp_scaling_min_valueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNlp_scaling_min_value (const Nlp_scaling_min_valueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNlp_scaling_min_value (::std::auto_ptr< Nlp_scaling_min_valueType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Nlp_scaling_min_valueType
    getNlp_scaling_min_valueDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTNLPScalingComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTNLPScalingComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTNLPScalingComplexType (const IPOPTNLPScalingComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTNLPScalingComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTNLPScalingComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Obj_scaling_factorOptional obj_scaling_factor_;
    static const Obj_scaling_factorType obj_scaling_factor_default_value_;
    Nlp_scaling_methodOptional nlp_scaling_method_;
    static const Nlp_scaling_methodType nlp_scaling_method_default_value_;
    Nlp_scaling_max_gradientOptional nlp_scaling_max_gradient_;
    Nlp_scaling_min_valueOptional nlp_scaling_min_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTNLPComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTNLPComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name bound_relax_factor
     *
     * @brief Accessor and modifier functions for the %bound_relax_factor
     * optional element.
     *
     * Factor for initial relaxation of the bounds
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Bound_relax_factor Bound_relax_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Bound_relax_factorType > Bound_relax_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Bound_relax_factorType, char > Bound_relax_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Bound_relax_factorOptional&
    getBound_relax_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Bound_relax_factorOptional&
    getBound_relax_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBound_relax_factor (const Bound_relax_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBound_relax_factor (const Bound_relax_factorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBound_relax_factor (::std::auto_ptr< Bound_relax_factorType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Bound_relax_factorType
    getBound_relax_factorDefaultValue ();

    //@}

    /**
     * @name honor_original_bounds
     *
     * @brief Accessor and modifier functions for the %honor_original_bounds
     * optional element.
     *
     * Indicates whether final points should be projected into original
     * bounds [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Honor_original_bounds Honor_original_boundsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Honor_original_boundsType > Honor_original_boundsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Honor_original_boundsType, char > Honor_original_boundsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Honor_original_boundsOptional&
    getHonor_original_bounds () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Honor_original_boundsOptional&
    getHonor_original_bounds ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHonor_original_bounds (const Honor_original_boundsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHonor_original_bounds (const Honor_original_boundsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHonor_original_bounds (::std::auto_ptr< Honor_original_boundsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Honor_original_boundsType&
    getHonor_original_boundsDefaultValue ();

    //@}

    /**
     * @name check_derivatives_for_naninf
     *
     * @brief Accessor and modifier functions for the %check_derivatives_for_naninf
     * optional element.
     *
     * Indicates whether it is desired to check for Nan/Inf in derivative
     * matrices [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Check_derivatives_for_naninf Check_derivatives_for_naninfType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Check_derivatives_for_naninfType > Check_derivatives_for_naninfOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Check_derivatives_for_naninfType, char > Check_derivatives_for_naninfTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Check_derivatives_for_naninfOptional&
    getCheck_derivatives_for_naninf () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Check_derivatives_for_naninfOptional&
    getCheck_derivatives_for_naninf ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCheck_derivatives_for_naninf (const Check_derivatives_for_naninfType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCheck_derivatives_for_naninf (const Check_derivatives_for_naninfOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCheck_derivatives_for_naninf (::std::auto_ptr< Check_derivatives_for_naninfType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Check_derivatives_for_naninfType&
    getCheck_derivatives_for_naninfDefaultValue ();

    //@}

    /**
     * @name fixed_variable_treatment
     *
     * @brief Accessor and modifier functions for the %fixed_variable_treatment
     * optional element.
     *
     * Determines how fixed variables should be handled
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Fixed_variable_treatment Fixed_variable_treatmentType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Fixed_variable_treatmentType > Fixed_variable_treatmentOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Fixed_variable_treatmentType, char > Fixed_variable_treatmentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Fixed_variable_treatmentOptional&
    getFixed_variable_treatment () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Fixed_variable_treatmentOptional&
    getFixed_variable_treatment ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFixed_variable_treatment (const Fixed_variable_treatmentType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFixed_variable_treatment (const Fixed_variable_treatmentOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFixed_variable_treatment (::std::auto_ptr< Fixed_variable_treatmentType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Fixed_variable_treatmentType&
    getFixed_variable_treatmentDefaultValue ();

    //@}

    /**
     * @name jac_c_constant
     *
     * @brief Accessor and modifier functions for the %jac_c_constant
     * optional element.
     *
     * Indicates whether all equality constraints are linear [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Jac_c_constant Jac_c_constantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Jac_c_constantType > Jac_c_constantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Jac_c_constantType, char > Jac_c_constantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Jac_c_constantOptional&
    getJac_c_constant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Jac_c_constantOptional&
    getJac_c_constant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJac_c_constant (const Jac_c_constantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setJac_c_constant (const Jac_c_constantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setJac_c_constant (::std::auto_ptr< Jac_c_constantType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Jac_c_constantType&
    getJac_c_constantDefaultValue ();

    //@}

    /**
     * @name jac_d_constant
     *
     * @brief Accessor and modifier functions for the %jac_d_constant
     * optional element.
     *
     * Indicates whether all inequality constraints are linear [no/yes]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Jac_d_constant Jac_d_constantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Jac_d_constantType > Jac_d_constantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Jac_d_constantType, char > Jac_d_constantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Jac_d_constantOptional&
    getJac_d_constant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Jac_d_constantOptional&
    getJac_d_constant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJac_d_constant (const Jac_d_constantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setJac_d_constant (const Jac_d_constantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setJac_d_constant (::std::auto_ptr< Jac_d_constantType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Jac_d_constantType&
    getJac_d_constantDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTNLPComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTNLPComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTNLPComplexType (const IPOPTNLPComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTNLPComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTNLPComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Bound_relax_factorOptional bound_relax_factor_;
    Honor_original_boundsOptional honor_original_bounds_;
    static const Honor_original_boundsType honor_original_bounds_default_value_;
    Check_derivatives_for_naninfOptional check_derivatives_for_naninf_;
    static const Check_derivatives_for_naninfType check_derivatives_for_naninf_default_value_;
    Fixed_variable_treatmentOptional fixed_variable_treatment_;
    static const Fixed_variable_treatmentType fixed_variable_treatment_default_value_;
    Jac_c_constantOptional jac_c_constant_;
    static const Jac_c_constantType jac_c_constant_default_value_;
    Jac_d_constantOptional jac_d_constant_;
    static const Jac_d_constantType jac_d_constant_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTLinearSolverComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTLinearSolverComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name linear_solver
     *
     * @brief Accessor and modifier functions for the %linear_solver
     * optional element.
     *
     * Linear solver used for step computations
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Linear_solver Linear_solverType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Linear_solverType > Linear_solverOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Linear_solverType, char > Linear_solverTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Linear_solverOptional&
    getLinear_solver () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Linear_solverOptional&
    getLinear_solver ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLinear_solver (const Linear_solverType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLinear_solver (const Linear_solverOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLinear_solver (::std::auto_ptr< Linear_solverType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Linear_solverType&
    getLinear_solverDefaultValue ();

    //@}

    /**
     * @name linear_system_scaling
     *
     * @brief Accessor and modifier functions for the %linear_system_scaling
     * optional element.
     *
     * Method for scaling the linear system. 
     * Determines the method used to compute symmetric scaling factors for
     * the augmented system (see also the "linear_scaling_on_demand" option).
     * This scaling is independent of the NLP problem scaling. By default,
     * MC19 is only used if MA27 or MA57 are selected as linear solvers. This
     * value is only available if Ipopt has been compiled with MC19. The
     * default value for this string option is "mc19".
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Linear_system_scaling Linear_system_scalingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Linear_system_scalingType > Linear_system_scalingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Linear_system_scalingType, char > Linear_system_scalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Linear_system_scalingOptional&
    getLinear_system_scaling () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Linear_system_scalingOptional&
    getLinear_system_scaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLinear_system_scaling (const Linear_system_scalingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLinear_system_scaling (const Linear_system_scalingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLinear_system_scaling (::std::auto_ptr< Linear_system_scalingType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Linear_system_scalingType&
    getLinear_system_scalingDefaultValue ();

    //@}

    /**
     * @name linear_scaling_on_demand
     *
     * @brief Accessor and modifier functions for the %linear_scaling_on_demand
     * optional element.
     *
     * Flag indicating that linear scaling is only done if it seems required.
     * 
     * This option is only important if a linear scaling method (e.g., mc19)
     * is used. If you choose "no", then the scaling factors are computed for
     * every linear system from the start. This can be quite expensive.
     * Choosing "yes" means that the algorithm will start the scaling method
     * only when the solutions to the linear system seem not good, and then
     * use it until the end. The default value for this string option is
     * "yes".
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Linear_scaling_on_demand Linear_scaling_on_demandType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Linear_scaling_on_demandType > Linear_scaling_on_demandOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Linear_scaling_on_demandType, char > Linear_scaling_on_demandTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Linear_scaling_on_demandOptional&
    getLinear_scaling_on_demand () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Linear_scaling_on_demandOptional&
    getLinear_scaling_on_demand ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLinear_scaling_on_demand (const Linear_scaling_on_demandType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLinear_scaling_on_demand (const Linear_scaling_on_demandOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLinear_scaling_on_demand (::std::auto_ptr< Linear_scaling_on_demandType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Linear_scaling_on_demandType&
    getLinear_scaling_on_demandDefaultValue ();

    //@}

    /**
     * @name min_refinement_steps
     *
     * @brief Accessor and modifier functions for the %min_refinement_steps
     * optional element.
     *
     * Minimum number of iterative refinement steps per linear system solve. 
     * Iterative refinement (on the full unsymmetric system) is performed for
     * each right hand side. This option determines the minimum number of
     * iterative refinements (i.e. at least "min_refinement_steps" iterative
     * refinement steps are enforced per right hand side.) The valid range
     * for this integer option is  [0,+inf] and its default value is 10.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Min_refinement_stepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Min_refinement_stepsType > Min_refinement_stepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Min_refinement_stepsType, char > Min_refinement_stepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Min_refinement_stepsOptional&
    getMin_refinement_steps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Min_refinement_stepsOptional&
    getMin_refinement_steps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMin_refinement_steps (const Min_refinement_stepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMin_refinement_steps (const Min_refinement_stepsOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Min_refinement_stepsType
    getMin_refinement_stepsDefaultValue ();

    //@}

    /**
     * @name max_refinement_steps
     *
     * @brief Accessor and modifier functions for the %max_refinement_steps
     * optional element.
     *
     * Maximum number of iterative refinement steps per linear system solve. 
     * Iterative refinement (on the full unsymmetric system) is performed for
     * each right hand side. This option determines the maximum number of
     * iterative refinements (i.e. at least "min_refinement_steps" iterative
     * refinement steps are enforced per right hand side.) The valid range
     * for this integer option is  [0,+inf] and its default value is 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Max_refinement_stepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_refinement_stepsType > Max_refinement_stepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_refinement_stepsType, char > Max_refinement_stepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_refinement_stepsOptional&
    getMax_refinement_steps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_refinement_stepsOptional&
    getMax_refinement_steps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_refinement_steps (const Max_refinement_stepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_refinement_steps (const Max_refinement_stepsOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Max_refinement_stepsType
    getMax_refinement_stepsDefaultValue ();

    //@}

    /**
     * @name ma27
     *
     * @brief Accessor and modifier functions for the %ma27
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MA27ComplexType Ma27Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma27Type > Ma27Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma27Type, char > Ma27Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma27Optional&
    getMa27 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma27Optional&
    getMa27 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa27 (const Ma27Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa27 (const Ma27Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa27 (::std::auto_ptr< Ma27Type > p);

    //@}

    /**
     * @name ma57
     *
     * @brief Accessor and modifier functions for the %ma57
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MA57ComplexType Ma57Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57Type > Ma57Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57Type, char > Ma57Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57Optional&
    getMa57 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57Optional&
    getMa57 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57 (const Ma57Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57 (const Ma57Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa57 (::std::auto_ptr< Ma57Type > p);

    //@}

    /**
     * @name ma77
     *
     * @brief Accessor and modifier functions for the %ma77
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MA77ComplexType Ma77Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77Type > Ma77Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77Type, char > Ma77Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77Optional&
    getMa77 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77Optional&
    getMa77 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77 (const Ma77Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77 (const Ma77Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa77 (::std::auto_ptr< Ma77Type > p);

    //@}

    /**
     * @name ma86
     *
     * @brief Accessor and modifier functions for the %ma86
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MA86ComplexType Ma86Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86Type > Ma86Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86Type, char > Ma86Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86Optional&
    getMa86 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86Optional&
    getMa86 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86 (const Ma86Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86 (const Ma86Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa86 (::std::auto_ptr< Ma86Type > p);

    //@}

    /**
     * @name ma97
     *
     * @brief Accessor and modifier functions for the %ma97
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MA97ComplexType Ma97Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97Type > Ma97Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97Type, char > Ma97Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97Optional&
    getMa97 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97Optional&
    getMa97 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97 (const Ma97Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97 (const Ma97Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97 (::std::auto_ptr< Ma97Type > p);

    //@}

    /**
     * @name mumps
     *
     * @brief Accessor and modifier functions for the %mumps
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MUMPSComplexType MumpsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MumpsType > MumpsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MumpsType, char > MumpsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MumpsOptional&
    getMumps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MumpsOptional&
    getMumps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps (const MumpsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps (const MumpsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMumps (::std::auto_ptr< MumpsType > p);

    //@}

    /**
     * @name pardiso
     *
     * @brief Accessor and modifier functions for the %pardiso
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PardisoComplexType PardisoType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PardisoType > PardisoOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PardisoType, char > PardisoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PardisoOptional&
    getPardiso () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PardisoOptional&
    getPardiso ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPardiso (const PardisoType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPardiso (const PardisoOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPardiso (::std::auto_ptr< PardisoType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTLinearSolverComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTLinearSolverComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTLinearSolverComplexType (const IPOPTLinearSolverComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTLinearSolverComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTLinearSolverComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Linear_solverOptional linear_solver_;
    static const Linear_solverType linear_solver_default_value_;
    Linear_system_scalingOptional linear_system_scaling_;
    static const Linear_system_scalingType linear_system_scaling_default_value_;
    Linear_scaling_on_demandOptional linear_scaling_on_demand_;
    static const Linear_scaling_on_demandType linear_scaling_on_demand_default_value_;
    Min_refinement_stepsOptional min_refinement_steps_;
    Max_refinement_stepsOptional max_refinement_steps_;
    Ma27Optional ma27_;
    Ma57Optional ma57_;
    Ma77Optional ma77_;
    Ma86Optional ma86_;
    Ma97Optional ma97_;
    MumpsOptional mumps_;
    PardisoOptional pardiso_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MA27ComplexType schema type.
   *
   * @nosubgrouping
   */
  class MA27ComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ma27_pivtol
     *
     * @brief Accessor and modifier functions for the %ma27_pivtol
     * optional element.
     *
     * Pivot tolerance for the linear solver MA27. 
     * A smaller number pivots for sparsity, a larger number pivots for
     * stability. This option is only available if Ipopt has been compiled
     * with MA27. The valid range for this real option is [0,1] and its
     * default value is  1e-8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma27_pivtolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma27_pivtolType > Ma27_pivtolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma27_pivtolType, char, ::xsd::cxx::tree::schema_type::double_ > Ma27_pivtolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma27_pivtolOptional&
    getMa27_pivtol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma27_pivtolOptional&
    getMa27_pivtol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa27_pivtol (const Ma27_pivtolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa27_pivtol (const Ma27_pivtolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma27_pivtolType
    getMa27_pivtolDefaultValue ();

    //@}

    /**
     * @name ma27_pivtolmax
     *
     * @brief Accessor and modifier functions for the %ma27_pivtolmax
     * optional element.
     *
     * Maximum pivot tolerance for the linear solver MA27. 
     * Ipopt may increase pivtol as high as ma27_pivtolmax to get a more
     * accurate solution to the linear system. This option is only available
     * if Ipopt has been compiled with MA27. The valid range for this real
     * option is  [0,1] and its default value is 0.0001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma27_pivtolmaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma27_pivtolmaxType > Ma27_pivtolmaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma27_pivtolmaxType, char, ::xsd::cxx::tree::schema_type::double_ > Ma27_pivtolmaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma27_pivtolmaxOptional&
    getMa27_pivtolmax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma27_pivtolmaxOptional&
    getMa27_pivtolmax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa27_pivtolmax (const Ma27_pivtolmaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa27_pivtolmax (const Ma27_pivtolmaxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma27_pivtolmaxType
    getMa27_pivtolmaxDefaultValue ();

    //@}

    /**
     * @name ma27_liw_init_factor
     *
     * @brief Accessor and modifier functions for the %ma27_liw_init_factor
     * optional element.
     *
     * Integer workspace memory for MA27. 
     * The initial integer workspace memory = liw_init_factor * memory
     * required by unfactored system. Ipopt will increase the workspace size
     * by meminc_factor if required. This option is only available if Ipopt
     * has been compiled with MA27. The valid range for this real option is
     * [1, inf] and its default value is 5.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma27_liw_init_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma27_liw_init_factorType > Ma27_liw_init_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma27_liw_init_factorType, char, ::xsd::cxx::tree::schema_type::double_ > Ma27_liw_init_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma27_liw_init_factorOptional&
    getMa27_liw_init_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma27_liw_init_factorOptional&
    getMa27_liw_init_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa27_liw_init_factor (const Ma27_liw_init_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa27_liw_init_factor (const Ma27_liw_init_factorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma27_liw_init_factorType
    getMa27_liw_init_factorDefaultValue ();

    //@}

    /**
     * @name ma27_la_init_factor
     *
     * @brief Accessor and modifier functions for the %ma27_la_init_factor
     * optional element.
     *
     * Real workspace memory for MA27. 
     * The initial real workspace memory = la_init_factor * memory required
     * by unfactored system. Ipopt will increase the workspace size by
     * meminc_factor if required. This option is only available if Ipopt has
     * been compiled with MA27. The valid range for this real option is  [1,
     * inf] and its default value is 5.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma27_la_init_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma27_la_init_factorType > Ma27_la_init_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma27_la_init_factorType, char, ::xsd::cxx::tree::schema_type::double_ > Ma27_la_init_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma27_la_init_factorOptional&
    getMa27_la_init_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma27_la_init_factorOptional&
    getMa27_la_init_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa27_la_init_factor (const Ma27_la_init_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa27_la_init_factor (const Ma27_la_init_factorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma27_la_init_factorType
    getMa27_la_init_factorDefaultValue ();

    //@}

    /**
     * @name ma27_meminc_factor
     *
     * @brief Accessor and modifier functions for the %ma27_meminc_factor
     * optional element.
     *
     * Increment factor for workspace size for MA27. 
     * If the integer or real workspace is not large enough, Ipopt will
     * increase its size by this factor. This option is only available if
     * Ipopt has been compiled with MA27. The valid range for this real
     * option is [1, inf] and its default value is 2.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma27_meminc_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma27_meminc_factorType > Ma27_meminc_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma27_meminc_factorType, char, ::xsd::cxx::tree::schema_type::double_ > Ma27_meminc_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma27_meminc_factorOptional&
    getMa27_meminc_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma27_meminc_factorOptional&
    getMa27_meminc_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa27_meminc_factor (const Ma27_meminc_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa27_meminc_factor (const Ma27_meminc_factorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma27_meminc_factorType
    getMa27_meminc_factorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MA27ComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MA27ComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MA27ComplexType (const MA27ComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MA27ComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MA27ComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Ma27_pivtolOptional ma27_pivtol_;
    Ma27_pivtolmaxOptional ma27_pivtolmax_;
    Ma27_liw_init_factorOptional ma27_liw_init_factor_;
    Ma27_la_init_factorOptional ma27_la_init_factor_;
    Ma27_meminc_factorOptional ma27_meminc_factor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MA57ComplexType schema type.
   *
   * @nosubgrouping
   */
  class MA57ComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ma57_pivtol
     *
     * @brief Accessor and modifier functions for the %ma57_pivtol
     * optional element.
     *
     * Pivot tolerance for the linear solver MA57. 
     * A smaller number pivots for sparsity, a larger number pivots for
     * stability. This option is only available if Ipopt has been compiled
     * with MA57. The valid range for this real option is [0,1] and its
     * default value is  1e-8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma57_pivtolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_pivtolType > Ma57_pivtolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_pivtolType, char, ::xsd::cxx::tree::schema_type::double_ > Ma57_pivtolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_pivtolOptional&
    getMa57_pivtol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_pivtolOptional&
    getMa57_pivtol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_pivtol (const Ma57_pivtolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_pivtol (const Ma57_pivtolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_pivtolType
    getMa57_pivtolDefaultValue ();

    //@}

    /**
     * @name ma57_pivtolmax
     *
     * @brief Accessor and modifier functions for the %ma57_pivtolmax
     * optional element.
     *
     * Maximum pivot tolerance for the linear solver MA57. 
     * Ipopt may increase pivtol as high as ma57_pivtolmax to get a more
     * accurate solution to the linear system. This option is only available
     * if Ipopt has been compiled with MA57. The valid range for this real
     * option is  [0,1] and its default value is 0.0001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma57_pivtolmaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_pivtolmaxType > Ma57_pivtolmaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_pivtolmaxType, char, ::xsd::cxx::tree::schema_type::double_ > Ma57_pivtolmaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_pivtolmaxOptional&
    getMa57_pivtolmax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_pivtolmaxOptional&
    getMa57_pivtolmax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_pivtolmax (const Ma57_pivtolmaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_pivtolmax (const Ma57_pivtolmaxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_pivtolmaxType
    getMa57_pivtolmaxDefaultValue ();

    //@}

    /**
     * @name ma57_pre_alloc
     *
     * @brief Accessor and modifier functions for the %ma57_pre_alloc
     * optional element.
     *
     * Safety factor for work space memory allocation for the linear solver
     * MA57. 
     * If 1 is chosen, the suggested amount of work space is used. However,
     * choosing a larger number might avoid reallocation if the suggest
     * values do not suffice. This option is only available if Ipopt has been
     * compiled with MA57. The valid range for this real option is  [1, inf] 
     * and its default value is 1.05.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma57_pre_allocType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_pre_allocType > Ma57_pre_allocOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_pre_allocType, char, ::xsd::cxx::tree::schema_type::double_ > Ma57_pre_allocTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_pre_allocOptional&
    getMa57_pre_alloc () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_pre_allocOptional&
    getMa57_pre_alloc ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_pre_alloc (const Ma57_pre_allocType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_pre_alloc (const Ma57_pre_allocOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_pre_allocType
    getMa57_pre_allocDefaultValue ();

    //@}

    /**
     * @name ma57_pivot_order
     *
     * @brief Accessor and modifier functions for the %ma57_pivot_order
     * optional element.
     *
     * Controls pivot order in MA57 
     * This is ICNTL(6) in MA57. The valid range for this integer option is
     * [0,5] and its default value is 5.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma57_pivot_orderType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_pivot_orderType > Ma57_pivot_orderOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_pivot_orderType, char > Ma57_pivot_orderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_pivot_orderOptional&
    getMa57_pivot_order () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_pivot_orderOptional&
    getMa57_pivot_order ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_pivot_order (const Ma57_pivot_orderType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_pivot_order (const Ma57_pivot_orderOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_pivot_orderType
    getMa57_pivot_orderDefaultValue ();

    //@}

    /**
     * @name ma57_automatic_scaling
     *
     * @brief Accessor and modifier functions for the %ma57_automatic_scaling
     * optional element.
     *
     * Controls MA57 automatic scaling 
     * This option controls the internal scaling option of MA57. For higher
     * reliability of the MA57 solver, you may want to set this option to
     * yes. This is ICNTL(15) in MA57. The default value for this string
     * option is "no". 
     * Possible values:
     * no: Do not scale the linear system matrix
     * yes: Scale the linear system matrix
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma57_automatic_scaling Ma57_automatic_scalingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_automatic_scalingType > Ma57_automatic_scalingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_automatic_scalingType, char > Ma57_automatic_scalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_automatic_scalingOptional&
    getMa57_automatic_scaling () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_automatic_scalingOptional&
    getMa57_automatic_scaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_automatic_scaling (const Ma57_automatic_scalingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_automatic_scaling (const Ma57_automatic_scalingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa57_automatic_scaling (::std::auto_ptr< Ma57_automatic_scalingType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma57_automatic_scalingType&
    getMa57_automatic_scalingDefaultValue ();

    //@}

    /**
     * @name ma57_block_size
     *
     * @brief Accessor and modifier functions for the %ma57_block_size
     * optional element.
     *
     * Controls block size used by Level 3 BLAS in MA57BD 
     * This is ICNTL(11) in MA57. The valid range for this integer option is
     * [1, inf] and its default value is 16. .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma57_block_sizeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_block_sizeType > Ma57_block_sizeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_block_sizeType, char > Ma57_block_sizeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_block_sizeOptional&
    getMa57_block_size () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_block_sizeOptional&
    getMa57_block_size ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_block_size (const Ma57_block_sizeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_block_size (const Ma57_block_sizeOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_block_sizeType
    getMa57_block_sizeDefaultValue ();

    //@}

    /**
     * @name ma57_node_amalgamation
     *
     * @brief Accessor and modifier functions for the %ma57_node_amalgamation
     * optional element.
     *
     * Node amalgamation parameter 
     * This is ICNTL(12) in MA57. The valid range for this integer option is 
     * [1, inf] and its default value is 16.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma57_node_amalgamationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_node_amalgamationType > Ma57_node_amalgamationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_node_amalgamationType, char > Ma57_node_amalgamationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_node_amalgamationOptional&
    getMa57_node_amalgamation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_node_amalgamationOptional&
    getMa57_node_amalgamation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_node_amalgamation (const Ma57_node_amalgamationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_node_amalgamation (const Ma57_node_amalgamationOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_node_amalgamationType
    getMa57_node_amalgamationDefaultValue ();

    //@}

    /**
     * @name ma57_small_pivot_flag
     *
     * @brief Accessor and modifier functions for the %ma57_small_pivot_flag
     * optional element.
     *
     * If set to 1, then when small entries defined by CNTL(2) are detected
     * they are removed and the corresponding pivots placed at the end of the
     * factorization. This can be particularly efficient if the matrix is
     * highly rank deficient. 
     * This is ICNTL(16) in MA57. The valid range for this integer option is 
     * [0,1] and its default value is 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma57_small_pivot_flagType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma57_small_pivot_flagType > Ma57_small_pivot_flagOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma57_small_pivot_flagType, char > Ma57_small_pivot_flagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma57_small_pivot_flagOptional&
    getMa57_small_pivot_flag () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma57_small_pivot_flagOptional&
    getMa57_small_pivot_flag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa57_small_pivot_flag (const Ma57_small_pivot_flagType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa57_small_pivot_flag (const Ma57_small_pivot_flagOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma57_small_pivot_flagType
    getMa57_small_pivot_flagDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MA57ComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MA57ComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MA57ComplexType (const MA57ComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MA57ComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MA57ComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Ma57_pivtolOptional ma57_pivtol_;
    Ma57_pivtolmaxOptional ma57_pivtolmax_;
    Ma57_pre_allocOptional ma57_pre_alloc_;
    Ma57_pivot_orderOptional ma57_pivot_order_;
    Ma57_automatic_scalingOptional ma57_automatic_scaling_;
    static const Ma57_automatic_scalingType ma57_automatic_scaling_default_value_;
    Ma57_block_sizeOptional ma57_block_size_;
    Ma57_node_amalgamationOptional ma57_node_amalgamation_;
    Ma57_small_pivot_flagOptional ma57_small_pivot_flag_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MA86ComplexType schema type.
   *
   * @nosubgrouping
   */
  class MA86ComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ma86_print_level
     *
     * @brief Accessor and modifier functions for the %ma86_print_level
     * optional element.
     *
     * Debug printing level for the linear solver ma86 
     * The valid range for this integer option is  [-inf, +inf] and its
     * default value is -1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma86_print_levelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_print_levelType > Ma86_print_levelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_print_levelType, char > Ma86_print_levelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_print_levelOptional&
    getMa86_print_level () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_print_levelOptional&
    getMa86_print_level ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_print_level (const Ma86_print_levelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_print_level (const Ma86_print_levelOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma86_print_levelType
    getMa86_print_levelDefaultValue ();

    //@}

    /**
     * @name ma86_nemin
     *
     * @brief Accessor and modifier functions for the %ma86_nemin
     * optional element.
     *
     * Node Amalgamation parameter 
     * Two nodes in elimination tree are merged if result has fewer than
     * ma86_nemin variables. The valid range for this integer option is [1,
     * inf] and its default value is 32.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma86_neminType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_neminType > Ma86_neminOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_neminType, char > Ma86_neminTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_neminOptional&
    getMa86_nemin () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_neminOptional&
    getMa86_nemin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_nemin (const Ma86_neminType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_nemin (const Ma86_neminOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma86_neminType
    getMa86_neminDefaultValue ();

    //@}

    /**
     * @name ma86_order
     *
     * @brief Accessor and modifier functions for the %ma86_order
     * optional element.
     *
     * CControls type of ordering used by HSL_MA86 
     * This option controls ordering for the solver HSL_MA86. The default
     * value for this string option is "auto". 
     * Possible values:
     * auto: Try both AMD and MeTiS, pick best
     * amd: Use the HSL_MC68 approximate minimum degree algorithm
     * metis: Use the MeTiS nested dissection algorithm (if available)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma86_order Ma86_orderType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_orderType > Ma86_orderOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_orderType, char > Ma86_orderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_orderOptional&
    getMa86_order () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_orderOptional&
    getMa86_order ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_order (const Ma86_orderType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_order (const Ma86_orderOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa86_order (::std::auto_ptr< Ma86_orderType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma86_orderType&
    getMa86_orderDefaultValue ();

    //@}

    /**
     * @name ma86_scaling
     *
     * @brief Accessor and modifier functions for the %ma86_scaling
     * optional element.
     *
     * Controls scaling of matrix 
     * This option controls scaling for the solver HSL_MA86. The default
     * value for this string option is "mc64". 
     * Possible values:
     * none: Do not scale the linear system matrix
     * mc64: Scale linear system matrix using MC64
     * mc77: Scale linear system matrix using MC77 [1,3,0]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma86_scaling Ma86_scalingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_scalingType > Ma86_scalingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_scalingType, char > Ma86_scalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_scalingOptional&
    getMa86_scaling () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_scalingOptional&
    getMa86_scaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_scaling (const Ma86_scalingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_scaling (const Ma86_scalingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa86_scaling (::std::auto_ptr< Ma86_scalingType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma86_scalingType&
    getMa86_scalingDefaultValue ();

    //@}

    /**
     * @name ma86_small
     *
     * @brief Accessor and modifier functions for the %ma86_small
     * optional element.
     *
     * Zero Pivot Threshold 
     * Any pivot less than ma86_small is treated as zero. The valid range for
     * this real option is  [0, inf] and its default value is 1e-20.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma86_smallType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_smallType > Ma86_smallOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_smallType, char, ::xsd::cxx::tree::schema_type::double_ > Ma86_smallTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_smallOptional&
    getMa86_small () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_smallOptional&
    getMa86_small ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_small (const Ma86_smallType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_small (const Ma86_smallOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma86_smallType
    getMa86_smallDefaultValue ();

    //@}

    /**
     * @name ma86_static
     *
     * @brief Accessor and modifier functions for the %ma86_static
     * optional element.
     *
     * Static Pivoting Threshold 
     * See ma86 documentation. Either ma86_static=0.0 or
     * ma86_static>ma86_small. ma86_static=0.0 disables static pivoting. The
     * valid range for this real option is [0, inf] and its default value is
     * 0 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma86_staticType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_staticType > Ma86_staticOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_staticType, char, ::xsd::cxx::tree::schema_type::double_ > Ma86_staticTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_staticOptional&
    getMa86_static () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_staticOptional&
    getMa86_static ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_static (const Ma86_staticType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_static (const Ma86_staticOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma86_staticType
    getMa86_staticDefaultValue ();

    //@}

    /**
     * @name ma86_u
     *
     * @brief Accessor and modifier functions for the %ma86_u
     * optional element.
     *
     * Pivoting Threshold 
     * See ma86 documentation. The valid range for this real option is  [0,
     * 0.5] and its default value is 1e-8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma86_uType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_uType > Ma86_uOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_uType, char, ::xsd::cxx::tree::schema_type::double_ > Ma86_uTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_uOptional&
    getMa86_u () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_uOptional&
    getMa86_u ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_u (const Ma86_uType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_u (const Ma86_uOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma86_uType
    getMa86_uDefaultValue ();

    //@}

    /**
     * @name ma86_umax
     *
     * @brief Accessor and modifier functions for the %ma86_umax
     * optional element.
     *
     * Maximum Pivoting Threshold 
     * Maximum value to which u will be increased to improve quality. The
     * valid range for this real option is  [0, 0.5] and its default value is
     * 0.0001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma86_umaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma86_umaxType > Ma86_umaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma86_umaxType, char, ::xsd::cxx::tree::schema_type::double_ > Ma86_umaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma86_umaxOptional&
    getMa86_umax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma86_umaxOptional&
    getMa86_umax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa86_umax (const Ma86_umaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa86_umax (const Ma86_umaxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma86_umaxType
    getMa86_umaxDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MA86ComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MA86ComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MA86ComplexType (const MA86ComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MA86ComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MA86ComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Ma86_print_levelOptional ma86_print_level_;
    Ma86_neminOptional ma86_nemin_;
    Ma86_orderOptional ma86_order_;
    static const Ma86_orderType ma86_order_default_value_;
    Ma86_scalingOptional ma86_scaling_;
    static const Ma86_scalingType ma86_scaling_default_value_;
    Ma86_smallOptional ma86_small_;
    Ma86_staticOptional ma86_static_;
    Ma86_uOptional ma86_u_;
    Ma86_umaxOptional ma86_umax_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MA77ComplexType schema type.
   *
   * @nosubgrouping
   */
  class MA77ComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ma77_print_level
     *
     * @brief Accessor and modifier functions for the %ma77_print_level
     * optional element.
     *
     * Debug printing level for the linear solver MA77 
     * The valid range for this integer option is  [-inf, +inf] and its
     * default value is -1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma77_print_levelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_print_levelType > Ma77_print_levelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_print_levelType, char > Ma77_print_levelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_print_levelOptional&
    getMa77_print_level () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_print_levelOptional&
    getMa77_print_level ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_print_level (const Ma77_print_levelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_print_level (const Ma77_print_levelOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_print_levelType
    getMa77_print_levelDefaultValue ();

    //@}

    /**
     * @name ma77_buffer_lpage
     *
     * @brief Accessor and modifier functions for the %ma77_buffer_lpage
     * optional element.
     *
     * Number of scalars per MA77 buffer page 
     * Number of scalars per an in-core buffer in the out-of-core solver
     * MA77. Must be at most ma77_file_size. The valid range for this integer
     * option is [1, inf] and its default value is 4096.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma77_buffer_lpageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_buffer_lpageType > Ma77_buffer_lpageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_buffer_lpageType, char > Ma77_buffer_lpageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_buffer_lpageOptional&
    getMa77_buffer_lpage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_buffer_lpageOptional&
    getMa77_buffer_lpage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_buffer_lpage (const Ma77_buffer_lpageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_buffer_lpage (const Ma77_buffer_lpageOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_buffer_lpageType
    getMa77_buffer_lpageDefaultValue ();

    //@}

    /**
     * @name ma77_buffer_npage
     *
     * @brief Accessor and modifier functions for the %ma77_buffer_npage
     * optional element.
     *
     * Number of pages that make up MA77 buffer 
     * Number of pages of size buffer_lpage that exist in-core for the
     * out-of-core solver MA77. The valid range for this integer option is
     * [1, inf] and its default value is 1600.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma77_buffer_npageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_buffer_npageType > Ma77_buffer_npageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_buffer_npageType, char > Ma77_buffer_npageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_buffer_npageOptional&
    getMa77_buffer_npage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_buffer_npageOptional&
    getMa77_buffer_npage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_buffer_npage (const Ma77_buffer_npageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_buffer_npage (const Ma77_buffer_npageOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_buffer_npageType
    getMa77_buffer_npageDefaultValue ();

    //@}

    /**
     * @name ma77_file_size
     *
     * @brief Accessor and modifier functions for the %ma77_file_size
     * optional element.
     *
     * Target size of each temporary file for MA77, scalars per type 
     * MA77 uses many temporary files, this option controls the size of each
     * one. It is measured in the number of entries (int or double), NOT
     * bytes. The valid range for this integer option is [1, inf] and its
     * default value is 2097152.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma77_file_sizeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_file_sizeType > Ma77_file_sizeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_file_sizeType, char > Ma77_file_sizeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_file_sizeOptional&
    getMa77_file_size () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_file_sizeOptional&
    getMa77_file_size ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_file_size (const Ma77_file_sizeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_file_size (const Ma77_file_sizeOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_file_sizeType
    getMa77_file_sizeDefaultValue ();

    //@}

    /**
     * @name ma77_maxstore
     *
     * @brief Accessor and modifier functions for the %ma77_maxstore
     * optional element.
     *
     * Maximum storage size for MA77 in-core mode 
     * If greater than zero, the maximum size of factors stored in core
     * before out-of-core mode is invoked. The valid range for this integer
     * option is [0, inf] and its default value is 0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma77_maxstoreType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_maxstoreType > Ma77_maxstoreOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_maxstoreType, char > Ma77_maxstoreTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_maxstoreOptional&
    getMa77_maxstore () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_maxstoreOptional&
    getMa77_maxstore ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_maxstore (const Ma77_maxstoreType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_maxstore (const Ma77_maxstoreOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_maxstoreType
    getMa77_maxstoreDefaultValue ();

    //@}

    /**
     * @name ma77_nemin
     *
     * @brief Accessor and modifier functions for the %ma77_nemin
     * optional element.
     *
     * Node Amalgamation parameter 
     * Two nodes in elimination tree are merged if result has fewer than
     * ma77_nemin variables. The valid range for this integer option is [1,
     * inf] and its default value is 8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma77_neminType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_neminType > Ma77_neminOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_neminType, char > Ma77_neminTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_neminOptional&
    getMa77_nemin () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_neminOptional&
    getMa77_nemin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_nemin (const Ma77_neminType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_nemin (const Ma77_neminOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_neminType
    getMa77_neminDefaultValue ();

    //@}

    /**
     * @name ma77_order
     *
     * @brief Accessor and modifier functions for the %ma77_order
     * optional element.
     *
     * Controls type of ordering used by HSL_MA77 
     * This option controls ordering for the solver HSL_MA77. The default
     * value for this string option is "metis". 
     * Possible values:
     * amd: Use the HSL_MC68 approximate minimum degree algorithm
     * metis: Use the MeTiS nested dissection algorithm (if available)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma77_order Ma77_orderType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_orderType > Ma77_orderOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_orderType, char > Ma77_orderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_orderOptional&
    getMa77_order () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_orderOptional&
    getMa77_order ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_order (const Ma77_orderType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_order (const Ma77_orderOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa77_order (::std::auto_ptr< Ma77_orderType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma77_orderType&
    getMa77_orderDefaultValue ();

    //@}

    /**
     * @name ma77_small
     *
     * @brief Accessor and modifier functions for the %ma77_small
     * optional element.
     *
     * Zero Pivot Threshold 
     * Any pivot less than ma77_small is treated as zero. The valid range for
     * this real option is  [0, inf] and its default value is 1e-20.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma77_smallType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_smallType > Ma77_smallOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_smallType, char, ::xsd::cxx::tree::schema_type::double_ > Ma77_smallTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_smallOptional&
    getMa77_small () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_smallOptional&
    getMa77_small ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_small (const Ma77_smallType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_small (const Ma77_smallOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_smallType
    getMa77_smallDefaultValue ();

    //@}

    /**
     * @name ma77_static
     *
     * @brief Accessor and modifier functions for the %ma77_static
     * optional element.
     *
     * Static Pivoting Threshold 
     * See MA77 documentation. Either ma77_static=0.0 or
     * ma77_static>ma77_small. ma77_static=0.0 disables static pivoting. The
     * valid range for this real option is [0, inf] and its default value is
     * 0 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma77_staticType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_staticType > Ma77_staticOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_staticType, char, ::xsd::cxx::tree::schema_type::double_ > Ma77_staticTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_staticOptional&
    getMa77_static () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_staticOptional&
    getMa77_static ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_static (const Ma77_staticType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_static (const Ma77_staticOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_staticType
    getMa77_staticDefaultValue ();

    //@}

    /**
     * @name ma77_u
     *
     * @brief Accessor and modifier functions for the %ma77_u
     * optional element.
     *
     * Pivoting Threshold 
     * See MA77 documentation. The valid range for this real option is  [0,
     * 0.5] and its default value is 1e-8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma77_uType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_uType > Ma77_uOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_uType, char, ::xsd::cxx::tree::schema_type::double_ > Ma77_uTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_uOptional&
    getMa77_u () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_uOptional&
    getMa77_u ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_u (const Ma77_uType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_u (const Ma77_uOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_uType
    getMa77_uDefaultValue ();

    //@}

    /**
     * @name ma77_umax
     *
     * @brief Accessor and modifier functions for the %ma77_umax
     * optional element.
     *
     * Maximum Pivoting Threshold 
     * Maximum value to which u will be increased to improve quality. The
     * valid range for this real option is  [0, 0.5]and its default value is
     * 0.0001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma77_umaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma77_umaxType > Ma77_umaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma77_umaxType, char, ::xsd::cxx::tree::schema_type::double_ > Ma77_umaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma77_umaxOptional&
    getMa77_umax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma77_umaxOptional&
    getMa77_umax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa77_umax (const Ma77_umaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa77_umax (const Ma77_umaxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma77_umaxType
    getMa77_umaxDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MA77ComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MA77ComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MA77ComplexType (const MA77ComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MA77ComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MA77ComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Ma77_print_levelOptional ma77_print_level_;
    Ma77_buffer_lpageOptional ma77_buffer_lpage_;
    Ma77_buffer_npageOptional ma77_buffer_npage_;
    Ma77_file_sizeOptional ma77_file_size_;
    Ma77_maxstoreOptional ma77_maxstore_;
    Ma77_neminOptional ma77_nemin_;
    Ma77_orderOptional ma77_order_;
    static const Ma77_orderType ma77_order_default_value_;
    Ma77_smallOptional ma77_small_;
    Ma77_staticOptional ma77_static_;
    Ma77_uOptional ma77_u_;
    Ma77_umaxOptional ma77_umax_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MA97ComplexType schema type.
   *
   * @nosubgrouping
   */
  class MA97ComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ma97_print_level
     *
     * @brief Accessor and modifier functions for the %ma97_print_level
     * optional element.
     *
     * Debug printing level for the linear solver MA97 
     * The valid range for this integer option is  [-inf, +inf] and its
     * default value is 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma97_print_levelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_print_levelType > Ma97_print_levelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_print_levelType, char > Ma97_print_levelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_print_levelOptional&
    getMa97_print_level () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_print_levelOptional&
    getMa97_print_level ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_print_level (const Ma97_print_levelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_print_level (const Ma97_print_levelOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma97_print_levelType
    getMa97_print_levelDefaultValue ();

    //@}

    /**
     * @name ma97_nemin
     *
     * @brief Accessor and modifier functions for the %ma97_nemin
     * optional element.
     *
     * Node Amalgamation parameter 
     * Two nodes in elimination tree are merged if result has fewer than
     * ma97_nemin variables. The valid range for this integer option is [1,
     * inf] and its default value is 8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Ma97_neminType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_neminType > Ma97_neminOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_neminType, char > Ma97_neminTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_neminOptional&
    getMa97_nemin () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_neminOptional&
    getMa97_nemin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_nemin (const Ma97_neminType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_nemin (const Ma97_neminOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma97_neminType
    getMa97_neminDefaultValue ();

    //@}

    /**
     * @name ma97_order
     *
     * @brief Accessor and modifier functions for the %ma97_order
     * optional element.
     *
     * Controls type of ordering used by HSL_MA97 
     * The default value for this string option is "auto". 
     * Possible values:
     * auto: Use HSL_MA97 heuristic to guess best of AMD and METIS
     * best: Try both AMD and MeTiS, pick best
     * amd: Use the HSL_MC68 approximate minimum degree algorithm
     * metis: Use the MeTiS nested dissection algorithm
     * matched-auto: Use the HSL_MC80 matching with heuristic choice of AMD
     * or METIS
     * matched-metis: Use the HSL_MC80 matching based ordering with METIS
     * matched-amd: Use the HSL_MC80 matching based ordering with AMD
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_order Ma97_orderType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_orderType > Ma97_orderOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_orderType, char > Ma97_orderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_orderOptional&
    getMa97_order () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_orderOptional&
    getMa97_order ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_order (const Ma97_orderType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_order (const Ma97_orderOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_order (::std::auto_ptr< Ma97_orderType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_orderType&
    getMa97_orderDefaultValue ();

    //@}

    /**
     * @name ma97_scaling
     *
     * @brief Accessor and modifier functions for the %ma97_scaling
     * optional element.
     *
     * Specifies strategy for scaling in HSL_MA97 linear solver 
     * The default value for this string option is "dynamic". 
     * Possible values:
     * none: Do not scale the linear system matrix
     * mc30: Scale all linear system matrices using MC30
     * mc64: Scale all linear system matrices using MC64
     * mc77: Scale all linear system matrices using MC77 [1,3,0]
     * dynamic: Dynamically select scaling according to rules specified by
     * ma97_scalingX and ma97_switchX options.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_scaling Ma97_scalingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_scalingType > Ma97_scalingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_scalingType, char > Ma97_scalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_scalingOptional&
    getMa97_scaling () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_scalingOptional&
    getMa97_scaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_scaling (const Ma97_scalingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_scaling (const Ma97_scalingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_scaling (::std::auto_ptr< Ma97_scalingType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_scalingType&
    getMa97_scalingDefaultValue ();

    //@}

    /**
     * @name ma97_scaling1
     *
     * @brief Accessor and modifier functions for the %ma97_scaling1
     * optional element.
     *
     * First scaling. 
     * If ma97_scaling=dynamic, this scaling is used according to the trigger
     * ma97_switch1. If ma97_switch2 is triggered it is disabled. The default
     * value for this string option is "mc64". 
     * Possible values:
     * none: No scaling
     * mc30: Scale linear system matrix using MC30
     * mc64: Scale linear system matrix using MC64
     * mc77: Scale linear system matrix using MC77 [1,3,0]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_scaling1 Ma97_scaling1Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_scaling1Type > Ma97_scaling1Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_scaling1Type, char > Ma97_scaling1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_scaling1Optional&
    getMa97_scaling1 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_scaling1Optional&
    getMa97_scaling1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_scaling1 (const Ma97_scaling1Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_scaling1 (const Ma97_scaling1Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_scaling1 (::std::auto_ptr< Ma97_scaling1Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_scaling1Type&
    getMa97_scaling1DefaultValue ();

    //@}

    /**
     * @name ma97_scaling2
     *
     * @brief Accessor and modifier functions for the %ma97_scaling2
     * optional element.
     *
     * Second scaling. 
     * If ma97_scaling=dynamic, this scaling is used according to the trigger
     * ma97_switch2. If ma97_switch3 is triggered it is disabled. The default
     * value for this string option is "mc64". 
     * Possible values:
     * none: No scaling
     * mc30: Scale linear system matrix using MC30
     * mc64: Scale linear system matrix using MC64
     * mc77: Scale linear system matrix using MC77 [1,3,0]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_scaling2 Ma97_scaling2Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_scaling2Type > Ma97_scaling2Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_scaling2Type, char > Ma97_scaling2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_scaling2Optional&
    getMa97_scaling2 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_scaling2Optional&
    getMa97_scaling2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_scaling2 (const Ma97_scaling2Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_scaling2 (const Ma97_scaling2Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_scaling2 (::std::auto_ptr< Ma97_scaling2Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_scaling2Type&
    getMa97_scaling2DefaultValue ();

    //@}

    /**
     * @name ma97_scaling3
     *
     * @brief Accessor and modifier functions for the %ma97_scaling3
     * optional element.
     *
     * Third scaling. 
     * If ma97_scaling=dynamic, this scaling is used according to the trigger
     * ma97_switch3. The default value for this string option is "mc64". 
     * Possible values:
     * none: No scaling
     * mc30: Scale linear system matrix using MC30
     * mc64: Scale linear system matrix using MC64
     * mc77: Scale linear system matrix using MC77 [1,3,0]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_scaling3 Ma97_scaling3Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_scaling3Type > Ma97_scaling3Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_scaling3Type, char > Ma97_scaling3Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_scaling3Optional&
    getMa97_scaling3 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_scaling3Optional&
    getMa97_scaling3 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_scaling3 (const Ma97_scaling3Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_scaling3 (const Ma97_scaling3Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_scaling3 (::std::auto_ptr< Ma97_scaling3Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_scaling3Type&
    getMa97_scaling3DefaultValue ();

    //@}

    /**
     * @name ma97_small
     *
     * @brief Accessor and modifier functions for the %ma97_small
     * optional element.
     *
     * Zero Pivot Threshold 
     * Any pivot less than ma77_small is treated as zero. The valid range for
     * this real option is  [0, inf] and its default value is 1e-20.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma97_smallType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_smallType > Ma97_smallOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_smallType, char, ::xsd::cxx::tree::schema_type::double_ > Ma97_smallTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_smallOptional&
    getMa97_small () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_smallOptional&
    getMa97_small ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_small (const Ma97_smallType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_small (const Ma97_smallOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma97_smallType
    getMa97_smallDefaultValue ();

    //@}

    /**
     * @name ma97_solve_blas3
     *
     * @brief Accessor and modifier functions for the %ma97_solve_blas3
     * optional element.
     *
     * Controls if blas2 or blas3 routines are used for solve 
     * The default value for this string option is "no". 
     * Possible values:
     * no: Use BLAS2 (faster, some implementations bit incompatible)
     * yes: Use BLAS3 (slower)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_solve_blas3 Ma97_solve_blas3Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_solve_blas3Type > Ma97_solve_blas3Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_solve_blas3Type, char > Ma97_solve_blas3Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_solve_blas3Optional&
    getMa97_solve_blas3 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_solve_blas3Optional&
    getMa97_solve_blas3 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_solve_blas3 (const Ma97_solve_blas3Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_solve_blas3 (const Ma97_solve_blas3Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_solve_blas3 (::std::auto_ptr< Ma97_solve_blas3Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_solve_blas3Type&
    getMa97_solve_blas3DefaultValue ();

    //@}

    /**
     * @name ma97_switch1
     *
     * @brief Accessor and modifier functions for the %ma97_switch1
     * optional element.
     *
     * First switch, determine when ma97_scaling1 is enabled. 
     * If ma97_scaling=dynamic, ma97_scaling1 is enabled according to this
     * condition. If ma97_switch2 occurs this option is henceforth ignored.
     * The default value for this string option is "od_hd_reuse". 
     * Possible values:
     * never: Scaling is never enabled.
     * at_start: Scaling to be used from the very start.
     * at_start_reuse: Scaling to be used on first iteration, then reused
     * thereafter.
     * on_demand: Scaling to be used after Ipopt request improved solution
     * (i.e. iterative refinement has failed).
     * on_demand_reuse: As on_demand, but reuse scaling from previous itr
     * high_delay: Scaling to be used after more than 0.05*n delays are
     * present
     * high_delay_reuse: Scaling to be used only when previous itr created
     * more that 0.05*n additional delays, otherwise reuse scaling from
     * previous itr
     * od_hd: Combination of on_demand and high_delay
     * od_hd_reuse: Combination of on_demand_reuse and high_delay_reuse
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_switch1 Ma97_switch1Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_switch1Type > Ma97_switch1Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_switch1Type, char > Ma97_switch1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_switch1Optional&
    getMa97_switch1 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_switch1Optional&
    getMa97_switch1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_switch1 (const Ma97_switch1Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_switch1 (const Ma97_switch1Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_switch1 (::std::auto_ptr< Ma97_switch1Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_switch1Type&
    getMa97_switch1DefaultValue ();

    //@}

    /**
     * @name ma97_switch2
     *
     * @brief Accessor and modifier functions for the %ma97_switch2
     * optional element.
     *
     * Second switch, determine when ma97_scaling2 is enabled. 
     * If ma97_scaling=dynamic, ma97_scaling2 is enabled according to this
     * condition. If ma97_switch3 occurs this option is henceforth ignored.
     * The default value for this string option is "never". 
     * Possible values:
     * never: Scaling is never enabled.
     * at_start: Scaling to be used from the very start.
     * at_start_reuse: Scaling to be used on first iteration, then reused
     * thereafter.
     * on_demand: Scaling to be used after Ipopt request improved solution
     * (i.e. iterative refinement has failed).
     * on_demand_reuse: As on_demand, but reuse scaling from previous itr
     * high_delay: Scaling to be used after more than 0.05*n delays are
     * present
     * high_delay_reuse: Scaling to be used only when previous itr created
     * more that 0.05*n additional delays, otherwise reuse scaling from
     * previous itr
     * od_hd: Combination of on_demand and high_delay
     * od_hd_reuse: Combination of on_demand_reuse and high_delay_reuse
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_switch2 Ma97_switch2Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_switch2Type > Ma97_switch2Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_switch2Type, char > Ma97_switch2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_switch2Optional&
    getMa97_switch2 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_switch2Optional&
    getMa97_switch2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_switch2 (const Ma97_switch2Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_switch2 (const Ma97_switch2Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_switch2 (::std::auto_ptr< Ma97_switch2Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_switch2Type&
    getMa97_switch2DefaultValue ();

    //@}

    /**
     * @name ma97_switch3
     *
     * @brief Accessor and modifier functions for the %ma97_switch3
     * optional element.
     *
     * Third switch, determine when ma97_scaling3 is enabled. 
     * If ma97_scaling=dynamic, ma97_scaling3 is enabled according to this
     * condition. The default value for this string option is "never". 
     * Possible values:
     * never: Scaling is never enabled.
     * at_start: Scaling to be used from the very start.
     * at_start_reuse: Scaling to be used on first iteration, then reused
     * thereafter.
     * on_demand: Scaling to be used after Ipopt request improved solution
     * (i.e. iterative refinement has failed).
     * on_demand_reuse: As on_demand, but reuse scaling from previous itr
     * high_delay: Scaling to be used after more than 0.05*n delays are
     * present
     * high_delay_reuse: Scaling to be used only when previous itr created
     * more that 0.05*n additional delays, otherwise reuse scaling from
     * previous itr
     * od_hd: Combination of on_demand and high_delay
     * od_hd_reuse: Combination of on_demand_reuse and high_delay_reuse
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Ma97_switch3 Ma97_switch3Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_switch3Type > Ma97_switch3Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_switch3Type, char > Ma97_switch3Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_switch3Optional&
    getMa97_switch3 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_switch3Optional&
    getMa97_switch3 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_switch3 (const Ma97_switch3Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_switch3 (const Ma97_switch3Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMa97_switch3 (::std::auto_ptr< Ma97_switch3Type > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Ma97_switch3Type&
    getMa97_switch3DefaultValue ();

    //@}

    /**
     * @name ma97_u
     *
     * @brief Accessor and modifier functions for the %ma97_u
     * optional element.
     *
     * Pivoting Threshold 
     * See MA97 documentation. The valid range for this real option is  [0,
     * 0.5] and its default value is  1e-8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma97_uType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_uType > Ma97_uOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_uType, char, ::xsd::cxx::tree::schema_type::double_ > Ma97_uTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_uOptional&
    getMa97_u () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_uOptional&
    getMa97_u ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_u (const Ma97_uType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_u (const Ma97_uOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma97_uType
    getMa97_uDefaultValue ();

    //@}

    /**
     * @name ma97_umax
     *
     * @brief Accessor and modifier functions for the %ma97_umax
     * optional element.
     *
     * Maximum Pivoting Threshold 
     * See MA97 documentation. The valid range for this real option is  [0,
     * 0.5] and its default value is 0.0001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Ma97_umaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Ma97_umaxType > Ma97_umaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Ma97_umaxType, char, ::xsd::cxx::tree::schema_type::double_ > Ma97_umaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Ma97_umaxOptional&
    getMa97_umax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Ma97_umaxOptional&
    getMa97_umax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMa97_umax (const Ma97_umaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMa97_umax (const Ma97_umaxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Ma97_umaxType
    getMa97_umaxDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MA97ComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MA97ComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MA97ComplexType (const MA97ComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MA97ComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MA97ComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Ma97_print_levelOptional ma97_print_level_;
    Ma97_neminOptional ma97_nemin_;
    Ma97_orderOptional ma97_order_;
    static const Ma97_orderType ma97_order_default_value_;
    Ma97_scalingOptional ma97_scaling_;
    static const Ma97_scalingType ma97_scaling_default_value_;
    Ma97_scaling1Optional ma97_scaling1_;
    static const Ma97_scaling1Type ma97_scaling1_default_value_;
    Ma97_scaling2Optional ma97_scaling2_;
    static const Ma97_scaling2Type ma97_scaling2_default_value_;
    Ma97_scaling3Optional ma97_scaling3_;
    static const Ma97_scaling3Type ma97_scaling3_default_value_;
    Ma97_smallOptional ma97_small_;
    Ma97_solve_blas3Optional ma97_solve_blas3_;
    static const Ma97_solve_blas3Type ma97_solve_blas3_default_value_;
    Ma97_switch1Optional ma97_switch1_;
    static const Ma97_switch1Type ma97_switch1_default_value_;
    Ma97_switch2Optional ma97_switch2_;
    static const Ma97_switch2Type ma97_switch2_default_value_;
    Ma97_switch3Optional ma97_switch3_;
    static const Ma97_switch3Type ma97_switch3_default_value_;
    Ma97_uOptional ma97_u_;
    Ma97_umaxOptional ma97_umax_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MUMPSComplexType schema type.
   *
   * @nosubgrouping
   */
  class MUMPSComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mumps_pivtol
     *
     * @brief Accessor and modifier functions for the %mumps_pivtol
     * optional element.
     *
     * Pivot tolerance for the linear solver MUMPS. 
     * A smaller number pivots for sparsity, a larger number pivots for
     * stability. This option is only available if Ipopt has been compiled
     * with MUMPS. The valid range for this real option is [0,1] and its
     * default value is  1e-6.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mumps_pivtolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mumps_pivtolType > Mumps_pivtolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mumps_pivtolType, char, ::xsd::cxx::tree::schema_type::double_ > Mumps_pivtolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mumps_pivtolOptional&
    getMumps_pivtol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mumps_pivtolOptional&
    getMumps_pivtol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps_pivtol (const Mumps_pivtolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps_pivtol (const Mumps_pivtolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mumps_pivtolType
    getMumps_pivtolDefaultValue ();

    //@}

    /**
     * @name mumps_pivtolmax
     *
     * @brief Accessor and modifier functions for the %mumps_pivtolmax
     * optional element.
     *
     * Maximum pivot tolerance for the linear solver MUMPS. 
     * Ipopt may increase pivtol as high as pivtolmax to get a more accurate
     * solution to the linear system. This option is only available if Ipopt
     * has been compiled with MUMPS. The valid range for this real option is 
     * [0,1] and its default value is 0.1
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mumps_pivtolmaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mumps_pivtolmaxType > Mumps_pivtolmaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mumps_pivtolmaxType, char, ::xsd::cxx::tree::schema_type::double_ > Mumps_pivtolmaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mumps_pivtolmaxOptional&
    getMumps_pivtolmax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mumps_pivtolmaxOptional&
    getMumps_pivtolmax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps_pivtolmax (const Mumps_pivtolmaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps_pivtolmax (const Mumps_pivtolmaxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mumps_pivtolmaxType
    getMumps_pivtolmaxDefaultValue ();

    //@}

    /**
     * @name mumps_mem_percent
     *
     * @brief Accessor and modifier functions for the %mumps_mem_percent
     * optional element.
     *
     * Percentage increase in the estimated working space for MUMPS. 
     * In MUMPS when significant extra fill-in is caused by numerical
     * pivoting, larger values of mumps_mem_percent may help use the
     * workspace more efficiently. On the other hand, if memory requirement
     * are too large at the very beginning of the optimization, choosing a
     * much smaller value for this option, such as 5, might reduce memory
     * requirements. The valid range for this integer option is [0, inf] and
     * its default value is 1000.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Mumps_mem_percentType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mumps_mem_percentType > Mumps_mem_percentOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mumps_mem_percentType, char > Mumps_mem_percentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mumps_mem_percentOptional&
    getMumps_mem_percent () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mumps_mem_percentOptional&
    getMumps_mem_percent ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps_mem_percent (const Mumps_mem_percentType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps_mem_percent (const Mumps_mem_percentOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mumps_mem_percentType
    getMumps_mem_percentDefaultValue ();

    //@}

    /**
     * @name mumps_permuting_scaling
     *
     * @brief Accessor and modifier functions for the %mumps_permuting_scaling
     * optional element.
     *
     * Controls permuting and scaling in MUMPS 
     * This is ICNTL(6) in MUMPS. The valid range for this integer option is 
     * [0,7] and its default value is 7.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Mumps_permuting_scalingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mumps_permuting_scalingType > Mumps_permuting_scalingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mumps_permuting_scalingType, char > Mumps_permuting_scalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mumps_permuting_scalingOptional&
    getMumps_permuting_scaling () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mumps_permuting_scalingOptional&
    getMumps_permuting_scaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps_permuting_scaling (const Mumps_permuting_scalingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps_permuting_scaling (const Mumps_permuting_scalingOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mumps_permuting_scalingType
    getMumps_permuting_scalingDefaultValue ();

    //@}

    /**
     * @name mumps_pivot_order
     *
     * @brief Accessor and modifier functions for the %mumps_pivot_order
     * optional element.
     *
     * Controls pivot order in MUMPS 
     * This is ICNTL(7) in MUMPS. The valid range for this integer option is
     * [0, 7] and its default value is 7.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Mumps_pivot_orderType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mumps_pivot_orderType > Mumps_pivot_orderOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mumps_pivot_orderType, char > Mumps_pivot_orderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mumps_pivot_orderOptional&
    getMumps_pivot_order () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mumps_pivot_orderOptional&
    getMumps_pivot_order ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps_pivot_order (const Mumps_pivot_orderType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps_pivot_order (const Mumps_pivot_orderOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mumps_pivot_orderType
    getMumps_pivot_orderDefaultValue ();

    //@}

    /**
     * @name mumps_scaling
     *
     * @brief Accessor and modifier functions for the %mumps_scaling
     * optional element.
     *
     * Controls scaling in MUMPS 
     * This is ICNTL(8) in MUMPS. The valid range for this integer option is
     * [-2,77] and its default value is 77.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Mumps_scalingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mumps_scalingType > Mumps_scalingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mumps_scalingType, char > Mumps_scalingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mumps_scalingOptional&
    getMumps_scaling () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mumps_scalingOptional&
    getMumps_scaling ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMumps_scaling (const Mumps_scalingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMumps_scaling (const Mumps_scalingOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mumps_scalingType
    getMumps_scalingDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MUMPSComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MUMPSComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MUMPSComplexType (const MUMPSComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MUMPSComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MUMPSComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Mumps_pivtolOptional mumps_pivtol_;
    Mumps_pivtolmaxOptional mumps_pivtolmax_;
    Mumps_mem_percentOptional mumps_mem_percent_;
    Mumps_permuting_scalingOptional mumps_permuting_scaling_;
    Mumps_pivot_orderOptional mumps_pivot_order_;
    Mumps_scalingOptional mumps_scaling_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PardisoComplexType schema type.
   *
   * @nosubgrouping
   */
  class PardisoComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name pardiso_matching_strategy
     *
     * @brief Accessor and modifier functions for the %pardiso_matching_strategy
     * optional element.
     *
     * Matching strategy to be used by Pardiso 
     * This is IPAR(13) in Pardiso manual. The default value for this string
     * option is "complete+2x2". 
     * Possible values:
     * complete: Match complete (IPAR(13)=1)
     * complete+2x2: Match complete+2x2 (IPAR(13)=2)
     * constraints: Match constraints (IPAR(13)=3)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Pardiso_matching_strategy Pardiso_matching_strategyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Pardiso_matching_strategyType > Pardiso_matching_strategyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Pardiso_matching_strategyType, char > Pardiso_matching_strategyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Pardiso_matching_strategyOptional&
    getPardiso_matching_strategy () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Pardiso_matching_strategyOptional&
    getPardiso_matching_strategy ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPardiso_matching_strategy (const Pardiso_matching_strategyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPardiso_matching_strategy (const Pardiso_matching_strategyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPardiso_matching_strategy (::std::auto_ptr< Pardiso_matching_strategyType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Pardiso_matching_strategyType&
    getPardiso_matching_strategyDefaultValue ();

    //@}

    /**
     * @name pardiso_max_iterative_refinement_steps
     *
     * @brief Accessor and modifier functions for the %pardiso_max_iterative_refinement_steps
     * optional element.
     *
     * Limit on number of iterative refinement steps. 
     * The solver does not perform more than the absolute value of this value
     * steps of iterative refinement and stops the process if a satisfactory
     * level of accuracy of the solution in terms of backward error is
     * achieved. If negative, the accumulation of the residue uses extended
     * precision real and complex data types. Perturbed pivots result in
     * iterative refinement. The solver automatically performs two steps of
     * iterative refinements when perturbed pivots are obtained during the
     * numerical factorization and this option is set to 0. The valid range
     * for this integer option is [-inf, inf] and its default value is 0 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Pardiso_max_iterative_refinement_stepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Pardiso_max_iterative_refinement_stepsType > Pardiso_max_iterative_refinement_stepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Pardiso_max_iterative_refinement_stepsType, char > Pardiso_max_iterative_refinement_stepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Pardiso_max_iterative_refinement_stepsOptional&
    getPardiso_max_iterative_refinement_steps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Pardiso_max_iterative_refinement_stepsOptional&
    getPardiso_max_iterative_refinement_steps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPardiso_max_iterative_refinement_steps (const Pardiso_max_iterative_refinement_stepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPardiso_max_iterative_refinement_steps (const Pardiso_max_iterative_refinement_stepsOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Pardiso_max_iterative_refinement_stepsType
    getPardiso_max_iterative_refinement_stepsDefaultValue ();

    //@}

    /**
     * @name pardiso_msglvl
     *
     * @brief Accessor and modifier functions for the %pardiso_msglvl
     * optional element.
     *
     * Pardiso message level 
     * This determines the amount of analysis output from the Pardiso solver.
     * This is MSGLVL in the Pardiso manual. The valid range for this integer
     * option is  [0, inf] and its default value is 0 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Pardiso_msglvlType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Pardiso_msglvlType > Pardiso_msglvlOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Pardiso_msglvlType, char > Pardiso_msglvlTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Pardiso_msglvlOptional&
    getPardiso_msglvl () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Pardiso_msglvlOptional&
    getPardiso_msglvl ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPardiso_msglvl (const Pardiso_msglvlType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPardiso_msglvl (const Pardiso_msglvlOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Pardiso_msglvlType
    getPardiso_msglvlDefaultValue ();

    //@}

    /**
     * @name pardiso_order
     *
     * @brief Accessor and modifier functions for the %pardiso_order
     * optional element.
     *
     * Controls the fill-in reduction ordering algorithm for the input
     * matrix. 
     * The default value for this string option is "five". 
     * Possible values:
     * amd: minimum degree algorithm
     * one: undocumented
     * metis: MeTiS nested dissection algorithm
     * pmetis: parallel (OpenMP) version of MeTiS nested dissection algorithm
     * four: undocumented
     * five: undocumented
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Pardiso_order Pardiso_orderType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Pardiso_orderType > Pardiso_orderOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Pardiso_orderType, char > Pardiso_orderTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Pardiso_orderOptional&
    getPardiso_order () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Pardiso_orderOptional&
    getPardiso_order ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPardiso_order (const Pardiso_orderType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPardiso_order (const Pardiso_orderOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPardiso_order (::std::auto_ptr< Pardiso_orderType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Pardiso_orderType&
    getPardiso_orderDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PardisoComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PardisoComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PardisoComplexType (const PardisoComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PardisoComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PardisoComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Pardiso_matching_strategyOptional pardiso_matching_strategy_;
    static const Pardiso_matching_strategyType pardiso_matching_strategy_default_value_;
    Pardiso_max_iterative_refinement_stepsOptional pardiso_max_iterative_refinement_steps_;
    Pardiso_msglvlOptional pardiso_msglvl_;
    Pardiso_orderOptional pardiso_order_;
    static const Pardiso_orderType pardiso_order_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTQuasiNewtonComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTQuasiNewtonComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name limited_memory_max_history
     *
     * @brief Accessor and modifier functions for the %limited_memory_max_history
     * optional element.
     *
     * Maximum size of the history for the limited quasi-Newton Hessian
     * approximation
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalIntegerSimpleType Limited_memory_max_historyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Limited_memory_max_historyType > Limited_memory_max_historyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Limited_memory_max_historyType, char > Limited_memory_max_historyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Limited_memory_max_historyOptional&
    getLimited_memory_max_history () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Limited_memory_max_historyOptional&
    getLimited_memory_max_history ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLimited_memory_max_history (const Limited_memory_max_historyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLimited_memory_max_history (const Limited_memory_max_historyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLimited_memory_max_history (::std::auto_ptr< Limited_memory_max_historyType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Limited_memory_max_historyType&
    getLimited_memory_max_historyDefaultValue ();

    //@}

    /**
     * @name limited_memory_max_skipping
     *
     * @brief Accessor and modifier functions for the %limited_memory_max_skipping
     * optional element.
     *
     * Threshold for successive iterations where update is skipped
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalIntegerSimpleType Limited_memory_max_skippingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Limited_memory_max_skippingType > Limited_memory_max_skippingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Limited_memory_max_skippingType, char > Limited_memory_max_skippingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Limited_memory_max_skippingOptional&
    getLimited_memory_max_skipping () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Limited_memory_max_skippingOptional&
    getLimited_memory_max_skipping ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLimited_memory_max_skipping (const Limited_memory_max_skippingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLimited_memory_max_skipping (const Limited_memory_max_skippingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLimited_memory_max_skipping (::std::auto_ptr< Limited_memory_max_skippingType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Limited_memory_max_skippingType&
    getLimited_memory_max_skippingDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTQuasiNewtonComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTQuasiNewtonComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTQuasiNewtonComplexType (const IPOPTQuasiNewtonComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTQuasiNewtonComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTQuasiNewtonComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Limited_memory_max_historyOptional limited_memory_max_history_;
    static const Limited_memory_max_historyType limited_memory_max_history_default_value_;
    Limited_memory_max_skippingOptional limited_memory_max_skipping_;
    static const Limited_memory_max_skippingType limited_memory_max_skipping_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTDerivativeCheckerComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTDerivativeCheckerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name derivative_test
     *
     * @brief Accessor and modifier functions for the %derivative_test
     * optional element.
     *
     * Enable derivative checker
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Derivative_test Derivative_testType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Derivative_testType > Derivative_testOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Derivative_testType, char > Derivative_testTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Derivative_testOptional&
    getDerivative_test () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Derivative_testOptional&
    getDerivative_test ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDerivative_test (const Derivative_testType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDerivative_test (const Derivative_testOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDerivative_test (::std::auto_ptr< Derivative_testType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Derivative_testType&
    getDerivative_testDefaultValue ();

    //@}

    /**
     * @name derivative_test_perturbation
     *
     * @brief Accessor and modifier functions for the %derivative_test_perturbation
     * optional element.
     *
     * Size of the finite difference perturbation in derivative test
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Derivative_test_perturbation Derivative_test_perturbationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Derivative_test_perturbationType > Derivative_test_perturbationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Derivative_test_perturbationType, char > Derivative_test_perturbationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Derivative_test_perturbationOptional&
    getDerivative_test_perturbation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Derivative_test_perturbationOptional&
    getDerivative_test_perturbation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDerivative_test_perturbation (const Derivative_test_perturbationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDerivative_test_perturbation (const Derivative_test_perturbationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDerivative_test_perturbation (::std::auto_ptr< Derivative_test_perturbationType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Derivative_test_perturbationType
    getDerivative_test_perturbationDefaultValue ();

    //@}

    /**
     * @name derivative_test_tol
     *
     * @brief Accessor and modifier functions for the %derivative_test_tol
     * optional element.
     *
     * Threshold for indicating wrong derivative
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Derivative_test_tol Derivative_test_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Derivative_test_tolType > Derivative_test_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Derivative_test_tolType, char > Derivative_test_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Derivative_test_tolOptional&
    getDerivative_test_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Derivative_test_tolOptional&
    getDerivative_test_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDerivative_test_tol (const Derivative_test_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDerivative_test_tol (const Derivative_test_tolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDerivative_test_tol (::std::auto_ptr< Derivative_test_tolType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Derivative_test_tolType
    getDerivative_test_tolDefaultValue ();

    //@}

    /**
     * @name derivative_test_print_all
     *
     * @brief Accessor and modifier functions for the %derivative_test_print_all
     * optional element.
     *
     * Indicates whether information for all estimated derivatives should be
     * printed
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Derivative_test_print_all Derivative_test_print_allType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Derivative_test_print_allType > Derivative_test_print_allOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Derivative_test_print_allType, char > Derivative_test_print_allTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Derivative_test_print_allOptional&
    getDerivative_test_print_all () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Derivative_test_print_allOptional&
    getDerivative_test_print_all ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDerivative_test_print_all (const Derivative_test_print_allType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDerivative_test_print_all (const Derivative_test_print_allOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDerivative_test_print_all (::std::auto_ptr< Derivative_test_print_allType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Derivative_test_print_allType&
    getDerivative_test_print_allDefaultValue ();

    //@}

    /**
     * @name jacobian_approximation
     *
     * @brief Accessor and modifier functions for the %jacobian_approximation
     * optional element.
     *
     * Specifies technique to compute constraint Jacobian
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Jacobian_approximation Jacobian_approximationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Jacobian_approximationType > Jacobian_approximationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Jacobian_approximationType, char > Jacobian_approximationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Jacobian_approximationOptional&
    getJacobian_approximation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Jacobian_approximationOptional&
    getJacobian_approximation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJacobian_approximation (const Jacobian_approximationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setJacobian_approximation (const Jacobian_approximationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setJacobian_approximation (::std::auto_ptr< Jacobian_approximationType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Jacobian_approximationType&
    getJacobian_approximationDefaultValue ();

    //@}

    /**
     * @name findiff_perturbation
     *
     * @brief Accessor and modifier functions for the %findiff_perturbation
     * optional element.
     *
     * Size of the finite difference perturbation for derivative
    approximation */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Findiff_perturbation Findiff_perturbationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Findiff_perturbationType > Findiff_perturbationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Findiff_perturbationType, char > Findiff_perturbationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Findiff_perturbationOptional&
    getFindiff_perturbation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Findiff_perturbationOptional&
    getFindiff_perturbation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFindiff_perturbation (const Findiff_perturbationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFindiff_perturbation (const Findiff_perturbationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFindiff_perturbation (::std::auto_ptr< Findiff_perturbationType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Findiff_perturbationType
    getFindiff_perturbationDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTDerivativeCheckerComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTDerivativeCheckerComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTDerivativeCheckerComplexType (const IPOPTDerivativeCheckerComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTDerivativeCheckerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTDerivativeCheckerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Derivative_testOptional derivative_test_;
    static const Derivative_testType derivative_test_default_value_;
    Derivative_test_perturbationOptional derivative_test_perturbation_;
    Derivative_test_tolOptional derivative_test_tol_;
    Derivative_test_print_allOptional derivative_test_print_all_;
    static const Derivative_test_print_allType derivative_test_print_all_default_value_;
    Jacobian_approximationOptional jacobian_approximation_;
    static const Jacobian_approximationType jacobian_approximation_default_value_;
    Findiff_perturbationOptional findiff_perturbation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTHessianPermutationComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTHessianPermutationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name min_hessian_perturbation
     *
     * @brief Accessor and modifier functions for the %min_hessian_perturbation
     * optional element.
     *
     * Smallest perturbation of the Hessian block. 
     * The size of the perturbation of the Hessian block is never selected
     * smaller than this value, unless no perturbation is necessary. (This is
     * delta_wmin in implementation paper.) The valid range for this real
     * option is  [0, +inf] and its default value is  1e-20
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Min_hessian_perturbationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Min_hessian_perturbationType > Min_hessian_perturbationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Min_hessian_perturbationType, char, ::xsd::cxx::tree::schema_type::double_ > Min_hessian_perturbationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Min_hessian_perturbationOptional&
    getMin_hessian_perturbation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Min_hessian_perturbationOptional&
    getMin_hessian_perturbation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMin_hessian_perturbation (const Min_hessian_perturbationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMin_hessian_perturbation (const Min_hessian_perturbationOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Min_hessian_perturbationType
    getMin_hessian_perturbationDefaultValue ();

    //@}

    /**
     * @name max_hessian_perturbation
     *
     * @brief Accessor and modifier functions for the %max_hessian_perturbation
     * optional element.
     *
     * This parameter gives the maximum value of the regularization
     * parameter. If a regularization of that size is not enough, the
     * algorithm skips this iteration and goes to the restoration phase.
     * (This is delta_wmax in the implementation paper.) The valid range for
     * this real option is [0,+inf] and its default value is 1e+20.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Max_hessian_perturbationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_hessian_perturbationType > Max_hessian_perturbationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_hessian_perturbationType, char, ::xsd::cxx::tree::schema_type::double_ > Max_hessian_perturbationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_hessian_perturbationOptional&
    getMax_hessian_perturbation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_hessian_perturbationOptional&
    getMax_hessian_perturbation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_hessian_perturbation (const Max_hessian_perturbationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_hessian_perturbation (const Max_hessian_perturbationOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Max_hessian_perturbationType
    getMax_hessian_perturbationDefaultValue ();

    //@}

    /**
     * @name first_hessian_perturbation
     *
     * @brief Accessor and modifier functions for the %first_hessian_perturbation
     * optional element.
     *
     * Size of first x-s perturbation tried. 
     * The first value tried for the x-s perturbation in the inertia
     * correction scheme.(This is delta_0 in the implementation paper.) The
     * valid range for this real option is  [0, inf] and its default value is
     * 1e4.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double First_hessian_perturbationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< First_hessian_perturbationType > First_hessian_perturbationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< First_hessian_perturbationType, char, ::xsd::cxx::tree::schema_type::double_ > First_hessian_perturbationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const First_hessian_perturbationOptional&
    getFirst_hessian_perturbation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    First_hessian_perturbationOptional&
    getFirst_hessian_perturbation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFirst_hessian_perturbation (const First_hessian_perturbationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFirst_hessian_perturbation (const First_hessian_perturbationOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static First_hessian_perturbationType
    getFirst_hessian_perturbationDefaultValue ();

    //@}

    /**
     * @name perturb_inc_fact_first
     *
     * @brief Accessor and modifier functions for the %perturb_inc_fact_first
     * optional element.
     *
     * Increase factor for x-s perturbation for very first perturbation. 
     * The factor by which the perturbation is increased when a trial value
     * was not sufficient - this value is used for the computation of the
     * very first perturbation and allows a different value for for the first
     * perturbation than that used for the remaining perturbations. (This is
     * bar_kappa_w+ in the implementation paper.) The valid range for this
     * real option is [1,inf] and its default value is100.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Perturb_inc_fact_firstType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Perturb_inc_fact_firstType > Perturb_inc_fact_firstOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Perturb_inc_fact_firstType, char, ::xsd::cxx::tree::schema_type::double_ > Perturb_inc_fact_firstTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Perturb_inc_fact_firstOptional&
    getPerturb_inc_fact_first () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Perturb_inc_fact_firstOptional&
    getPerturb_inc_fact_first ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPerturb_inc_fact_first (const Perturb_inc_fact_firstType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPerturb_inc_fact_first (const Perturb_inc_fact_firstOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Perturb_inc_fact_firstType
    getPerturb_inc_fact_firstDefaultValue ();

    //@}

    /**
     * @name perturb_inc_fact
     *
     * @brief Accessor and modifier functions for the %perturb_inc_fact
     * optional element.
     *
     * Increase factor for x-s perturbation. 
     * The factor by which the perturbation is increased when a trial value
     * was not sufficient - this value is used for the computation of all
     * perturbations except for the first. (This is kappa_w+ in the
     * implementation paper.) The valid range for this real option is [0,
     * inf] and its default value is 8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Perturb_inc_factType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Perturb_inc_factType > Perturb_inc_factOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Perturb_inc_factType, char, ::xsd::cxx::tree::schema_type::double_ > Perturb_inc_factTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Perturb_inc_factOptional&
    getPerturb_inc_fact () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Perturb_inc_factOptional&
    getPerturb_inc_fact ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPerturb_inc_fact (const Perturb_inc_factType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPerturb_inc_fact (const Perturb_inc_factOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Perturb_inc_factType
    getPerturb_inc_factDefaultValue ();

    //@}

    /**
     * @name perturb_dec_fact
     *
     * @brief Accessor and modifier functions for the %perturb_dec_fact
     * optional element.
     *
     * Decrease factor for x-s perturbation. 
     * The factor by which the perturbation is decreased when a trial value
     * is deduced from the size of the most recent successful perturbation.
     * (This is kappa_w- in the implementation paper.) The valid range for
     * this real option is [0, inf] and its default value is 0.333333.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Perturb_dec_factType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Perturb_dec_factType > Perturb_dec_factOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Perturb_dec_factType, char, ::xsd::cxx::tree::schema_type::double_ > Perturb_dec_factTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Perturb_dec_factOptional&
    getPerturb_dec_fact () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Perturb_dec_factOptional&
    getPerturb_dec_fact ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPerturb_dec_fact (const Perturb_dec_factType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPerturb_dec_fact (const Perturb_dec_factOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Perturb_dec_factType
    getPerturb_dec_factDefaultValue ();

    //@}

    /**
     * @name jacobian_regularization_value
     *
     * @brief Accessor and modifier functions for the %jacobian_regularization_value
     * optional element.
     *
     * Size of the regularization for rank-deficient constraint Jacobians. 
     * (This is bar delta_c in the implementation paper.) The valid range for
     * this real option is [0, inf] and its default value is 1e-8. .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Jacobian_regularization_valueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Jacobian_regularization_valueType > Jacobian_regularization_valueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Jacobian_regularization_valueType, char, ::xsd::cxx::tree::schema_type::double_ > Jacobian_regularization_valueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Jacobian_regularization_valueOptional&
    getJacobian_regularization_value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Jacobian_regularization_valueOptional&
    getJacobian_regularization_value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJacobian_regularization_value (const Jacobian_regularization_valueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setJacobian_regularization_value (const Jacobian_regularization_valueOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Jacobian_regularization_valueType
    getJacobian_regularization_valueDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTHessianPermutationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTHessianPermutationComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTHessianPermutationComplexType (const IPOPTHessianPermutationComplexType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTHessianPermutationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTHessianPermutationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Min_hessian_perturbationOptional min_hessian_perturbation_;
    Max_hessian_perturbationOptional max_hessian_perturbation_;
    First_hessian_perturbationOptional first_hessian_perturbation_;
    Perturb_inc_fact_firstOptional perturb_inc_fact_first_;
    Perturb_inc_factOptional perturb_inc_fact_;
    Perturb_dec_factOptional perturb_dec_fact_;
    Jacobian_regularization_valueOptional jacobian_regularization_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTRestorationPhaseComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTRestorationPhaseComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name expect_infeasible_problem
     *
     * @brief Accessor and modifier functions for the %expect_infeasible_problem
     * optional element.
     *
     * Enable heuristics to quickly detect an infeasible problem. 
     * This options is meant to activate heuristics that may speed up the
     * infeasibility determination if you expect that there is a good chance
     * for the problem to be infeasible. In the filter line search procedure,
     * the restoration phase is called more quickly than usually, and more
     * reduction in the constraint violation is enforced before the
     * restoration phase is left. If the problem is square, this option is
     * enabled automatically. The default value for this string option is
     * "no". 
     * Possible values:
     * no: the problem probably be feasible
     * yes: the problem has a good chance to be infeasible
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Expect_infeasible_problem Expect_infeasible_problemType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Expect_infeasible_problemType > Expect_infeasible_problemOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Expect_infeasible_problemType, char > Expect_infeasible_problemTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Expect_infeasible_problemOptional&
    getExpect_infeasible_problem () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Expect_infeasible_problemOptional&
    getExpect_infeasible_problem ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpect_infeasible_problem (const Expect_infeasible_problemType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpect_infeasible_problem (const Expect_infeasible_problemOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExpect_infeasible_problem (::std::auto_ptr< Expect_infeasible_problemType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Expect_infeasible_problemType&
    getExpect_infeasible_problemDefaultValue ();

    //@}

    /**
     * @name expect_infeasible_problem_ctol
     *
     * @brief Accessor and modifier functions for the %expect_infeasible_problem_ctol
     * optional element.
     *
     * Threshold for disabling "expect_infeasible_problem" option. 
     * If the constraint violation becomes smaller than this threshold, the
     * "expect_infeasible_problem" heuristics in the filter line search are
     * disabled. If the problem is square, this options is set to 0. The
     * valid range for this real option is [0, inf] and its default value is
     * 0.001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Expect_infeasible_problem_ctolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Expect_infeasible_problem_ctolType > Expect_infeasible_problem_ctolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Expect_infeasible_problem_ctolType, char, ::xsd::cxx::tree::schema_type::double_ > Expect_infeasible_problem_ctolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Expect_infeasible_problem_ctolOptional&
    getExpect_infeasible_problem_ctol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Expect_infeasible_problem_ctolOptional&
    getExpect_infeasible_problem_ctol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpect_infeasible_problem_ctol (const Expect_infeasible_problem_ctolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpect_infeasible_problem_ctol (const Expect_infeasible_problem_ctolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Expect_infeasible_problem_ctolType
    getExpect_infeasible_problem_ctolDefaultValue ();

    //@}

    /**
     * @name expect_infeasible_problem_ytol
     *
     * @brief Accessor and modifier functions for the %expect_infeasible_problem_ytol
     * optional element.
     *
     * Multiplier threshold for activating "expect_infeasible_problem"
     * option. 
     * If the max norm of the constraint multipliers becomes larger than this
     * value and "expect_infeasible_problem" is chosen, then the restoration
     * phase is entered. The valid range for this real option is [0, inf] and
     * its default value is  1e8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Expect_infeasible_problem_ytolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Expect_infeasible_problem_ytolType > Expect_infeasible_problem_ytolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Expect_infeasible_problem_ytolType, char, ::xsd::cxx::tree::schema_type::double_ > Expect_infeasible_problem_ytolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Expect_infeasible_problem_ytolOptional&
    getExpect_infeasible_problem_ytol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Expect_infeasible_problem_ytolOptional&
    getExpect_infeasible_problem_ytol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpect_infeasible_problem_ytol (const Expect_infeasible_problem_ytolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpect_infeasible_problem_ytol (const Expect_infeasible_problem_ytolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Expect_infeasible_problem_ytolType
    getExpect_infeasible_problem_ytolDefaultValue ();

    //@}

    /**
     * @name start_with_resto
     *
     * @brief Accessor and modifier functions for the %start_with_resto
     * optional element.
     *
     * Tells algorithm to switch to restoration phase in first iteration. 
     * Setting this option to "yes" forces the algorithm to switch to the
     * feasibility restoration phase in the first iteration. If the initial
     * point is feasible, the algorithm will abort with a failure. The
     * default value for this string option is "no". 
     * Possible values:
     * no: don't force start in restoration phase
     * yes: force start in restoration phase
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Start_with_resto Start_with_restoType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Start_with_restoType > Start_with_restoOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Start_with_restoType, char > Start_with_restoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Start_with_restoOptional&
    getStart_with_resto () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Start_with_restoOptional&
    getStart_with_resto ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStart_with_resto (const Start_with_restoType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStart_with_resto (const Start_with_restoOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStart_with_resto (::std::auto_ptr< Start_with_restoType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Start_with_restoType&
    getStart_with_restoDefaultValue ();

    //@}

    /**
     * @name soft_resto_pderror_reduction_factor
     *
     * @brief Accessor and modifier functions for the %soft_resto_pderror_reduction_factor
     * optional element.
     *
     * Required reduction in primal-dual error in the soft restoration phase.
     * 
     * The soft restoration phase attempts to reduce the primal-dual error
     * with regular steps. If the damped primal-dual step (damped only to
     * satisfy the fraction-to-the-boundary rule) is not decreasing the
     * primal-dual error by at least this factor, then the regular
     * restoration phase is called. Choosing "0" here disables the soft
     * restoration phase. The valid range for this real option is [0, inf]
     * and its default value is 0.9999 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Soft_resto_pderror_reduction_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Soft_resto_pderror_reduction_factorType > Soft_resto_pderror_reduction_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Soft_resto_pderror_reduction_factorType, char, ::xsd::cxx::tree::schema_type::double_ > Soft_resto_pderror_reduction_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Soft_resto_pderror_reduction_factorOptional&
    getSoft_resto_pderror_reduction_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Soft_resto_pderror_reduction_factorOptional&
    getSoft_resto_pderror_reduction_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSoft_resto_pderror_reduction_factor (const Soft_resto_pderror_reduction_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSoft_resto_pderror_reduction_factor (const Soft_resto_pderror_reduction_factorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Soft_resto_pderror_reduction_factorType
    getSoft_resto_pderror_reduction_factorDefaultValue ();

    //@}

    /**
     * @name required_infeasibility_reduction
     *
     * @brief Accessor and modifier functions for the %required_infeasibility_reduction
     * optional element.
     *
     * Required reduction of infeasibility before leaving restoration phase. 
     * The restoration phase algorithm is performed, until a point is found
     * that is acceptable to the filter and the infeasibility has been
     * reduced by at least the fraction given by this option. The valid range
     * for this real option is [0, inf] and its default value is 0.9 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Required_infeasibility_reductionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Required_infeasibility_reductionType > Required_infeasibility_reductionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Required_infeasibility_reductionType, char, ::xsd::cxx::tree::schema_type::double_ > Required_infeasibility_reductionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Required_infeasibility_reductionOptional&
    getRequired_infeasibility_reduction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Required_infeasibility_reductionOptional&
    getRequired_infeasibility_reduction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRequired_infeasibility_reduction (const Required_infeasibility_reductionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRequired_infeasibility_reduction (const Required_infeasibility_reductionOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Required_infeasibility_reductionType
    getRequired_infeasibility_reductionDefaultValue ();

    //@}

    /**
     * @name bound_mult_reset_threshold
     *
     * @brief Accessor and modifier functions for the %bound_mult_reset_threshold
     * optional element.
     *
     * Threshold for resetting bound multipliers after the restoration phase.
     * 
     * After returning from the restoration phase, the bound multipliers are
     * updated with a Newton step for complementarity. Here, the change in
     * the primal variables during the entire restoration phase is taken to
     * be the corresponding primal Newton step. However, if after the update
     * the largest bound multiplier exceeds the threshold specified by this
     * option, the multipliers are all reset to 1. The valid range for this
     * real option is [0, inf] and its default value is 1000 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Bound_mult_reset_thresholdType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Bound_mult_reset_thresholdType > Bound_mult_reset_thresholdOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Bound_mult_reset_thresholdType, char, ::xsd::cxx::tree::schema_type::double_ > Bound_mult_reset_thresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Bound_mult_reset_thresholdOptional&
    getBound_mult_reset_threshold () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Bound_mult_reset_thresholdOptional&
    getBound_mult_reset_threshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBound_mult_reset_threshold (const Bound_mult_reset_thresholdType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBound_mult_reset_threshold (const Bound_mult_reset_thresholdOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Bound_mult_reset_thresholdType
    getBound_mult_reset_thresholdDefaultValue ();

    //@}

    /**
     * @name constr_mult_reset_threshold
     *
     * @brief Accessor and modifier functions for the %constr_mult_reset_threshold
     * optional element.
     *
     * Threshold for resetting equality and inequality multipliers after
     * restoration phase. 
     * After returning from the restoration phase, the constraint multipliers
     * are recomputed by a least square estimate. This option triggers when
     * those least-square estimates should be ignored. The valid range for
     * this real option is  [0, inf] and its default value is 0 .
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Constr_mult_reset_thresholdType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Constr_mult_reset_thresholdType > Constr_mult_reset_thresholdOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Constr_mult_reset_thresholdType, char, ::xsd::cxx::tree::schema_type::double_ > Constr_mult_reset_thresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Constr_mult_reset_thresholdOptional&
    getConstr_mult_reset_threshold () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Constr_mult_reset_thresholdOptional&
    getConstr_mult_reset_threshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstr_mult_reset_threshold (const Constr_mult_reset_thresholdType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstr_mult_reset_threshold (const Constr_mult_reset_thresholdOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Constr_mult_reset_thresholdType
    getConstr_mult_reset_thresholdDefaultValue ();

    //@}

    /**
     * @name evaluate_orig_obj_at_resto_trial
     *
     * @brief Accessor and modifier functions for the %evaluate_orig_obj_at_resto_trial
     * optional element.
     *
     * Determines if the original objective function should be evaluated at
     * restoration phase trial points. 
     * Setting this option to "yes" makes the restoration phase algorithm
     * evaluate the objective function of the original problem at every trial
     * point encountered during the restoration phase, even if this value is
     * not required. In this way, it is guaranteed that the original
     * objective function can be evaluated without error at all accepted
     * iterates; otherwise the algorithm might fail at a point where the
     * restoration phase accepts an iterate that is good for the restoration
     * phase problem, but not the original problem. On the other hand, if the
     * evaluation of the original objective is expensive, this might be
     * costly. The default value for this string option is "yes". 
     * Possible values:
     * no: skip evaluation
     * yes: evaluate at every trial point
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Evaluate_orig_obj_at_resto_trial Evaluate_orig_obj_at_resto_trialType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Evaluate_orig_obj_at_resto_trialType > Evaluate_orig_obj_at_resto_trialOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Evaluate_orig_obj_at_resto_trialType, char > Evaluate_orig_obj_at_resto_trialTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Evaluate_orig_obj_at_resto_trialOptional&
    getEvaluate_orig_obj_at_resto_trial () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Evaluate_orig_obj_at_resto_trialOptional&
    getEvaluate_orig_obj_at_resto_trial ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEvaluate_orig_obj_at_resto_trial (const Evaluate_orig_obj_at_resto_trialType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEvaluate_orig_obj_at_resto_trial (const Evaluate_orig_obj_at_resto_trialOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEvaluate_orig_obj_at_resto_trial (::std::auto_ptr< Evaluate_orig_obj_at_resto_trialType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Evaluate_orig_obj_at_resto_trialType&
    getEvaluate_orig_obj_at_resto_trialDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTRestorationPhaseComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTRestorationPhaseComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTRestorationPhaseComplexType (const IPOPTRestorationPhaseComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTRestorationPhaseComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTRestorationPhaseComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Expect_infeasible_problemOptional expect_infeasible_problem_;
    static const Expect_infeasible_problemType expect_infeasible_problem_default_value_;
    Expect_infeasible_problem_ctolOptional expect_infeasible_problem_ctol_;
    Expect_infeasible_problem_ytolOptional expect_infeasible_problem_ytol_;
    Start_with_restoOptional start_with_resto_;
    static const Start_with_restoType start_with_resto_default_value_;
    Soft_resto_pderror_reduction_factorOptional soft_resto_pderror_reduction_factor_;
    Required_infeasibility_reductionOptional required_infeasibility_reduction_;
    Bound_mult_reset_thresholdOptional bound_mult_reset_threshold_;
    Constr_mult_reset_thresholdOptional constr_mult_reset_threshold_;
    Evaluate_orig_obj_at_resto_trialOptional evaluate_orig_obj_at_resto_trial_;
    static const Evaluate_orig_obj_at_resto_trialType evaluate_orig_obj_at_resto_trial_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTMultiplierUpdatesComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTMultiplierUpdatesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name alpha_for_y
     *
     * @brief Accessor and modifier functions for the %alpha_for_y
     * optional element.
     *
     * Method to determine the step size for constraint multipliers. 
     * This option determines how the step size (alpha_y) will be calculated
     * when updating the constraint multipliers. The default value for this
     * string option is "primal". 
     * Possible values:
     * primal: use primal step size
     * bound-mult: use step size for the bound multipliers (good for LPs)
     * min: use the min of primal and bound multipliers
     * max: use the max of primal and bound multipliers
     * full: take a full step of size one
     * min-dual-infeas: choose step size minimizing new dual infeasibility
     * safer-min-dual-infeas: like "min_dual_infeas", but safeguarded by
     * "min" and "max"
     * primal-and-full: use the primal step size, and full step if delta_x
     * smaller or equal than alpha_for_y_tol
     * dual-and-full: use the dual step size, and full step if delta_x
     * smaller or equal than alpha_for_y_tol
     * acceptor: Call LSAcceptor to get step size for y
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Alpha_for_y Alpha_for_yType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Alpha_for_yType > Alpha_for_yOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Alpha_for_yType, char > Alpha_for_yTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Alpha_for_yOptional&
    getAlpha_for_y () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Alpha_for_yOptional&
    getAlpha_for_y ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAlpha_for_y (const Alpha_for_yType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAlpha_for_y (const Alpha_for_yOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAlpha_for_y (::std::auto_ptr< Alpha_for_yType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Alpha_for_yType&
    getAlpha_for_yDefaultValue ();

    //@}

    /**
     * @name alpha_for_y_tol
     *
     * @brief Accessor and modifier functions for the %alpha_for_y_tol
     * optional element.
     *
     * Tolerance for switching to full equality multiplier steps. 
     * This is only relevant if "alpha_for_y" is chosen "primal-and-full" or
     * "dual-and-full". The step size for the equality constraint multipliers
     * is taken to be one if the max-norm of the primal step is less than
     * this tolerance. The valid range for this real option is  [0, inf] and
     * its default value is 10.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Alpha_for_y_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Alpha_for_y_tolType > Alpha_for_y_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Alpha_for_y_tolType, char, ::xsd::cxx::tree::schema_type::double_ > Alpha_for_y_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Alpha_for_y_tolOptional&
    getAlpha_for_y_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Alpha_for_y_tolOptional&
    getAlpha_for_y_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAlpha_for_y_tol (const Alpha_for_y_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAlpha_for_y_tol (const Alpha_for_y_tolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Alpha_for_y_tolType
    getAlpha_for_y_tolDefaultValue ();

    //@}

    /**
     * @name recalc_y
     *
     * @brief Accessor and modifier functions for the %recalc_y
     * optional element.
     *
     * Tells the algorithm to recalculate the equality and inequality
     * multipliers as least square estimates. 
     * This asks the algorithm to recompute the multipliers, whenever the
     * current infeasibility is less than recalc_y_feas_tol. Choosing yes
     * might be helpful in the quasi-Newton option. However, each
     * recalculation requires an extra factorization of the linear system. If
     * a limited memory quasi-Newton option is chosen, this is used by
     * default. The default value for this string option is "no". 
     * Possible values:
     * no: use the Newton step to update the multipliers
     * yes: use least-square multiplier estimates
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Recalc_y Recalc_yType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Recalc_yType > Recalc_yOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Recalc_yType, char > Recalc_yTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Recalc_yOptional&
    getRecalc_y () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Recalc_yOptional&
    getRecalc_y ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRecalc_y (const Recalc_yType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRecalc_y (const Recalc_yOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRecalc_y (::std::auto_ptr< Recalc_yType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Recalc_yType&
    getRecalc_yDefaultValue ();

    //@}

    /**
     * @name recalc_y_feas_tol
     *
     * @brief Accessor and modifier functions for the %recalc_y_feas_tol
     * optional element.
     *
     * Feasibility threshold for recomputation of multipliers. 
     * If recalc_y is chosen and the current infeasibility is less than this
     * value, then the multipliers are recomputed. The valid range for this
     * real option is [0, inf] and its default value is 1e-6.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Recalc_y_feas_tolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Recalc_y_feas_tolType > Recalc_y_feas_tolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Recalc_y_feas_tolType, char, ::xsd::cxx::tree::schema_type::double_ > Recalc_y_feas_tolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Recalc_y_feas_tolOptional&
    getRecalc_y_feas_tol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Recalc_y_feas_tolOptional&
    getRecalc_y_feas_tol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRecalc_y_feas_tol (const Recalc_y_feas_tolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRecalc_y_feas_tol (const Recalc_y_feas_tolOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Recalc_y_feas_tolType
    getRecalc_y_feas_tolDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTMultiplierUpdatesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTMultiplierUpdatesComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTMultiplierUpdatesComplexType (const IPOPTMultiplierUpdatesComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTMultiplierUpdatesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTMultiplierUpdatesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Alpha_for_yOptional alpha_for_y_;
    static const Alpha_for_yType alpha_for_y_default_value_;
    Alpha_for_y_tolOptional alpha_for_y_tol_;
    Recalc_yOptional recalc_y_;
    static const Recalc_yType recalc_y_default_value_;
    Recalc_y_feas_tolOptional recalc_y_feas_tol_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTLineSearchComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTLineSearchComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name max_soc
     *
     * @brief Accessor and modifier functions for the %max_soc
     * optional element.
     *
     * Maximum number of second order correction trial steps at each
     * iteration. 
     * Choosing 0 disables the second order corrections. (This is pmax of
     * Step A-5.9 of Algorithm A in the implementation paper.) The valid
     * range for this integer option is  [0, inf] and its default value is 4
    . */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Max_socType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_socType > Max_socOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_socType, char > Max_socTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_socOptional&
    getMax_soc () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_socOptional&
    getMax_soc ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_soc (const Max_socType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_soc (const Max_socOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Max_socType
    getMax_socDefaultValue ();

    //@}

    /**
     * @name watchdog_shortened_iter_trigger
     *
     * @brief Accessor and modifier functions for the %watchdog_shortened_iter_trigger
     * optional element.
     *
     * Number of shortened iterations that trigger the watchdog. 
     * If the number of successive iterations in which the backtracking line
     * search did not accept the first trial point exceeds this number, the
     * watchdog procedure is activated. Choosing "0" here disables the
     * watchdog procedure. The valid range for this integer option is 
     * [0,inf] and its default value is 10.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Watchdog_shortened_iter_triggerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Watchdog_shortened_iter_triggerType > Watchdog_shortened_iter_triggerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Watchdog_shortened_iter_triggerType, char > Watchdog_shortened_iter_triggerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Watchdog_shortened_iter_triggerOptional&
    getWatchdog_shortened_iter_trigger () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Watchdog_shortened_iter_triggerOptional&
    getWatchdog_shortened_iter_trigger ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWatchdog_shortened_iter_trigger (const Watchdog_shortened_iter_triggerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWatchdog_shortened_iter_trigger (const Watchdog_shortened_iter_triggerOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Watchdog_shortened_iter_triggerType
    getWatchdog_shortened_iter_triggerDefaultValue ();

    //@}

    /**
     * @name watchdog_trial_iter_max
     *
     * @brief Accessor and modifier functions for the %watchdog_trial_iter_max
     * optional element.
     *
     * Maximum number of watchdog iterations. 
     * This option determines the number of trial iterations allowed before
     * the watchdog procedure is aborted and the algorithm returns to the
     * stored point. The valid range for this integer option is [1, inf] and
     * its default value is 3.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Watchdog_trial_iter_maxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Watchdog_trial_iter_maxType > Watchdog_trial_iter_maxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Watchdog_trial_iter_maxType, char > Watchdog_trial_iter_maxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Watchdog_trial_iter_maxOptional&
    getWatchdog_trial_iter_max () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Watchdog_trial_iter_maxOptional&
    getWatchdog_trial_iter_max ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWatchdog_trial_iter_max (const Watchdog_trial_iter_maxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWatchdog_trial_iter_max (const Watchdog_trial_iter_maxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Watchdog_trial_iter_maxType
    getWatchdog_trial_iter_maxDefaultValue ();

    //@}

    /**
     * @name accept_every_trial_step
     *
     * @brief Accessor and modifier functions for the %accept_every_trial_step
     * optional element.
     *
     * Always accept the first trial step. 
     * Setting this option to "yes" essentially disables the line search and
     * makes the algorithm take aggressive steps, without global convergence
     * guarantees. The default value for this string option is "no". 
     * Possible values:
     * no: don't arbitrarily accept the full step
     * yes: always accept the full step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Accept_every_trial_step Accept_every_trial_stepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Accept_every_trial_stepType > Accept_every_trial_stepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Accept_every_trial_stepType, char > Accept_every_trial_stepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Accept_every_trial_stepOptional&
    getAccept_every_trial_step () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Accept_every_trial_stepOptional&
    getAccept_every_trial_step ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAccept_every_trial_step (const Accept_every_trial_stepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAccept_every_trial_step (const Accept_every_trial_stepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAccept_every_trial_step (::std::auto_ptr< Accept_every_trial_stepType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Accept_every_trial_stepType&
    getAccept_every_trial_stepDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTLineSearchComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTLineSearchComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTLineSearchComplexType (const IPOPTLineSearchComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTLineSearchComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTLineSearchComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Max_socOptional max_soc_;
    Watchdog_shortened_iter_triggerOptional watchdog_shortened_iter_trigger_;
    Watchdog_trial_iter_maxOptional watchdog_trial_iter_max_;
    Accept_every_trial_stepOptional accept_every_trial_step_;
    static const Accept_every_trial_stepType accept_every_trial_step_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTWarmStartComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTWarmStartComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name warm_start_init_point
     *
     * @brief Accessor and modifier functions for the %warm_start_init_point
     * optional element.
     *
     * Warm-start for initial point 
     * Indicates whether this optimization should use a warm start
     * initialization, where values of primal and dual variables are given
     * (e.g., from a previous optimization of a related problem.) The default
     * value for this string option is "no". 
     * Possible values:
     * no: do not use the warm start initialization
     * yes: use the warm start initialization
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Warm_start_init_point Warm_start_init_pointType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_init_pointType > Warm_start_init_pointOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_init_pointType, char > Warm_start_init_pointTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_init_pointOptional&
    getWarm_start_init_point () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_init_pointOptional&
    getWarm_start_init_point ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_init_point (const Warm_start_init_pointType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_init_point (const Warm_start_init_pointOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWarm_start_init_point (::std::auto_ptr< Warm_start_init_pointType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Warm_start_init_pointType&
    getWarm_start_init_pointDefaultValue ();

    //@}

    /**
     * @name warm_start_bound_frac
     *
     * @brief Accessor and modifier functions for the %warm_start_bound_frac
     * optional element.
     *
     * same as bound_frac for the regular initializer. 
     * The valid range for this real option is [0,0.5] and its default value
     * is 0.001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Warm_start_bound_fracType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_bound_fracType > Warm_start_bound_fracOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_bound_fracType, char, ::xsd::cxx::tree::schema_type::double_ > Warm_start_bound_fracTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_bound_fracOptional&
    getWarm_start_bound_frac () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_bound_fracOptional&
    getWarm_start_bound_frac ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_bound_frac (const Warm_start_bound_fracType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_bound_frac (const Warm_start_bound_fracOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Warm_start_bound_fracType
    getWarm_start_bound_fracDefaultValue ();

    //@}

    /**
     * @name warm_start_bound_push
     *
     * @brief Accessor and modifier functions for the %warm_start_bound_push
     * optional element.
     *
     * same as bound_push for the regular initializer. 
     * The valid range for this real option is [0, inf] and its default value
     * is 0.001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Warm_start_bound_pushType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_bound_pushType > Warm_start_bound_pushOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_bound_pushType, char, ::xsd::cxx::tree::schema_type::double_ > Warm_start_bound_pushTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_bound_pushOptional&
    getWarm_start_bound_push () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_bound_pushOptional&
    getWarm_start_bound_push ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_bound_push (const Warm_start_bound_pushType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_bound_push (const Warm_start_bound_pushOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Warm_start_bound_pushType
    getWarm_start_bound_pushDefaultValue ();

    //@}

    /**
     * @name warm_start_slack_bound_frac
     *
     * @brief Accessor and modifier functions for the %warm_start_slack_bound_frac
     * optional element.
     *
     * same as slack_bound_frac for the regular initializer. 
     * The valid range for this real option is   [0,0.5] and its default
     * value is 0.001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Warm_start_slack_bound_fracType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_slack_bound_fracType > Warm_start_slack_bound_fracOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_slack_bound_fracType, char, ::xsd::cxx::tree::schema_type::double_ > Warm_start_slack_bound_fracTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_slack_bound_fracOptional&
    getWarm_start_slack_bound_frac () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_slack_bound_fracOptional&
    getWarm_start_slack_bound_frac ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_slack_bound_frac (const Warm_start_slack_bound_fracType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_slack_bound_frac (const Warm_start_slack_bound_fracOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Warm_start_slack_bound_fracType
    getWarm_start_slack_bound_fracDefaultValue ();

    //@}

    /**
     * @name warm_start_slack_bound_push
     *
     * @brief Accessor and modifier functions for the %warm_start_slack_bound_push
     * optional element.
     *
     * same as slack_bound_push for the regular initializer. 
     * The valid range for this real option is [0, inf] and its default value
     * is 0.001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Warm_start_slack_bound_pushType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_slack_bound_pushType > Warm_start_slack_bound_pushOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_slack_bound_pushType, char, ::xsd::cxx::tree::schema_type::double_ > Warm_start_slack_bound_pushTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_slack_bound_pushOptional&
    getWarm_start_slack_bound_push () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_slack_bound_pushOptional&
    getWarm_start_slack_bound_push ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_slack_bound_push (const Warm_start_slack_bound_pushType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_slack_bound_push (const Warm_start_slack_bound_pushOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Warm_start_slack_bound_pushType
    getWarm_start_slack_bound_pushDefaultValue ();

    //@}

    /**
     * @name warm_start_mult_bound_push
     *
     * @brief Accessor and modifier functions for the %warm_start_mult_bound_push
     * optional element.
     *
     * same as mult_bound_push for the regular initializer. 
     * The valid range for this real option is [0, inf] and its default value
     * is 0.001.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Warm_start_mult_bound_pushType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_mult_bound_pushType > Warm_start_mult_bound_pushOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_mult_bound_pushType, char, ::xsd::cxx::tree::schema_type::double_ > Warm_start_mult_bound_pushTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_mult_bound_pushOptional&
    getWarm_start_mult_bound_push () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_mult_bound_pushOptional&
    getWarm_start_mult_bound_push ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_mult_bound_push (const Warm_start_mult_bound_pushType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_mult_bound_push (const Warm_start_mult_bound_pushOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Warm_start_mult_bound_pushType
    getWarm_start_mult_bound_pushDefaultValue ();

    //@}

    /**
     * @name warm_start_mult_init_max
     *
     * @brief Accessor and modifier functions for the %warm_start_mult_init_max
     * optional element.
     *
     * Maximum initial value for the equality multipliers. 
     * The valid range for this real option is [-inf, +inf] and its default
     * value is  1e6.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Warm_start_mult_init_maxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Warm_start_mult_init_maxType > Warm_start_mult_init_maxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Warm_start_mult_init_maxType, char, ::xsd::cxx::tree::schema_type::double_ > Warm_start_mult_init_maxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Warm_start_mult_init_maxOptional&
    getWarm_start_mult_init_max () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Warm_start_mult_init_maxOptional&
    getWarm_start_mult_init_max ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWarm_start_mult_init_max (const Warm_start_mult_init_maxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWarm_start_mult_init_max (const Warm_start_mult_init_maxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Warm_start_mult_init_maxType
    getWarm_start_mult_init_maxDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTWarmStartComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTWarmStartComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTWarmStartComplexType (const IPOPTWarmStartComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTWarmStartComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTWarmStartComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Warm_start_init_pointOptional warm_start_init_point_;
    static const Warm_start_init_pointType warm_start_init_point_default_value_;
    Warm_start_bound_fracOptional warm_start_bound_frac_;
    Warm_start_bound_pushOptional warm_start_bound_push_;
    Warm_start_slack_bound_fracOptional warm_start_slack_bound_frac_;
    Warm_start_slack_bound_pushOptional warm_start_slack_bound_push_;
    Warm_start_mult_bound_pushOptional warm_start_mult_bound_push_;
    Warm_start_mult_init_maxOptional warm_start_mult_init_max_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTInitializationComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTInitializationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name bound_frac
     *
     * @brief Accessor and modifier functions for the %bound_frac
     * optional element.
     *
     * Desired minimum relative distance from the initial point to bound. 
     * Determines how much the initial point might have to be modified in
     * order to be sufficiently inside the bounds (together with
     * "bound_push"). (This is kappa_2 in Section 3.6 of implementation
     * paper.) The valid range for this real option is [0, 0.5]and its
     * default value is 0.01..
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Bound_fracType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Bound_fracType > Bound_fracOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Bound_fracType, char, ::xsd::cxx::tree::schema_type::double_ > Bound_fracTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Bound_fracOptional&
    getBound_frac () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Bound_fracOptional&
    getBound_frac ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBound_frac (const Bound_fracType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBound_frac (const Bound_fracOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Bound_fracType
    getBound_fracDefaultValue ();

    //@}

    /**
     * @name bound_push
     *
     * @brief Accessor and modifier functions for the %bound_push
     * optional element.
     *
     * Desired minimum absolute distance from the initial point to bound. 
     * Determines how much the initial point might have to be modified in
     * order to be sufficiently inside the bounds (together with
     * "bound_frac"). (This is kappa_1 in Section 3.6 of implementation
     * paper.) The valid range for this real option is [0, inf] and its
     * default value is 0.01.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Bound_pushType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Bound_pushType > Bound_pushOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Bound_pushType, char, ::xsd::cxx::tree::schema_type::double_ > Bound_pushTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Bound_pushOptional&
    getBound_push () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Bound_pushOptional&
    getBound_push ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBound_push (const Bound_pushType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBound_push (const Bound_pushOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Bound_pushType
    getBound_pushDefaultValue ();

    //@}

    /**
     * @name slack_bound_frac
     *
     * @brief Accessor and modifier functions for the %slack_bound_frac
     * optional element.
     *
     * Desired minimum relative distance from the initial slack to bound. 
     * Determines how much the initial slack variables might have to be
     * modified in order to be sufficiently inside the inequality bounds
     * (together with "slack_bound_push"). (This is kappa_2 in Section 3.6 of
     * implementation paper.) The valid range for this real option is  [0,
     * 0.5] and its default value is 0.01.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Slack_bound_fracType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Slack_bound_fracType > Slack_bound_fracOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Slack_bound_fracType, char, ::xsd::cxx::tree::schema_type::double_ > Slack_bound_fracTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Slack_bound_fracOptional&
    getSlack_bound_frac () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Slack_bound_fracOptional&
    getSlack_bound_frac ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSlack_bound_frac (const Slack_bound_fracType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSlack_bound_frac (const Slack_bound_fracOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Slack_bound_fracType
    getSlack_bound_fracDefaultValue ();

    //@}

    /**
     * @name slack_bound_push
     *
     * @brief Accessor and modifier functions for the %slack_bound_push
     * optional element.
     *
     * Desired minimum absolute distance from the initial slack to bound. 
     * Determines how much the initial slack variables might have to be
     * modified in order to be sufficiently inside the inequality bounds
     * (together with "slack_bound_frac"). (This is kappa_1 in Section 3.6 of
     * implementation paper.) The valid range for this real option is  [0,
     * inf] and its default value is 0.01.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Slack_bound_pushType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Slack_bound_pushType > Slack_bound_pushOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Slack_bound_pushType, char, ::xsd::cxx::tree::schema_type::double_ > Slack_bound_pushTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Slack_bound_pushOptional&
    getSlack_bound_push () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Slack_bound_pushOptional&
    getSlack_bound_push ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSlack_bound_push (const Slack_bound_pushType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSlack_bound_push (const Slack_bound_pushOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Slack_bound_pushType
    getSlack_bound_pushDefaultValue ();

    //@}

    /**
     * @name bound_mult_init_val
     *
     * @brief Accessor and modifier functions for the %bound_mult_init_val
     * optional element.
     *
     * Initial value for the bound multipliers. 
     * All dual variables corresponding to bound constraints are initialized
     * to this value. The valid range for this real option is  [0, inf] and
     * its default value is 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Bound_mult_init_valType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Bound_mult_init_valType > Bound_mult_init_valOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Bound_mult_init_valType, char, ::xsd::cxx::tree::schema_type::double_ > Bound_mult_init_valTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Bound_mult_init_valOptional&
    getBound_mult_init_val () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Bound_mult_init_valOptional&
    getBound_mult_init_val ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBound_mult_init_val (const Bound_mult_init_valType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBound_mult_init_val (const Bound_mult_init_valOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Bound_mult_init_valType
    getBound_mult_init_valDefaultValue ();

    //@}

    /**
     * @name constr_mult_init_max
     *
     * @brief Accessor and modifier functions for the %constr_mult_init_max
     * optional element.
     *
     * Maximum allowed least-square guess of constraint multipliers. 
     * Determines how large the initial least-square guesses of the
     * constraint multipliers are allowed to be (in max-norm). If the guess
     * is larger than this value, it is discarded and all constraint
     * multipliers are set to zero. This options is also used when
     * initializing the restoration phase. By default,
     * "resto.constr_mult_init_max" (the one used in RestoIterateInitializer)
     * is set to zero. The valid range for this real option is [0, inf] and
     * its default value is 1000.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Constr_mult_init_maxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Constr_mult_init_maxType > Constr_mult_init_maxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Constr_mult_init_maxType, char, ::xsd::cxx::tree::schema_type::double_ > Constr_mult_init_maxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Constr_mult_init_maxOptional&
    getConstr_mult_init_max () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Constr_mult_init_maxOptional&
    getConstr_mult_init_max ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstr_mult_init_max (const Constr_mult_init_maxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstr_mult_init_max (const Constr_mult_init_maxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Constr_mult_init_maxType
    getConstr_mult_init_maxDefaultValue ();

    //@}

    /**
     * @name bound_mult_init_method
     *
     * @brief Accessor and modifier functions for the %bound_mult_init_method
     * optional element.
     *
     * Initialization method for bound multipliers 
     * This option defines how the iterates for the bound multipliers are
     * initialized. If "constant" is chosen, then all bound multipliers are
     * initialized to the value of "bound_mult_init_val". If "mu-based" is
     * chosen, the each value is initialized to the the value of "mu_init"
     * divided by the corresponding slack variable. This latter option might
     * be useful if the starting point is close to the optimal solution. The
     * default value for this string option is "constant". 
     * Possible values:
     * constant: set all bound multipliers to the value of
     * bound_mult_init_val
     * mu-based: initialize to mu_init/x_slack
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Bound_mult_init_method Bound_mult_init_methodType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Bound_mult_init_methodType > Bound_mult_init_methodOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Bound_mult_init_methodType, char > Bound_mult_init_methodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Bound_mult_init_methodOptional&
    getBound_mult_init_method () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Bound_mult_init_methodOptional&
    getBound_mult_init_method ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBound_mult_init_method (const Bound_mult_init_methodType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBound_mult_init_method (const Bound_mult_init_methodOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBound_mult_init_method (::std::auto_ptr< Bound_mult_init_methodType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Bound_mult_init_methodType&
    getBound_mult_init_methodDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTInitializationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTInitializationComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTInitializationComplexType (const IPOPTInitializationComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTInitializationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTInitializationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Bound_fracOptional bound_frac_;
    Bound_pushOptional bound_push_;
    Slack_bound_fracOptional slack_bound_frac_;
    Slack_bound_pushOptional slack_bound_push_;
    Bound_mult_init_valOptional bound_mult_init_val_;
    Constr_mult_init_maxOptional constr_mult_init_max_;
    Bound_mult_init_methodOptional bound_mult_init_method_;
    static const Bound_mult_init_methodType bound_mult_init_method_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IPOPTBarrierParameterComplexType schema type.
   *
   * @nosubgrouping
   */
  class IPOPTBarrierParameterComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mehrotra_algorithm
     *
     * @brief Accessor and modifier functions for the %mehrotra_algorithm
     * optional element.
     *
     * Indicates if we want to do Mehrotra's algorithm. 
     * If set to yes, Ipopt runs as Mehrotra's predictor-corrector algorithm.
     * This works usually very well for LPs and convex QPs. This
     * automatically disables the line search, and chooses the (unglobalized)
     * adaptive mu strategy with the "probing" oracle, and uses
     * "corrector_type=affine" without any safeguards; you should not set any
     * of those options explicitly in addition. Also, unless otherwise
     * specified, the values of "bound_push", "bound_frac", and
     * "bound_mult_init_val" are set more aggressive, and sets
     * "alpha_for_y=bound_mult". The default value for this string option is
     * "no". 
     * Possible values:
     * no: Do the usual Ipopt algorithm.
     * yes: Do Mehrotra's predictor-corrector algorithm.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Mehrotra_algorithm Mehrotra_algorithmType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mehrotra_algorithmType > Mehrotra_algorithmOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mehrotra_algorithmType, char > Mehrotra_algorithmTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mehrotra_algorithmOptional&
    getMehrotra_algorithm () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mehrotra_algorithmOptional&
    getMehrotra_algorithm ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMehrotra_algorithm (const Mehrotra_algorithmType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMehrotra_algorithm (const Mehrotra_algorithmOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMehrotra_algorithm (::std::auto_ptr< Mehrotra_algorithmType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Mehrotra_algorithmType&
    getMehrotra_algorithmDefaultValue ();

    //@}

    /**
     * @name mu_strategy
     *
     * @brief Accessor and modifier functions for the %mu_strategy
     * optional element.
     *
     * Update strategy for barrier parameter. 
     * Determines which barrier parameter update strategy is to be used. The
     * default value for this string option is "monotone". 
     * Possible values:
     * monotone: use the monotone (Fiacco-McCormick) strategy
     * adaptive: use the adaptive update strategy
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Mu_strategy Mu_strategyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_strategyType > Mu_strategyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_strategyType, char > Mu_strategyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_strategyOptional&
    getMu_strategy () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_strategyOptional&
    getMu_strategy ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_strategy (const Mu_strategyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_strategy (const Mu_strategyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMu_strategy (::std::auto_ptr< Mu_strategyType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Mu_strategyType&
    getMu_strategyDefaultValue ();

    //@}

    /**
     * @name mu_oracle
     *
     * @brief Accessor and modifier functions for the %mu_oracle
     * optional element.
     *
     * Oracle for a new barrier parameter in the adaptive strategy. 
     * Determines how a new barrier parameter is computed in each "free-mode"
     * iteration of the adaptive barrier parameter strategy. (Only considered
     * if "adaptive" is selected for option "mu_strategy"). The default value
     * for this string option is "quality-function". 
     * Possible values:
     * probing: Mehrotra's probing heuristic
     * loqo: LOQO's centrality rule
     * quality-function: minimize a quality function
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Mu_oracle Mu_oracleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_oracleType > Mu_oracleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_oracleType, char > Mu_oracleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_oracleOptional&
    getMu_oracle () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_oracleOptional&
    getMu_oracle ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_oracle (const Mu_oracleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_oracle (const Mu_oracleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMu_oracle (::std::auto_ptr< Mu_oracleType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Mu_oracleType&
    getMu_oracleDefaultValue ();

    //@}

    /**
     * @name quality_function_max_section_steps
     *
     * @brief Accessor and modifier functions for the %quality_function_max_section_steps
     * optional element.
     *
     * Maximum number of search steps during direct search procedure
     * determining the optimal centering parameter. 
     * The golden section search is performed for the quality function based
     * mu oracle. (Only used if option "mu_oracle" is set to
     * "quality-function".) The valid range for this integer option is [0,
     * inf] and its default value is 8.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int Quality_function_max_section_stepsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Quality_function_max_section_stepsType > Quality_function_max_section_stepsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Quality_function_max_section_stepsType, char > Quality_function_max_section_stepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Quality_function_max_section_stepsOptional&
    getQuality_function_max_section_steps () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Quality_function_max_section_stepsOptional&
    getQuality_function_max_section_steps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQuality_function_max_section_steps (const Quality_function_max_section_stepsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQuality_function_max_section_steps (const Quality_function_max_section_stepsOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Quality_function_max_section_stepsType
    getQuality_function_max_section_stepsDefaultValue ();

    //@}

    /**
     * @name fixed_mu_oracle
     *
     * @brief Accessor and modifier functions for the %fixed_mu_oracle
     * optional element.
     *
     * Oracle for the barrier parameter when switching to fixed mode. 
     * Determines how the first value of the barrier parameter should be
     * computed when switching to the "monotone mode" in the adaptive
     * strategy. (Only considered if "adaptive" is selected for option
     * "mu_strategy".) The default value for this string option is
     * "average_compl". 
     * Possible values:
     * probing: Mehrotra's probing heuristic
     * loqo: LOQO's centrality rule
     * quality-function: minimize a quality function
     * average_compl: base on current average complementarity
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Fixed_mu_oracle Fixed_mu_oracleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Fixed_mu_oracleType > Fixed_mu_oracleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Fixed_mu_oracleType, char > Fixed_mu_oracleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Fixed_mu_oracleOptional&
    getFixed_mu_oracle () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Fixed_mu_oracleOptional&
    getFixed_mu_oracle ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFixed_mu_oracle (const Fixed_mu_oracleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFixed_mu_oracle (const Fixed_mu_oracleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFixed_mu_oracle (::std::auto_ptr< Fixed_mu_oracleType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Fixed_mu_oracleType&
    getFixed_mu_oracleDefaultValue ();

    //@}

    /**
     * @name adaptive_mu_globalization
     *
     * @brief Accessor and modifier functions for the %adaptive_mu_globalization
     * optional element.
     *
     * Globalization strategy for the adaptive mu selection mode. 
     * To achieve global convergence of the adaptive version, the algorithm
     * has to switch to the monotone mode (Fiacco-McCormick approach) when
     * convergence does not seem to appear. This option sets the criterion
     * used to decide when to do this switch. (Only used if option
     * "mu_strategy" is chosen as "adaptive".) The default value for this
     * string option is "obj-constr-filter". 
     * Possible values:
     * kkt-error: nonmonotone decrease of kkt-error
     * obj-constr-filter: 2-dim filter for objective and constraint violation
     * never-monotone-mode: disables globalization
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Adaptive_mu_globalization Adaptive_mu_globalizationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Adaptive_mu_globalizationType > Adaptive_mu_globalizationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Adaptive_mu_globalizationType, char > Adaptive_mu_globalizationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Adaptive_mu_globalizationOptional&
    getAdaptive_mu_globalization () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Adaptive_mu_globalizationOptional&
    getAdaptive_mu_globalization ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAdaptive_mu_globalization (const Adaptive_mu_globalizationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAdaptive_mu_globalization (const Adaptive_mu_globalizationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAdaptive_mu_globalization (::std::auto_ptr< Adaptive_mu_globalizationType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Adaptive_mu_globalizationType&
    getAdaptive_mu_globalizationDefaultValue ();

    //@}

    /**
     * @name mu_init
     *
     * @brief Accessor and modifier functions for the %mu_init
     * optional element.
     *
     * Initial value for the barrier parameter. 
     * This option determines the initial value for the barrier parameter
     * (mu). It is only relevant in the monotone, Fiacco-McCormick version of
     * the algorithm. (i.e., if "mu_strategy" is chosen as "monotone") The
     * valid range for this real option is [0,inf] and its default value
     * is0.1..
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_initType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_initType > Mu_initOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_initType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_initTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_initOptional&
    getMu_init () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_initOptional&
    getMu_init ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_init (const Mu_initType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_init (const Mu_initOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_initType
    getMu_initDefaultValue ();

    //@}

    /**
     * @name mu_max_fact
     *
     * @brief Accessor and modifier functions for the %mu_max_fact
     * optional element.
     *
     * Factor for initialization of maximum value for barrier parameter. 
     * This option determines the upper bound on the barrier parameter. This
     * upper bound is computed as the average complementarity at the initial
     * point times the value of this option. (Only used if option
     * "mu_strategy" is chosen as "adaptive".) The valid range for this real
     * option is [0, inf] and its default value is 1000.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_max_factType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_max_factType > Mu_max_factOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_max_factType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_max_factTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_max_factOptional&
    getMu_max_fact () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_max_factOptional&
    getMu_max_fact ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_max_fact (const Mu_max_factType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_max_fact (const Mu_max_factOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_max_factType
    getMu_max_factDefaultValue ();

    //@}

    /**
     * @name mu_max
     *
     * @brief Accessor and modifier functions for the %mu_max
     * optional element.
     *
     * Maximum value for barrier parameter. 
     * This option specifies an upper bound on the barrier parameter in the
     * adaptive mu selection mode. If this option is set, it overwrites the
     * effect of mu_max_fact. (Only used if option "mu_strategy" is chosen as
     * "adaptive".) The valid range for this real option is [0, inf] and its
     * default value is 100000.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_maxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_maxType > Mu_maxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_maxType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_maxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_maxOptional&
    getMu_max () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_maxOptional&
    getMu_max ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_max (const Mu_maxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_max (const Mu_maxOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_maxType
    getMu_maxDefaultValue ();

    //@}

    /**
     * @name mu_min
     *
     * @brief Accessor and modifier functions for the %mu_min
     * optional element.
     *
     * Minimum value for barrier parameter. 
     * This option specifies the lower bound on the barrier parameter in the
     * adaptive mu selection mode. By default, it is set to the minimum of
     * 1e-11 and min("tol","compl_inf_tol")/("barrier_tol_factor"+1), which
     * should be a reasonable value. (Only used if option "mu_strategy" is
     * chosen as "adaptive".) The valid range for this real option is  [0,
     * inf] and its default value is 1e-11.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_minType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_minType > Mu_minOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_minType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_minTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_minOptional&
    getMu_min () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_minOptional&
    getMu_min ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_min (const Mu_minType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_min (const Mu_minOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_minType
    getMu_minDefaultValue ();

    //@}

    /**
     * @name mu_target
     *
     * @brief Accessor and modifier functions for the %mu_target
     * optional element.
     *
     * Desired value of complementarity. 
     * Usually, the barrier parameter is driven to zero and the termination
     * test for complementarity is measured with respect to zero
     * complementarity. However, in some cases it might be desired to have
     * Ipopt solve barrier problem for strictly positive value of the barrier
     * parameter. In this case, the value of "mu_target" specifies the final
     * value of the barrier parameter, and the termination tests are then
     * defined with respect to the barrier problem for this value of the
     * barrier parameter. The valid range for this real option is [0, inf]
     * and its default value is 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_targetType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_targetType > Mu_targetOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_targetType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_targetTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_targetOptional&
    getMu_target () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_targetOptional&
    getMu_target ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_target (const Mu_targetType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_target (const Mu_targetOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_targetType
    getMu_targetDefaultValue ();

    //@}

    /**
     * @name barrier_tol_factor
     *
     * @brief Accessor and modifier functions for the %barrier_tol_factor
     * optional element.
     *
     * Factor for mu in barrier stop test. 
     * The convergence tolerance for each barrier problem in the monotone
     * mode is the value of the barrier parameter times "barrier_tol_factor".
     * This option is also used in the adaptive mu strategy during the
     * monotone mode. (This is kappa_epsilon in implementation paper). The
     * valid range for this real option is [0, inf]and its default value is
     * 10.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Barrier_tol_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Barrier_tol_factorType > Barrier_tol_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Barrier_tol_factorType, char, ::xsd::cxx::tree::schema_type::double_ > Barrier_tol_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Barrier_tol_factorOptional&
    getBarrier_tol_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Barrier_tol_factorOptional&
    getBarrier_tol_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBarrier_tol_factor (const Barrier_tol_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBarrier_tol_factor (const Barrier_tol_factorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Barrier_tol_factorType
    getBarrier_tol_factorDefaultValue ();

    //@}

    /**
     * @name mu_linear_decrease_factor
     *
     * @brief Accessor and modifier functions for the %mu_linear_decrease_factor
     * optional element.
     *
     * Determines linear decrease rate of barrier parameter. 
     * For the Fiacco-McCormick update procedure the new barrier parameter mu
     * is obtained by taking the minimum of mu*"mu_linear_decrease_factor"
     * and mu"superlinear_decrease_power". (This is kappa_mu in
     * implementation paper.) This option is also used in the adaptive mu
     * strategy during the monotone mode. The valid range for this real
     * option is[0,1] and its default value is 0.2
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_linear_decrease_factorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_linear_decrease_factorType > Mu_linear_decrease_factorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_linear_decrease_factorType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_linear_decrease_factorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_linear_decrease_factorOptional&
    getMu_linear_decrease_factor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_linear_decrease_factorOptional&
    getMu_linear_decrease_factor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_linear_decrease_factor (const Mu_linear_decrease_factorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_linear_decrease_factor (const Mu_linear_decrease_factorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_linear_decrease_factorType
    getMu_linear_decrease_factorDefaultValue ();

    //@}

    /**
     * @name mu_superlinear_decrease_power
     *
     * @brief Accessor and modifier functions for the %mu_superlinear_decrease_power
     * optional element.
     *
     * Determines superlinear decrease rate of barrier parameter. 
     * For the Fiacco-McCormick update procedure the new barrier parameter mu
     * is obtained by taking the minimum of mu*"mu_linear_decrease_factor"
     * and mu"superlinear_decrease_power". (This is theta_mu in
     * implementation paper.) This option is also used in the adaptive mu
     * strategy during the monotone mode. The valid range for this real
     * option is  [1,2] and its default value is 1.5.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Mu_superlinear_decrease_powerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Mu_superlinear_decrease_powerType > Mu_superlinear_decrease_powerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Mu_superlinear_decrease_powerType, char, ::xsd::cxx::tree::schema_type::double_ > Mu_superlinear_decrease_powerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Mu_superlinear_decrease_powerOptional&
    getMu_superlinear_decrease_power () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Mu_superlinear_decrease_powerOptional&
    getMu_superlinear_decrease_power ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMu_superlinear_decrease_power (const Mu_superlinear_decrease_powerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMu_superlinear_decrease_power (const Mu_superlinear_decrease_powerOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Mu_superlinear_decrease_powerType
    getMu_superlinear_decrease_powerDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IPOPTBarrierParameterComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IPOPTBarrierParameterComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IPOPTBarrierParameterComplexType (const IPOPTBarrierParameterComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IPOPTBarrierParameterComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IPOPTBarrierParameterComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Mehrotra_algorithmOptional mehrotra_algorithm_;
    static const Mehrotra_algorithmType mehrotra_algorithm_default_value_;
    Mu_strategyOptional mu_strategy_;
    static const Mu_strategyType mu_strategy_default_value_;
    Mu_oracleOptional mu_oracle_;
    static const Mu_oracleType mu_oracle_default_value_;
    Quality_function_max_section_stepsOptional quality_function_max_section_steps_;
    Fixed_mu_oracleOptional fixed_mu_oracle_;
    static const Fixed_mu_oracleType fixed_mu_oracle_default_value_;
    Adaptive_mu_globalizationOptional adaptive_mu_globalization_;
    static const Adaptive_mu_globalizationType adaptive_mu_globalization_default_value_;
    Mu_initOptional mu_init_;
    Mu_max_factOptional mu_max_fact_;
    Mu_maxOptional mu_max_;
    Mu_minOptional mu_min_;
    Mu_targetOptional mu_target_;
    Barrier_tol_factorOptional barrier_tol_factor_;
    Mu_linear_decrease_factorOptional mu_linear_decrease_factor_;
    Mu_superlinear_decrease_powerOptional mu_superlinear_decrease_power_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SAComplexType schema type.
   *
   * @nosubgrouping
   */
  class SAComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ftoll
     *
     * @brief Accessor and modifier functions for the %ftoll
     * optional element.
     *
     * ???
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType FtollType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FtollType > FtollOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FtollType, char > FtollTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FtollOptional&
    getFtoll () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FtollOptional&
    getFtoll ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFtoll (const FtollType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFtoll (const FtollOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFtoll (::std::auto_ptr< FtollType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const FtollType&
    getFtollDefaultValue ();

    //@}

    /**
     * @name dels
     *
     * @brief Accessor and modifier functions for the %dels
     * optional element.
     *
     * ???
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType DelsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DelsType > DelsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DelsType, char > DelsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DelsOptional&
    getDels () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DelsOptional&
    getDels ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDels (const DelsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDels (const DelsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDels (::std::auto_ptr< DelsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const DelsType&
    getDelsDefaultValue ();

    //@}

    /**
     * @name max_iter
     *
     * @brief Accessor and modifier functions for the %max_iter
     * optional element.
     *
     * Maximum number of iterations
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer Max_iterType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_iterType > Max_iterOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_iterType, char > Max_iterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_iterOptional&
    getMax_iter () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_iterOptional&
    getMax_iter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_iter (const Max_iterType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_iter (const Max_iterOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Max_iterType
    getMax_iterDefaultValue ();

    //@}

    /**
     * @name max_cpu_time
     *
     * @brief Accessor and modifier functions for the %max_cpu_time
     * optional element.
     *
     * maximum cpu time for executing the optimization
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Max_cpu_timeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Max_cpu_timeType > Max_cpu_timeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Max_cpu_timeType, char > Max_cpu_timeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Max_cpu_timeOptional&
    getMax_cpu_time () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Max_cpu_timeOptional&
    getMax_cpu_time ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMax_cpu_time (const Max_cpu_timeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMax_cpu_time (const Max_cpu_timeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMax_cpu_time (::std::auto_ptr< Max_cpu_timeType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const Max_cpu_timeType&
    getMax_cpu_timeDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SAComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SAComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SAComplexType (const SAComplexType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SAComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SAComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FtollOptional ftoll_;
    static const FtollType ftoll_default_value_;
    DelsOptional dels_;
    static const DelsType dels_default_value_;
    Max_iterOptional max_iter_;
    Max_cpu_timeOptional max_cpu_time_;
    static const Max_cpu_timeType max_cpu_time_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LoggingComplexType schema type.
   *
   * @nosubgrouping
   */
  class LoggingComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name logLevel
     *
     * @brief Accessor and modifier functions for the %logLevel
     * required element.
     *
     * definition of the logging level, 0 = fatal error, 1 = error, 2 =
     * warning, 3 = info, 4 = debug messages
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalIntegerSimpleType LogLevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LogLevelType, char > LogLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LogLevelType&
    getLogLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LogLevelType&
    getLogLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLogLevel (const LogLevelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLogLevel (::std::auto_ptr< LogLevelType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const LogLevelType&
    getLogLevelDefaultValue ();

    //@}

    /**
     * @name eventCode
     *
     * @brief Accessor and modifier functions for the %eventCode
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalBooleanSimpleType EventCodeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EventCodeType > EventCodeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EventCodeType, char > EventCodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EventCodeOptional&
    getEventCode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EventCodeOptional&
    getEventCode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEventCode (const EventCodeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEventCode (const EventCodeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEventCode (::std::auto_ptr< EventCodeType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const EventCodeType&
    getEventCodeDefaultValue ();

    //@}

    /**
     * @name flushing
     *
     * @brief Accessor and modifier functions for the %flushing
     * required element.
     *
     * set flushing of the diagnostics file after each new message (=true) or
     * at the end of the program execution (=false)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalBooleanSimpleType FlushingType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlushingType, char > FlushingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FlushingType&
    getFlushing () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FlushingType&
    getFlushing ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlushing (const FlushingType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFlushing (::std::auto_ptr< FlushingType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const FlushingType&
    getFlushingDefaultValue ();

    //@}

    /**
     * @name constraintViolationTolerance
     *
     * @brief Accessor and modifier functions for the %constraintViolationTolerance
     * optional element.
     *
     * tolerance for scaled constraints for which a constraint violation is
     * detected
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ConstraintViolationToleranceType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConstraintViolationToleranceType > ConstraintViolationToleranceOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstraintViolationToleranceType, char > ConstraintViolationToleranceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConstraintViolationToleranceOptional&
    getConstraintViolationTolerance () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ConstraintViolationToleranceOptional&
    getConstraintViolationTolerance ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstraintViolationTolerance (const ConstraintViolationToleranceType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstraintViolationTolerance (const ConstraintViolationToleranceOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConstraintViolationTolerance (::std::auto_ptr< ConstraintViolationToleranceType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const ConstraintViolationToleranceType&
    getConstraintViolationToleranceDefaultValue ();

    //@}

    /**
     * @name reportConstraintViolation
     *
     * @brief Accessor and modifier functions for the %reportConstraintViolation
     * optional element.
     *
     * report constraint violation in diagnostics
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReportConstraintViolation ReportConstraintViolationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReportConstraintViolationType > ReportConstraintViolationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReportConstraintViolationType, char > ReportConstraintViolationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReportConstraintViolationOptional&
    getReportConstraintViolation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReportConstraintViolationOptional&
    getReportConstraintViolation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReportConstraintViolation (const ReportConstraintViolationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReportConstraintViolation (const ReportConstraintViolationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReportConstraintViolation (::std::auto_ptr< ReportConstraintViolationType > p);

    //@}

    /**
     * @name outputObjectiveFunction
     *
     * @brief Accessor and modifier functions for the %outputObjectiveFunction
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FunctionOutputEnumStringType OutputObjectiveFunctionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OutputObjectiveFunctionType > OutputObjectiveFunctionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputObjectiveFunctionType, char > OutputObjectiveFunctionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OutputObjectiveFunctionOptional&
    getOutputObjectiveFunction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OutputObjectiveFunctionOptional&
    getOutputObjectiveFunction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutputObjectiveFunction (const OutputObjectiveFunctionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOutputObjectiveFunction (const OutputObjectiveFunctionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOutputObjectiveFunction (::std::auto_ptr< OutputObjectiveFunctionType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const OutputObjectiveFunctionType&
    getOutputObjectiveFunctionDefaultValue ();

    //@}

    /**
     * @name outputConstraints
     *
     * @brief Accessor and modifier functions for the %outputConstraints
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FunctionOutputEnumStringType OutputConstraintsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OutputConstraintsType > OutputConstraintsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputConstraintsType, char > OutputConstraintsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OutputConstraintsOptional&
    getOutputConstraints () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OutputConstraintsOptional&
    getOutputConstraints ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutputConstraints (const OutputConstraintsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOutputConstraints (const OutputConstraintsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOutputConstraints (::std::auto_ptr< OutputConstraintsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const OutputConstraintsType&
    getOutputConstraintsDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LoggingComplexType (const LogLevelType&,
                        const FlushingType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LoggingComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LoggingComplexType (const LoggingComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LoggingComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LoggingComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LogLevelType > logLevel_;
    static const LogLevelType logLevel_default_value_;
    EventCodeOptional eventCode_;
    static const EventCodeType eventCode_default_value_;
    ::xsd::cxx::tree::one< FlushingType > flushing_;
    static const FlushingType flushing_default_value_;
    ConstraintViolationToleranceOptional constraintViolationTolerance_;
    static const ConstraintViolationToleranceType constraintViolationTolerance_default_value_;
    ReportConstraintViolationOptional reportConstraintViolation_;
    OutputObjectiveFunctionOptional outputObjectiveFunction_;
    static const OutputObjectiveFunctionType outputObjectiveFunction_default_value_;
    OutputConstraintsOptional outputConstraints_;
    static const OutputConstraintsType outputConstraints_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UserDefinedStateExportComplexType schema type.
   *
   * @nosubgrouping
   */
  class UserDefinedStateExportComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name startDate
     *
     * @brief Accessor and modifier functions for the %startDate
     * required element.
     *
     * Start date and time for exporting state files.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTimeComplexType StartDateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StartDateType, char > StartDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StartDateType&
    getStartDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StartDateType&
    getStartDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStartDate (const StartDateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStartDate (::std::auto_ptr< StartDateType > p);

    //@}

    /**
     * @name endDate
     *
     * @brief Accessor and modifier functions for the %endDate
     * required element.
     *
     * End date and time for exporting state files.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTimeComplexType EndDateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EndDateType, char > EndDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EndDateType&
    getEndDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EndDateType&
    getEndDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEndDate (const EndDateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEndDate (::std::auto_ptr< EndDateType > p);

    //@}

    /**
     * @name stateTimeStep
     *
     * @brief Accessor and modifier functions for the %stateTimeStep
     * optional element.
     *
     * Step in seconds for exporting state files
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double StateTimeStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateTimeStepType > StateTimeStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateTimeStepType, char, ::xsd::cxx::tree::schema_type::double_ > StateTimeStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateTimeStepOptional&
    getStateTimeStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateTimeStepOptional&
    getStateTimeStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateTimeStep (const StateTimeStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStateTimeStep (const StateTimeStepOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static StateTimeStepType
    getStateTimeStepDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UserDefinedStateExportComplexType (const StartDateType&,
                                       const EndDateType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    UserDefinedStateExportComplexType (::std::auto_ptr< StartDateType >&,
                                       ::std::auto_ptr< EndDateType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UserDefinedStateExportComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UserDefinedStateExportComplexType (const UserDefinedStateExportComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UserDefinedStateExportComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UserDefinedStateExportComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StartDateType > startDate_;
    ::xsd::cxx::tree::one< EndDateType > endDate_;
    StateTimeStepOptional stateTimeStep_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ModeClosedLoopComplexType schema type.
   *
   * @nosubgrouping
   */
  class ModeClosedLoopComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name recedingHorizon
     *
     * @brief Accessor and modifier functions for the %recedingHorizon
     * required element.
     *
     * Number of time steps after which the optimization is repeated
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer RecedingHorizonType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RecedingHorizonType, char > RecedingHorizonTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RecedingHorizonType&
    getRecedingHorizon () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RecedingHorizonType&
    getRecedingHorizon ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRecedingHorizon (const RecedingHorizonType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static RecedingHorizonType
    getRecedingHorizonDefaultValue ();

    //@}

    /**
     * @name forecastHorizon
     *
     * @brief Accessor and modifier functions for the %forecastHorizon
     * required element.
     *
     * Number of time steps of forecasts in the predictive control mode
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer ForecastHorizonType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ForecastHorizonType, char > ForecastHorizonTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ForecastHorizonType&
    getForecastHorizon () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ForecastHorizonType&
    getForecastHorizon ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setForecastHorizon (const ForecastHorizonType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ForecastHorizonType
    getForecastHorizonDefaultValue ();

    //@}

    /**
     * @name optimization
     *
     * @brief Accessor and modifier functions for the %optimization
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ModeOptimizationComplexType OptimizationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OptimizationType, char > OptimizationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OptimizationType&
    getOptimization () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OptimizationType&
    getOptimization ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOptimization (const OptimizationType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOptimization (::std::auto_ptr< OptimizationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ModeClosedLoopComplexType (const RecedingHorizonType&,
                               const ForecastHorizonType&,
                               const OptimizationType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ModeClosedLoopComplexType (const RecedingHorizonType&,
                               const ForecastHorizonType&,
                               ::std::auto_ptr< OptimizationType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ModeClosedLoopComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ModeClosedLoopComplexType (const ModeClosedLoopComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ModeClosedLoopComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ModeClosedLoopComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RecedingHorizonType > recedingHorizon_;
    ::xsd::cxx::tree::one< ForecastHorizonType > forecastHorizon_;
    ::xsd::cxx::tree::one< OptimizationType > optimization_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParallelizationComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParallelizationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nThread
     *
     * @brief Accessor and modifier functions for the %nThread
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int NThreadType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NThreadType > NThreadOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NThreadType, char > NThreadTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NThreadOptional&
    getNThread () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NThreadOptional&
    getNThread ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNThread (const NThreadType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNThread (const NThreadOptional& x);

    //@}

    /**
     * @name simulation
     *
     * @brief Accessor and modifier functions for the %simulation
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParallelModeEnumStringType SimulationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SimulationType > SimulationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimulationType, char > SimulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SimulationOptional&
    getSimulation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SimulationOptional&
    getSimulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimulation (const SimulationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSimulation (const SimulationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSimulation (::std::auto_ptr< SimulationType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const SimulationType&
    getSimulationDefaultValue ();

    //@}

    /**
     * @name constraints
     *
     * @brief Accessor and modifier functions for the %constraints
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParallelModeEnumStringType ConstraintsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConstraintsType > ConstraintsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstraintsType, char > ConstraintsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConstraintsOptional&
    getConstraints () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ConstraintsOptional&
    getConstraints ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstraints (const ConstraintsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstraints (const ConstraintsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConstraints (::std::auto_ptr< ConstraintsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const ConstraintsType&
    getConstraintsDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParallelizationComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParallelizationComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParallelizationComplexType (const ParallelizationComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParallelizationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParallelizationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NThreadOptional nThread_;
    SimulationOptional simulation_;
    static const SimulationType simulation_default_value_;
    ConstraintsOptional constraints_;
    static const ConstraintsType constraints_default_value_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ParallelModeEnumStringType
   * schema type.
   */
  class ParallelModeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      NONE,
      ENSEMBLE,
      INTERNAL,
      ENSEMBLE_INTERNAL
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    ParallelModeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    ParallelModeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    ParallelModeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    ParallelModeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParallelModeEnumStringType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParallelModeEnumStringType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParallelModeEnumStringType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParallelModeEnumStringType (const ParallelModeEnumStringType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParallelModeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    ParallelModeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_ParallelModeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_ParallelModeEnumStringType_convert () const;

    public:
    static const char* const _xsd_ParallelModeEnumStringType_literals_[4];
    static const Value _xsd_ParallelModeEnumStringType_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %OptimizerModeEnumStringType
   * schema type.
   */
  class OptimizerModeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      SEQUENTIAL,
      PARALLEL
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    OptimizerModeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    OptimizerModeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    OptimizerModeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    OptimizerModeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OptimizerModeEnumStringType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OptimizerModeEnumStringType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OptimizerModeEnumStringType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OptimizerModeEnumStringType (const OptimizerModeEnumStringType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OptimizerModeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    OptimizerModeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_OptimizerModeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_OptimizerModeEnumStringType_convert () const;

    public:
    static const char* const _xsd_OptimizerModeEnumStringType_literals_[2];
    static const Value _xsd_OptimizerModeEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ParameterFileTypeEnumStringType
   * schema type.
   */
  class ParameterFileTypeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      TREEVECTOR,
      PIMODELPARAMETERS
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    ParameterFileTypeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    ParameterFileTypeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    ParameterFileTypeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    ParameterFileTypeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterFileTypeEnumStringType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterFileTypeEnumStringType (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterFileTypeEnumStringType (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterFileTypeEnumStringType (const ParameterFileTypeEnumStringType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterFileTypeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    ParameterFileTypeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_ParameterFileTypeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_ParameterFileTypeEnumStringType_convert () const;

    public:
    static const char* const _xsd_ParameterFileTypeEnumStringType_literals_[2];
    static const Value _xsd_ParameterFileTypeEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ParameterFilePrefixEnumStringType
   * schema type.
   */
  class ParameterFilePrefixEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      NONE,
      LOCATIONID
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    ParameterFilePrefixEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    ParameterFilePrefixEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    ParameterFilePrefixEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    ParameterFilePrefixEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterFilePrefixEnumStringType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterFilePrefixEnumStringType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterFilePrefixEnumStringType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterFilePrefixEnumStringType (const ParameterFilePrefixEnumStringType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterFilePrefixEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    ParameterFilePrefixEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_ParameterFilePrefixEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_ParameterFilePrefixEnumStringType_convert () const;

    public:
    static const char* const _xsd_ParameterFilePrefixEnumStringType_literals_[2];
    static const Value _xsd_ParameterFilePrefixEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %PeriodEnumStringType
   * schema type.
   */
  class PeriodEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      COMPLETE,
      UPDATE,
      FORECAST
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    PeriodEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    PeriodEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    PeriodEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    PeriodEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PeriodEnumStringType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PeriodEnumStringType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PeriodEnumStringType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PeriodEnumStringType (const PeriodEnumStringType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PeriodEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    PeriodEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_PeriodEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_PeriodEnumStringType_convert () const;

    public:
    static const char* const _xsd_PeriodEnumStringType_literals_[3];
    static const Value _xsd_PeriodEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %FunctionOutputEnumStringType
   * schema type.
   */
  class FunctionOutputEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      NONE,
      VALUE,
      DERIVATIVE,
      VALUE_DERIVATIVE
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    FunctionOutputEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    FunctionOutputEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    FunctionOutputEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    FunctionOutputEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FunctionOutputEnumStringType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FunctionOutputEnumStringType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FunctionOutputEnumStringType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FunctionOutputEnumStringType (const FunctionOutputEnumStringType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FunctionOutputEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    FunctionOutputEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_FunctionOutputEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_FunctionOutputEnumStringType_convert () const;

    public:
    static const char* const _xsd_FunctionOutputEnumStringType_literals_[4];
    static const Value _xsd_FunctionOutputEnumStringType_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %algorithm
   * schema type.
   */
  class Algorithm: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      ipopt,
      ipopth,
      conopt
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Algorithm (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Algorithm (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Algorithm (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Algorithm (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Algorithm (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Algorithm (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Algorithm (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Algorithm (const Algorithm& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Algorithm*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Algorithm&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Algorithm_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Algorithm_convert () const;

    public:
    static const char* const _xsd_Algorithm_literals_[3];
    static const Value _xsd_Algorithm_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %print_level schema type.
   *
   * @nosubgrouping
   */
  class Print_level: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Print_level (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_level (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_level (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_level (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Print_level (const Print_level& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Print_level*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Print_level ();
  };

  /**
   * @brief Enumeration class corresponding to the %print_user_options
   * schema type.
   */
  class Print_user_options: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Print_user_options (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Print_user_options (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Print_user_options (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Print_user_options (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_user_options (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_user_options (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_user_options (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Print_user_options (const Print_user_options& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Print_user_options*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Print_user_options&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Print_user_options_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Print_user_options_convert () const;

    public:
    static const char* const _xsd_Print_user_options_literals_[2];
    static const Value _xsd_Print_user_options_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %print_options_documentation
   * schema type.
   */
  class Print_options_documentation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Print_options_documentation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Print_options_documentation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Print_options_documentation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Print_options_documentation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_options_documentation (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_options_documentation (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_options_documentation (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Print_options_documentation (const Print_options_documentation& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Print_options_documentation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Print_options_documentation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Print_options_documentation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Print_options_documentation_convert () const;

    public:
    static const char* const _xsd_Print_options_documentation_literals_[2];
    static const Value _xsd_Print_options_documentation_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %print_timing_statistics
   * schema type.
   */
  class Print_timing_statistics: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Print_timing_statistics (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Print_timing_statistics (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Print_timing_statistics (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Print_timing_statistics (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_timing_statistics (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_timing_statistics (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Print_timing_statistics (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Print_timing_statistics (const Print_timing_statistics& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Print_timing_statistics*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Print_timing_statistics&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Print_timing_statistics_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Print_timing_statistics_convert () const;

    public:
    static const char* const _xsd_Print_timing_statistics_literals_[2];
    static const Value _xsd_Print_timing_statistics_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %file_print_level schema type.
   *
   * @nosubgrouping
   */
  class File_print_level: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    File_print_level (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    File_print_level (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    File_print_level (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    File_print_level (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    File_print_level (const File_print_level& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual File_print_level*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~File_print_level ();
  };

  /**
   * @brief Enumeration class corresponding to the %nlp_scaling_method
   * schema type.
   */
  class Nlp_scaling_method: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      user_scaling,
      gradient_based
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Nlp_scaling_method (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Nlp_scaling_method (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Nlp_scaling_method (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Nlp_scaling_method (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_method (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_method (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_method (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nlp_scaling_method (const Nlp_scaling_method& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nlp_scaling_method*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Nlp_scaling_method&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Nlp_scaling_method_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Nlp_scaling_method_convert () const;

    public:
    static const char* const _xsd_Nlp_scaling_method_literals_[3];
    static const Value _xsd_Nlp_scaling_method_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %nlp_scaling_max_gradient schema type.
   *
   * @nosubgrouping
   */
  class Nlp_scaling_max_gradient: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nlp_scaling_max_gradient (const ::xml_schema::Double&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_max_gradient (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_max_gradient (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_max_gradient (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nlp_scaling_max_gradient (const Nlp_scaling_max_gradient& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nlp_scaling_max_gradient*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nlp_scaling_max_gradient ();
  };

  /**
   * @brief Class corresponding to the %nlp_scaling_min_value schema type.
   *
   * @nosubgrouping
   */
  class Nlp_scaling_min_value: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Nlp_scaling_min_value (const ::xml_schema::Double&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_min_value (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_min_value (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Nlp_scaling_min_value (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Nlp_scaling_min_value (const Nlp_scaling_min_value& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Nlp_scaling_min_value*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Nlp_scaling_min_value ();
  };

  /**
   * @brief Class corresponding to the %bound_relax_factor schema type.
   *
   * @nosubgrouping
   */
  class Bound_relax_factor: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Bound_relax_factor (const ::xml_schema::Double&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Bound_relax_factor (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Bound_relax_factor (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Bound_relax_factor (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Bound_relax_factor (const Bound_relax_factor& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Bound_relax_factor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Bound_relax_factor ();
  };

  /**
   * @brief Enumeration class corresponding to the %honor_original_bounds
   * schema type.
   */
  class Honor_original_bounds: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Honor_original_bounds (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Honor_original_bounds (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Honor_original_bounds (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Honor_original_bounds (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Honor_original_bounds (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Honor_original_bounds (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Honor_original_bounds (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Honor_original_bounds (const Honor_original_bounds& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Honor_original_bounds*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Honor_original_bounds&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Honor_original_bounds_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Honor_original_bounds_convert () const;

    public:
    static const char* const _xsd_Honor_original_bounds_literals_[2];
    static const Value _xsd_Honor_original_bounds_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %check_derivatives_for_naninf
   * schema type.
   */
  class Check_derivatives_for_naninf: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Check_derivatives_for_naninf (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Check_derivatives_for_naninf (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Check_derivatives_for_naninf (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Check_derivatives_for_naninf (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Check_derivatives_for_naninf (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Check_derivatives_for_naninf (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Check_derivatives_for_naninf (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Check_derivatives_for_naninf (const Check_derivatives_for_naninf& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Check_derivatives_for_naninf*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Check_derivatives_for_naninf&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Check_derivatives_for_naninf_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Check_derivatives_for_naninf_convert () const;

    public:
    static const char* const _xsd_Check_derivatives_for_naninf_literals_[2];
    static const Value _xsd_Check_derivatives_for_naninf_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %fixed_variable_treatment
   * schema type.
   */
  class Fixed_variable_treatment: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      make_parameter,
      make_constraint,
      relax_bounds
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Fixed_variable_treatment (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Fixed_variable_treatment (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Fixed_variable_treatment (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Fixed_variable_treatment (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Fixed_variable_treatment (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Fixed_variable_treatment (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Fixed_variable_treatment (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Fixed_variable_treatment (const Fixed_variable_treatment& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Fixed_variable_treatment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Fixed_variable_treatment&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Fixed_variable_treatment_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Fixed_variable_treatment_convert () const;

    public:
    static const char* const _xsd_Fixed_variable_treatment_literals_[3];
    static const Value _xsd_Fixed_variable_treatment_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %jac_c_constant
   * schema type.
   */
  class Jac_c_constant: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Jac_c_constant (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Jac_c_constant (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Jac_c_constant (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Jac_c_constant (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jac_c_constant (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jac_c_constant (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jac_c_constant (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Jac_c_constant (const Jac_c_constant& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Jac_c_constant*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Jac_c_constant&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Jac_c_constant_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Jac_c_constant_convert () const;

    public:
    static const char* const _xsd_Jac_c_constant_literals_[2];
    static const Value _xsd_Jac_c_constant_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %jac_d_constant
   * schema type.
   */
  class Jac_d_constant: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Jac_d_constant (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Jac_d_constant (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Jac_d_constant (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Jac_d_constant (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jac_d_constant (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jac_d_constant (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jac_d_constant (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Jac_d_constant (const Jac_d_constant& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Jac_d_constant*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Jac_d_constant&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Jac_d_constant_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Jac_d_constant_convert () const;

    public:
    static const char* const _xsd_Jac_d_constant_literals_[2];
    static const Value _xsd_Jac_d_constant_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %linear_solver
   * schema type.
   */
  class Linear_solver: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      ma27,
      ma57,
      ma77,
      ma86,
      ma97,
      mumps,
      pardiso
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Linear_solver (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Linear_solver (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Linear_solver (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Linear_solver (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_solver (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_solver (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_solver (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Linear_solver (const Linear_solver& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Linear_solver*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Linear_solver&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Linear_solver_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Linear_solver_convert () const;

    public:
    static const char* const _xsd_Linear_solver_literals_[7];
    static const Value _xsd_Linear_solver_indexes_[7];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %linear_system_scaling
   * schema type.
   */
  class Linear_system_scaling: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      mc19,
      slack_based
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Linear_system_scaling (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Linear_system_scaling (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Linear_system_scaling (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Linear_system_scaling (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_system_scaling (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_system_scaling (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_system_scaling (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Linear_system_scaling (const Linear_system_scaling& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Linear_system_scaling*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Linear_system_scaling&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Linear_system_scaling_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Linear_system_scaling_convert () const;

    public:
    static const char* const _xsd_Linear_system_scaling_literals_[3];
    static const Value _xsd_Linear_system_scaling_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %linear_scaling_on_demand
   * schema type.
   */
  class Linear_scaling_on_demand: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Linear_scaling_on_demand (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Linear_scaling_on_demand (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Linear_scaling_on_demand (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Linear_scaling_on_demand (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_scaling_on_demand (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_scaling_on_demand (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Linear_scaling_on_demand (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Linear_scaling_on_demand (const Linear_scaling_on_demand& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Linear_scaling_on_demand*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Linear_scaling_on_demand&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Linear_scaling_on_demand_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Linear_scaling_on_demand_convert () const;

    public:
    static const char* const _xsd_Linear_scaling_on_demand_literals_[2];
    static const Value _xsd_Linear_scaling_on_demand_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma57_automatic_scaling
   * schema type.
   */
  class Ma57_automatic_scaling: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma57_automatic_scaling (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma57_automatic_scaling (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma57_automatic_scaling (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma57_automatic_scaling (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma57_automatic_scaling (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma57_automatic_scaling (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma57_automatic_scaling (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma57_automatic_scaling (const Ma57_automatic_scaling& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma57_automatic_scaling*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma57_automatic_scaling&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma57_automatic_scaling_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma57_automatic_scaling_convert () const;

    public:
    static const char* const _xsd_Ma57_automatic_scaling_literals_[2];
    static const Value _xsd_Ma57_automatic_scaling_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma86_order
   * schema type.
   */
  class Ma86_order: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      auto_,
      amd,
      metis
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma86_order (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma86_order (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma86_order (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma86_order (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma86_order (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma86_order (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma86_order (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma86_order (const Ma86_order& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma86_order*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma86_order&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma86_order_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma86_order_convert () const;

    public:
    static const char* const _xsd_Ma86_order_literals_[3];
    static const Value _xsd_Ma86_order_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma86_scaling
   * schema type.
   */
  class Ma86_scaling: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      mone,
      mc64,
      mc77
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma86_scaling (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma86_scaling (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma86_scaling (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma86_scaling (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma86_scaling (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma86_scaling (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma86_scaling (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma86_scaling (const Ma86_scaling& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma86_scaling*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma86_scaling&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma86_scaling_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma86_scaling_convert () const;

    public:
    static const char* const _xsd_Ma86_scaling_literals_[3];
    static const Value _xsd_Ma86_scaling_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma77_order
   * schema type.
   */
  class Ma77_order: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      amd,
      metis
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma77_order (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma77_order (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma77_order (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma77_order (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma77_order (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma77_order (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma77_order (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma77_order (const Ma77_order& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma77_order*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma77_order&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma77_order_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma77_order_convert () const;

    public:
    static const char* const _xsd_Ma77_order_literals_[2];
    static const Value _xsd_Ma77_order_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_order
   * schema type.
   */
  class Ma97_order: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      auto_,
      best,
      amd,
      metis,
      matched_auto,
      matched_metis,
      matched_amd
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_order (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_order (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_order (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_order (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_order (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_order (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_order (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_order (const Ma97_order& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_order*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_order&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_order_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_order_convert () const;

    public:
    static const char* const _xsd_Ma97_order_literals_[7];
    static const Value _xsd_Ma97_order_indexes_[7];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_scaling
   * schema type.
   */
  class Ma97_scaling: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      mc30,
      mc64,
      mc77,
      dynamic
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_scaling (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_scaling (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_scaling (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_scaling (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_scaling (const Ma97_scaling& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_scaling*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_scaling&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_scaling_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_scaling_convert () const;

    public:
    static const char* const _xsd_Ma97_scaling_literals_[5];
    static const Value _xsd_Ma97_scaling_indexes_[5];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_scaling1
   * schema type.
   */
  class Ma97_scaling1: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      mc30,
      mc64,
      mc77
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_scaling1 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_scaling1 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_scaling1 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_scaling1 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling1 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling1 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_scaling1 (const Ma97_scaling1& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_scaling1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_scaling1&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_scaling1_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_scaling1_convert () const;

    public:
    static const char* const _xsd_Ma97_scaling1_literals_[4];
    static const Value _xsd_Ma97_scaling1_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_scaling2
   * schema type.
   */
  class Ma97_scaling2: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      mc30,
      mc64,
      mc77
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_scaling2 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_scaling2 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_scaling2 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_scaling2 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling2 (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling2 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling2 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_scaling2 (const Ma97_scaling2& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_scaling2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_scaling2&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_scaling2_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_scaling2_convert () const;

    public:
    static const char* const _xsd_Ma97_scaling2_literals_[4];
    static const Value _xsd_Ma97_scaling2_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_scaling3
   * schema type.
   */
  class Ma97_scaling3: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      mc30,
      mc64,
      mc77
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_scaling3 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_scaling3 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_scaling3 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_scaling3 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling3 (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling3 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_scaling3 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_scaling3 (const Ma97_scaling3& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_scaling3*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_scaling3&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_scaling3_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_scaling3_convert () const;

    public:
    static const char* const _xsd_Ma97_scaling3_literals_[4];
    static const Value _xsd_Ma97_scaling3_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_solve_blas3
   * schema type.
   */
  class Ma97_solve_blas3: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_solve_blas3 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_solve_blas3 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_solve_blas3 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_solve_blas3 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_solve_blas3 (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_solve_blas3 (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_solve_blas3 (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_solve_blas3 (const Ma97_solve_blas3& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_solve_blas3*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_solve_blas3&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_solve_blas3_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_solve_blas3_convert () const;

    public:
    static const char* const _xsd_Ma97_solve_blas3_literals_[2];
    static const Value _xsd_Ma97_solve_blas3_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_switch1
   * schema type.
   */
  class Ma97_switch1: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      never,
      at_start,
      at_start_reuse,
      on_demand,
      on_demand_reuse,
      high_delay,
      high_delay_reuse,
      od_hd,
      od_hd_reuse
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_switch1 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_switch1 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_switch1 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_switch1 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch1 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch1 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_switch1 (const Ma97_switch1& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_switch1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_switch1&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_switch1_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_switch1_convert () const;

    public:
    static const char* const _xsd_Ma97_switch1_literals_[9];
    static const Value _xsd_Ma97_switch1_indexes_[9];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_switch2
   * schema type.
   */
  class Ma97_switch2: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      never,
      at_start,
      at_start_reuse,
      on_demand,
      on_demand_reuse,
      high_delay,
      high_delay_reuse,
      od_hd,
      od_hd_reuse
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_switch2 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_switch2 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_switch2 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_switch2 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch2 (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch2 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch2 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_switch2 (const Ma97_switch2& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_switch2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_switch2&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_switch2_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_switch2_convert () const;

    public:
    static const char* const _xsd_Ma97_switch2_literals_[9];
    static const Value _xsd_Ma97_switch2_indexes_[9];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ma97_switch3
   * schema type.
   */
  class Ma97_switch3: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      never,
      at_start,
      at_start_reuse,
      on_demand,
      on_demand_reuse,
      high_delay,
      high_delay_reuse,
      od_hd,
      od_hd_reuse
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Ma97_switch3 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Ma97_switch3 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Ma97_switch3 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Ma97_switch3 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch3 (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch3 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Ma97_switch3 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Ma97_switch3 (const Ma97_switch3& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Ma97_switch3*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Ma97_switch3&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Ma97_switch3_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Ma97_switch3_convert () const;

    public:
    static const char* const _xsd_Ma97_switch3_literals_[9];
    static const Value _xsd_Ma97_switch3_indexes_[9];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %pardiso_matching_strategy
   * schema type.
   */
  class Pardiso_matching_strategy: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      complete,
      complete_2x2,
      constraints
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Pardiso_matching_strategy (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Pardiso_matching_strategy (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Pardiso_matching_strategy (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Pardiso_matching_strategy (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Pardiso_matching_strategy (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Pardiso_matching_strategy (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Pardiso_matching_strategy (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Pardiso_matching_strategy (const Pardiso_matching_strategy& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Pardiso_matching_strategy*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Pardiso_matching_strategy&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Pardiso_matching_strategy_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Pardiso_matching_strategy_convert () const;

    public:
    static const char* const _xsd_Pardiso_matching_strategy_literals_[3];
    static const Value _xsd_Pardiso_matching_strategy_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %pardiso_order
   * schema type.
   */
  class Pardiso_order: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      amd,
      one,
      metis,
      pmetis,
      four,
      five
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Pardiso_order (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Pardiso_order (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Pardiso_order (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Pardiso_order (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Pardiso_order (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Pardiso_order (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Pardiso_order (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Pardiso_order (const Pardiso_order& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Pardiso_order*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Pardiso_order&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Pardiso_order_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Pardiso_order_convert () const;

    public:
    static const char* const _xsd_Pardiso_order_literals_[6];
    static const Value _xsd_Pardiso_order_indexes_[6];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %derivative_test
   * schema type.
   */
  class Derivative_test: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      first_order
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Derivative_test (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Derivative_test (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Derivative_test (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Derivative_test (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Derivative_test (const Derivative_test& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Derivative_test*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Derivative_test&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Derivative_test_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Derivative_test_convert () const;

    public:
    static const char* const _xsd_Derivative_test_literals_[2];
    static const Value _xsd_Derivative_test_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %derivative_test_perturbation schema type.
   *
   * @nosubgrouping
   */
  class Derivative_test_perturbation: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Derivative_test_perturbation (const ::xml_schema::Double&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_perturbation (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_perturbation (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_perturbation (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Derivative_test_perturbation (const Derivative_test_perturbation& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Derivative_test_perturbation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Derivative_test_perturbation ();
  };

  /**
   * @brief Class corresponding to the %derivative_test_tol schema type.
   *
   * @nosubgrouping
   */
  class Derivative_test_tol: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Derivative_test_tol (const ::xml_schema::Double&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_tol (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_tol (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_tol (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Derivative_test_tol (const Derivative_test_tol& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Derivative_test_tol*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Derivative_test_tol ();
  };

  /**
   * @brief Enumeration class corresponding to the %derivative_test_print_all
   * schema type.
   */
  class Derivative_test_print_all: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      yes,
      no
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Derivative_test_print_all (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Derivative_test_print_all (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Derivative_test_print_all (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Derivative_test_print_all (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_print_all (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_print_all (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Derivative_test_print_all (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Derivative_test_print_all (const Derivative_test_print_all& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Derivative_test_print_all*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Derivative_test_print_all&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Derivative_test_print_all_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Derivative_test_print_all_convert () const;

    public:
    static const char* const _xsd_Derivative_test_print_all_literals_[2];
    static const Value _xsd_Derivative_test_print_all_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %jacobian_approximation
   * schema type.
   */
  class Jacobian_approximation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      exact,
      finite_difference_values
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Jacobian_approximation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Jacobian_approximation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Jacobian_approximation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Jacobian_approximation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jacobian_approximation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jacobian_approximation (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Jacobian_approximation (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Jacobian_approximation (const Jacobian_approximation& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Jacobian_approximation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Jacobian_approximation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Jacobian_approximation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Jacobian_approximation_convert () const;

    public:
    static const char* const _xsd_Jacobian_approximation_literals_[2];
    static const Value _xsd_Jacobian_approximation_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %findiff_perturbation schema type.
   *
   * @nosubgrouping
   */
  class Findiff_perturbation: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Findiff_perturbation (const ::xml_schema::Double&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Findiff_perturbation (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Findiff_perturbation (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Findiff_perturbation (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Findiff_perturbation (const Findiff_perturbation& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Findiff_perturbation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Findiff_perturbation ();
  };

  /**
   * @brief Enumeration class corresponding to the %expect_infeasible_problem
   * schema type.
   */
  class Expect_infeasible_problem: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Expect_infeasible_problem (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Expect_infeasible_problem (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Expect_infeasible_problem (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Expect_infeasible_problem (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Expect_infeasible_problem (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Expect_infeasible_problem (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Expect_infeasible_problem (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Expect_infeasible_problem (const Expect_infeasible_problem& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Expect_infeasible_problem*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Expect_infeasible_problem&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Expect_infeasible_problem_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Expect_infeasible_problem_convert () const;

    public:
    static const char* const _xsd_Expect_infeasible_problem_literals_[2];
    static const Value _xsd_Expect_infeasible_problem_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %start_with_resto
   * schema type.
   */
  class Start_with_resto: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Start_with_resto (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Start_with_resto (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Start_with_resto (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Start_with_resto (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Start_with_resto (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Start_with_resto (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Start_with_resto (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Start_with_resto (const Start_with_resto& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Start_with_resto*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Start_with_resto&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Start_with_resto_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Start_with_resto_convert () const;

    public:
    static const char* const _xsd_Start_with_resto_literals_[2];
    static const Value _xsd_Start_with_resto_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %evaluate_orig_obj_at_resto_trial
   * schema type.
   */
  class Evaluate_orig_obj_at_resto_trial: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Evaluate_orig_obj_at_resto_trial (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Evaluate_orig_obj_at_resto_trial (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Evaluate_orig_obj_at_resto_trial (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Evaluate_orig_obj_at_resto_trial (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Evaluate_orig_obj_at_resto_trial (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Evaluate_orig_obj_at_resto_trial (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Evaluate_orig_obj_at_resto_trial (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Evaluate_orig_obj_at_resto_trial (const Evaluate_orig_obj_at_resto_trial& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Evaluate_orig_obj_at_resto_trial*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Evaluate_orig_obj_at_resto_trial&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Evaluate_orig_obj_at_resto_trial_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Evaluate_orig_obj_at_resto_trial_convert () const;

    public:
    static const char* const _xsd_Evaluate_orig_obj_at_resto_trial_literals_[2];
    static const Value _xsd_Evaluate_orig_obj_at_resto_trial_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %alpha_for_y
   * schema type.
   */
  class Alpha_for_y: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      primal,
      bound_mult,
      min,
      max,
      full,
      min_dual_infeas,
      safer_min_dual_infeas,
      primal_and_full,
      dual_and_full,
      acceptor
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Alpha_for_y (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Alpha_for_y (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Alpha_for_y (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Alpha_for_y (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Alpha_for_y (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Alpha_for_y (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Alpha_for_y (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Alpha_for_y (const Alpha_for_y& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Alpha_for_y*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Alpha_for_y&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Alpha_for_y_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Alpha_for_y_convert () const;

    public:
    static const char* const _xsd_Alpha_for_y_literals_[10];
    static const Value _xsd_Alpha_for_y_indexes_[10];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %recalc_y
   * schema type.
   */
  class Recalc_y: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Recalc_y (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Recalc_y (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Recalc_y (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Recalc_y (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Recalc_y (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Recalc_y (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Recalc_y (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Recalc_y (const Recalc_y& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Recalc_y*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Recalc_y&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Recalc_y_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Recalc_y_convert () const;

    public:
    static const char* const _xsd_Recalc_y_literals_[2];
    static const Value _xsd_Recalc_y_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %accept_every_trial_step
   * schema type.
   */
  class Accept_every_trial_step: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Accept_every_trial_step (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Accept_every_trial_step (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Accept_every_trial_step (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Accept_every_trial_step (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Accept_every_trial_step (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Accept_every_trial_step (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Accept_every_trial_step (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Accept_every_trial_step (const Accept_every_trial_step& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Accept_every_trial_step*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Accept_every_trial_step&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Accept_every_trial_step_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Accept_every_trial_step_convert () const;

    public:
    static const char* const _xsd_Accept_every_trial_step_literals_[2];
    static const Value _xsd_Accept_every_trial_step_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %warm_start_init_point
   * schema type.
   */
  class Warm_start_init_point: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Warm_start_init_point (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Warm_start_init_point (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Warm_start_init_point (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Warm_start_init_point (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Warm_start_init_point (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Warm_start_init_point (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Warm_start_init_point (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Warm_start_init_point (const Warm_start_init_point& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Warm_start_init_point*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Warm_start_init_point&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Warm_start_init_point_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Warm_start_init_point_convert () const;

    public:
    static const char* const _xsd_Warm_start_init_point_literals_[2];
    static const Value _xsd_Warm_start_init_point_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %bound_mult_init_method
   * schema type.
   */
  class Bound_mult_init_method: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      constant,
      mu_based
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Bound_mult_init_method (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Bound_mult_init_method (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Bound_mult_init_method (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Bound_mult_init_method (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Bound_mult_init_method (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Bound_mult_init_method (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Bound_mult_init_method (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Bound_mult_init_method (const Bound_mult_init_method& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Bound_mult_init_method*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Bound_mult_init_method&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Bound_mult_init_method_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Bound_mult_init_method_convert () const;

    public:
    static const char* const _xsd_Bound_mult_init_method_literals_[2];
    static const Value _xsd_Bound_mult_init_method_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %mehrotra_algorithm
   * schema type.
   */
  class Mehrotra_algorithm: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      no,
      yes
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Mehrotra_algorithm (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Mehrotra_algorithm (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Mehrotra_algorithm (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Mehrotra_algorithm (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mehrotra_algorithm (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mehrotra_algorithm (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mehrotra_algorithm (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mehrotra_algorithm (const Mehrotra_algorithm& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Mehrotra_algorithm*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Mehrotra_algorithm&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Mehrotra_algorithm_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Mehrotra_algorithm_convert () const;

    public:
    static const char* const _xsd_Mehrotra_algorithm_literals_[2];
    static const Value _xsd_Mehrotra_algorithm_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %mu_strategy
   * schema type.
   */
  class Mu_strategy: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      monotone,
      adaptive
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Mu_strategy (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Mu_strategy (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Mu_strategy (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Mu_strategy (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mu_strategy (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mu_strategy (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mu_strategy (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mu_strategy (const Mu_strategy& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Mu_strategy*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Mu_strategy&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Mu_strategy_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Mu_strategy_convert () const;

    public:
    static const char* const _xsd_Mu_strategy_literals_[2];
    static const Value _xsd_Mu_strategy_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %mu_oracle
   * schema type.
   */
  class Mu_oracle: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      probing,
      loqo,
      quality_function
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Mu_oracle (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Mu_oracle (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Mu_oracle (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Mu_oracle (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mu_oracle (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mu_oracle (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mu_oracle (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mu_oracle (const Mu_oracle& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Mu_oracle*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Mu_oracle&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Mu_oracle_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Mu_oracle_convert () const;

    public:
    static const char* const _xsd_Mu_oracle_literals_[3];
    static const Value _xsd_Mu_oracle_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %fixed_mu_oracle
   * schema type.
   */
  class Fixed_mu_oracle: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      probing,
      loqo,
      quality_function,
      average_compl
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Fixed_mu_oracle (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Fixed_mu_oracle (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Fixed_mu_oracle (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Fixed_mu_oracle (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Fixed_mu_oracle (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Fixed_mu_oracle (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Fixed_mu_oracle (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Fixed_mu_oracle (const Fixed_mu_oracle& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Fixed_mu_oracle*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Fixed_mu_oracle&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Fixed_mu_oracle_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Fixed_mu_oracle_convert () const;

    public:
    static const char* const _xsd_Fixed_mu_oracle_literals_[4];
    static const Value _xsd_Fixed_mu_oracle_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %adaptive_mu_globalization
   * schema type.
   */
  class Adaptive_mu_globalization: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      kkt_error,
      obj_constr_filter,
      never_monotone_mode
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Adaptive_mu_globalization (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Adaptive_mu_globalization (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Adaptive_mu_globalization (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Adaptive_mu_globalization (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Adaptive_mu_globalization (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Adaptive_mu_globalization (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Adaptive_mu_globalization (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Adaptive_mu_globalization (const Adaptive_mu_globalization& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Adaptive_mu_globalization*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Adaptive_mu_globalization&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Adaptive_mu_globalization_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Adaptive_mu_globalization_convert () const;

    public:
    static const char* const _xsd_Adaptive_mu_globalization_literals_[3];
    static const Value _xsd_Adaptive_mu_globalization_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %reportConstraintViolation schema type.
   *
   * @nosubgrouping
   */
  class ReportConstraintViolation: public ::xml_schema::Type
  {
    public:
    /**
     * @name level
     *
     * @brief Accessor and modifier functions for the %level
     * optional attribute with a default value.
     *
     * constraint violation is reported as 0 = fatal error, 1 = error, 2 =
     * warning, 3 = info, 4 = debug messages
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalIntegerSimpleType LevelType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelType, char > LevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LevelType&
    getLevel () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LevelType&
    getLevel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLevel (const LevelType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLevel (::std::auto_ptr< LevelType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const LevelType&
    getLevelDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReportConstraintViolation ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReportConstraintViolation (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReportConstraintViolation (const ReportConstraintViolation& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReportConstraintViolation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReportConstraintViolation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LevelType > level_;
    static const LevelType level_default_value_;

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace fews
{
  /**
   * @name Parsing functions for the %rtcRuntimeConfig document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (const ::std::string& uri,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (const ::std::string& uri,
                         ::xml_schema::ErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (const ::std::string& uri,
                         ::xercesc::DOMErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::std::istream& is,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::std::istream& is,
                         ::xml_schema::ErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::std::istream& is,
                         ::xercesc::DOMErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::std::istream& is,
                         const ::std::string& id,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::std::istream& is,
                         const ::std::string& id,
                         ::xml_schema::ErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::std::istream& is,
                         const ::std::string& id,
                         ::xercesc::DOMErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::xercesc::InputSource& is,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::xercesc::InputSource& is,
                         ::xml_schema::ErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::xercesc::InputSource& is,
                         ::xercesc::DOMErrorHandler& eh,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (const ::xercesc::DOMDocument& d,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::auto_ptr< ::fews::RtcRuntimeConfigComplexType >
  parseRtcRuntimeConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::Flags f = 0,
                         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace fews
{
  /**
   * @name Serialization functions for the %rtcRuntimeConfig document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeRtcRuntimeConfig (::std::ostream& os,
                             const ::fews::RtcRuntimeConfigComplexType& x, 
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             const ::std::string& e = "UTF-8",
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcRuntimeConfig (::std::ostream& os,
                             const ::fews::RtcRuntimeConfigComplexType& x, 
                             ::xml_schema::ErrorHandler& eh,
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             const ::std::string& e = "UTF-8",
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcRuntimeConfig (::std::ostream& os,
                             const ::fews::RtcRuntimeConfigComplexType& x, 
                             ::xercesc::DOMErrorHandler& eh,
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             const ::std::string& e = "UTF-8",
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeRtcRuntimeConfig (::xercesc::XMLFormatTarget& ft,
                             const ::fews::RtcRuntimeConfigComplexType& x, 
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             const ::std::string& e = "UTF-8",
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcRuntimeConfig (::xercesc::XMLFormatTarget& ft,
                             const ::fews::RtcRuntimeConfigComplexType& x, 
                             ::xml_schema::ErrorHandler& eh,
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             const ::std::string& e = "UTF-8",
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcRuntimeConfig (::xercesc::XMLFormatTarget& ft,
                             const ::fews::RtcRuntimeConfigComplexType& x, 
                             ::xercesc::DOMErrorHandler& eh,
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             const ::std::string& e = "UTF-8",
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  serializeRtcRuntimeConfig (::xercesc::DOMDocument& d,
                             const ::fews::RtcRuntimeConfigComplexType& x,
                             ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeRtcRuntimeConfig (const ::fews::RtcRuntimeConfigComplexType& x, 
                             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                             ::xml_schema::Flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const RtcRuntimeConfigComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const FileComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const FileDataComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const FileObjectiveComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const FileParameterComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const FileScenarioTreeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const FileToolsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PeriodComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UserDefinedRuntimeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PIInputRuntimeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PIRunFileRuntimeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ModesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ModeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ModeSimulationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ModeOptimizationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OptimizerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GAMSComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTTerminationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTNLPScalingComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTNLPComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTLinearSolverComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MA27ComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MA57ComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MA86ComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MA77ComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MA97ComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MUMPSComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PardisoComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTQuasiNewtonComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTDerivativeCheckerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTHessianPermutationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTRestorationPhaseComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTMultiplierUpdatesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTLineSearchComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTWarmStartComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTInitializationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IPOPTBarrierParameterComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SAComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LoggingComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UserDefinedStateExportComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ModeClosedLoopComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParallelizationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParallelModeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const ParallelModeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const ParallelModeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const OptimizerModeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const OptimizerModeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const OptimizerModeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterFileTypeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const ParameterFileTypeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const ParameterFileTypeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterFilePrefixEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const ParameterFilePrefixEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const ParameterFilePrefixEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const PeriodEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const PeriodEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const PeriodEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const FunctionOutputEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const FunctionOutputEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const FunctionOutputEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const Algorithm&);

  void
  operator<< (::xercesc::DOMAttr&, const Algorithm&);

  void
  operator<< (::xml_schema::ListStream&,
              const Algorithm&);

  void
  operator<< (::xercesc::DOMElement&, const Print_level&);

  void
  operator<< (::xercesc::DOMAttr&, const Print_level&);

  void
  operator<< (::xml_schema::ListStream&,
              const Print_level&);

  void
  operator<< (::xercesc::DOMElement&, const Print_user_options&);

  void
  operator<< (::xercesc::DOMAttr&, const Print_user_options&);

  void
  operator<< (::xml_schema::ListStream&,
              const Print_user_options&);

  void
  operator<< (::xercesc::DOMElement&, const Print_options_documentation&);

  void
  operator<< (::xercesc::DOMAttr&, const Print_options_documentation&);

  void
  operator<< (::xml_schema::ListStream&,
              const Print_options_documentation&);

  void
  operator<< (::xercesc::DOMElement&, const Print_timing_statistics&);

  void
  operator<< (::xercesc::DOMAttr&, const Print_timing_statistics&);

  void
  operator<< (::xml_schema::ListStream&,
              const Print_timing_statistics&);

  void
  operator<< (::xercesc::DOMElement&, const File_print_level&);

  void
  operator<< (::xercesc::DOMAttr&, const File_print_level&);

  void
  operator<< (::xml_schema::ListStream&,
              const File_print_level&);

  void
  operator<< (::xercesc::DOMElement&, const Nlp_scaling_method&);

  void
  operator<< (::xercesc::DOMAttr&, const Nlp_scaling_method&);

  void
  operator<< (::xml_schema::ListStream&,
              const Nlp_scaling_method&);

  void
  operator<< (::xercesc::DOMElement&, const Nlp_scaling_max_gradient&);

  void
  operator<< (::xercesc::DOMAttr&, const Nlp_scaling_max_gradient&);

  void
  operator<< (::xml_schema::ListStream&,
              const Nlp_scaling_max_gradient&);

  void
  operator<< (::xercesc::DOMElement&, const Nlp_scaling_min_value&);

  void
  operator<< (::xercesc::DOMAttr&, const Nlp_scaling_min_value&);

  void
  operator<< (::xml_schema::ListStream&,
              const Nlp_scaling_min_value&);

  void
  operator<< (::xercesc::DOMElement&, const Bound_relax_factor&);

  void
  operator<< (::xercesc::DOMAttr&, const Bound_relax_factor&);

  void
  operator<< (::xml_schema::ListStream&,
              const Bound_relax_factor&);

  void
  operator<< (::xercesc::DOMElement&, const Honor_original_bounds&);

  void
  operator<< (::xercesc::DOMAttr&, const Honor_original_bounds&);

  void
  operator<< (::xml_schema::ListStream&,
              const Honor_original_bounds&);

  void
  operator<< (::xercesc::DOMElement&, const Check_derivatives_for_naninf&);

  void
  operator<< (::xercesc::DOMAttr&, const Check_derivatives_for_naninf&);

  void
  operator<< (::xml_schema::ListStream&,
              const Check_derivatives_for_naninf&);

  void
  operator<< (::xercesc::DOMElement&, const Fixed_variable_treatment&);

  void
  operator<< (::xercesc::DOMAttr&, const Fixed_variable_treatment&);

  void
  operator<< (::xml_schema::ListStream&,
              const Fixed_variable_treatment&);

  void
  operator<< (::xercesc::DOMElement&, const Jac_c_constant&);

  void
  operator<< (::xercesc::DOMAttr&, const Jac_c_constant&);

  void
  operator<< (::xml_schema::ListStream&,
              const Jac_c_constant&);

  void
  operator<< (::xercesc::DOMElement&, const Jac_d_constant&);

  void
  operator<< (::xercesc::DOMAttr&, const Jac_d_constant&);

  void
  operator<< (::xml_schema::ListStream&,
              const Jac_d_constant&);

  void
  operator<< (::xercesc::DOMElement&, const Linear_solver&);

  void
  operator<< (::xercesc::DOMAttr&, const Linear_solver&);

  void
  operator<< (::xml_schema::ListStream&,
              const Linear_solver&);

  void
  operator<< (::xercesc::DOMElement&, const Linear_system_scaling&);

  void
  operator<< (::xercesc::DOMAttr&, const Linear_system_scaling&);

  void
  operator<< (::xml_schema::ListStream&,
              const Linear_system_scaling&);

  void
  operator<< (::xercesc::DOMElement&, const Linear_scaling_on_demand&);

  void
  operator<< (::xercesc::DOMAttr&, const Linear_scaling_on_demand&);

  void
  operator<< (::xml_schema::ListStream&,
              const Linear_scaling_on_demand&);

  void
  operator<< (::xercesc::DOMElement&, const Ma57_automatic_scaling&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma57_automatic_scaling&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma57_automatic_scaling&);

  void
  operator<< (::xercesc::DOMElement&, const Ma86_order&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma86_order&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma86_order&);

  void
  operator<< (::xercesc::DOMElement&, const Ma86_scaling&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma86_scaling&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma86_scaling&);

  void
  operator<< (::xercesc::DOMElement&, const Ma77_order&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma77_order&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma77_order&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_order&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_order&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_order&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_scaling&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_scaling&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_scaling&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_scaling1&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_scaling1&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_scaling1&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_scaling2&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_scaling2&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_scaling2&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_scaling3&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_scaling3&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_scaling3&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_solve_blas3&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_solve_blas3&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_solve_blas3&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_switch1&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_switch1&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_switch1&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_switch2&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_switch2&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_switch2&);

  void
  operator<< (::xercesc::DOMElement&, const Ma97_switch3&);

  void
  operator<< (::xercesc::DOMAttr&, const Ma97_switch3&);

  void
  operator<< (::xml_schema::ListStream&,
              const Ma97_switch3&);

  void
  operator<< (::xercesc::DOMElement&, const Pardiso_matching_strategy&);

  void
  operator<< (::xercesc::DOMAttr&, const Pardiso_matching_strategy&);

  void
  operator<< (::xml_schema::ListStream&,
              const Pardiso_matching_strategy&);

  void
  operator<< (::xercesc::DOMElement&, const Pardiso_order&);

  void
  operator<< (::xercesc::DOMAttr&, const Pardiso_order&);

  void
  operator<< (::xml_schema::ListStream&,
              const Pardiso_order&);

  void
  operator<< (::xercesc::DOMElement&, const Derivative_test&);

  void
  operator<< (::xercesc::DOMAttr&, const Derivative_test&);

  void
  operator<< (::xml_schema::ListStream&,
              const Derivative_test&);

  void
  operator<< (::xercesc::DOMElement&, const Derivative_test_perturbation&);

  void
  operator<< (::xercesc::DOMAttr&, const Derivative_test_perturbation&);

  void
  operator<< (::xml_schema::ListStream&,
              const Derivative_test_perturbation&);

  void
  operator<< (::xercesc::DOMElement&, const Derivative_test_tol&);

  void
  operator<< (::xercesc::DOMAttr&, const Derivative_test_tol&);

  void
  operator<< (::xml_schema::ListStream&,
              const Derivative_test_tol&);

  void
  operator<< (::xercesc::DOMElement&, const Derivative_test_print_all&);

  void
  operator<< (::xercesc::DOMAttr&, const Derivative_test_print_all&);

  void
  operator<< (::xml_schema::ListStream&,
              const Derivative_test_print_all&);

  void
  operator<< (::xercesc::DOMElement&, const Jacobian_approximation&);

  void
  operator<< (::xercesc::DOMAttr&, const Jacobian_approximation&);

  void
  operator<< (::xml_schema::ListStream&,
              const Jacobian_approximation&);

  void
  operator<< (::xercesc::DOMElement&, const Findiff_perturbation&);

  void
  operator<< (::xercesc::DOMAttr&, const Findiff_perturbation&);

  void
  operator<< (::xml_schema::ListStream&,
              const Findiff_perturbation&);

  void
  operator<< (::xercesc::DOMElement&, const Expect_infeasible_problem&);

  void
  operator<< (::xercesc::DOMAttr&, const Expect_infeasible_problem&);

  void
  operator<< (::xml_schema::ListStream&,
              const Expect_infeasible_problem&);

  void
  operator<< (::xercesc::DOMElement&, const Start_with_resto&);

  void
  operator<< (::xercesc::DOMAttr&, const Start_with_resto&);

  void
  operator<< (::xml_schema::ListStream&,
              const Start_with_resto&);

  void
  operator<< (::xercesc::DOMElement&, const Evaluate_orig_obj_at_resto_trial&);

  void
  operator<< (::xercesc::DOMAttr&, const Evaluate_orig_obj_at_resto_trial&);

  void
  operator<< (::xml_schema::ListStream&,
              const Evaluate_orig_obj_at_resto_trial&);

  void
  operator<< (::xercesc::DOMElement&, const Alpha_for_y&);

  void
  operator<< (::xercesc::DOMAttr&, const Alpha_for_y&);

  void
  operator<< (::xml_schema::ListStream&,
              const Alpha_for_y&);

  void
  operator<< (::xercesc::DOMElement&, const Recalc_y&);

  void
  operator<< (::xercesc::DOMAttr&, const Recalc_y&);

  void
  operator<< (::xml_schema::ListStream&,
              const Recalc_y&);

  void
  operator<< (::xercesc::DOMElement&, const Accept_every_trial_step&);

  void
  operator<< (::xercesc::DOMAttr&, const Accept_every_trial_step&);

  void
  operator<< (::xml_schema::ListStream&,
              const Accept_every_trial_step&);

  void
  operator<< (::xercesc::DOMElement&, const Warm_start_init_point&);

  void
  operator<< (::xercesc::DOMAttr&, const Warm_start_init_point&);

  void
  operator<< (::xml_schema::ListStream&,
              const Warm_start_init_point&);

  void
  operator<< (::xercesc::DOMElement&, const Bound_mult_init_method&);

  void
  operator<< (::xercesc::DOMAttr&, const Bound_mult_init_method&);

  void
  operator<< (::xml_schema::ListStream&,
              const Bound_mult_init_method&);

  void
  operator<< (::xercesc::DOMElement&, const Mehrotra_algorithm&);

  void
  operator<< (::xercesc::DOMAttr&, const Mehrotra_algorithm&);

  void
  operator<< (::xml_schema::ListStream&,
              const Mehrotra_algorithm&);

  void
  operator<< (::xercesc::DOMElement&, const Mu_strategy&);

  void
  operator<< (::xercesc::DOMAttr&, const Mu_strategy&);

  void
  operator<< (::xml_schema::ListStream&,
              const Mu_strategy&);

  void
  operator<< (::xercesc::DOMElement&, const Mu_oracle&);

  void
  operator<< (::xercesc::DOMAttr&, const Mu_oracle&);

  void
  operator<< (::xml_schema::ListStream&,
              const Mu_oracle&);

  void
  operator<< (::xercesc::DOMElement&, const Fixed_mu_oracle&);

  void
  operator<< (::xercesc::DOMAttr&, const Fixed_mu_oracle&);

  void
  operator<< (::xml_schema::ListStream&,
              const Fixed_mu_oracle&);

  void
  operator<< (::xercesc::DOMElement&, const Adaptive_mu_globalization&);

  void
  operator<< (::xercesc::DOMAttr&, const Adaptive_mu_globalization&);

  void
  operator<< (::xml_schema::ListStream&,
              const Adaptive_mu_globalization&);

  void
  operator<< (::xercesc::DOMElement&, const ReportConstraintViolation&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // RTC_RUNTIME_CONFIG_HXX
