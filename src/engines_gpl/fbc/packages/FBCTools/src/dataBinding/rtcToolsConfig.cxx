// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rtcToolsConfig.hxx"

namespace fews
{
  // RtcToolsConfigComplexType
  // 

  const RtcToolsConfigComplexType::GeneralOptional& RtcToolsConfigComplexType::
  getGeneral () const
  {
    return this->general_;
  }

  RtcToolsConfigComplexType::GeneralOptional& RtcToolsConfigComplexType::
  getGeneral ()
  {
    return this->general_;
  }

  void RtcToolsConfigComplexType::
  setGeneral (const GeneralType& x)
  {
    this->general_.set (x);
  }

  void RtcToolsConfigComplexType::
  setGeneral (const GeneralOptional& x)
  {
    this->general_ = x;
  }

  void RtcToolsConfigComplexType::
  setGeneral (::std::auto_ptr< GeneralType > x)
  {
    this->general_.set (x);
  }

  const RtcToolsConfigComplexType::ComponentsOptional& RtcToolsConfigComplexType::
  getComponents () const
  {
    return this->components_;
  }

  RtcToolsConfigComplexType::ComponentsOptional& RtcToolsConfigComplexType::
  getComponents ()
  {
    return this->components_;
  }

  void RtcToolsConfigComplexType::
  setComponents (const ComponentsType& x)
  {
    this->components_.set (x);
  }

  void RtcToolsConfigComplexType::
  setComponents (const ComponentsOptional& x)
  {
    this->components_ = x;
  }

  void RtcToolsConfigComplexType::
  setComponents (::std::auto_ptr< ComponentsType > x)
  {
    this->components_.set (x);
  }

  const RtcToolsConfigComplexType::RulesOptional& RtcToolsConfigComplexType::
  getRules () const
  {
    return this->rules_;
  }

  RtcToolsConfigComplexType::RulesOptional& RtcToolsConfigComplexType::
  getRules ()
  {
    return this->rules_;
  }

  void RtcToolsConfigComplexType::
  setRules (const RulesType& x)
  {
    this->rules_.set (x);
  }

  void RtcToolsConfigComplexType::
  setRules (const RulesOptional& x)
  {
    this->rules_ = x;
  }

  void RtcToolsConfigComplexType::
  setRules (::std::auto_ptr< RulesType > x)
  {
    this->rules_.set (x);
  }

  const RtcToolsConfigComplexType::TriggersOptional& RtcToolsConfigComplexType::
  getTriggers () const
  {
    return this->triggers_;
  }

  RtcToolsConfigComplexType::TriggersOptional& RtcToolsConfigComplexType::
  getTriggers ()
  {
    return this->triggers_;
  }

  void RtcToolsConfigComplexType::
  setTriggers (const TriggersType& x)
  {
    this->triggers_.set (x);
  }

  void RtcToolsConfigComplexType::
  setTriggers (const TriggersOptional& x)
  {
    this->triggers_ = x;
  }

  void RtcToolsConfigComplexType::
  setTriggers (::std::auto_ptr< TriggersType > x)
  {
    this->triggers_.set (x);
  }


  // GeneralModuleConfigComplexType
  // 

  const GeneralModuleConfigComplexType::DescriptionOptional& GeneralModuleConfigComplexType::
  getDescription () const
  {
    return this->description_;
  }

  GeneralModuleConfigComplexType::DescriptionOptional& GeneralModuleConfigComplexType::
  getDescription ()
  {
    return this->description_;
  }

  void GeneralModuleConfigComplexType::
  setDescription (const DescriptionType& x)
  {
    this->description_.set (x);
  }

  void GeneralModuleConfigComplexType::
  setDescription (const DescriptionOptional& x)
  {
    this->description_ = x;
  }

  void GeneralModuleConfigComplexType::
  setDescription (::std::auto_ptr< DescriptionType > x)
  {
    this->description_.set (x);
  }

  const GeneralModuleConfigComplexType::PoolRoutingSchemeType& GeneralModuleConfigComplexType::
  getPoolRoutingScheme () const
  {
    return this->poolRoutingScheme_.get ();
  }

  GeneralModuleConfigComplexType::PoolRoutingSchemeType& GeneralModuleConfigComplexType::
  getPoolRoutingScheme ()
  {
    return this->poolRoutingScheme_.get ();
  }

  void GeneralModuleConfigComplexType::
  setPoolRoutingScheme (const PoolRoutingSchemeType& x)
  {
    this->poolRoutingScheme_.set (x);
  }

  void GeneralModuleConfigComplexType::
  setPoolRoutingScheme (::std::auto_ptr< PoolRoutingSchemeType > x)
  {
    this->poolRoutingScheme_.set (x);
  }

  const GeneralModuleConfigComplexType::ThetaType& GeneralModuleConfigComplexType::
  getTheta () const
  {
    return this->theta_.get ();
  }

  GeneralModuleConfigComplexType::ThetaType& GeneralModuleConfigComplexType::
  getTheta ()
  {
    return this->theta_.get ();
  }

  void GeneralModuleConfigComplexType::
  setTheta (const ThetaType& x)
  {
    this->theta_.set (x);
  }


  // ComponentsComplexType
  // 

  const ComponentsComplexType::ComponentSequence& ComponentsComplexType::
  getComponent () const
  {
    return this->component_;
  }

  ComponentsComplexType::ComponentSequence& ComponentsComplexType::
  getComponent ()
  {
    return this->component_;
  }

  void ComponentsComplexType::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }


  // ComponentComplexType
  // 

  const ComponentComplexType::AccumulationOptional& ComponentComplexType::
  getAccumulation () const
  {
    return this->accumulation_;
  }

  ComponentComplexType::AccumulationOptional& ComponentComplexType::
  getAccumulation ()
  {
    return this->accumulation_;
  }

  void ComponentComplexType::
  setAccumulation (const AccumulationType& x)
  {
    this->accumulation_.set (x);
  }

  void ComponentComplexType::
  setAccumulation (const AccumulationOptional& x)
  {
    this->accumulation_ = x;
  }

  void ComponentComplexType::
  setAccumulation (::std::auto_ptr< AccumulationType > x)
  {
    this->accumulation_.set (x);
  }

  const ComponentComplexType::AllocationTableOptional& ComponentComplexType::
  getAllocationTable () const
  {
    return this->allocationTable_;
  }

  ComponentComplexType::AllocationTableOptional& ComponentComplexType::
  getAllocationTable ()
  {
    return this->allocationTable_;
  }

  void ComponentComplexType::
  setAllocationTable (const AllocationTableType& x)
  {
    this->allocationTable_.set (x);
  }

  void ComponentComplexType::
  setAllocationTable (const AllocationTableOptional& x)
  {
    this->allocationTable_ = x;
  }

  void ComponentComplexType::
  setAllocationTable (::std::auto_ptr< AllocationTableType > x)
  {
    this->allocationTable_.set (x);
  }

  const ComponentComplexType::ArmaOptional& ComponentComplexType::
  getArma () const
  {
    return this->arma_;
  }

  ComponentComplexType::ArmaOptional& ComponentComplexType::
  getArma ()
  {
    return this->arma_;
  }

  void ComponentComplexType::
  setArma (const ArmaType& x)
  {
    this->arma_.set (x);
  }

  void ComponentComplexType::
  setArma (const ArmaOptional& x)
  {
    this->arma_ = x;
  }

  void ComponentComplexType::
  setArma (::std::auto_ptr< ArmaType > x)
  {
    this->arma_.set (x);
  }

  const ComponentComplexType::ExpressionOptional& ComponentComplexType::
  getExpression () const
  {
    return this->expression_;
  }

  ComponentComplexType::ExpressionOptional& ComponentComplexType::
  getExpression ()
  {
    return this->expression_;
  }

  void ComponentComplexType::
  setExpression (const ExpressionType& x)
  {
    this->expression_.set (x);
  }

  void ComponentComplexType::
  setExpression (const ExpressionOptional& x)
  {
    this->expression_ = x;
  }

  void ComponentComplexType::
  setExpression (::std::auto_ptr< ExpressionType > x)
  {
    this->expression_.set (x);
  }

  const ComponentComplexType::GradientOptional& ComponentComplexType::
  getGradient () const
  {
    return this->gradient_;
  }

  ComponentComplexType::GradientOptional& ComponentComplexType::
  getGradient ()
  {
    return this->gradient_;
  }

  void ComponentComplexType::
  setGradient (const GradientType& x)
  {
    this->gradient_.set (x);
  }

  void ComponentComplexType::
  setGradient (const GradientOptional& x)
  {
    this->gradient_ = x;
  }

  void ComponentComplexType::
  setGradient (::std::auto_ptr< GradientType > x)
  {
    this->gradient_.set (x);
  }

  const ComponentComplexType::HbvOptional& ComponentComplexType::
  getHbv () const
  {
    return this->hbv_;
  }

  ComponentComplexType::HbvOptional& ComponentComplexType::
  getHbv ()
  {
    return this->hbv_;
  }

  void ComponentComplexType::
  setHbv (const HbvType& x)
  {
    this->hbv_.set (x);
  }

  void ComponentComplexType::
  setHbv (const HbvOptional& x)
  {
    this->hbv_ = x;
  }

  void ComponentComplexType::
  setHbv (::std::auto_ptr< HbvType > x)
  {
    this->hbv_.set (x);
  }

  const ComponentComplexType::HydraulicModelOptional& ComponentComplexType::
  getHydraulicModel () const
  {
    return this->hydraulicModel_;
  }

  ComponentComplexType::HydraulicModelOptional& ComponentComplexType::
  getHydraulicModel ()
  {
    return this->hydraulicModel_;
  }

  void ComponentComplexType::
  setHydraulicModel (const HydraulicModelType& x)
  {
    this->hydraulicModel_.set (x);
  }

  void ComponentComplexType::
  setHydraulicModel (const HydraulicModelOptional& x)
  {
    this->hydraulicModel_ = x;
  }

  void ComponentComplexType::
  setHydraulicModel (::std::auto_ptr< HydraulicModelType > x)
  {
    this->hydraulicModel_.set (x);
  }

  const ComponentComplexType::HydrologicalModelOptional& ComponentComplexType::
  getHydrologicalModel () const
  {
    return this->hydrologicalModel_;
  }

  ComponentComplexType::HydrologicalModelOptional& ComponentComplexType::
  getHydrologicalModel ()
  {
    return this->hydrologicalModel_;
  }

  void ComponentComplexType::
  setHydrologicalModel (const HydrologicalModelType& x)
  {
    this->hydrologicalModel_.set (x);
  }

  void ComponentComplexType::
  setHydrologicalModel (const HydrologicalModelOptional& x)
  {
    this->hydrologicalModel_ = x;
  }

  void ComponentComplexType::
  setHydrologicalModel (::std::auto_ptr< HydrologicalModelType > x)
  {
    this->hydrologicalModel_.set (x);
  }

  const ComponentComplexType::LookupTableOptional& ComponentComplexType::
  getLookupTable () const
  {
    return this->lookupTable_;
  }

  ComponentComplexType::LookupTableOptional& ComponentComplexType::
  getLookupTable ()
  {
    return this->lookupTable_;
  }

  void ComponentComplexType::
  setLookupTable (const LookupTableType& x)
  {
    this->lookupTable_.set (x);
  }

  void ComponentComplexType::
  setLookupTable (const LookupTableOptional& x)
  {
    this->lookupTable_ = x;
  }

  void ComponentComplexType::
  setLookupTable (::std::auto_ptr< LookupTableType > x)
  {
    this->lookupTable_.set (x);
  }

  const ComponentComplexType::Lookup2DTableOptional& ComponentComplexType::
  getLookup2DTable () const
  {
    return this->lookup2DTable_;
  }

  ComponentComplexType::Lookup2DTableOptional& ComponentComplexType::
  getLookup2DTable ()
  {
    return this->lookup2DTable_;
  }

  void ComponentComplexType::
  setLookup2DTable (const Lookup2DTableType& x)
  {
    this->lookup2DTable_.set (x);
  }

  void ComponentComplexType::
  setLookup2DTable (const Lookup2DTableOptional& x)
  {
    this->lookup2DTable_ = x;
  }

  void ComponentComplexType::
  setLookup2DTable (::std::auto_ptr< Lookup2DTableType > x)
  {
    this->lookup2DTable_.set (x);
  }

  const ComponentComplexType::MergerOptional& ComponentComplexType::
  getMerger () const
  {
    return this->merger_;
  }

  ComponentComplexType::MergerOptional& ComponentComplexType::
  getMerger ()
  {
    return this->merger_;
  }

  void ComponentComplexType::
  setMerger (const MergerType& x)
  {
    this->merger_.set (x);
  }

  void ComponentComplexType::
  setMerger (const MergerOptional& x)
  {
    this->merger_ = x;
  }

  void ComponentComplexType::
  setMerger (::std::auto_ptr< MergerType > x)
  {
    this->merger_.set (x);
  }

  const ComponentComplexType::MergerSplitterOptional& ComponentComplexType::
  getMergerSplitter () const
  {
    return this->mergerSplitter_;
  }

  ComponentComplexType::MergerSplitterOptional& ComponentComplexType::
  getMergerSplitter ()
  {
    return this->mergerSplitter_;
  }

  void ComponentComplexType::
  setMergerSplitter (const MergerSplitterType& x)
  {
    this->mergerSplitter_.set (x);
  }

  void ComponentComplexType::
  setMergerSplitter (const MergerSplitterOptional& x)
  {
    this->mergerSplitter_ = x;
  }

  void ComponentComplexType::
  setMergerSplitter (::std::auto_ptr< MergerSplitterType > x)
  {
    this->mergerSplitter_.set (x);
  }

  const ComponentComplexType::NeuralNetworkOptional& ComponentComplexType::
  getNeuralNetwork () const
  {
    return this->neuralNetwork_;
  }

  ComponentComplexType::NeuralNetworkOptional& ComponentComplexType::
  getNeuralNetwork ()
  {
    return this->neuralNetwork_;
  }

  void ComponentComplexType::
  setNeuralNetwork (const NeuralNetworkType& x)
  {
    this->neuralNetwork_.set (x);
  }

  void ComponentComplexType::
  setNeuralNetwork (const NeuralNetworkOptional& x)
  {
    this->neuralNetwork_ = x;
  }

  void ComponentComplexType::
  setNeuralNetwork (::std::auto_ptr< NeuralNetworkType > x)
  {
    this->neuralNetwork_.set (x);
  }

  const ComponentComplexType::ReservoirOptional& ComponentComplexType::
  getReservoir () const
  {
    return this->reservoir_;
  }

  ComponentComplexType::ReservoirOptional& ComponentComplexType::
  getReservoir ()
  {
    return this->reservoir_;
  }

  void ComponentComplexType::
  setReservoir (const ReservoirType& x)
  {
    this->reservoir_.set (x);
  }

  void ComponentComplexType::
  setReservoir (const ReservoirOptional& x)
  {
    this->reservoir_ = x;
  }

  void ComponentComplexType::
  setReservoir (::std::auto_ptr< ReservoirType > x)
  {
    this->reservoir_.set (x);
  }

  const ComponentComplexType::ReservoirCompactOptional& ComponentComplexType::
  getReservoirCompact () const
  {
    return this->reservoirCompact_;
  }

  ComponentComplexType::ReservoirCompactOptional& ComponentComplexType::
  getReservoirCompact ()
  {
    return this->reservoirCompact_;
  }

  void ComponentComplexType::
  setReservoirCompact (const ReservoirCompactType& x)
  {
    this->reservoirCompact_.set (x);
  }

  void ComponentComplexType::
  setReservoirCompact (const ReservoirCompactOptional& x)
  {
    this->reservoirCompact_ = x;
  }

  void ComponentComplexType::
  setReservoirCompact (::std::auto_ptr< ReservoirCompactType > x)
  {
    this->reservoirCompact_.set (x);
  }

  const ComponentComplexType::LorentGeversOptional& ComponentComplexType::
  getLorentGevers () const
  {
    return this->lorentGevers_;
  }

  ComponentComplexType::LorentGeversOptional& ComponentComplexType::
  getLorentGevers ()
  {
    return this->lorentGevers_;
  }

  void ComponentComplexType::
  setLorentGevers (const LorentGeversType& x)
  {
    this->lorentGevers_.set (x);
  }

  void ComponentComplexType::
  setLorentGevers (const LorentGeversOptional& x)
  {
    this->lorentGevers_ = x;
  }

  void ComponentComplexType::
  setLorentGevers (::std::auto_ptr< LorentGeversType > x)
  {
    this->lorentGevers_.set (x);
  }

  const ComponentComplexType::RoutingOptional& ComponentComplexType::
  getRouting () const
  {
    return this->routing_;
  }

  ComponentComplexType::RoutingOptional& ComponentComplexType::
  getRouting ()
  {
    return this->routing_;
  }

  void ComponentComplexType::
  setRouting (const RoutingType& x)
  {
    this->routing_.set (x);
  }

  void ComponentComplexType::
  setRouting (const RoutingOptional& x)
  {
    this->routing_ = x;
  }

  void ComponentComplexType::
  setRouting (::std::auto_ptr< RoutingType > x)
  {
    this->routing_.set (x);
  }

  const ComponentComplexType::SrmOptional& ComponentComplexType::
  getSrm () const
  {
    return this->srm_;
  }

  ComponentComplexType::SrmOptional& ComponentComplexType::
  getSrm ()
  {
    return this->srm_;
  }

  void ComponentComplexType::
  setSrm (const SrmType& x)
  {
    this->srm_.set (x);
  }

  void ComponentComplexType::
  setSrm (const SrmOptional& x)
  {
    this->srm_ = x;
  }

  void ComponentComplexType::
  setSrm (::std::auto_ptr< SrmType > x)
  {
    this->srm_.set (x);
  }

  const ComponentComplexType::UnitDelayOptional& ComponentComplexType::
  getUnitDelay () const
  {
    return this->unitDelay_;
  }

  ComponentComplexType::UnitDelayOptional& ComponentComplexType::
  getUnitDelay ()
  {
    return this->unitDelay_;
  }

  void ComponentComplexType::
  setUnitDelay (const UnitDelayType& x)
  {
    this->unitDelay_.set (x);
  }

  void ComponentComplexType::
  setUnitDelay (const UnitDelayOptional& x)
  {
    this->unitDelay_ = x;
  }

  void ComponentComplexType::
  setUnitDelay (::std::auto_ptr< UnitDelayType > x)
  {
    this->unitDelay_.set (x);
  }

  const ComponentComplexType::UnitHydrographOptional& ComponentComplexType::
  getUnitHydrograph () const
  {
    return this->unitHydrograph_;
  }

  ComponentComplexType::UnitHydrographOptional& ComponentComplexType::
  getUnitHydrograph ()
  {
    return this->unitHydrograph_;
  }

  void ComponentComplexType::
  setUnitHydrograph (const UnitHydrographType& x)
  {
    this->unitHydrograph_.set (x);
  }

  void ComponentComplexType::
  setUnitHydrograph (const UnitHydrographOptional& x)
  {
    this->unitHydrograph_ = x;
  }

  void ComponentComplexType::
  setUnitHydrograph (::std::auto_ptr< UnitHydrographType > x)
  {
    this->unitHydrograph_.set (x);
  }

  const ComponentComplexType::TemplateOptional& ComponentComplexType::
  getTemplate () const
  {
    return this->template__;
  }

  ComponentComplexType::TemplateOptional& ComponentComplexType::
  getTemplate ()
  {
    return this->template__;
  }

  void ComponentComplexType::
  setTemplate (const TemplateType& x)
  {
    this->template__.set (x);
  }

  void ComponentComplexType::
  setTemplate (const TemplateOptional& x)
  {
    this->template__ = x;
  }

  void ComponentComplexType::
  setTemplate (::std::auto_ptr< TemplateType > x)
  {
    this->template__.set (x);
  }


  // AllocationTableComplexType
  // 

  const AllocationTableComplexType::TableOptional& AllocationTableComplexType::
  getTable () const
  {
    return this->table_;
  }

  AllocationTableComplexType::TableOptional& AllocationTableComplexType::
  getTable ()
  {
    return this->table_;
  }

  void AllocationTableComplexType::
  setTable (const TableType& x)
  {
    this->table_.set (x);
  }

  void AllocationTableComplexType::
  setTable (const TableOptional& x)
  {
    this->table_ = x;
  }

  void AllocationTableComplexType::
  setTable (::std::auto_ptr< TableType > x)
  {
    this->table_.set (x);
  }

  const AllocationTableComplexType::TableExternalOptional& AllocationTableComplexType::
  getTableExternal () const
  {
    return this->tableExternal_;
  }

  AllocationTableComplexType::TableExternalOptional& AllocationTableComplexType::
  getTableExternal ()
  {
    return this->tableExternal_;
  }

  void AllocationTableComplexType::
  setTableExternal (const TableExternalType& x)
  {
    this->tableExternal_.set (x);
  }

  void AllocationTableComplexType::
  setTableExternal (const TableExternalOptional& x)
  {
    this->tableExternal_ = x;
  }

  void AllocationTableComplexType::
  setTableExternal (::std::auto_ptr< TableExternalType > x)
  {
    this->tableExternal_.set (x);
  }

  const AllocationTableComplexType::InputType& AllocationTableComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  AllocationTableComplexType::InputType& AllocationTableComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void AllocationTableComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void AllocationTableComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const AllocationTableComplexType::OutputType& AllocationTableComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  AllocationTableComplexType::OutputType& AllocationTableComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void AllocationTableComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void AllocationTableComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const AllocationTableComplexType::IdType& AllocationTableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  AllocationTableComplexType::IdType& AllocationTableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void AllocationTableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void AllocationTableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const AllocationTableComplexType::NameOptional& AllocationTableComplexType::
  getName () const
  {
    return this->name_;
  }

  AllocationTableComplexType::NameOptional& AllocationTableComplexType::
  getName ()
  {
    return this->name_;
  }

  void AllocationTableComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void AllocationTableComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void AllocationTableComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ATableComplexType
  // 

  const ATableComplexType::RowSequence& ATableComplexType::
  getRow () const
  {
    return this->row_;
  }

  ATableComplexType::RowSequence& ATableComplexType::
  getRow ()
  {
    return this->row_;
  }

  void ATableComplexType::
  setRow (const RowSequence& s)
  {
    this->row_ = s;
  }


  // InputATableComplexType
  // 

  const InputATableComplexType::XType& InputATableComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  InputATableComplexType::XType& InputATableComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void InputATableComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void InputATableComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const InputATableComplexType::ValueSelectionOptional& InputATableComplexType::
  getValueSelection () const
  {
    return this->valueSelection_;
  }

  InputATableComplexType::ValueSelectionOptional& InputATableComplexType::
  getValueSelection ()
  {
    return this->valueSelection_;
  }

  void InputATableComplexType::
  setValueSelection (const ValueSelectionType& x)
  {
    this->valueSelection_.set (x);
  }

  void InputATableComplexType::
  setValueSelection (const ValueSelectionOptional& x)
  {
    this->valueSelection_ = x;
  }

  void InputATableComplexType::
  setValueSelection (::std::auto_ptr< ValueSelectionType > x)
  {
    this->valueSelection_.set (x);
  }


  // OutputATableComplexType
  // 

  const OutputATableComplexType::YSequence& OutputATableComplexType::
  getY () const
  {
    return this->y_;
  }

  OutputATableComplexType::YSequence& OutputATableComplexType::
  getY ()
  {
    return this->y_;
  }

  void OutputATableComplexType::
  setY (const YSequence& s)
  {
    this->y_ = s;
  }


  // HydrologicalModelComplexType
  // 

  const HydrologicalModelComplexType::SubmodelSequence& HydrologicalModelComplexType::
  getSubmodel () const
  {
    return this->submodel_;
  }

  HydrologicalModelComplexType::SubmodelSequence& HydrologicalModelComplexType::
  getSubmodel ()
  {
    return this->submodel_;
  }

  void HydrologicalModelComplexType::
  setSubmodel (const SubmodelSequence& s)
  {
    this->submodel_ = s;
  }

  const HydrologicalModelComplexType::IdType& HydrologicalModelComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  HydrologicalModelComplexType::IdType& HydrologicalModelComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void HydrologicalModelComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void HydrologicalModelComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const HydrologicalModelComplexType::NameOptional& HydrologicalModelComplexType::
  getName () const
  {
    return this->name_;
  }

  HydrologicalModelComplexType::NameOptional& HydrologicalModelComplexType::
  getName ()
  {
    return this->name_;
  }

  void HydrologicalModelComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void HydrologicalModelComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void HydrologicalModelComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // SubmodelComplexType
  // 

  const SubmodelComplexType::TypicalProfileOptional& SubmodelComplexType::
  getTypicalProfile () const
  {
    return this->typicalProfile_;
  }

  SubmodelComplexType::TypicalProfileOptional& SubmodelComplexType::
  getTypicalProfile ()
  {
    return this->typicalProfile_;
  }

  void SubmodelComplexType::
  setTypicalProfile (const TypicalProfileType& x)
  {
    this->typicalProfile_.set (x);
  }

  void SubmodelComplexType::
  setTypicalProfile (const TypicalProfileOptional& x)
  {
    this->typicalProfile_ = x;
  }

  void SubmodelComplexType::
  setTypicalProfile (::std::auto_ptr< TypicalProfileType > x)
  {
    this->typicalProfile_.set (x);
  }

  const SubmodelComplexType::SnowRainJunctionOptional& SubmodelComplexType::
  getSnowRainJunction () const
  {
    return this->snowRainJunction_;
  }

  SubmodelComplexType::SnowRainJunctionOptional& SubmodelComplexType::
  getSnowRainJunction ()
  {
    return this->snowRainJunction_;
  }

  void SubmodelComplexType::
  setSnowRainJunction (const SnowRainJunctionType& x)
  {
    this->snowRainJunction_.set (x);
  }

  void SubmodelComplexType::
  setSnowRainJunction (const SnowRainJunctionOptional& x)
  {
    this->snowRainJunction_ = x;
  }

  void SubmodelComplexType::
  setSnowRainJunction (::std::auto_ptr< SnowRainJunctionType > x)
  {
    this->snowRainJunction_.set (x);
  }

  const SubmodelComplexType::EvaporationPotentialOptional& SubmodelComplexType::
  getEvaporationPotential () const
  {
    return this->evaporationPotential_;
  }

  SubmodelComplexType::EvaporationPotentialOptional& SubmodelComplexType::
  getEvaporationPotential ()
  {
    return this->evaporationPotential_;
  }

  void SubmodelComplexType::
  setEvaporationPotential (const EvaporationPotentialType& x)
  {
    this->evaporationPotential_.set (x);
  }

  void SubmodelComplexType::
  setEvaporationPotential (const EvaporationPotentialOptional& x)
  {
    this->evaporationPotential_ = x;
  }

  void SubmodelComplexType::
  setEvaporationPotential (::std::auto_ptr< EvaporationPotentialType > x)
  {
    this->evaporationPotential_.set (x);
  }

  const SubmodelComplexType::StorageSystemOptional& SubmodelComplexType::
  getStorageSystem () const
  {
    return this->storageSystem_;
  }

  SubmodelComplexType::StorageSystemOptional& SubmodelComplexType::
  getStorageSystem ()
  {
    return this->storageSystem_;
  }

  void SubmodelComplexType::
  setStorageSystem (const StorageSystemType& x)
  {
    this->storageSystem_.set (x);
  }

  void SubmodelComplexType::
  setStorageSystem (const StorageSystemOptional& x)
  {
    this->storageSystem_ = x;
  }

  void SubmodelComplexType::
  setStorageSystem (::std::auto_ptr< StorageSystemType > x)
  {
    this->storageSystem_.set (x);
  }


  // ReleaseTotalComplexType
  // 

  const ReleaseTotalComplexType::InputType& ReleaseTotalComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ReleaseTotalComplexType::InputType& ReleaseTotalComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ReleaseTotalComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ReleaseTotalComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ReleaseTotalComplexType::OutputType& ReleaseTotalComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ReleaseTotalComplexType::OutputType& ReleaseTotalComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ReleaseTotalComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ReleaseTotalComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ReleaseTotalComplexType::IdType& ReleaseTotalComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ReleaseTotalComplexType::IdType& ReleaseTotalComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ReleaseTotalComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ReleaseTotalComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ReleaseTotalComplexType::NameOptional& ReleaseTotalComplexType::
  getName () const
  {
    return this->name_;
  }

  ReleaseTotalComplexType::NameOptional& ReleaseTotalComplexType::
  getName ()
  {
    return this->name_;
  }

  void ReleaseTotalComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ReleaseTotalComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ReleaseTotalComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterReleaseTotalComplexType
  // 

  const ParameterReleaseTotalComplexType::AREAType& ParameterReleaseTotalComplexType::
  getAREA () const
  {
    return this->AREA_.get ();
  }

  ParameterReleaseTotalComplexType::AREAType& ParameterReleaseTotalComplexType::
  getAREA ()
  {
    return this->AREA_.get ();
  }

  void ParameterReleaseTotalComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterReleaseTotalComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }


  // InputReleaseTotalComplexType
  // 

  const InputReleaseTotalComplexType::DischargeSequence& InputReleaseTotalComplexType::
  getDischarge () const
  {
    return this->discharge_;
  }

  InputReleaseTotalComplexType::DischargeSequence& InputReleaseTotalComplexType::
  getDischarge ()
  {
    return this->discharge_;
  }

  void InputReleaseTotalComplexType::
  setDischarge (const DischargeSequence& s)
  {
    this->discharge_ = s;
  }

  const InputReleaseTotalComplexType::DischargeType& InputReleaseTotalComplexType::
  getDischargeDefaultValue ()
  {
    return discharge_default_value_;
  }


  // EvaporationPotentialComplexType
  // 

  const EvaporationPotentialComplexType::ParameterType& EvaporationPotentialComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  EvaporationPotentialComplexType::ParameterType& EvaporationPotentialComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void EvaporationPotentialComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void EvaporationPotentialComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const EvaporationPotentialComplexType::InputType& EvaporationPotentialComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  EvaporationPotentialComplexType::InputType& EvaporationPotentialComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void EvaporationPotentialComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void EvaporationPotentialComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const EvaporationPotentialComplexType::OutputType& EvaporationPotentialComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  EvaporationPotentialComplexType::OutputType& EvaporationPotentialComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void EvaporationPotentialComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void EvaporationPotentialComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const EvaporationPotentialComplexType::IdType& EvaporationPotentialComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  EvaporationPotentialComplexType::IdType& EvaporationPotentialComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void EvaporationPotentialComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void EvaporationPotentialComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const EvaporationPotentialComplexType::NameOptional& EvaporationPotentialComplexType::
  getName () const
  {
    return this->name_;
  }

  EvaporationPotentialComplexType::NameOptional& EvaporationPotentialComplexType::
  getName ()
  {
    return this->name_;
  }

  void EvaporationPotentialComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void EvaporationPotentialComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void EvaporationPotentialComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterEvaporationPotentialComplexType
  // 

  const ParameterEvaporationPotentialComplexType::ECORROptional& ParameterEvaporationPotentialComplexType::
  getECORR () const
  {
    return this->ECORR_;
  }

  ParameterEvaporationPotentialComplexType::ECORROptional& ParameterEvaporationPotentialComplexType::
  getECORR ()
  {
    return this->ECORR_;
  }

  void ParameterEvaporationPotentialComplexType::
  setECORR (const ECORRType& x)
  {
    this->ECORR_.set (x);
  }

  void ParameterEvaporationPotentialComplexType::
  setECORR (const ECORROptional& x)
  {
    this->ECORR_ = x;
  }

  void ParameterEvaporationPotentialComplexType::
  setECORR (::std::auto_ptr< ECORRType > x)
  {
    this->ECORR_.set (x);
  }

  const ParameterEvaporationPotentialComplexType::ETFType& ParameterEvaporationPotentialComplexType::
  getETF () const
  {
    return this->ETF_.get ();
  }

  ParameterEvaporationPotentialComplexType::ETFType& ParameterEvaporationPotentialComplexType::
  getETF ()
  {
    return this->ETF_.get ();
  }

  void ParameterEvaporationPotentialComplexType::
  setETF (const ETFType& x)
  {
    this->ETF_.set (x);
  }

  void ParameterEvaporationPotentialComplexType::
  setETF (::std::auto_ptr< ETFType > x)
  {
    this->ETF_.set (x);
  }


  // InputEvaporationPotentialComplexType
  // 

  const InputEvaporationPotentialComplexType::EPMType& InputEvaporationPotentialComplexType::
  getEPM () const
  {
    return this->EPM_.get ();
  }

  InputEvaporationPotentialComplexType::EPMType& InputEvaporationPotentialComplexType::
  getEPM ()
  {
    return this->EPM_.get ();
  }

  void InputEvaporationPotentialComplexType::
  setEPM (const EPMType& x)
  {
    this->EPM_.set (x);
  }

  void InputEvaporationPotentialComplexType::
  setEPM (::std::auto_ptr< EPMType > x)
  {
    this->EPM_.set (x);
  }

  const InputEvaporationPotentialComplexType::EPMType& InputEvaporationPotentialComplexType::
  getEPMDefaultValue ()
  {
    return EPM_default_value_;
  }

  const InputEvaporationPotentialComplexType::TMType& InputEvaporationPotentialComplexType::
  getTM () const
  {
    return this->TM_.get ();
  }

  InputEvaporationPotentialComplexType::TMType& InputEvaporationPotentialComplexType::
  getTM ()
  {
    return this->TM_.get ();
  }

  void InputEvaporationPotentialComplexType::
  setTM (const TMType& x)
  {
    this->TM_.set (x);
  }

  void InputEvaporationPotentialComplexType::
  setTM (::std::auto_ptr< TMType > x)
  {
    this->TM_.set (x);
  }

  const InputEvaporationPotentialComplexType::TMType& InputEvaporationPotentialComplexType::
  getTMDefaultValue ()
  {
    return TM_default_value_;
  }

  const InputEvaporationPotentialComplexType::TType& InputEvaporationPotentialComplexType::
  getT () const
  {
    return this->T_.get ();
  }

  InputEvaporationPotentialComplexType::TType& InputEvaporationPotentialComplexType::
  getT ()
  {
    return this->T_.get ();
  }

  void InputEvaporationPotentialComplexType::
  setT (const TType& x)
  {
    this->T_.set (x);
  }

  void InputEvaporationPotentialComplexType::
  setT (::std::auto_ptr< TType > x)
  {
    this->T_.set (x);
  }

  const InputEvaporationPotentialComplexType::TType& InputEvaporationPotentialComplexType::
  getTDefaultValue ()
  {
    return T_default_value_;
  }


  // OutputEvaporationPotentialComplexType
  // 

  const OutputEvaporationPotentialComplexType::EPType& OutputEvaporationPotentialComplexType::
  getEP () const
  {
    return this->EP_.get ();
  }

  OutputEvaporationPotentialComplexType::EPType& OutputEvaporationPotentialComplexType::
  getEP ()
  {
    return this->EP_.get ();
  }

  void OutputEvaporationPotentialComplexType::
  setEP (const EPType& x)
  {
    this->EP_.set (x);
  }

  void OutputEvaporationPotentialComplexType::
  setEP (::std::auto_ptr< EPType > x)
  {
    this->EP_.set (x);
  }

  const OutputEvaporationPotentialComplexType::EPType& OutputEvaporationPotentialComplexType::
  getEPDefaultValue ()
  {
    return EP_default_value_;
  }


  // TypicalProfileComplexType
  // 

  const TypicalProfileComplexType::DataSequence& TypicalProfileComplexType::
  getData () const
  {
    return this->data_;
  }

  TypicalProfileComplexType::DataSequence& TypicalProfileComplexType::
  getData ()
  {
    return this->data_;
  }

  void TypicalProfileComplexType::
  setData (const DataSequence& s)
  {
    this->data_ = s;
  }

  const TypicalProfileComplexType::OutputType& TypicalProfileComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  TypicalProfileComplexType::OutputType& TypicalProfileComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void TypicalProfileComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void TypicalProfileComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const TypicalProfileComplexType::IdType& TypicalProfileComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TypicalProfileComplexType::IdType& TypicalProfileComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TypicalProfileComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TypicalProfileComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const TypicalProfileComplexType::NameOptional& TypicalProfileComplexType::
  getName () const
  {
    return this->name_;
  }

  TypicalProfileComplexType::NameOptional& TypicalProfileComplexType::
  getName ()
  {
    return this->name_;
  }

  void TypicalProfileComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void TypicalProfileComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void TypicalProfileComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // DataTypicalProfileComplexType
  // 

  const DataTypicalProfileComplexType::MonthOfYearType& DataTypicalProfileComplexType::
  getMonthOfYear () const
  {
    return this->monthOfYear_.get ();
  }

  DataTypicalProfileComplexType::MonthOfYearType& DataTypicalProfileComplexType::
  getMonthOfYear ()
  {
    return this->monthOfYear_.get ();
  }

  void DataTypicalProfileComplexType::
  setMonthOfYear (const MonthOfYearType& x)
  {
    this->monthOfYear_.set (x);
  }

  void DataTypicalProfileComplexType::
  setMonthOfYear (::std::auto_ptr< MonthOfYearType > x)
  {
    this->monthOfYear_.set (x);
  }

  const DataTypicalProfileComplexType::ValueType& DataTypicalProfileComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  DataTypicalProfileComplexType::ValueType& DataTypicalProfileComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void DataTypicalProfileComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // SnowRainJunctionComplexType
  // 

  const SnowRainJunctionComplexType::ParameterType& SnowRainJunctionComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  SnowRainJunctionComplexType::ParameterType& SnowRainJunctionComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void SnowRainJunctionComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void SnowRainJunctionComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const SnowRainJunctionComplexType::InputType& SnowRainJunctionComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  SnowRainJunctionComplexType::InputType& SnowRainJunctionComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void SnowRainJunctionComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void SnowRainJunctionComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const SnowRainJunctionComplexType::OutputType& SnowRainJunctionComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  SnowRainJunctionComplexType::OutputType& SnowRainJunctionComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void SnowRainJunctionComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void SnowRainJunctionComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const SnowRainJunctionComplexType::IdType& SnowRainJunctionComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  SnowRainJunctionComplexType::IdType& SnowRainJunctionComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void SnowRainJunctionComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void SnowRainJunctionComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const SnowRainJunctionComplexType::NameOptional& SnowRainJunctionComplexType::
  getName () const
  {
    return this->name_;
  }

  SnowRainJunctionComplexType::NameOptional& SnowRainJunctionComplexType::
  getName ()
  {
    return this->name_;
  }

  void SnowRainJunctionComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void SnowRainJunctionComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void SnowRainJunctionComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterSnowRainJunctionComplexType
  // 

  const ParameterSnowRainJunctionComplexType::DOptional& ParameterSnowRainJunctionComplexType::
  getD () const
  {
    return this->D_;
  }

  ParameterSnowRainJunctionComplexType::DOptional& ParameterSnowRainJunctionComplexType::
  getD ()
  {
    return this->D_;
  }

  void ParameterSnowRainJunctionComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void ParameterSnowRainJunctionComplexType::
  setD (const DOptional& x)
  {
    this->D_ = x;
  }

  void ParameterSnowRainJunctionComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }

  const ParameterSnowRainJunctionComplexType::RFCFOptional& ParameterSnowRainJunctionComplexType::
  getRFCF () const
  {
    return this->RFCF_;
  }

  ParameterSnowRainJunctionComplexType::RFCFOptional& ParameterSnowRainJunctionComplexType::
  getRFCF ()
  {
    return this->RFCF_;
  }

  void ParameterSnowRainJunctionComplexType::
  setRFCF (const RFCFType& x)
  {
    this->RFCF_.set (x);
  }

  void ParameterSnowRainJunctionComplexType::
  setRFCF (const RFCFOptional& x)
  {
    this->RFCF_ = x;
  }

  void ParameterSnowRainJunctionComplexType::
  setRFCF (::std::auto_ptr< RFCFType > x)
  {
    this->RFCF_.set (x);
  }

  const ParameterSnowRainJunctionComplexType::SFCFOptional& ParameterSnowRainJunctionComplexType::
  getSFCF () const
  {
    return this->SFCF_;
  }

  ParameterSnowRainJunctionComplexType::SFCFOptional& ParameterSnowRainJunctionComplexType::
  getSFCF ()
  {
    return this->SFCF_;
  }

  void ParameterSnowRainJunctionComplexType::
  setSFCF (const SFCFType& x)
  {
    this->SFCF_.set (x);
  }

  void ParameterSnowRainJunctionComplexType::
  setSFCF (const SFCFOptional& x)
  {
    this->SFCF_ = x;
  }

  void ParameterSnowRainJunctionComplexType::
  setSFCF (::std::auto_ptr< SFCFType > x)
  {
    this->SFCF_.set (x);
  }

  const ParameterSnowRainJunctionComplexType::TTType& ParameterSnowRainJunctionComplexType::
  getTT () const
  {
    return this->TT_.get ();
  }

  ParameterSnowRainJunctionComplexType::TTType& ParameterSnowRainJunctionComplexType::
  getTT ()
  {
    return this->TT_.get ();
  }

  void ParameterSnowRainJunctionComplexType::
  setTT (const TTType& x)
  {
    this->TT_.set (x);
  }

  void ParameterSnowRainJunctionComplexType::
  setTT (::std::auto_ptr< TTType > x)
  {
    this->TT_.set (x);
  }

  const ParameterSnowRainJunctionComplexType::TTIType& ParameterSnowRainJunctionComplexType::
  getTTI () const
  {
    return this->TTI_.get ();
  }

  ParameterSnowRainJunctionComplexType::TTIType& ParameterSnowRainJunctionComplexType::
  getTTI ()
  {
    return this->TTI_.get ();
  }

  void ParameterSnowRainJunctionComplexType::
  setTTI (const TTIType& x)
  {
    this->TTI_.set (x);
  }

  void ParameterSnowRainJunctionComplexType::
  setTTI (::std::auto_ptr< TTIType > x)
  {
    this->TTI_.set (x);
  }


  // InputSnowRainJunctionComplexType
  // 

  const InputSnowRainJunctionComplexType::PType& InputSnowRainJunctionComplexType::
  getP () const
  {
    return this->P_.get ();
  }

  InputSnowRainJunctionComplexType::PType& InputSnowRainJunctionComplexType::
  getP ()
  {
    return this->P_.get ();
  }

  void InputSnowRainJunctionComplexType::
  setP (const PType& x)
  {
    this->P_.set (x);
  }

  void InputSnowRainJunctionComplexType::
  setP (::std::auto_ptr< PType > x)
  {
    this->P_.set (x);
  }

  const InputSnowRainJunctionComplexType::PType& InputSnowRainJunctionComplexType::
  getPDefaultValue ()
  {
    return P_default_value_;
  }

  const InputSnowRainJunctionComplexType::TType& InputSnowRainJunctionComplexType::
  getT () const
  {
    return this->T_.get ();
  }

  InputSnowRainJunctionComplexType::TType& InputSnowRainJunctionComplexType::
  getT ()
  {
    return this->T_.get ();
  }

  void InputSnowRainJunctionComplexType::
  setT (const TType& x)
  {
    this->T_.set (x);
  }

  void InputSnowRainJunctionComplexType::
  setT (::std::auto_ptr< TType > x)
  {
    this->T_.set (x);
  }

  const InputSnowRainJunctionComplexType::TType& InputSnowRainJunctionComplexType::
  getTDefaultValue ()
  {
    return T_default_value_;
  }


  // OutputSnowRainJunctionComplexType
  // 

  const OutputSnowRainJunctionComplexType::RFType& OutputSnowRainJunctionComplexType::
  getRF () const
  {
    return this->RF_.get ();
  }

  OutputSnowRainJunctionComplexType::RFType& OutputSnowRainJunctionComplexType::
  getRF ()
  {
    return this->RF_.get ();
  }

  void OutputSnowRainJunctionComplexType::
  setRF (const RFType& x)
  {
    this->RF_.set (x);
  }

  void OutputSnowRainJunctionComplexType::
  setRF (::std::auto_ptr< RFType > x)
  {
    this->RF_.set (x);
  }

  const OutputSnowRainJunctionComplexType::RFType& OutputSnowRainJunctionComplexType::
  getRFDefaultValue ()
  {
    return RF_default_value_;
  }

  const OutputSnowRainJunctionComplexType::SFType& OutputSnowRainJunctionComplexType::
  getSF () const
  {
    return this->SF_.get ();
  }

  OutputSnowRainJunctionComplexType::SFType& OutputSnowRainJunctionComplexType::
  getSF ()
  {
    return this->SF_.get ();
  }

  void OutputSnowRainJunctionComplexType::
  setSF (const SFType& x)
  {
    this->SF_.set (x);
  }

  void OutputSnowRainJunctionComplexType::
  setSF (::std::auto_ptr< SFType > x)
  {
    this->SF_.set (x);
  }

  const OutputSnowRainJunctionComplexType::SFType& OutputSnowRainJunctionComplexType::
  getSFDefaultValue ()
  {
    return SF_default_value_;
  }


  // StorageSystemComplexType
  // 

  const StorageSystemComplexType::SettingsOptional& StorageSystemComplexType::
  getSettings () const
  {
    return this->settings_;
  }

  StorageSystemComplexType::SettingsOptional& StorageSystemComplexType::
  getSettings ()
  {
    return this->settings_;
  }

  void StorageSystemComplexType::
  setSettings (const SettingsType& x)
  {
    this->settings_.set (x);
  }

  void StorageSystemComplexType::
  setSettings (const SettingsOptional& x)
  {
    this->settings_ = x;
  }

  void StorageSystemComplexType::
  setSettings (::std::auto_ptr< SettingsType > x)
  {
    this->settings_.set (x);
  }

  const StorageSystemComplexType::StorageNodeSequence& StorageSystemComplexType::
  getStorageNode () const
  {
    return this->storageNode_;
  }

  StorageSystemComplexType::StorageNodeSequence& StorageSystemComplexType::
  getStorageNode ()
  {
    return this->storageNode_;
  }

  void StorageSystemComplexType::
  setStorageNode (const StorageNodeSequence& s)
  {
    this->storageNode_ = s;
  }

  const StorageSystemComplexType::LinkSequence& StorageSystemComplexType::
  getLink () const
  {
    return this->link_;
  }

  StorageSystemComplexType::LinkSequence& StorageSystemComplexType::
  getLink ()
  {
    return this->link_;
  }

  void StorageSystemComplexType::
  setLink (const LinkSequence& s)
  {
    this->link_ = s;
  }

  const StorageSystemComplexType::OutputOptional& StorageSystemComplexType::
  getOutput () const
  {
    return this->output_;
  }

  StorageSystemComplexType::OutputOptional& StorageSystemComplexType::
  getOutput ()
  {
    return this->output_;
  }

  void StorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void StorageSystemComplexType::
  setOutput (const OutputOptional& x)
  {
    this->output_ = x;
  }

  void StorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const StorageSystemComplexType::IdType& StorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  StorageSystemComplexType::IdType& StorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void StorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void StorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const StorageSystemComplexType::NameOptional& StorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  StorageSystemComplexType::NameOptional& StorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void StorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void StorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void StorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // StorageSystemSettingsComplexType
  // 

  const StorageSystemSettingsComplexType::ConvergenceThresholdType& StorageSystemSettingsComplexType::
  getConvergenceThreshold () const
  {
    return this->convergenceThreshold_.get ();
  }

  StorageSystemSettingsComplexType::ConvergenceThresholdType& StorageSystemSettingsComplexType::
  getConvergenceThreshold ()
  {
    return this->convergenceThreshold_.get ();
  }

  void StorageSystemSettingsComplexType::
  setConvergenceThreshold (const ConvergenceThresholdType& x)
  {
    this->convergenceThreshold_.set (x);
  }

  StorageSystemSettingsComplexType::ConvergenceThresholdType StorageSystemSettingsComplexType::
  getConvergenceThresholdDefaultValue ()
  {
    return ConvergenceThresholdType (1e-6);
  }

  const StorageSystemSettingsComplexType::AcceptableConvergenceThresholdOptional& StorageSystemSettingsComplexType::
  getAcceptableConvergenceThreshold () const
  {
    return this->acceptableConvergenceThreshold_;
  }

  StorageSystemSettingsComplexType::AcceptableConvergenceThresholdOptional& StorageSystemSettingsComplexType::
  getAcceptableConvergenceThreshold ()
  {
    return this->acceptableConvergenceThreshold_;
  }

  void StorageSystemSettingsComplexType::
  setAcceptableConvergenceThreshold (const AcceptableConvergenceThresholdType& x)
  {
    this->acceptableConvergenceThreshold_.set (x);
  }

  void StorageSystemSettingsComplexType::
  setAcceptableConvergenceThreshold (const AcceptableConvergenceThresholdOptional& x)
  {
    this->acceptableConvergenceThreshold_ = x;
  }

  StorageSystemSettingsComplexType::AcceptableConvergenceThresholdType StorageSystemSettingsComplexType::
  getAcceptableConvergenceThresholdDefaultValue ()
  {
    return AcceptableConvergenceThresholdType (1e-4);
  }

  const StorageSystemSettingsComplexType::TreatNonConvergenceAsErrorType& StorageSystemSettingsComplexType::
  getTreatNonConvergenceAsError () const
  {
    return this->treatNonConvergenceAsError_.get ();
  }

  StorageSystemSettingsComplexType::TreatNonConvergenceAsErrorType& StorageSystemSettingsComplexType::
  getTreatNonConvergenceAsError ()
  {
    return this->treatNonConvergenceAsError_.get ();
  }

  void StorageSystemSettingsComplexType::
  setTreatNonConvergenceAsError (const TreatNonConvergenceAsErrorType& x)
  {
    this->treatNonConvergenceAsError_.set (x);
  }

  StorageSystemSettingsComplexType::TreatNonConvergenceAsErrorType StorageSystemSettingsComplexType::
  getTreatNonConvergenceAsErrorDefaultValue ()
  {
    return TreatNonConvergenceAsErrorType (true);
  }


  // OutputStorageSystemComplexType
  // 

  const OutputStorageSystemComplexType::NJacType& OutputStorageSystemComplexType::
  getNJac () const
  {
    return this->nJac_.get ();
  }

  OutputStorageSystemComplexType::NJacType& OutputStorageSystemComplexType::
  getNJac ()
  {
    return this->nJac_.get ();
  }

  void OutputStorageSystemComplexType::
  setNJac (const NJacType& x)
  {
    this->nJac_.set (x);
  }

  void OutputStorageSystemComplexType::
  setNJac (::std::auto_ptr< NJacType > x)
  {
    this->nJac_.set (x);
  }

  const OutputStorageSystemComplexType::NFunType& OutputStorageSystemComplexType::
  getNFun () const
  {
    return this->nFun_.get ();
  }

  OutputStorageSystemComplexType::NFunType& OutputStorageSystemComplexType::
  getNFun ()
  {
    return this->nFun_.get ();
  }

  void OutputStorageSystemComplexType::
  setNFun (const NFunType& x)
  {
    this->nFun_.set (x);
  }

  void OutputStorageSystemComplexType::
  setNFun (::std::auto_ptr< NFunType > x)
  {
    this->nFun_.set (x);
  }

  const OutputStorageSystemComplexType::ResType& OutputStorageSystemComplexType::
  getRes () const
  {
    return this->res_.get ();
  }

  OutputStorageSystemComplexType::ResType& OutputStorageSystemComplexType::
  getRes ()
  {
    return this->res_.get ();
  }

  void OutputStorageSystemComplexType::
  setRes (const ResType& x)
  {
    this->res_.set (x);
  }

  void OutputStorageSystemComplexType::
  setRes (::std::auto_ptr< ResType > x)
  {
    this->res_.set (x);
  }


  // NodeStorageSystemComplexType
  // 

  const NodeStorageSystemComplexType::AREAOptional& NodeStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  NodeStorageSystemComplexType::AREAOptional& NodeStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void NodeStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void NodeStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void NodeStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const NodeStorageSystemComplexType::StateMinOptional& NodeStorageSystemComplexType::
  getStateMin () const
  {
    return this->stateMin_;
  }

  NodeStorageSystemComplexType::StateMinOptional& NodeStorageSystemComplexType::
  getStateMin ()
  {
    return this->stateMin_;
  }

  void NodeStorageSystemComplexType::
  setStateMin (const StateMinType& x)
  {
    this->stateMin_.set (x);
  }

  void NodeStorageSystemComplexType::
  setStateMin (const StateMinOptional& x)
  {
    this->stateMin_ = x;
  }

  void NodeStorageSystemComplexType::
  setStateMin (::std::auto_ptr< StateMinType > x)
  {
    this->stateMin_.set (x);
  }

  const NodeStorageSystemComplexType::StateMaxOptional& NodeStorageSystemComplexType::
  getStateMax () const
  {
    return this->stateMax_;
  }

  NodeStorageSystemComplexType::StateMaxOptional& NodeStorageSystemComplexType::
  getStateMax ()
  {
    return this->stateMax_;
  }

  void NodeStorageSystemComplexType::
  setStateMax (const StateMaxType& x)
  {
    this->stateMax_.set (x);
  }

  void NodeStorageSystemComplexType::
  setStateMax (const StateMaxOptional& x)
  {
    this->stateMax_ = x;
  }

  void NodeStorageSystemComplexType::
  setStateMax (::std::auto_ptr< StateMaxType > x)
  {
    this->stateMax_.set (x);
  }

  const NodeStorageSystemComplexType::InputOptional& NodeStorageSystemComplexType::
  getInput () const
  {
    return this->input_;
  }

  NodeStorageSystemComplexType::InputOptional& NodeStorageSystemComplexType::
  getInput ()
  {
    return this->input_;
  }

  void NodeStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void NodeStorageSystemComplexType::
  setInput (const InputOptional& x)
  {
    this->input_ = x;
  }

  void NodeStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const NodeStorageSystemComplexType::StateType& NodeStorageSystemComplexType::
  getState () const
  {
    return this->state_.get ();
  }

  NodeStorageSystemComplexType::StateType& NodeStorageSystemComplexType::
  getState ()
  {
    return this->state_.get ();
  }

  void NodeStorageSystemComplexType::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void NodeStorageSystemComplexType::
  setState (::std::auto_ptr< StateType > x)
  {
    this->state_.set (x);
  }

  const NodeStorageSystemComplexType::ResiduumType& NodeStorageSystemComplexType::
  getResiduum () const
  {
    return this->residuum_.get ();
  }

  NodeStorageSystemComplexType::ResiduumType& NodeStorageSystemComplexType::
  getResiduum ()
  {
    return this->residuum_.get ();
  }

  void NodeStorageSystemComplexType::
  setResiduum (const ResiduumType& x)
  {
    this->residuum_.set (x);
  }

  void NodeStorageSystemComplexType::
  setResiduum (::std::auto_ptr< ResiduumType > x)
  {
    this->residuum_.set (x);
  }

  const NodeStorageSystemComplexType::IdType& NodeStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  NodeStorageSystemComplexType::IdType& NodeStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void NodeStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void NodeStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const NodeStorageSystemComplexType::NameOptional& NodeStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  NodeStorageSystemComplexType::NameOptional& NodeStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void NodeStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void NodeStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void NodeStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputNodeStorageSystemComplexType
  // 

  const InputNodeStorageSystemComplexType::DischargeSequence& InputNodeStorageSystemComplexType::
  getDischarge () const
  {
    return this->discharge_;
  }

  InputNodeStorageSystemComplexType::DischargeSequence& InputNodeStorageSystemComplexType::
  getDischarge ()
  {
    return this->discharge_;
  }

  void InputNodeStorageSystemComplexType::
  setDischarge (const DischargeSequence& s)
  {
    this->discharge_ = s;
  }

  const InputNodeStorageSystemComplexType::UnitVolumeSequence& InputNodeStorageSystemComplexType::
  getUnitVolume () const
  {
    return this->unitVolume_;
  }

  InputNodeStorageSystemComplexType::UnitVolumeSequence& InputNodeStorageSystemComplexType::
  getUnitVolume ()
  {
    return this->unitVolume_;
  }

  void InputNodeStorageSystemComplexType::
  setUnitVolume (const UnitVolumeSequence& s)
  {
    this->unitVolume_ = s;
  }

  const InputNodeStorageSystemComplexType::StateOptional& InputNodeStorageSystemComplexType::
  getState () const
  {
    return this->state_;
  }

  InputNodeStorageSystemComplexType::StateOptional& InputNodeStorageSystemComplexType::
  getState ()
  {
    return this->state_;
  }

  void InputNodeStorageSystemComplexType::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void InputNodeStorageSystemComplexType::
  setState (const StateOptional& x)
  {
    this->state_ = x;
  }

  void InputNodeStorageSystemComplexType::
  setState (::std::auto_ptr< StateType > x)
  {
    this->state_.set (x);
  }


  // LinkStorageSystemComplexType
  // 

  const LinkStorageSystemComplexType::CapillaryFlowOptional& LinkStorageSystemComplexType::
  getCapillaryFlow () const
  {
    return this->capillaryFlow_;
  }

  LinkStorageSystemComplexType::CapillaryFlowOptional& LinkStorageSystemComplexType::
  getCapillaryFlow ()
  {
    return this->capillaryFlow_;
  }

  void LinkStorageSystemComplexType::
  setCapillaryFlow (const CapillaryFlowType& x)
  {
    this->capillaryFlow_.set (x);
  }

  void LinkStorageSystemComplexType::
  setCapillaryFlow (const CapillaryFlowOptional& x)
  {
    this->capillaryFlow_ = x;
  }

  void LinkStorageSystemComplexType::
  setCapillaryFlow (::std::auto_ptr< CapillaryFlowType > x)
  {
    this->capillaryFlow_.set (x);
  }

  const LinkStorageSystemComplexType::EvaporationActualOptional& LinkStorageSystemComplexType::
  getEvaporationActual () const
  {
    return this->evaporationActual_;
  }

  LinkStorageSystemComplexType::EvaporationActualOptional& LinkStorageSystemComplexType::
  getEvaporationActual ()
  {
    return this->evaporationActual_;
  }

  void LinkStorageSystemComplexType::
  setEvaporationActual (const EvaporationActualType& x)
  {
    this->evaporationActual_.set (x);
  }

  void LinkStorageSystemComplexType::
  setEvaporationActual (const EvaporationActualOptional& x)
  {
    this->evaporationActual_ = x;
  }

  void LinkStorageSystemComplexType::
  setEvaporationActual (::std::auto_ptr< EvaporationActualType > x)
  {
    this->evaporationActual_.set (x);
  }

  const LinkStorageSystemComplexType::EvaporationInterceptionOptional& LinkStorageSystemComplexType::
  getEvaporationInterception () const
  {
    return this->evaporationInterception_;
  }

  LinkStorageSystemComplexType::EvaporationInterceptionOptional& LinkStorageSystemComplexType::
  getEvaporationInterception ()
  {
    return this->evaporationInterception_;
  }

  void LinkStorageSystemComplexType::
  setEvaporationInterception (const EvaporationInterceptionType& x)
  {
    this->evaporationInterception_.set (x);
  }

  void LinkStorageSystemComplexType::
  setEvaporationInterception (const EvaporationInterceptionOptional& x)
  {
    this->evaporationInterception_ = x;
  }

  void LinkStorageSystemComplexType::
  setEvaporationInterception (::std::auto_ptr< EvaporationInterceptionType > x)
  {
    this->evaporationInterception_.set (x);
  }

  const LinkStorageSystemComplexType::GroundwaterFlowOptional& LinkStorageSystemComplexType::
  getGroundwaterFlow () const
  {
    return this->groundwaterFlow_;
  }

  LinkStorageSystemComplexType::GroundwaterFlowOptional& LinkStorageSystemComplexType::
  getGroundwaterFlow ()
  {
    return this->groundwaterFlow_;
  }

  void LinkStorageSystemComplexType::
  setGroundwaterFlow (const GroundwaterFlowType& x)
  {
    this->groundwaterFlow_.set (x);
  }

  void LinkStorageSystemComplexType::
  setGroundwaterFlow (const GroundwaterFlowOptional& x)
  {
    this->groundwaterFlow_ = x;
  }

  void LinkStorageSystemComplexType::
  setGroundwaterFlow (::std::auto_ptr< GroundwaterFlowType > x)
  {
    this->groundwaterFlow_.set (x);
  }

  const LinkStorageSystemComplexType::PercolationOptional& LinkStorageSystemComplexType::
  getPercolation () const
  {
    return this->percolation_;
  }

  LinkStorageSystemComplexType::PercolationOptional& LinkStorageSystemComplexType::
  getPercolation ()
  {
    return this->percolation_;
  }

  void LinkStorageSystemComplexType::
  setPercolation (const PercolationType& x)
  {
    this->percolation_.set (x);
  }

  void LinkStorageSystemComplexType::
  setPercolation (const PercolationOptional& x)
  {
    this->percolation_ = x;
  }

  void LinkStorageSystemComplexType::
  setPercolation (::std::auto_ptr< PercolationType > x)
  {
    this->percolation_.set (x);
  }

  const LinkStorageSystemComplexType::ReleaseInterceptionOptional& LinkStorageSystemComplexType::
  getReleaseInterception () const
  {
    return this->releaseInterception_;
  }

  LinkStorageSystemComplexType::ReleaseInterceptionOptional& LinkStorageSystemComplexType::
  getReleaseInterception ()
  {
    return this->releaseInterception_;
  }

  void LinkStorageSystemComplexType::
  setReleaseInterception (const ReleaseInterceptionType& x)
  {
    this->releaseInterception_.set (x);
  }

  void LinkStorageSystemComplexType::
  setReleaseInterception (const ReleaseInterceptionOptional& x)
  {
    this->releaseInterception_ = x;
  }

  void LinkStorageSystemComplexType::
  setReleaseInterception (::std::auto_ptr< ReleaseInterceptionType > x)
  {
    this->releaseInterception_.set (x);
  }

  const LinkStorageSystemComplexType::ResponseOptional& LinkStorageSystemComplexType::
  getResponse () const
  {
    return this->response_;
  }

  LinkStorageSystemComplexType::ResponseOptional& LinkStorageSystemComplexType::
  getResponse ()
  {
    return this->response_;
  }

  void LinkStorageSystemComplexType::
  setResponse (const ResponseType& x)
  {
    this->response_.set (x);
  }

  void LinkStorageSystemComplexType::
  setResponse (const ResponseOptional& x)
  {
    this->response_ = x;
  }

  void LinkStorageSystemComplexType::
  setResponse (::std::auto_ptr< ResponseType > x)
  {
    this->response_.set (x);
  }

  const LinkStorageSystemComplexType::SewerOverflowOptional& LinkStorageSystemComplexType::
  getSewerOverflow () const
  {
    return this->sewerOverflow_;
  }

  LinkStorageSystemComplexType::SewerOverflowOptional& LinkStorageSystemComplexType::
  getSewerOverflow ()
  {
    return this->sewerOverflow_;
  }

  void LinkStorageSystemComplexType::
  setSewerOverflow (const SewerOverflowType& x)
  {
    this->sewerOverflow_.set (x);
  }

  void LinkStorageSystemComplexType::
  setSewerOverflow (const SewerOverflowOptional& x)
  {
    this->sewerOverflow_ = x;
  }

  void LinkStorageSystemComplexType::
  setSewerOverflow (::std::auto_ptr< SewerOverflowType > x)
  {
    this->sewerOverflow_.set (x);
  }

  const LinkStorageSystemComplexType::SoilRunoffOptional& LinkStorageSystemComplexType::
  getSoilRunoff () const
  {
    return this->soilRunoff_;
  }

  LinkStorageSystemComplexType::SoilRunoffOptional& LinkStorageSystemComplexType::
  getSoilRunoff ()
  {
    return this->soilRunoff_;
  }

  void LinkStorageSystemComplexType::
  setSoilRunoff (const SoilRunoffType& x)
  {
    this->soilRunoff_.set (x);
  }

  void LinkStorageSystemComplexType::
  setSoilRunoff (const SoilRunoffOptional& x)
  {
    this->soilRunoff_ = x;
  }

  void LinkStorageSystemComplexType::
  setSoilRunoff (::std::auto_ptr< SoilRunoffType > x)
  {
    this->soilRunoff_.set (x);
  }

  const LinkStorageSystemComplexType::WasteWaterTreatmentPlantOptional& LinkStorageSystemComplexType::
  getWasteWaterTreatmentPlant () const
  {
    return this->wasteWaterTreatmentPlant_;
  }

  LinkStorageSystemComplexType::WasteWaterTreatmentPlantOptional& LinkStorageSystemComplexType::
  getWasteWaterTreatmentPlant ()
  {
    return this->wasteWaterTreatmentPlant_;
  }

  void LinkStorageSystemComplexType::
  setWasteWaterTreatmentPlant (const WasteWaterTreatmentPlantType& x)
  {
    this->wasteWaterTreatmentPlant_.set (x);
  }

  void LinkStorageSystemComplexType::
  setWasteWaterTreatmentPlant (const WasteWaterTreatmentPlantOptional& x)
  {
    this->wasteWaterTreatmentPlant_ = x;
  }

  void LinkStorageSystemComplexType::
  setWasteWaterTreatmentPlant (::std::auto_ptr< WasteWaterTreatmentPlantType > x)
  {
    this->wasteWaterTreatmentPlant_.set (x);
  }

  const LinkStorageSystemComplexType::WaterDistributionConstantOptional& LinkStorageSystemComplexType::
  getWaterDistributionConstant () const
  {
    return this->waterDistributionConstant_;
  }

  LinkStorageSystemComplexType::WaterDistributionConstantOptional& LinkStorageSystemComplexType::
  getWaterDistributionConstant ()
  {
    return this->waterDistributionConstant_;
  }

  void LinkStorageSystemComplexType::
  setWaterDistributionConstant (const WaterDistributionConstantType& x)
  {
    this->waterDistributionConstant_.set (x);
  }

  void LinkStorageSystemComplexType::
  setWaterDistributionConstant (const WaterDistributionConstantOptional& x)
  {
    this->waterDistributionConstant_ = x;
  }

  void LinkStorageSystemComplexType::
  setWaterDistributionConstant (::std::auto_ptr< WaterDistributionConstantType > x)
  {
    this->waterDistributionConstant_.set (x);
  }

  const LinkStorageSystemComplexType::WaterDistributionVariableOptional& LinkStorageSystemComplexType::
  getWaterDistributionVariable () const
  {
    return this->waterDistributionVariable_;
  }

  LinkStorageSystemComplexType::WaterDistributionVariableOptional& LinkStorageSystemComplexType::
  getWaterDistributionVariable ()
  {
    return this->waterDistributionVariable_;
  }

  void LinkStorageSystemComplexType::
  setWaterDistributionVariable (const WaterDistributionVariableType& x)
  {
    this->waterDistributionVariable_.set (x);
  }

  void LinkStorageSystemComplexType::
  setWaterDistributionVariable (const WaterDistributionVariableOptional& x)
  {
    this->waterDistributionVariable_ = x;
  }

  void LinkStorageSystemComplexType::
  setWaterDistributionVariable (::std::auto_ptr< WaterDistributionVariableType > x)
  {
    this->waterDistributionVariable_.set (x);
  }

  const LinkStorageSystemComplexType::MeltRefreezingOptional& LinkStorageSystemComplexType::
  getMeltRefreezing () const
  {
    return this->meltRefreezing_;
  }

  LinkStorageSystemComplexType::MeltRefreezingOptional& LinkStorageSystemComplexType::
  getMeltRefreezing ()
  {
    return this->meltRefreezing_;
  }

  void LinkStorageSystemComplexType::
  setMeltRefreezing (const MeltRefreezingType& x)
  {
    this->meltRefreezing_.set (x);
  }

  void LinkStorageSystemComplexType::
  setMeltRefreezing (const MeltRefreezingOptional& x)
  {
    this->meltRefreezing_ = x;
  }

  void LinkStorageSystemComplexType::
  setMeltRefreezing (::std::auto_ptr< MeltRefreezingType > x)
  {
    this->meltRefreezing_.set (x);
  }

  const LinkStorageSystemComplexType::ReleaseWaterContentOptional& LinkStorageSystemComplexType::
  getReleaseWaterContent () const
  {
    return this->releaseWaterContent_;
  }

  LinkStorageSystemComplexType::ReleaseWaterContentOptional& LinkStorageSystemComplexType::
  getReleaseWaterContent ()
  {
    return this->releaseWaterContent_;
  }

  void LinkStorageSystemComplexType::
  setReleaseWaterContent (const ReleaseWaterContentType& x)
  {
    this->releaseWaterContent_.set (x);
  }

  void LinkStorageSystemComplexType::
  setReleaseWaterContent (const ReleaseWaterContentOptional& x)
  {
    this->releaseWaterContent_ = x;
  }

  void LinkStorageSystemComplexType::
  setReleaseWaterContent (::std::auto_ptr< ReleaseWaterContentType > x)
  {
    this->releaseWaterContent_.set (x);
  }

  const LinkStorageSystemComplexType::IrrigationOptional& LinkStorageSystemComplexType::
  getIrrigation () const
  {
    return this->irrigation_;
  }

  LinkStorageSystemComplexType::IrrigationOptional& LinkStorageSystemComplexType::
  getIrrigation ()
  {
    return this->irrigation_;
  }

  void LinkStorageSystemComplexType::
  setIrrigation (const IrrigationType& x)
  {
    this->irrigation_.set (x);
  }

  void LinkStorageSystemComplexType::
  setIrrigation (const IrrigationOptional& x)
  {
    this->irrigation_ = x;
  }

  void LinkStorageSystemComplexType::
  setIrrigation (::std::auto_ptr< IrrigationType > x)
  {
    this->irrigation_.set (x);
  }


  // OutputLinkStorageSystemComplexType
  // 

  const OutputLinkStorageSystemComplexType::HType& OutputLinkStorageSystemComplexType::
  getH () const
  {
    return this->H_.get ();
  }

  OutputLinkStorageSystemComplexType::HType& OutputLinkStorageSystemComplexType::
  getH ()
  {
    return this->H_.get ();
  }

  void OutputLinkStorageSystemComplexType::
  setH (const HType& x)
  {
    this->H_.set (x);
  }

  void OutputLinkStorageSystemComplexType::
  setH (::std::auto_ptr< HType > x)
  {
    this->H_.set (x);
  }

  const OutputLinkStorageSystemComplexType::QType& OutputLinkStorageSystemComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  OutputLinkStorageSystemComplexType::QType& OutputLinkStorageSystemComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void OutputLinkStorageSystemComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void OutputLinkStorageSystemComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }


  // MeltRefreezingStorageSystemComplexType
  // 

  const MeltRefreezingStorageSystemComplexType::ParameterType& MeltRefreezingStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  MeltRefreezingStorageSystemComplexType::ParameterType& MeltRefreezingStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void MeltRefreezingStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const MeltRefreezingStorageSystemComplexType::NodeUType& MeltRefreezingStorageSystemComplexType::
  getNodeU () const
  {
    return this->nodeU_.get ();
  }

  MeltRefreezingStorageSystemComplexType::NodeUType& MeltRefreezingStorageSystemComplexType::
  getNodeU ()
  {
    return this->nodeU_.get ();
  }

  void MeltRefreezingStorageSystemComplexType::
  setNodeU (const NodeUType& x)
  {
    this->nodeU_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setNodeU (::std::auto_ptr< NodeUType > x)
  {
    this->nodeU_.set (x);
  }

  const MeltRefreezingStorageSystemComplexType::NodeDType& MeltRefreezingStorageSystemComplexType::
  getNodeD () const
  {
    return this->nodeD_.get ();
  }

  MeltRefreezingStorageSystemComplexType::NodeDType& MeltRefreezingStorageSystemComplexType::
  getNodeD ()
  {
    return this->nodeD_.get ();
  }

  void MeltRefreezingStorageSystemComplexType::
  setNodeD (const NodeDType& x)
  {
    this->nodeD_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setNodeD (::std::auto_ptr< NodeDType > x)
  {
    this->nodeD_.set (x);
  }

  const MeltRefreezingStorageSystemComplexType::InputType& MeltRefreezingStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  MeltRefreezingStorageSystemComplexType::InputType& MeltRefreezingStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void MeltRefreezingStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const MeltRefreezingStorageSystemComplexType::OutputType& MeltRefreezingStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  MeltRefreezingStorageSystemComplexType::OutputType& MeltRefreezingStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void MeltRefreezingStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const MeltRefreezingStorageSystemComplexType::IdType& MeltRefreezingStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  MeltRefreezingStorageSystemComplexType::IdType& MeltRefreezingStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void MeltRefreezingStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const MeltRefreezingStorageSystemComplexType::NameOptional& MeltRefreezingStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  MeltRefreezingStorageSystemComplexType::NameOptional& MeltRefreezingStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void MeltRefreezingStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void MeltRefreezingStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void MeltRefreezingStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterMeltRefreezingStorageSystemComplexType
  // 

  const ParameterMeltRefreezingStorageSystemComplexType::AREAOptional& ParameterMeltRefreezingStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterMeltRefreezingStorageSystemComplexType::AREAOptional& ParameterMeltRefreezingStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterMeltRefreezingStorageSystemComplexType::CFMAXType& ParameterMeltRefreezingStorageSystemComplexType::
  getCFMAX () const
  {
    return this->CFMAX_.get ();
  }

  ParameterMeltRefreezingStorageSystemComplexType::CFMAXType& ParameterMeltRefreezingStorageSystemComplexType::
  getCFMAX ()
  {
    return this->CFMAX_.get ();
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setCFMAX (const CFMAXType& x)
  {
    this->CFMAX_.set (x);
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setCFMAX (::std::auto_ptr< CFMAXType > x)
  {
    this->CFMAX_.set (x);
  }

  const ParameterMeltRefreezingStorageSystemComplexType::CFRType& ParameterMeltRefreezingStorageSystemComplexType::
  getCFR () const
  {
    return this->CFR_.get ();
  }

  ParameterMeltRefreezingStorageSystemComplexType::CFRType& ParameterMeltRefreezingStorageSystemComplexType::
  getCFR ()
  {
    return this->CFR_.get ();
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setCFR (const CFRType& x)
  {
    this->CFR_.set (x);
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setCFR (::std::auto_ptr< CFRType > x)
  {
    this->CFR_.set (x);
  }

  const ParameterMeltRefreezingStorageSystemComplexType::MOptional& ParameterMeltRefreezingStorageSystemComplexType::
  getM () const
  {
    return this->M_;
  }

  ParameterMeltRefreezingStorageSystemComplexType::MOptional& ParameterMeltRefreezingStorageSystemComplexType::
  getM ()
  {
    return this->M_;
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setM (const MType& x)
  {
    this->M_.set (x);
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setM (const MOptional& x)
  {
    this->M_ = x;
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setM (::std::auto_ptr< MType > x)
  {
    this->M_.set (x);
  }

  const ParameterMeltRefreezingStorageSystemComplexType::TTMType& ParameterMeltRefreezingStorageSystemComplexType::
  getTTM () const
  {
    return this->TTM_.get ();
  }

  ParameterMeltRefreezingStorageSystemComplexType::TTMType& ParameterMeltRefreezingStorageSystemComplexType::
  getTTM ()
  {
    return this->TTM_.get ();
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setTTM (const TTMType& x)
  {
    this->TTM_.set (x);
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  setTTM (::std::auto_ptr< TTMType > x)
  {
    this->TTM_.set (x);
  }


  // ReleaseWaterContentStorageSystemComplexType
  // 

  const ReleaseWaterContentStorageSystemComplexType::ParameterType& ReleaseWaterContentStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  ReleaseWaterContentStorageSystemComplexType::ParameterType& ReleaseWaterContentStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const ReleaseWaterContentStorageSystemComplexType::NodeUType& ReleaseWaterContentStorageSystemComplexType::
  getNodeU () const
  {
    return this->nodeU_.get ();
  }

  ReleaseWaterContentStorageSystemComplexType::NodeUType& ReleaseWaterContentStorageSystemComplexType::
  getNodeU ()
  {
    return this->nodeU_.get ();
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setNodeU (const NodeUType& x)
  {
    this->nodeU_.set (x);
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setNodeU (::std::auto_ptr< NodeUType > x)
  {
    this->nodeU_.set (x);
  }

  const ReleaseWaterContentStorageSystemComplexType::NodeAType& ReleaseWaterContentStorageSystemComplexType::
  getNodeA () const
  {
    return this->nodeA_.get ();
  }

  ReleaseWaterContentStorageSystemComplexType::NodeAType& ReleaseWaterContentStorageSystemComplexType::
  getNodeA ()
  {
    return this->nodeA_.get ();
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setNodeA (const NodeAType& x)
  {
    this->nodeA_.set (x);
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setNodeA (::std::auto_ptr< NodeAType > x)
  {
    this->nodeA_.set (x);
  }

  const ReleaseWaterContentStorageSystemComplexType::OutputType& ReleaseWaterContentStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ReleaseWaterContentStorageSystemComplexType::OutputType& ReleaseWaterContentStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ReleaseWaterContentStorageSystemComplexType::IdType& ReleaseWaterContentStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ReleaseWaterContentStorageSystemComplexType::IdType& ReleaseWaterContentStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ReleaseWaterContentStorageSystemComplexType::NameOptional& ReleaseWaterContentStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  ReleaseWaterContentStorageSystemComplexType::NameOptional& ReleaseWaterContentStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ReleaseWaterContentStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterReleaseWaterContentStorageSystemComplexType
  // 

  const ParameterReleaseWaterContentStorageSystemComplexType::AREAOptional& ParameterReleaseWaterContentStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterReleaseWaterContentStorageSystemComplexType::AREAOptional& ParameterReleaseWaterContentStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterReleaseWaterContentStorageSystemComplexType::WHCType& ParameterReleaseWaterContentStorageSystemComplexType::
  getWHC () const
  {
    return this->WHC_.get ();
  }

  ParameterReleaseWaterContentStorageSystemComplexType::WHCType& ParameterReleaseWaterContentStorageSystemComplexType::
  getWHC ()
  {
    return this->WHC_.get ();
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setWHC (const WHCType& x)
  {
    this->WHC_.set (x);
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setWHC (::std::auto_ptr< WHCType > x)
  {
    this->WHC_.set (x);
  }

  const ParameterReleaseWaterContentStorageSystemComplexType::MOptional& ParameterReleaseWaterContentStorageSystemComplexType::
  getM () const
  {
    return this->M_;
  }

  ParameterReleaseWaterContentStorageSystemComplexType::MOptional& ParameterReleaseWaterContentStorageSystemComplexType::
  getM ()
  {
    return this->M_;
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setM (const MType& x)
  {
    this->M_.set (x);
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setM (const MOptional& x)
  {
    this->M_ = x;
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  setM (::std::auto_ptr< MType > x)
  {
    this->M_.set (x);
  }


  // EvaporationInterceptionStorageSystemComplexType
  // 

  const EvaporationInterceptionStorageSystemComplexType::ParameterType& EvaporationInterceptionStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  EvaporationInterceptionStorageSystemComplexType::ParameterType& EvaporationInterceptionStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const EvaporationInterceptionStorageSystemComplexType::InputType& EvaporationInterceptionStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  EvaporationInterceptionStorageSystemComplexType::InputType& EvaporationInterceptionStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const EvaporationInterceptionStorageSystemComplexType::OutputType& EvaporationInterceptionStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  EvaporationInterceptionStorageSystemComplexType::OutputType& EvaporationInterceptionStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const EvaporationInterceptionStorageSystemComplexType::IdType& EvaporationInterceptionStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  EvaporationInterceptionStorageSystemComplexType::IdType& EvaporationInterceptionStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const EvaporationInterceptionStorageSystemComplexType::NameOptional& EvaporationInterceptionStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  EvaporationInterceptionStorageSystemComplexType::NameOptional& EvaporationInterceptionStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void EvaporationInterceptionStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputEvaporationInterceptionStorageSystemComplexType
  // 

  const InputEvaporationInterceptionStorageSystemComplexType::HUpType& InputEvaporationInterceptionStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputEvaporationInterceptionStorageSystemComplexType::HUpType& InputEvaporationInterceptionStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputEvaporationInterceptionStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputEvaporationInterceptionStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputEvaporationInterceptionStorageSystemComplexType::EPType& InputEvaporationInterceptionStorageSystemComplexType::
  getEP () const
  {
    return this->EP_.get ();
  }

  InputEvaporationInterceptionStorageSystemComplexType::EPType& InputEvaporationInterceptionStorageSystemComplexType::
  getEP ()
  {
    return this->EP_.get ();
  }

  void InputEvaporationInterceptionStorageSystemComplexType::
  setEP (const EPType& x)
  {
    this->EP_.set (x);
  }

  void InputEvaporationInterceptionStorageSystemComplexType::
  setEP (::std::auto_ptr< EPType > x)
  {
    this->EP_.set (x);
  }


  // ParameterEvaporationInterceptionStorageSystemComplexType
  // 

  const ParameterEvaporationInterceptionStorageSystemComplexType::AREAOptional& ParameterEvaporationInterceptionStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterEvaporationInterceptionStorageSystemComplexType::AREAOptional& ParameterEvaporationInterceptionStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterEvaporationInterceptionStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterEvaporationInterceptionStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterEvaporationInterceptionStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }


  // ReleaseAboveThresholdStorageSystemComplexType
  // 

  const ReleaseAboveThresholdStorageSystemComplexType::ParameterType& ReleaseAboveThresholdStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  ReleaseAboveThresholdStorageSystemComplexType::ParameterType& ReleaseAboveThresholdStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const ReleaseAboveThresholdStorageSystemComplexType::InputType& ReleaseAboveThresholdStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ReleaseAboveThresholdStorageSystemComplexType::InputType& ReleaseAboveThresholdStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ReleaseAboveThresholdStorageSystemComplexType::OutputType& ReleaseAboveThresholdStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ReleaseAboveThresholdStorageSystemComplexType::OutputType& ReleaseAboveThresholdStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ReleaseAboveThresholdStorageSystemComplexType::IdType& ReleaseAboveThresholdStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ReleaseAboveThresholdStorageSystemComplexType::IdType& ReleaseAboveThresholdStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ReleaseAboveThresholdStorageSystemComplexType::NameOptional& ReleaseAboveThresholdStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  ReleaseAboveThresholdStorageSystemComplexType::NameOptional& ReleaseAboveThresholdStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterReleaseAboveThresholdStorageSystemComplexType
  // 

  const ParameterReleaseAboveThresholdStorageSystemComplexType::AREAOptional& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::AREAOptional& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterReleaseAboveThresholdStorageSystemComplexType::FRACOptional& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getFRAC () const
  {
    return this->FRAC_;
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::FRACOptional& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getFRAC ()
  {
    return this->FRAC_;
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setFRAC (const FRACType& x)
  {
    this->FRAC_.set (x);
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setFRAC (const FRACOptional& x)
  {
    this->FRAC_ = x;
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setFRAC (::std::auto_ptr< FRACType > x)
  {
    this->FRAC_.set (x);
  }

  const ParameterReleaseAboveThresholdStorageSystemComplexType::FRACType& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getFRACDefaultValue ()
  {
    return FRAC_default_value_;
  }

  const ParameterReleaseAboveThresholdStorageSystemComplexType::LICType& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getLIC () const
  {
    return this->LIC_.get ();
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::LICType& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getLIC ()
  {
    return this->LIC_.get ();
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setLIC (const LICType& x)
  {
    this->LIC_.set (x);
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setLIC (::std::auto_ptr< LICType > x)
  {
    this->LIC_.set (x);
  }

  const ParameterReleaseAboveThresholdStorageSystemComplexType::MOptional& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getM () const
  {
    return this->M_;
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::MOptional& ParameterReleaseAboveThresholdStorageSystemComplexType::
  getM ()
  {
    return this->M_;
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setM (const MType& x)
  {
    this->M_.set (x);
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setM (const MOptional& x)
  {
    this->M_ = x;
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  setM (::std::auto_ptr< MType > x)
  {
    this->M_.set (x);
  }


  // InputReleaseAboveThresholdStorageSystemComplexType
  // 

  const InputReleaseAboveThresholdStorageSystemComplexType::HUpType& InputReleaseAboveThresholdStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputReleaseAboveThresholdStorageSystemComplexType::HUpType& InputReleaseAboveThresholdStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputReleaseAboveThresholdStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputReleaseAboveThresholdStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputReleaseAboveThresholdStorageSystemComplexType::HDownOptional& InputReleaseAboveThresholdStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_;
  }

  InputReleaseAboveThresholdStorageSystemComplexType::HDownOptional& InputReleaseAboveThresholdStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_;
  }

  void InputReleaseAboveThresholdStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputReleaseAboveThresholdStorageSystemComplexType::
  setHDown (const HDownOptional& x)
  {
    this->HDown_ = x;
  }

  void InputReleaseAboveThresholdStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }


  // IrrigationStorageSystemComplexType
  // 

  const IrrigationStorageSystemComplexType::ParameterType& IrrigationStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  IrrigationStorageSystemComplexType::ParameterType& IrrigationStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void IrrigationStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void IrrigationStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const IrrigationStorageSystemComplexType::NodeUType& IrrigationStorageSystemComplexType::
  getNodeU () const
  {
    return this->nodeU_.get ();
  }

  IrrigationStorageSystemComplexType::NodeUType& IrrigationStorageSystemComplexType::
  getNodeU ()
  {
    return this->nodeU_.get ();
  }

  void IrrigationStorageSystemComplexType::
  setNodeU (const NodeUType& x)
  {
    this->nodeU_.set (x);
  }

  void IrrigationStorageSystemComplexType::
  setNodeU (::std::auto_ptr< NodeUType > x)
  {
    this->nodeU_.set (x);
  }

  const IrrigationStorageSystemComplexType::NodeDType& IrrigationStorageSystemComplexType::
  getNodeD () const
  {
    return this->nodeD_.get ();
  }

  IrrigationStorageSystemComplexType::NodeDType& IrrigationStorageSystemComplexType::
  getNodeD ()
  {
    return this->nodeD_.get ();
  }

  void IrrigationStorageSystemComplexType::
  setNodeD (const NodeDType& x)
  {
    this->nodeD_.set (x);
  }

  void IrrigationStorageSystemComplexType::
  setNodeD (::std::auto_ptr< NodeDType > x)
  {
    this->nodeD_.set (x);
  }

  const IrrigationStorageSystemComplexType::OutputType& IrrigationStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  IrrigationStorageSystemComplexType::OutputType& IrrigationStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void IrrigationStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void IrrigationStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const IrrigationStorageSystemComplexType::IdType& IrrigationStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  IrrigationStorageSystemComplexType::IdType& IrrigationStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void IrrigationStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void IrrigationStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const IrrigationStorageSystemComplexType::NameOptional& IrrigationStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  IrrigationStorageSystemComplexType::NameOptional& IrrigationStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void IrrigationStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void IrrigationStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void IrrigationStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterIrrigationStorageSystemComplexType
  // 

  const ParameterIrrigationStorageSystemComplexType::AREAOptional& ParameterIrrigationStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterIrrigationStorageSystemComplexType::AREAOptional& ParameterIrrigationStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterIrrigationStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterIrrigationStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterIrrigationStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterIrrigationStorageSystemComplexType::IRR_CONSTOptional& ParameterIrrigationStorageSystemComplexType::
  getIRR_CONST () const
  {
    return this->IRR_CONST_;
  }

  ParameterIrrigationStorageSystemComplexType::IRR_CONSTOptional& ParameterIrrigationStorageSystemComplexType::
  getIRR_CONST ()
  {
    return this->IRR_CONST_;
  }

  void ParameterIrrigationStorageSystemComplexType::
  setIRR_CONST (const IRR_CONSTType& x)
  {
    this->IRR_CONST_.set (x);
  }

  void ParameterIrrigationStorageSystemComplexType::
  setIRR_CONST (const IRR_CONSTOptional& x)
  {
    this->IRR_CONST_ = x;
  }

  void ParameterIrrigationStorageSystemComplexType::
  setIRR_CONST (::std::auto_ptr< IRR_CONSTType > x)
  {
    this->IRR_CONST_.set (x);
  }

  const ParameterIrrigationStorageSystemComplexType::IRR_THRType& ParameterIrrigationStorageSystemComplexType::
  getIRR_THR () const
  {
    return this->IRR_THR_.get ();
  }

  ParameterIrrigationStorageSystemComplexType::IRR_THRType& ParameterIrrigationStorageSystemComplexType::
  getIRR_THR ()
  {
    return this->IRR_THR_.get ();
  }

  void ParameterIrrigationStorageSystemComplexType::
  setIRR_THR (const IRR_THRType& x)
  {
    this->IRR_THR_.set (x);
  }

  void ParameterIrrigationStorageSystemComplexType::
  setIRR_THR (::std::auto_ptr< IRR_THRType > x)
  {
    this->IRR_THR_.set (x);
  }

  const ParameterIrrigationStorageSystemComplexType::MOptional& ParameterIrrigationStorageSystemComplexType::
  getM () const
  {
    return this->M_;
  }

  ParameterIrrigationStorageSystemComplexType::MOptional& ParameterIrrigationStorageSystemComplexType::
  getM ()
  {
    return this->M_;
  }

  void ParameterIrrigationStorageSystemComplexType::
  setM (const MType& x)
  {
    this->M_.set (x);
  }

  void ParameterIrrigationStorageSystemComplexType::
  setM (const MOptional& x)
  {
    this->M_ = x;
  }

  void ParameterIrrigationStorageSystemComplexType::
  setM (::std::auto_ptr< MType > x)
  {
    this->M_.set (x);
  }


  // WaterDistributionConstantStorageSystemComplexType
  // 

  const WaterDistributionConstantStorageSystemComplexType::ParameterType& WaterDistributionConstantStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  WaterDistributionConstantStorageSystemComplexType::ParameterType& WaterDistributionConstantStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const WaterDistributionConstantStorageSystemComplexType::InputType& WaterDistributionConstantStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  WaterDistributionConstantStorageSystemComplexType::InputType& WaterDistributionConstantStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const WaterDistributionConstantStorageSystemComplexType::OutputType& WaterDistributionConstantStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  WaterDistributionConstantStorageSystemComplexType::OutputType& WaterDistributionConstantStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const WaterDistributionConstantStorageSystemComplexType::IdType& WaterDistributionConstantStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  WaterDistributionConstantStorageSystemComplexType::IdType& WaterDistributionConstantStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const WaterDistributionConstantStorageSystemComplexType::NameOptional& WaterDistributionConstantStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  WaterDistributionConstantStorageSystemComplexType::NameOptional& WaterDistributionConstantStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void WaterDistributionConstantStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterWaterDistributionConstantStorageSystemComplexType
  // 

  const ParameterWaterDistributionConstantStorageSystemComplexType::AREAOptional& ParameterWaterDistributionConstantStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::AREAOptional& ParameterWaterDistributionConstantStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterWaterDistributionConstantStorageSystemComplexType::DType& ParameterWaterDistributionConstantStorageSystemComplexType::
  getD () const
  {
    return this->D_.get ();
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::DType& ParameterWaterDistributionConstantStorageSystemComplexType::
  getD ()
  {
    return this->D_.get ();
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }

  const ParameterWaterDistributionConstantStorageSystemComplexType::MIN_UPOptional& ParameterWaterDistributionConstantStorageSystemComplexType::
  getMIN_UP () const
  {
    return this->MIN_UP_;
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::MIN_UPOptional& ParameterWaterDistributionConstantStorageSystemComplexType::
  getMIN_UP ()
  {
    return this->MIN_UP_;
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setMIN_UP (const MIN_UPType& x)
  {
    this->MIN_UP_.set (x);
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setMIN_UP (const MIN_UPOptional& x)
  {
    this->MIN_UP_ = x;
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setMIN_UP (::std::auto_ptr< MIN_UPType > x)
  {
    this->MIN_UP_.set (x);
  }

  const ParameterWaterDistributionConstantStorageSystemComplexType::MOptional& ParameterWaterDistributionConstantStorageSystemComplexType::
  getM () const
  {
    return this->M_;
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::MOptional& ParameterWaterDistributionConstantStorageSystemComplexType::
  getM ()
  {
    return this->M_;
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setM (const MType& x)
  {
    this->M_.set (x);
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setM (const MOptional& x)
  {
    this->M_ = x;
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  setM (::std::auto_ptr< MType > x)
  {
    this->M_.set (x);
  }


  // InputWaterDistributionConstantStorageSystemComplexType
  // 

  const InputWaterDistributionConstantStorageSystemComplexType::HUpType& InputWaterDistributionConstantStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputWaterDistributionConstantStorageSystemComplexType::HUpType& InputWaterDistributionConstantStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputWaterDistributionConstantStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputWaterDistributionConstantStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputWaterDistributionConstantStorageSystemComplexType::HDownOptional& InputWaterDistributionConstantStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_;
  }

  InputWaterDistributionConstantStorageSystemComplexType::HDownOptional& InputWaterDistributionConstantStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_;
  }

  void InputWaterDistributionConstantStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputWaterDistributionConstantStorageSystemComplexType::
  setHDown (const HDownOptional& x)
  {
    this->HDown_ = x;
  }

  void InputWaterDistributionConstantStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }


  // WaterDistributionVariableStorageSystemComplexType
  // 

  const WaterDistributionVariableStorageSystemComplexType::ParameterType& WaterDistributionVariableStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  WaterDistributionVariableStorageSystemComplexType::ParameterType& WaterDistributionVariableStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const WaterDistributionVariableStorageSystemComplexType::InputType& WaterDistributionVariableStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  WaterDistributionVariableStorageSystemComplexType::InputType& WaterDistributionVariableStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const WaterDistributionVariableStorageSystemComplexType::OutputType& WaterDistributionVariableStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  WaterDistributionVariableStorageSystemComplexType::OutputType& WaterDistributionVariableStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const WaterDistributionVariableStorageSystemComplexType::IdType& WaterDistributionVariableStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  WaterDistributionVariableStorageSystemComplexType::IdType& WaterDistributionVariableStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const WaterDistributionVariableStorageSystemComplexType::NameOptional& WaterDistributionVariableStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  WaterDistributionVariableStorageSystemComplexType::NameOptional& WaterDistributionVariableStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void WaterDistributionVariableStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterWaterDistributionVariableStorageSystemComplexType
  // 

  const ParameterWaterDistributionVariableStorageSystemComplexType::AREAOptional& ParameterWaterDistributionVariableStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterWaterDistributionVariableStorageSystemComplexType::AREAOptional& ParameterWaterDistributionVariableStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterWaterDistributionVariableStorageSystemComplexType::MIN_UPOptional& ParameterWaterDistributionVariableStorageSystemComplexType::
  getMIN_UP () const
  {
    return this->MIN_UP_;
  }

  ParameterWaterDistributionVariableStorageSystemComplexType::MIN_UPOptional& ParameterWaterDistributionVariableStorageSystemComplexType::
  getMIN_UP ()
  {
    return this->MIN_UP_;
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setMIN_UP (const MIN_UPType& x)
  {
    this->MIN_UP_.set (x);
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setMIN_UP (const MIN_UPOptional& x)
  {
    this->MIN_UP_ = x;
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setMIN_UP (::std::auto_ptr< MIN_UPType > x)
  {
    this->MIN_UP_.set (x);
  }

  const ParameterWaterDistributionVariableStorageSystemComplexType::MOptional& ParameterWaterDistributionVariableStorageSystemComplexType::
  getM () const
  {
    return this->M_;
  }

  ParameterWaterDistributionVariableStorageSystemComplexType::MOptional& ParameterWaterDistributionVariableStorageSystemComplexType::
  getM ()
  {
    return this->M_;
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setM (const MType& x)
  {
    this->M_.set (x);
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setM (const MOptional& x)
  {
    this->M_ = x;
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  setM (::std::auto_ptr< MType > x)
  {
    this->M_.set (x);
  }


  // InputWaterDistributionVariableStorageSystemComplexType
  // 

  const InputWaterDistributionVariableStorageSystemComplexType::HUpType& InputWaterDistributionVariableStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputWaterDistributionVariableStorageSystemComplexType::HUpType& InputWaterDistributionVariableStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputWaterDistributionVariableStorageSystemComplexType::HDownOptional& InputWaterDistributionVariableStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_;
  }

  InputWaterDistributionVariableStorageSystemComplexType::HDownOptional& InputWaterDistributionVariableStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_;
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setHDown (const HDownOptional& x)
  {
    this->HDown_ = x;
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }

  const InputWaterDistributionVariableStorageSystemComplexType::DType& InputWaterDistributionVariableStorageSystemComplexType::
  getD () const
  {
    return this->D_.get ();
  }

  InputWaterDistributionVariableStorageSystemComplexType::DType& InputWaterDistributionVariableStorageSystemComplexType::
  getD ()
  {
    return this->D_.get ();
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }


  // GroundwaterFlowStorageSystemComplexType
  // 

  const GroundwaterFlowStorageSystemComplexType::ParameterType& GroundwaterFlowStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  GroundwaterFlowStorageSystemComplexType::ParameterType& GroundwaterFlowStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void GroundwaterFlowStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void GroundwaterFlowStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const GroundwaterFlowStorageSystemComplexType::InputType& GroundwaterFlowStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  GroundwaterFlowStorageSystemComplexType::InputType& GroundwaterFlowStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void GroundwaterFlowStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void GroundwaterFlowStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const GroundwaterFlowStorageSystemComplexType::OutputType& GroundwaterFlowStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  GroundwaterFlowStorageSystemComplexType::OutputType& GroundwaterFlowStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void GroundwaterFlowStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void GroundwaterFlowStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const GroundwaterFlowStorageSystemComplexType::IdType& GroundwaterFlowStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  GroundwaterFlowStorageSystemComplexType::IdType& GroundwaterFlowStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void GroundwaterFlowStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void GroundwaterFlowStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const GroundwaterFlowStorageSystemComplexType::NameOptional& GroundwaterFlowStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  GroundwaterFlowStorageSystemComplexType::NameOptional& GroundwaterFlowStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void GroundwaterFlowStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void GroundwaterFlowStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void GroundwaterFlowStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputGroundwaterFlowStorageSystemComplexType
  // 

  const InputGroundwaterFlowStorageSystemComplexType::HUpType& InputGroundwaterFlowStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputGroundwaterFlowStorageSystemComplexType::HUpType& InputGroundwaterFlowStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputGroundwaterFlowStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputGroundwaterFlowStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputGroundwaterFlowStorageSystemComplexType::HDownType& InputGroundwaterFlowStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_.get ();
  }

  InputGroundwaterFlowStorageSystemComplexType::HDownType& InputGroundwaterFlowStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_.get ();
  }

  void InputGroundwaterFlowStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputGroundwaterFlowStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }


  // ParametergroundwaterFlowStorageSystemComplexType
  // 

  const ParametergroundwaterFlowStorageSystemComplexType::ALPHAType& ParametergroundwaterFlowStorageSystemComplexType::
  getALPHA () const
  {
    return this->ALPHA_.get ();
  }

  ParametergroundwaterFlowStorageSystemComplexType::ALPHAType& ParametergroundwaterFlowStorageSystemComplexType::
  getALPHA ()
  {
    return this->ALPHA_.get ();
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setALPHA (const ALPHAType& x)
  {
    this->ALPHA_.set (x);
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setALPHA (::std::auto_ptr< ALPHAType > x)
  {
    this->ALPHA_.set (x);
  }

  const ParametergroundwaterFlowStorageSystemComplexType::AREAOptional& ParametergroundwaterFlowStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParametergroundwaterFlowStorageSystemComplexType::AREAOptional& ParametergroundwaterFlowStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParametergroundwaterFlowStorageSystemComplexType::KType& ParametergroundwaterFlowStorageSystemComplexType::
  getK () const
  {
    return this->K_.get ();
  }

  ParametergroundwaterFlowStorageSystemComplexType::KType& ParametergroundwaterFlowStorageSystemComplexType::
  getK ()
  {
    return this->K_.get ();
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setK (const KType& x)
  {
    this->K_.set (x);
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setK (::std::auto_ptr< KType > x)
  {
    this->K_.set (x);
  }

  const ParametergroundwaterFlowStorageSystemComplexType::MAX_GFLOWType& ParametergroundwaterFlowStorageSystemComplexType::
  getMAX_GFLOW () const
  {
    return this->MAX_GFLOW_.get ();
  }

  ParametergroundwaterFlowStorageSystemComplexType::MAX_GFLOWType& ParametergroundwaterFlowStorageSystemComplexType::
  getMAX_GFLOW ()
  {
    return this->MAX_GFLOW_.get ();
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setMAX_GFLOW (const MAX_GFLOWType& x)
  {
    this->MAX_GFLOW_.set (x);
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  setMAX_GFLOW (::std::auto_ptr< MAX_GFLOWType > x)
  {
    this->MAX_GFLOW_.set (x);
  }


  // EvaporationActualStorageSystemComplexType
  // 

  const EvaporationActualStorageSystemComplexType::ParameterType& EvaporationActualStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  EvaporationActualStorageSystemComplexType::ParameterType& EvaporationActualStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void EvaporationActualStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void EvaporationActualStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const EvaporationActualStorageSystemComplexType::InputType& EvaporationActualStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  EvaporationActualStorageSystemComplexType::InputType& EvaporationActualStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void EvaporationActualStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void EvaporationActualStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const EvaporationActualStorageSystemComplexType::OutputType& EvaporationActualStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  EvaporationActualStorageSystemComplexType::OutputType& EvaporationActualStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void EvaporationActualStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void EvaporationActualStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const EvaporationActualStorageSystemComplexType::IdType& EvaporationActualStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  EvaporationActualStorageSystemComplexType::IdType& EvaporationActualStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void EvaporationActualStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void EvaporationActualStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const EvaporationActualStorageSystemComplexType::NameOptional& EvaporationActualStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  EvaporationActualStorageSystemComplexType::NameOptional& EvaporationActualStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void EvaporationActualStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void EvaporationActualStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void EvaporationActualStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputEvaporationActualStorageSystemComplexType
  // 

  const InputEvaporationActualStorageSystemComplexType::HUpType& InputEvaporationActualStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputEvaporationActualStorageSystemComplexType::HUpType& InputEvaporationActualStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputEvaporationActualStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputEvaporationActualStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputEvaporationActualStorageSystemComplexType::EPType& InputEvaporationActualStorageSystemComplexType::
  getEP () const
  {
    return this->EP_.get ();
  }

  InputEvaporationActualStorageSystemComplexType::EPType& InputEvaporationActualStorageSystemComplexType::
  getEP ()
  {
    return this->EP_.get ();
  }

  void InputEvaporationActualStorageSystemComplexType::
  setEP (const EPType& x)
  {
    this->EP_.set (x);
  }

  void InputEvaporationActualStorageSystemComplexType::
  setEP (::std::auto_ptr< EPType > x)
  {
    this->EP_.set (x);
  }

  const InputEvaporationActualStorageSystemComplexType::EIOptional& InputEvaporationActualStorageSystemComplexType::
  getEI () const
  {
    return this->EI_;
  }

  InputEvaporationActualStorageSystemComplexType::EIOptional& InputEvaporationActualStorageSystemComplexType::
  getEI ()
  {
    return this->EI_;
  }

  void InputEvaporationActualStorageSystemComplexType::
  setEI (const EIType& x)
  {
    this->EI_.set (x);
  }

  void InputEvaporationActualStorageSystemComplexType::
  setEI (const EIOptional& x)
  {
    this->EI_ = x;
  }

  void InputEvaporationActualStorageSystemComplexType::
  setEI (::std::auto_ptr< EIType > x)
  {
    this->EI_.set (x);
  }


  // ParameterEvaporationActualStorageSystemComplexType
  // 

  const ParameterEvaporationActualStorageSystemComplexType::AREAOptional& ParameterEvaporationActualStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterEvaporationActualStorageSystemComplexType::AREAOptional& ParameterEvaporationActualStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterEvaporationActualStorageSystemComplexType::DOptional& ParameterEvaporationActualStorageSystemComplexType::
  getD () const
  {
    return this->D_;
  }

  ParameterEvaporationActualStorageSystemComplexType::DOptional& ParameterEvaporationActualStorageSystemComplexType::
  getD ()
  {
    return this->D_;
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setD (const DOptional& x)
  {
    this->D_ = x;
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }

  const ParameterEvaporationActualStorageSystemComplexType::FCType& ParameterEvaporationActualStorageSystemComplexType::
  getFC () const
  {
    return this->FC_.get ();
  }

  ParameterEvaporationActualStorageSystemComplexType::FCType& ParameterEvaporationActualStorageSystemComplexType::
  getFC ()
  {
    return this->FC_.get ();
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setFC (const FCType& x)
  {
    this->FC_.set (x);
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setFC (::std::auto_ptr< FCType > x)
  {
    this->FC_.set (x);
  }

  const ParameterEvaporationActualStorageSystemComplexType::LPType& ParameterEvaporationActualStorageSystemComplexType::
  getLP () const
  {
    return this->LP_.get ();
  }

  ParameterEvaporationActualStorageSystemComplexType::LPType& ParameterEvaporationActualStorageSystemComplexType::
  getLP ()
  {
    return this->LP_.get ();
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setLP (const LPType& x)
  {
    this->LP_.set (x);
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  setLP (::std::auto_ptr< LPType > x)
  {
    this->LP_.set (x);
  }


  // SoilRunoffStorageSystemComplexType
  // 

  const SoilRunoffStorageSystemComplexType::ParameterType& SoilRunoffStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  SoilRunoffStorageSystemComplexType::ParameterType& SoilRunoffStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void SoilRunoffStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void SoilRunoffStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const SoilRunoffStorageSystemComplexType::InputType& SoilRunoffStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  SoilRunoffStorageSystemComplexType::InputType& SoilRunoffStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void SoilRunoffStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void SoilRunoffStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const SoilRunoffStorageSystemComplexType::OutputType& SoilRunoffStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  SoilRunoffStorageSystemComplexType::OutputType& SoilRunoffStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void SoilRunoffStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void SoilRunoffStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const SoilRunoffStorageSystemComplexType::IdType& SoilRunoffStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  SoilRunoffStorageSystemComplexType::IdType& SoilRunoffStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void SoilRunoffStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void SoilRunoffStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const SoilRunoffStorageSystemComplexType::NameOptional& SoilRunoffStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  SoilRunoffStorageSystemComplexType::NameOptional& SoilRunoffStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void SoilRunoffStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void SoilRunoffStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void SoilRunoffStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputSoilRunoffStorageSystemComplexType
  // 

  const InputSoilRunoffStorageSystemComplexType::HUpType& InputSoilRunoffStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputSoilRunoffStorageSystemComplexType::HUpType& InputSoilRunoffStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputSoilRunoffStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputSoilRunoffStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputSoilRunoffStorageSystemComplexType::HDownOptional& InputSoilRunoffStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_;
  }

  InputSoilRunoffStorageSystemComplexType::HDownOptional& InputSoilRunoffStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_;
  }

  void InputSoilRunoffStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputSoilRunoffStorageSystemComplexType::
  setHDown (const HDownOptional& x)
  {
    this->HDown_ = x;
  }

  void InputSoilRunoffStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }

  const InputSoilRunoffStorageSystemComplexType::INFSequence& InputSoilRunoffStorageSystemComplexType::
  getINF () const
  {
    return this->INF_;
  }

  InputSoilRunoffStorageSystemComplexType::INFSequence& InputSoilRunoffStorageSystemComplexType::
  getINF ()
  {
    return this->INF_;
  }

  void InputSoilRunoffStorageSystemComplexType::
  setINF (const INFSequence& s)
  {
    this->INF_ = s;
  }


  // ParameterSoilRunoffStorageSystemComplexType
  // 

  const ParameterSoilRunoffStorageSystemComplexType::AREAOptional& ParameterSoilRunoffStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterSoilRunoffStorageSystemComplexType::AREAOptional& ParameterSoilRunoffStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterSoilRunoffStorageSystemComplexType::BETAType& ParameterSoilRunoffStorageSystemComplexType::
  getBETA () const
  {
    return this->BETA_.get ();
  }

  ParameterSoilRunoffStorageSystemComplexType::BETAType& ParameterSoilRunoffStorageSystemComplexType::
  getBETA ()
  {
    return this->BETA_.get ();
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setBETA (const BETAType& x)
  {
    this->BETA_.set (x);
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setBETA (::std::auto_ptr< BETAType > x)
  {
    this->BETA_.set (x);
  }

  const ParameterSoilRunoffStorageSystemComplexType::FCType& ParameterSoilRunoffStorageSystemComplexType::
  getFC () const
  {
    return this->FC_.get ();
  }

  ParameterSoilRunoffStorageSystemComplexType::FCType& ParameterSoilRunoffStorageSystemComplexType::
  getFC ()
  {
    return this->FC_.get ();
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setFC (const FCType& x)
  {
    this->FC_.set (x);
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  setFC (::std::auto_ptr< FCType > x)
  {
    this->FC_.set (x);
  }


  // CapillaryFlowStorageSystemComplexType
  // 

  const CapillaryFlowStorageSystemComplexType::ParameterType& CapillaryFlowStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  CapillaryFlowStorageSystemComplexType::ParameterType& CapillaryFlowStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void CapillaryFlowStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void CapillaryFlowStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const CapillaryFlowStorageSystemComplexType::InputType& CapillaryFlowStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  CapillaryFlowStorageSystemComplexType::InputType& CapillaryFlowStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void CapillaryFlowStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void CapillaryFlowStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const CapillaryFlowStorageSystemComplexType::OutputType& CapillaryFlowStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  CapillaryFlowStorageSystemComplexType::OutputType& CapillaryFlowStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void CapillaryFlowStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void CapillaryFlowStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const CapillaryFlowStorageSystemComplexType::IdType& CapillaryFlowStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  CapillaryFlowStorageSystemComplexType::IdType& CapillaryFlowStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void CapillaryFlowStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void CapillaryFlowStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const CapillaryFlowStorageSystemComplexType::NameOptional& CapillaryFlowStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  CapillaryFlowStorageSystemComplexType::NameOptional& CapillaryFlowStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void CapillaryFlowStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void CapillaryFlowStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void CapillaryFlowStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputCapillaryFlowStorageSystemComplexType
  // 

  const InputCapillaryFlowStorageSystemComplexType::HUpType& InputCapillaryFlowStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputCapillaryFlowStorageSystemComplexType::HUpType& InputCapillaryFlowStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputCapillaryFlowStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputCapillaryFlowStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputCapillaryFlowStorageSystemComplexType::HDownType& InputCapillaryFlowStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_.get ();
  }

  InputCapillaryFlowStorageSystemComplexType::HDownType& InputCapillaryFlowStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_.get ();
  }

  void InputCapillaryFlowStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputCapillaryFlowStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }


  // ParameterCapillaryFlowStorageSystemComplexType
  // 

  const ParameterCapillaryFlowStorageSystemComplexType::AREAOptional& ParameterCapillaryFlowStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterCapillaryFlowStorageSystemComplexType::AREAOptional& ParameterCapillaryFlowStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterCapillaryFlowStorageSystemComplexType::CFLUXType& ParameterCapillaryFlowStorageSystemComplexType::
  getCFLUX () const
  {
    return this->CFLUX_.get ();
  }

  ParameterCapillaryFlowStorageSystemComplexType::CFLUXType& ParameterCapillaryFlowStorageSystemComplexType::
  getCFLUX ()
  {
    return this->CFLUX_.get ();
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setCFLUX (const CFLUXType& x)
  {
    this->CFLUX_.set (x);
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setCFLUX (::std::auto_ptr< CFLUXType > x)
  {
    this->CFLUX_.set (x);
  }

  const ParameterCapillaryFlowStorageSystemComplexType::FCType& ParameterCapillaryFlowStorageSystemComplexType::
  getFC () const
  {
    return this->FC_.get ();
  }

  ParameterCapillaryFlowStorageSystemComplexType::FCType& ParameterCapillaryFlowStorageSystemComplexType::
  getFC ()
  {
    return this->FC_.get ();
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setFC (const FCType& x)
  {
    this->FC_.set (x);
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  setFC (::std::auto_ptr< FCType > x)
  {
    this->FC_.set (x);
  }


  // ResponseStorageSystemComplexType
  // 

  const ResponseStorageSystemComplexType::ParameterType& ResponseStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  ResponseStorageSystemComplexType::ParameterType& ResponseStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void ResponseStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void ResponseStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const ResponseStorageSystemComplexType::InputType& ResponseStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ResponseStorageSystemComplexType::InputType& ResponseStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ResponseStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ResponseStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ResponseStorageSystemComplexType::OutputType& ResponseStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ResponseStorageSystemComplexType::OutputType& ResponseStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ResponseStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ResponseStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ResponseStorageSystemComplexType::IdType& ResponseStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ResponseStorageSystemComplexType::IdType& ResponseStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ResponseStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ResponseStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ResponseStorageSystemComplexType::NameOptional& ResponseStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  ResponseStorageSystemComplexType::NameOptional& ResponseStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void ResponseStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ResponseStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ResponseStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterResponseStorageSystemComplexType
  // 

  const ParameterResponseStorageSystemComplexType::AREAOptional& ParameterResponseStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterResponseStorageSystemComplexType::AREAOptional& ParameterResponseStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterResponseStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterResponseStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterResponseStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterResponseStorageSystemComplexType::KType& ParameterResponseStorageSystemComplexType::
  getK () const
  {
    return this->K_.get ();
  }

  ParameterResponseStorageSystemComplexType::KType& ParameterResponseStorageSystemComplexType::
  getK ()
  {
    return this->K_.get ();
  }

  void ParameterResponseStorageSystemComplexType::
  setK (const KType& x)
  {
    this->K_.set (x);
  }

  void ParameterResponseStorageSystemComplexType::
  setK (::std::auto_ptr< KType > x)
  {
    this->K_.set (x);
  }

  const ParameterResponseStorageSystemComplexType::ALPHAOptional& ParameterResponseStorageSystemComplexType::
  getALPHA () const
  {
    return this->ALPHA_;
  }

  ParameterResponseStorageSystemComplexType::ALPHAOptional& ParameterResponseStorageSystemComplexType::
  getALPHA ()
  {
    return this->ALPHA_;
  }

  void ParameterResponseStorageSystemComplexType::
  setALPHA (const ALPHAType& x)
  {
    this->ALPHA_.set (x);
  }

  void ParameterResponseStorageSystemComplexType::
  setALPHA (const ALPHAOptional& x)
  {
    this->ALPHA_ = x;
  }

  void ParameterResponseStorageSystemComplexType::
  setALPHA (::std::auto_ptr< ALPHAType > x)
  {
    this->ALPHA_.set (x);
  }


  // InputResponseStorageSystemComplexType
  // 

  const InputResponseStorageSystemComplexType::HUpType& InputResponseStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputResponseStorageSystemComplexType::HUpType& InputResponseStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputResponseStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputResponseStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }


  // PercolationStorageSystemComplexType
  // 

  const PercolationStorageSystemComplexType::ParameterType& PercolationStorageSystemComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  PercolationStorageSystemComplexType::ParameterType& PercolationStorageSystemComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void PercolationStorageSystemComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void PercolationStorageSystemComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const PercolationStorageSystemComplexType::InputType& PercolationStorageSystemComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  PercolationStorageSystemComplexType::InputType& PercolationStorageSystemComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void PercolationStorageSystemComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void PercolationStorageSystemComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const PercolationStorageSystemComplexType::OutputType& PercolationStorageSystemComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  PercolationStorageSystemComplexType::OutputType& PercolationStorageSystemComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void PercolationStorageSystemComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void PercolationStorageSystemComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const PercolationStorageSystemComplexType::IdType& PercolationStorageSystemComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  PercolationStorageSystemComplexType::IdType& PercolationStorageSystemComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void PercolationStorageSystemComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void PercolationStorageSystemComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const PercolationStorageSystemComplexType::NameOptional& PercolationStorageSystemComplexType::
  getName () const
  {
    return this->name_;
  }

  PercolationStorageSystemComplexType::NameOptional& PercolationStorageSystemComplexType::
  getName ()
  {
    return this->name_;
  }

  void PercolationStorageSystemComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void PercolationStorageSystemComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void PercolationStorageSystemComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ParameterPercolationStorageSystemComplexType
  // 

  const ParameterPercolationStorageSystemComplexType::AREAOptional& ParameterPercolationStorageSystemComplexType::
  getAREA () const
  {
    return this->AREA_;
  }

  ParameterPercolationStorageSystemComplexType::AREAOptional& ParameterPercolationStorageSystemComplexType::
  getAREA ()
  {
    return this->AREA_;
  }

  void ParameterPercolationStorageSystemComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void ParameterPercolationStorageSystemComplexType::
  setAREA (const AREAOptional& x)
  {
    this->AREA_ = x;
  }

  void ParameterPercolationStorageSystemComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const ParameterPercolationStorageSystemComplexType::PERCType& ParameterPercolationStorageSystemComplexType::
  getPERC () const
  {
    return this->PERC_.get ();
  }

  ParameterPercolationStorageSystemComplexType::PERCType& ParameterPercolationStorageSystemComplexType::
  getPERC ()
  {
    return this->PERC_.get ();
  }

  void ParameterPercolationStorageSystemComplexType::
  setPERC (const PERCType& x)
  {
    this->PERC_.set (x);
  }

  void ParameterPercolationStorageSystemComplexType::
  setPERC (::std::auto_ptr< PERCType > x)
  {
    this->PERC_.set (x);
  }


  // InputPercolationStorageSystemComplexType
  // 

  const InputPercolationStorageSystemComplexType::HUpType& InputPercolationStorageSystemComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  InputPercolationStorageSystemComplexType::HUpType& InputPercolationStorageSystemComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void InputPercolationStorageSystemComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void InputPercolationStorageSystemComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const InputPercolationStorageSystemComplexType::HDownOptional& InputPercolationStorageSystemComplexType::
  getHDown () const
  {
    return this->HDown_;
  }

  InputPercolationStorageSystemComplexType::HDownOptional& InputPercolationStorageSystemComplexType::
  getHDown ()
  {
    return this->HDown_;
  }

  void InputPercolationStorageSystemComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void InputPercolationStorageSystemComplexType::
  setHDown (const HDownOptional& x)
  {
    this->HDown_ = x;
  }

  void InputPercolationStorageSystemComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }


  // ArmaComplexType
  // 

  const ArmaComplexType::ArCoefType& ArmaComplexType::
  getArCoef () const
  {
    return this->arCoef_.get ();
  }

  ArmaComplexType::ArCoefType& ArmaComplexType::
  getArCoef ()
  {
    return this->arCoef_.get ();
  }

  void ArmaComplexType::
  setArCoef (const ArCoefType& x)
  {
    this->arCoef_.set (x);
  }

  ArmaComplexType::ArCoefType ArmaComplexType::
  getArCoefDefaultValue ()
  {
    return ArCoefType (1.0);
  }

  const ArmaComplexType::InputType& ArmaComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ArmaComplexType::InputType& ArmaComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ArmaComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ArmaComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ArmaComplexType::OutputType& ArmaComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ArmaComplexType::OutputType& ArmaComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ArmaComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ArmaComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ArmaComplexType::IdType& ArmaComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ArmaComplexType::IdType& ArmaComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ArmaComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ArmaComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ArmaComplexType::NameOptional& ArmaComplexType::
  getName () const
  {
    return this->name_;
  }

  ArmaComplexType::NameOptional& ArmaComplexType::
  getName ()
  {
    return this->name_;
  }

  void ArmaComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ArmaComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ArmaComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ArmaInputComplexType
  // 

  const ArmaInputComplexType::ObsType& ArmaInputComplexType::
  getObs () const
  {
    return this->obs_.get ();
  }

  ArmaInputComplexType::ObsType& ArmaInputComplexType::
  getObs ()
  {
    return this->obs_.get ();
  }

  void ArmaInputComplexType::
  setObs (const ObsType& x)
  {
    this->obs_.set (x);
  }

  void ArmaInputComplexType::
  setObs (::std::auto_ptr< ObsType > x)
  {
    this->obs_.set (x);
  }

  const ArmaInputComplexType::SimType& ArmaInputComplexType::
  getSim () const
  {
    return this->sim_.get ();
  }

  ArmaInputComplexType::SimType& ArmaInputComplexType::
  getSim ()
  {
    return this->sim_.get ();
  }

  void ArmaInputComplexType::
  setSim (const SimType& x)
  {
    this->sim_.set (x);
  }

  void ArmaInputComplexType::
  setSim (::std::auto_ptr< SimType > x)
  {
    this->sim_.set (x);
  }


  // ArmaOutputComplexType
  // 

  const ArmaOutputComplexType::ArmaType& ArmaOutputComplexType::
  getArma () const
  {
    return this->arma_.get ();
  }

  ArmaOutputComplexType::ArmaType& ArmaOutputComplexType::
  getArma ()
  {
    return this->arma_.get ();
  }

  void ArmaOutputComplexType::
  setArma (const ArmaType& x)
  {
    this->arma_.set (x);
  }

  void ArmaOutputComplexType::
  setArma (::std::auto_ptr< ArmaType > x)
  {
    this->arma_.set (x);
  }


  // AccumulationComplexType
  // 

  const AccumulationComplexType::MultiplierOptional& AccumulationComplexType::
  getMultiplier () const
  {
    return this->multiplier_;
  }

  AccumulationComplexType::MultiplierOptional& AccumulationComplexType::
  getMultiplier ()
  {
    return this->multiplier_;
  }

  void AccumulationComplexType::
  setMultiplier (const MultiplierType& x)
  {
    this->multiplier_.set (x);
  }

  void AccumulationComplexType::
  setMultiplier (const MultiplierOptional& x)
  {
    this->multiplier_ = x;
  }

  AccumulationComplexType::MultiplierType AccumulationComplexType::
  getMultiplierDefaultValue ()
  {
    return MultiplierType (1.0);
  }

  const AccumulationComplexType::InputType& AccumulationComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  AccumulationComplexType::InputType& AccumulationComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void AccumulationComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void AccumulationComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const AccumulationComplexType::OutputType& AccumulationComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  AccumulationComplexType::OutputType& AccumulationComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void AccumulationComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void AccumulationComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const AccumulationComplexType::IdType& AccumulationComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  AccumulationComplexType::IdType& AccumulationComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void AccumulationComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void AccumulationComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const AccumulationComplexType::NameOptional& AccumulationComplexType::
  getName () const
  {
    return this->name_;
  }

  AccumulationComplexType::NameOptional& AccumulationComplexType::
  getName ()
  {
    return this->name_;
  }

  void AccumulationComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void AccumulationComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void AccumulationComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // AccumulationInputComplexType
  // 

  const AccumulationInputComplexType::XType& AccumulationInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  AccumulationInputComplexType::XType& AccumulationInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void AccumulationInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void AccumulationInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // AccumulationOutputComplexType
  // 

  const AccumulationOutputComplexType::YType& AccumulationOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  AccumulationOutputComplexType::YType& AccumulationOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void AccumulationOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void AccumulationOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // GradientComplexType
  // 

  const GradientComplexType::MultiplierOptional& GradientComplexType::
  getMultiplier () const
  {
    return this->multiplier_;
  }

  GradientComplexType::MultiplierOptional& GradientComplexType::
  getMultiplier ()
  {
    return this->multiplier_;
  }

  void GradientComplexType::
  setMultiplier (const MultiplierType& x)
  {
    this->multiplier_.set (x);
  }

  void GradientComplexType::
  setMultiplier (const MultiplierOptional& x)
  {
    this->multiplier_ = x;
  }

  GradientComplexType::MultiplierType GradientComplexType::
  getMultiplierDefaultValue ()
  {
    return MultiplierType (1.0);
  }

  const GradientComplexType::InputType& GradientComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  GradientComplexType::InputType& GradientComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void GradientComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void GradientComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const GradientComplexType::OutputType& GradientComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  GradientComplexType::OutputType& GradientComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void GradientComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void GradientComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const GradientComplexType::IdType& GradientComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  GradientComplexType::IdType& GradientComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void GradientComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void GradientComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const GradientComplexType::NameOptional& GradientComplexType::
  getName () const
  {
    return this->name_;
  }

  GradientComplexType::NameOptional& GradientComplexType::
  getName ()
  {
    return this->name_;
  }

  void GradientComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void GradientComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void GradientComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // GradientInputComplexType
  // 

  const GradientInputComplexType::XType& GradientInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  GradientInputComplexType::XType& GradientInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void GradientInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void GradientInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // GradientOutputComplexType
  // 

  const GradientOutputComplexType::DxType& GradientOutputComplexType::
  getDx () const
  {
    return this->dx_.get ();
  }

  GradientOutputComplexType::DxType& GradientOutputComplexType::
  getDx ()
  {
    return this->dx_.get ();
  }

  void GradientOutputComplexType::
  setDx (const DxType& x)
  {
    this->dx_.set (x);
  }

  void GradientOutputComplexType::
  setDx (::std::auto_ptr< DxType > x)
  {
    this->dx_.set (x);
  }


  // LorentGeversComplexType
  // 

  const LorentGeversComplexType::ParameterSoilType& LorentGeversComplexType::
  getParameterSoil () const
  {
    return this->parameterSoil_.get ();
  }

  LorentGeversComplexType::ParameterSoilType& LorentGeversComplexType::
  getParameterSoil ()
  {
    return this->parameterSoil_.get ();
  }

  void LorentGeversComplexType::
  setParameterSoil (const ParameterSoilType& x)
  {
    this->parameterSoil_.set (x);
  }

  void LorentGeversComplexType::
  setParameterSoil (::std::auto_ptr< ParameterSoilType > x)
  {
    this->parameterSoil_.set (x);
  }

  const LorentGeversComplexType::ParameterResponseType& LorentGeversComplexType::
  getParameterResponse () const
  {
    return this->parameterResponse_.get ();
  }

  LorentGeversComplexType::ParameterResponseType& LorentGeversComplexType::
  getParameterResponse ()
  {
    return this->parameterResponse_.get ();
  }

  void LorentGeversComplexType::
  setParameterResponse (const ParameterResponseType& x)
  {
    this->parameterResponse_.set (x);
  }

  void LorentGeversComplexType::
  setParameterResponse (::std::auto_ptr< ParameterResponseType > x)
  {
    this->parameterResponse_.set (x);
  }

  const LorentGeversComplexType::InputType& LorentGeversComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  LorentGeversComplexType::InputType& LorentGeversComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void LorentGeversComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void LorentGeversComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const LorentGeversComplexType::StateType& LorentGeversComplexType::
  getState () const
  {
    return this->state_.get ();
  }

  LorentGeversComplexType::StateType& LorentGeversComplexType::
  getState ()
  {
    return this->state_.get ();
  }

  void LorentGeversComplexType::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void LorentGeversComplexType::
  setState (::std::auto_ptr< StateType > x)
  {
    this->state_.set (x);
  }

  const LorentGeversComplexType::StateUpdateOptional& LorentGeversComplexType::
  getStateUpdate () const
  {
    return this->stateUpdate_;
  }

  LorentGeversComplexType::StateUpdateOptional& LorentGeversComplexType::
  getStateUpdate ()
  {
    return this->stateUpdate_;
  }

  void LorentGeversComplexType::
  setStateUpdate (const StateUpdateType& x)
  {
    this->stateUpdate_.set (x);
  }

  void LorentGeversComplexType::
  setStateUpdate (const StateUpdateOptional& x)
  {
    this->stateUpdate_ = x;
  }

  void LorentGeversComplexType::
  setStateUpdate (::std::auto_ptr< StateUpdateType > x)
  {
    this->stateUpdate_.set (x);
  }

  const LorentGeversComplexType::OutputType& LorentGeversComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  LorentGeversComplexType::OutputType& LorentGeversComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void LorentGeversComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void LorentGeversComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const LorentGeversComplexType::IdType& LorentGeversComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  LorentGeversComplexType::IdType& LorentGeversComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void LorentGeversComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void LorentGeversComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const LorentGeversComplexType::NameOptional& LorentGeversComplexType::
  getName () const
  {
    return this->name_;
  }

  LorentGeversComplexType::NameOptional& LorentGeversComplexType::
  getName ()
  {
    return this->name_;
  }

  void LorentGeversComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void LorentGeversComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void LorentGeversComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // LorentGeversParameterSoilComplexType
  // 

  const LorentGeversParameterSoilComplexType::BETAType& LorentGeversParameterSoilComplexType::
  getBETA () const
  {
    return this->BETA_.get ();
  }

  LorentGeversParameterSoilComplexType::BETAType& LorentGeversParameterSoilComplexType::
  getBETA ()
  {
    return this->BETA_.get ();
  }

  void LorentGeversParameterSoilComplexType::
  setBETA (const BETAType& x)
  {
    this->BETA_.set (x);
  }

  void LorentGeversParameterSoilComplexType::
  setBETA (::std::auto_ptr< BETAType > x)
  {
    this->BETA_.set (x);
  }

  const LorentGeversParameterSoilComplexType::PMAXType& LorentGeversParameterSoilComplexType::
  getPMAX () const
  {
    return this->PMAX_.get ();
  }

  LorentGeversParameterSoilComplexType::PMAXType& LorentGeversParameterSoilComplexType::
  getPMAX ()
  {
    return this->PMAX_.get ();
  }

  void LorentGeversParameterSoilComplexType::
  setPMAX (const PMAXType& x)
  {
    this->PMAX_.set (x);
  }

  void LorentGeversParameterSoilComplexType::
  setPMAX (::std::auto_ptr< PMAXType > x)
  {
    this->PMAX_.set (x);
  }

  const LorentGeversParameterSoilComplexType::SMAXType& LorentGeversParameterSoilComplexType::
  getSMAX () const
  {
    return this->SMAX_.get ();
  }

  LorentGeversParameterSoilComplexType::SMAXType& LorentGeversParameterSoilComplexType::
  getSMAX ()
  {
    return this->SMAX_.get ();
  }

  void LorentGeversParameterSoilComplexType::
  setSMAX (const SMAXType& x)
  {
    this->SMAX_.set (x);
  }

  void LorentGeversParameterSoilComplexType::
  setSMAX (::std::auto_ptr< SMAXType > x)
  {
    this->SMAX_.set (x);
  }


  // LorentGeversParameterResponseComplexType
  // 

  const LorentGeversParameterResponseComplexType::AREAType& LorentGeversParameterResponseComplexType::
  getAREA () const
  {
    return this->AREA_.get ();
  }

  LorentGeversParameterResponseComplexType::AREAType& LorentGeversParameterResponseComplexType::
  getAREA ()
  {
    return this->AREA_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const LorentGeversParameterResponseComplexType::KSType& LorentGeversParameterResponseComplexType::
  getKS () const
  {
    return this->KS_.get ();
  }

  LorentGeversParameterResponseComplexType::KSType& LorentGeversParameterResponseComplexType::
  getKS ()
  {
    return this->KS_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setKS (const KSType& x)
  {
    this->KS_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setKS (::std::auto_ptr< KSType > x)
  {
    this->KS_.set (x);
  }

  const LorentGeversParameterResponseComplexType::TS1Type& LorentGeversParameterResponseComplexType::
  getTS1 () const
  {
    return this->TS1_.get ();
  }

  LorentGeversParameterResponseComplexType::TS1Type& LorentGeversParameterResponseComplexType::
  getTS1 ()
  {
    return this->TS1_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setTS1 (const TS1Type& x)
  {
    this->TS1_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setTS1 (::std::auto_ptr< TS1Type > x)
  {
    this->TS1_.set (x);
  }

  const LorentGeversParameterResponseComplexType::TS2Type& LorentGeversParameterResponseComplexType::
  getTS2 () const
  {
    return this->TS2_.get ();
  }

  LorentGeversParameterResponseComplexType::TS2Type& LorentGeversParameterResponseComplexType::
  getTS2 ()
  {
    return this->TS2_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setTS2 (const TS2Type& x)
  {
    this->TS2_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setTS2 (::std::auto_ptr< TS2Type > x)
  {
    this->TS2_.set (x);
  }

  const LorentGeversParameterResponseComplexType::KBType& LorentGeversParameterResponseComplexType::
  getKB () const
  {
    return this->KB_.get ();
  }

  LorentGeversParameterResponseComplexType::KBType& LorentGeversParameterResponseComplexType::
  getKB ()
  {
    return this->KB_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setKB (const KBType& x)
  {
    this->KB_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setKB (::std::auto_ptr< KBType > x)
  {
    this->KB_.set (x);
  }

  const LorentGeversParameterResponseComplexType::TB1Type& LorentGeversParameterResponseComplexType::
  getTB1 () const
  {
    return this->TB1_.get ();
  }

  LorentGeversParameterResponseComplexType::TB1Type& LorentGeversParameterResponseComplexType::
  getTB1 ()
  {
    return this->TB1_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setTB1 (const TB1Type& x)
  {
    this->TB1_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setTB1 (::std::auto_ptr< TB1Type > x)
  {
    this->TB1_.set (x);
  }

  const LorentGeversParameterResponseComplexType::TB2Type& LorentGeversParameterResponseComplexType::
  getTB2 () const
  {
    return this->TB2_.get ();
  }

  LorentGeversParameterResponseComplexType::TB2Type& LorentGeversParameterResponseComplexType::
  getTB2 ()
  {
    return this->TB2_.get ();
  }

  void LorentGeversParameterResponseComplexType::
  setTB2 (const TB2Type& x)
  {
    this->TB2_.set (x);
  }

  void LorentGeversParameterResponseComplexType::
  setTB2 (::std::auto_ptr< TB2Type > x)
  {
    this->TB2_.set (x);
  }


  // LorentGeversInputComplexType
  // 

  const LorentGeversInputComplexType::EPType& LorentGeversInputComplexType::
  getEP () const
  {
    return this->EP_.get ();
  }

  LorentGeversInputComplexType::EPType& LorentGeversInputComplexType::
  getEP ()
  {
    return this->EP_.get ();
  }

  void LorentGeversInputComplexType::
  setEP (const EPType& x)
  {
    this->EP_.set (x);
  }

  void LorentGeversInputComplexType::
  setEP (::std::auto_ptr< EPType > x)
  {
    this->EP_.set (x);
  }

  const LorentGeversInputComplexType::PType& LorentGeversInputComplexType::
  getP () const
  {
    return this->P_.get ();
  }

  LorentGeversInputComplexType::PType& LorentGeversInputComplexType::
  getP ()
  {
    return this->P_.get ();
  }

  void LorentGeversInputComplexType::
  setP (const PType& x)
  {
    this->P_.set (x);
  }

  void LorentGeversInputComplexType::
  setP (::std::auto_ptr< PType > x)
  {
    this->P_.set (x);
  }


  // LorentGeversStateComplexType
  // 

  const LorentGeversStateComplexType::SType& LorentGeversStateComplexType::
  getS () const
  {
    return this->S_.get ();
  }

  LorentGeversStateComplexType::SType& LorentGeversStateComplexType::
  getS ()
  {
    return this->S_.get ();
  }

  void LorentGeversStateComplexType::
  setS (const SType& x)
  {
    this->S_.set (x);
  }

  void LorentGeversStateComplexType::
  setS (::std::auto_ptr< SType > x)
  {
    this->S_.set (x);
  }

  const LorentGeversStateComplexType::QS1Type& LorentGeversStateComplexType::
  getQS1 () const
  {
    return this->QS1_.get ();
  }

  LorentGeversStateComplexType::QS1Type& LorentGeversStateComplexType::
  getQS1 ()
  {
    return this->QS1_.get ();
  }

  void LorentGeversStateComplexType::
  setQS1 (const QS1Type& x)
  {
    this->QS1_.set (x);
  }

  void LorentGeversStateComplexType::
  setQS1 (::std::auto_ptr< QS1Type > x)
  {
    this->QS1_.set (x);
  }

  const LorentGeversStateComplexType::QS2Type& LorentGeversStateComplexType::
  getQS2 () const
  {
    return this->QS2_.get ();
  }

  LorentGeversStateComplexType::QS2Type& LorentGeversStateComplexType::
  getQS2 ()
  {
    return this->QS2_.get ();
  }

  void LorentGeversStateComplexType::
  setQS2 (const QS2Type& x)
  {
    this->QS2_.set (x);
  }

  void LorentGeversStateComplexType::
  setQS2 (::std::auto_ptr< QS2Type > x)
  {
    this->QS2_.set (x);
  }

  const LorentGeversStateComplexType::QB1Type& LorentGeversStateComplexType::
  getQB1 () const
  {
    return this->QB1_.get ();
  }

  LorentGeversStateComplexType::QB1Type& LorentGeversStateComplexType::
  getQB1 ()
  {
    return this->QB1_.get ();
  }

  void LorentGeversStateComplexType::
  setQB1 (const QB1Type& x)
  {
    this->QB1_.set (x);
  }

  void LorentGeversStateComplexType::
  setQB1 (::std::auto_ptr< QB1Type > x)
  {
    this->QB1_.set (x);
  }

  const LorentGeversStateComplexType::QB2Type& LorentGeversStateComplexType::
  getQB2 () const
  {
    return this->QB2_.get ();
  }

  LorentGeversStateComplexType::QB2Type& LorentGeversStateComplexType::
  getQB2 ()
  {
    return this->QB2_.get ();
  }

  void LorentGeversStateComplexType::
  setQB2 (const QB2Type& x)
  {
    this->QB2_.set (x);
  }

  void LorentGeversStateComplexType::
  setQB2 (::std::auto_ptr< QB2Type > x)
  {
    this->QB2_.set (x);
  }


  // LorentGeversStateUpdateComplexType
  // 

  const LorentGeversStateUpdateComplexType::SType& LorentGeversStateUpdateComplexType::
  getS () const
  {
    return this->S_.get ();
  }

  LorentGeversStateUpdateComplexType::SType& LorentGeversStateUpdateComplexType::
  getS ()
  {
    return this->S_.get ();
  }

  void LorentGeversStateUpdateComplexType::
  setS (const SType& x)
  {
    this->S_.set (x);
  }

  void LorentGeversStateUpdateComplexType::
  setS (::std::auto_ptr< SType > x)
  {
    this->S_.set (x);
  }


  // LorentGeversOutputComplexType
  // 

  const LorentGeversOutputComplexType::QType& LorentGeversOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  LorentGeversOutputComplexType::QType& LorentGeversOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void LorentGeversOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void LorentGeversOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }


  // HBVComplexType
  // 

  const HBVComplexType::ParameterInputType& HBVComplexType::
  getParameterInput () const
  {
    return this->parameterInput_.get ();
  }

  HBVComplexType::ParameterInputType& HBVComplexType::
  getParameterInput ()
  {
    return this->parameterInput_.get ();
  }

  void HBVComplexType::
  setParameterInput (const ParameterInputType& x)
  {
    this->parameterInput_.set (x);
  }

  void HBVComplexType::
  setParameterInput (::std::auto_ptr< ParameterInputType > x)
  {
    this->parameterInput_.set (x);
  }

  const HBVComplexType::ParameterSnowType& HBVComplexType::
  getParameterSnow () const
  {
    return this->parameterSnow_.get ();
  }

  HBVComplexType::ParameterSnowType& HBVComplexType::
  getParameterSnow ()
  {
    return this->parameterSnow_.get ();
  }

  void HBVComplexType::
  setParameterSnow (const ParameterSnowType& x)
  {
    this->parameterSnow_.set (x);
  }

  void HBVComplexType::
  setParameterSnow (::std::auto_ptr< ParameterSnowType > x)
  {
    this->parameterSnow_.set (x);
  }

  const HBVComplexType::ParameterInterceptionType& HBVComplexType::
  getParameterInterception () const
  {
    return this->parameterInterception_.get ();
  }

  HBVComplexType::ParameterInterceptionType& HBVComplexType::
  getParameterInterception ()
  {
    return this->parameterInterception_.get ();
  }

  void HBVComplexType::
  setParameterInterception (const ParameterInterceptionType& x)
  {
    this->parameterInterception_.set (x);
  }

  void HBVComplexType::
  setParameterInterception (::std::auto_ptr< ParameterInterceptionType > x)
  {
    this->parameterInterception_.set (x);
  }

  const HBVComplexType::ParameterSoilType& HBVComplexType::
  getParameterSoil () const
  {
    return this->parameterSoil_.get ();
  }

  HBVComplexType::ParameterSoilType& HBVComplexType::
  getParameterSoil ()
  {
    return this->parameterSoil_.get ();
  }

  void HBVComplexType::
  setParameterSoil (const ParameterSoilType& x)
  {
    this->parameterSoil_.set (x);
  }

  void HBVComplexType::
  setParameterSoil (::std::auto_ptr< ParameterSoilType > x)
  {
    this->parameterSoil_.set (x);
  }

  const HBVComplexType::ParameterResponseType& HBVComplexType::
  getParameterResponse () const
  {
    return this->parameterResponse_.get ();
  }

  HBVComplexType::ParameterResponseType& HBVComplexType::
  getParameterResponse ()
  {
    return this->parameterResponse_.get ();
  }

  void HBVComplexType::
  setParameterResponse (const ParameterResponseType& x)
  {
    this->parameterResponse_.set (x);
  }

  void HBVComplexType::
  setParameterResponse (::std::auto_ptr< ParameterResponseType > x)
  {
    this->parameterResponse_.set (x);
  }

  const HBVComplexType::InputType& HBVComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  HBVComplexType::InputType& HBVComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void HBVComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void HBVComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const HBVComplexType::LinkOptional& HBVComplexType::
  getLink () const
  {
    return this->link_;
  }

  HBVComplexType::LinkOptional& HBVComplexType::
  getLink ()
  {
    return this->link_;
  }

  void HBVComplexType::
  setLink (const LinkType& x)
  {
    this->link_.set (x);
  }

  void HBVComplexType::
  setLink (const LinkOptional& x)
  {
    this->link_ = x;
  }

  void HBVComplexType::
  setLink (::std::auto_ptr< LinkType > x)
  {
    this->link_.set (x);
  }

  const HBVComplexType::StateType& HBVComplexType::
  getState () const
  {
    return this->state_.get ();
  }

  HBVComplexType::StateType& HBVComplexType::
  getState ()
  {
    return this->state_.get ();
  }

  void HBVComplexType::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void HBVComplexType::
  setState (::std::auto_ptr< StateType > x)
  {
    this->state_.set (x);
  }

  const HBVComplexType::StateUpdateOptional& HBVComplexType::
  getStateUpdate () const
  {
    return this->stateUpdate_;
  }

  HBVComplexType::StateUpdateOptional& HBVComplexType::
  getStateUpdate ()
  {
    return this->stateUpdate_;
  }

  void HBVComplexType::
  setStateUpdate (const StateUpdateType& x)
  {
    this->stateUpdate_.set (x);
  }

  void HBVComplexType::
  setStateUpdate (const StateUpdateOptional& x)
  {
    this->stateUpdate_ = x;
  }

  void HBVComplexType::
  setStateUpdate (::std::auto_ptr< StateUpdateType > x)
  {
    this->stateUpdate_.set (x);
  }

  const HBVComplexType::OutputType& HBVComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  HBVComplexType::OutputType& HBVComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void HBVComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void HBVComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const HBVComplexType::IdType& HBVComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  HBVComplexType::IdType& HBVComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void HBVComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void HBVComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const HBVComplexType::NameOptional& HBVComplexType::
  getName () const
  {
    return this->name_;
  }

  HBVComplexType::NameOptional& HBVComplexType::
  getName ()
  {
    return this->name_;
  }

  void HBVComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void HBVComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void HBVComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // HBVParameterInputComplexType
  // 

  const HBVParameterInputComplexType::ECORROptional& HBVParameterInputComplexType::
  getECORR () const
  {
    return this->ECORR_;
  }

  HBVParameterInputComplexType::ECORROptional& HBVParameterInputComplexType::
  getECORR ()
  {
    return this->ECORR_;
  }

  void HBVParameterInputComplexType::
  setECORR (const ECORRType& x)
  {
    this->ECORR_.set (x);
  }

  void HBVParameterInputComplexType::
  setECORR (const ECORROptional& x)
  {
    this->ECORR_ = x;
  }

  void HBVParameterInputComplexType::
  setECORR (::std::auto_ptr< ECORRType > x)
  {
    this->ECORR_.set (x);
  }

  const HBVParameterInputComplexType::RFCFOptional& HBVParameterInputComplexType::
  getRFCF () const
  {
    return this->RFCF_;
  }

  HBVParameterInputComplexType::RFCFOptional& HBVParameterInputComplexType::
  getRFCF ()
  {
    return this->RFCF_;
  }

  void HBVParameterInputComplexType::
  setRFCF (const RFCFType& x)
  {
    this->RFCF_.set (x);
  }

  void HBVParameterInputComplexType::
  setRFCF (const RFCFOptional& x)
  {
    this->RFCF_ = x;
  }

  void HBVParameterInputComplexType::
  setRFCF (::std::auto_ptr< RFCFType > x)
  {
    this->RFCF_.set (x);
  }

  const HBVParameterInputComplexType::SFCFOptional& HBVParameterInputComplexType::
  getSFCF () const
  {
    return this->SFCF_;
  }

  HBVParameterInputComplexType::SFCFOptional& HBVParameterInputComplexType::
  getSFCF ()
  {
    return this->SFCF_;
  }

  void HBVParameterInputComplexType::
  setSFCF (const SFCFType& x)
  {
    this->SFCF_.set (x);
  }

  void HBVParameterInputComplexType::
  setSFCF (const SFCFOptional& x)
  {
    this->SFCF_ = x;
  }

  void HBVParameterInputComplexType::
  setSFCF (::std::auto_ptr< SFCFType > x)
  {
    this->SFCF_.set (x);
  }

  const HBVParameterInputComplexType::TTType& HBVParameterInputComplexType::
  getTT () const
  {
    return this->TT_.get ();
  }

  HBVParameterInputComplexType::TTType& HBVParameterInputComplexType::
  getTT ()
  {
    return this->TT_.get ();
  }

  void HBVParameterInputComplexType::
  setTT (const TTType& x)
  {
    this->TT_.set (x);
  }

  void HBVParameterInputComplexType::
  setTT (::std::auto_ptr< TTType > x)
  {
    this->TT_.set (x);
  }

  const HBVParameterInputComplexType::TTIType& HBVParameterInputComplexType::
  getTTI () const
  {
    return this->TTI_.get ();
  }

  HBVParameterInputComplexType::TTIType& HBVParameterInputComplexType::
  getTTI ()
  {
    return this->TTI_.get ();
  }

  void HBVParameterInputComplexType::
  setTTI (const TTIType& x)
  {
    this->TTI_.set (x);
  }

  void HBVParameterInputComplexType::
  setTTI (::std::auto_ptr< TTIType > x)
  {
    this->TTI_.set (x);
  }


  // HBVParameterSnowComplexType
  // 

  const HBVParameterSnowComplexType::CFMAXType& HBVParameterSnowComplexType::
  getCFMAX () const
  {
    return this->CFMAX_.get ();
  }

  HBVParameterSnowComplexType::CFMAXType& HBVParameterSnowComplexType::
  getCFMAX ()
  {
    return this->CFMAX_.get ();
  }

  void HBVParameterSnowComplexType::
  setCFMAX (const CFMAXType& x)
  {
    this->CFMAX_.set (x);
  }

  void HBVParameterSnowComplexType::
  setCFMAX (::std::auto_ptr< CFMAXType > x)
  {
    this->CFMAX_.set (x);
  }

  const HBVParameterSnowComplexType::CFRType& HBVParameterSnowComplexType::
  getCFR () const
  {
    return this->CFR_.get ();
  }

  HBVParameterSnowComplexType::CFRType& HBVParameterSnowComplexType::
  getCFR ()
  {
    return this->CFR_.get ();
  }

  void HBVParameterSnowComplexType::
  setCFR (const CFRType& x)
  {
    this->CFR_.set (x);
  }

  void HBVParameterSnowComplexType::
  setCFR (::std::auto_ptr< CFRType > x)
  {
    this->CFR_.set (x);
  }

  const HBVParameterSnowComplexType::CWHType& HBVParameterSnowComplexType::
  getCWH () const
  {
    return this->CWH_.get ();
  }

  HBVParameterSnowComplexType::CWHType& HBVParameterSnowComplexType::
  getCWH ()
  {
    return this->CWH_.get ();
  }

  void HBVParameterSnowComplexType::
  setCWH (const CWHType& x)
  {
    this->CWH_.set (x);
  }

  void HBVParameterSnowComplexType::
  setCWH (::std::auto_ptr< CWHType > x)
  {
    this->CWH_.set (x);
  }

  const HBVParameterSnowComplexType::TTMType& HBVParameterSnowComplexType::
  getTTM () const
  {
    return this->TTM_.get ();
  }

  HBVParameterSnowComplexType::TTMType& HBVParameterSnowComplexType::
  getTTM ()
  {
    return this->TTM_.get ();
  }

  void HBVParameterSnowComplexType::
  setTTM (const TTMType& x)
  {
    this->TTM_.set (x);
  }

  void HBVParameterSnowComplexType::
  setTTM (::std::auto_ptr< TTMType > x)
  {
    this->TTM_.set (x);
  }


  // HBVParameterInterceptionComplexType
  // 

  const HBVParameterInterceptionComplexType::LICType& HBVParameterInterceptionComplexType::
  getLIC () const
  {
    return this->LIC_.get ();
  }

  HBVParameterInterceptionComplexType::LICType& HBVParameterInterceptionComplexType::
  getLIC ()
  {
    return this->LIC_.get ();
  }

  void HBVParameterInterceptionComplexType::
  setLIC (const LICType& x)
  {
    this->LIC_.set (x);
  }

  void HBVParameterInterceptionComplexType::
  setLIC (::std::auto_ptr< LICType > x)
  {
    this->LIC_.set (x);
  }


  // HBVParameterSoilComplexType
  // 

  const HBVParameterSoilComplexType::BETAType& HBVParameterSoilComplexType::
  getBETA () const
  {
    return this->BETA_.get ();
  }

  HBVParameterSoilComplexType::BETAType& HBVParameterSoilComplexType::
  getBETA ()
  {
    return this->BETA_.get ();
  }

  void HBVParameterSoilComplexType::
  setBETA (const BETAType& x)
  {
    this->BETA_.set (x);
  }

  void HBVParameterSoilComplexType::
  setBETA (::std::auto_ptr< BETAType > x)
  {
    this->BETA_.set (x);
  }

  const HBVParameterSoilComplexType::CFLUXType& HBVParameterSoilComplexType::
  getCFLUX () const
  {
    return this->CFLUX_.get ();
  }

  HBVParameterSoilComplexType::CFLUXType& HBVParameterSoilComplexType::
  getCFLUX ()
  {
    return this->CFLUX_.get ();
  }

  void HBVParameterSoilComplexType::
  setCFLUX (const CFLUXType& x)
  {
    this->CFLUX_.set (x);
  }

  void HBVParameterSoilComplexType::
  setCFLUX (::std::auto_ptr< CFLUXType > x)
  {
    this->CFLUX_.set (x);
  }

  const HBVParameterSoilComplexType::ETFType& HBVParameterSoilComplexType::
  getETF () const
  {
    return this->ETF_.get ();
  }

  HBVParameterSoilComplexType::ETFType& HBVParameterSoilComplexType::
  getETF ()
  {
    return this->ETF_.get ();
  }

  void HBVParameterSoilComplexType::
  setETF (const ETFType& x)
  {
    this->ETF_.set (x);
  }

  void HBVParameterSoilComplexType::
  setETF (::std::auto_ptr< ETFType > x)
  {
    this->ETF_.set (x);
  }

  const HBVParameterSoilComplexType::FCType& HBVParameterSoilComplexType::
  getFC () const
  {
    return this->FC_.get ();
  }

  HBVParameterSoilComplexType::FCType& HBVParameterSoilComplexType::
  getFC ()
  {
    return this->FC_.get ();
  }

  void HBVParameterSoilComplexType::
  setFC (const FCType& x)
  {
    this->FC_.set (x);
  }

  void HBVParameterSoilComplexType::
  setFC (::std::auto_ptr< FCType > x)
  {
    this->FC_.set (x);
  }

  const HBVParameterSoilComplexType::LPType& HBVParameterSoilComplexType::
  getLP () const
  {
    return this->LP_.get ();
  }

  HBVParameterSoilComplexType::LPType& HBVParameterSoilComplexType::
  getLP ()
  {
    return this->LP_.get ();
  }

  void HBVParameterSoilComplexType::
  setLP (const LPType& x)
  {
    this->LP_.set (x);
  }

  void HBVParameterSoilComplexType::
  setLP (::std::auto_ptr< LPType > x)
  {
    this->LP_.set (x);
  }


  // HBVParameterResponseComplexType
  // 

  const HBVParameterResponseComplexType::ALPHAType& HBVParameterResponseComplexType::
  getALPHA () const
  {
    return this->ALPHA_.get ();
  }

  HBVParameterResponseComplexType::ALPHAType& HBVParameterResponseComplexType::
  getALPHA ()
  {
    return this->ALPHA_.get ();
  }

  void HBVParameterResponseComplexType::
  setALPHA (const ALPHAType& x)
  {
    this->ALPHA_.set (x);
  }

  void HBVParameterResponseComplexType::
  setALPHA (::std::auto_ptr< ALPHAType > x)
  {
    this->ALPHA_.set (x);
  }

  const HBVParameterResponseComplexType::AREAType& HBVParameterResponseComplexType::
  getAREA () const
  {
    return this->AREA_.get ();
  }

  HBVParameterResponseComplexType::AREAType& HBVParameterResponseComplexType::
  getAREA ()
  {
    return this->AREA_.get ();
  }

  void HBVParameterResponseComplexType::
  setAREA (const AREAType& x)
  {
    this->AREA_.set (x);
  }

  void HBVParameterResponseComplexType::
  setAREA (::std::auto_ptr< AREAType > x)
  {
    this->AREA_.set (x);
  }

  const HBVParameterResponseComplexType::KType& HBVParameterResponseComplexType::
  getK () const
  {
    return this->K_.get ();
  }

  HBVParameterResponseComplexType::KType& HBVParameterResponseComplexType::
  getK ()
  {
    return this->K_.get ();
  }

  void HBVParameterResponseComplexType::
  setK (const KType& x)
  {
    this->K_.set (x);
  }

  void HBVParameterResponseComplexType::
  setK (::std::auto_ptr< KType > x)
  {
    this->K_.set (x);
  }

  const HBVParameterResponseComplexType::K1Type& HBVParameterResponseComplexType::
  getK1 () const
  {
    return this->K1_.get ();
  }

  HBVParameterResponseComplexType::K1Type& HBVParameterResponseComplexType::
  getK1 ()
  {
    return this->K1_.get ();
  }

  void HBVParameterResponseComplexType::
  setK1 (const K1Type& x)
  {
    this->K1_.set (x);
  }

  void HBVParameterResponseComplexType::
  setK1 (::std::auto_ptr< K1Type > x)
  {
    this->K1_.set (x);
  }

  const HBVParameterResponseComplexType::PERCType& HBVParameterResponseComplexType::
  getPERC () const
  {
    return this->PERC_.get ();
  }

  HBVParameterResponseComplexType::PERCType& HBVParameterResponseComplexType::
  getPERC ()
  {
    return this->PERC_.get ();
  }

  void HBVParameterResponseComplexType::
  setPERC (const PERCType& x)
  {
    this->PERC_.set (x);
  }

  void HBVParameterResponseComplexType::
  setPERC (::std::auto_ptr< PERCType > x)
  {
    this->PERC_.set (x);
  }


  // HBVInputComplexType
  // 

  const HBVInputComplexType::EPType& HBVInputComplexType::
  getEP () const
  {
    return this->EP_.get ();
  }

  HBVInputComplexType::EPType& HBVInputComplexType::
  getEP ()
  {
    return this->EP_.get ();
  }

  void HBVInputComplexType::
  setEP (const EPType& x)
  {
    this->EP_.set (x);
  }

  void HBVInputComplexType::
  setEP (::std::auto_ptr< EPType > x)
  {
    this->EP_.set (x);
  }

  const HBVInputComplexType::PType& HBVInputComplexType::
  getP () const
  {
    return this->P_.get ();
  }

  HBVInputComplexType::PType& HBVInputComplexType::
  getP ()
  {
    return this->P_.get ();
  }

  void HBVInputComplexType::
  setP (const PType& x)
  {
    this->P_.set (x);
  }

  void HBVInputComplexType::
  setP (::std::auto_ptr< PType > x)
  {
    this->P_.set (x);
  }

  const HBVInputComplexType::TType& HBVInputComplexType::
  getT () const
  {
    return this->T_.get ();
  }

  HBVInputComplexType::TType& HBVInputComplexType::
  getT ()
  {
    return this->T_.get ();
  }

  void HBVInputComplexType::
  setT (const TType& x)
  {
    this->T_.set (x);
  }

  void HBVInputComplexType::
  setT (::std::auto_ptr< TType > x)
  {
    this->T_.set (x);
  }

  const HBVInputComplexType::TMType& HBVInputComplexType::
  getTM () const
  {
    return this->TM_.get ();
  }

  HBVInputComplexType::TMType& HBVInputComplexType::
  getTM ()
  {
    return this->TM_.get ();
  }

  void HBVInputComplexType::
  setTM (const TMType& x)
  {
    this->TM_.set (x);
  }

  void HBVInputComplexType::
  setTM (::std::auto_ptr< TMType > x)
  {
    this->TM_.set (x);
  }


  // HBVLinkComplexType
  // 

  const HBVLinkComplexType::CFType& HBVLinkComplexType::
  getCF () const
  {
    return this->CF_.get ();
  }

  HBVLinkComplexType::CFType& HBVLinkComplexType::
  getCF ()
  {
    return this->CF_.get ();
  }

  void HBVLinkComplexType::
  setCF (const CFType& x)
  {
    this->CF_.set (x);
  }

  void HBVLinkComplexType::
  setCF (::std::auto_ptr< CFType > x)
  {
    this->CF_.set (x);
  }

  const HBVLinkComplexType::EAType& HBVLinkComplexType::
  getEA () const
  {
    return this->EA_.get ();
  }

  HBVLinkComplexType::EAType& HBVLinkComplexType::
  getEA ()
  {
    return this->EA_.get ();
  }

  void HBVLinkComplexType::
  setEA (const EAType& x)
  {
    this->EA_.set (x);
  }

  void HBVLinkComplexType::
  setEA (::std::auto_ptr< EAType > x)
  {
    this->EA_.set (x);
  }

  const HBVLinkComplexType::EIType& HBVLinkComplexType::
  getEI () const
  {
    return this->EI_.get ();
  }

  HBVLinkComplexType::EIType& HBVLinkComplexType::
  getEI ()
  {
    return this->EI_.get ();
  }

  void HBVLinkComplexType::
  setEI (const EIType& x)
  {
    this->EI_.set (x);
  }

  void HBVLinkComplexType::
  setEI (::std::auto_ptr< EIType > x)
  {
    this->EI_.set (x);
  }

  const HBVLinkComplexType::EPType& HBVLinkComplexType::
  getEP () const
  {
    return this->EP_.get ();
  }

  HBVLinkComplexType::EPType& HBVLinkComplexType::
  getEP ()
  {
    return this->EP_.get ();
  }

  void HBVLinkComplexType::
  setEP (const EPType& x)
  {
    this->EP_.set (x);
  }

  void HBVLinkComplexType::
  setEP (::std::auto_ptr< EPType > x)
  {
    this->EP_.set (x);
  }

  const HBVLinkComplexType::INType& HBVLinkComplexType::
  getIN () const
  {
    return this->IN_.get ();
  }

  HBVLinkComplexType::INType& HBVLinkComplexType::
  getIN ()
  {
    return this->IN_.get ();
  }

  void HBVLinkComplexType::
  setIN (const INType& x)
  {
    this->IN_.set (x);
  }

  void HBVLinkComplexType::
  setIN (::std::auto_ptr< INType > x)
  {
    this->IN_.set (x);
  }

  const HBVLinkComplexType::INIType& HBVLinkComplexType::
  getINI () const
  {
    return this->INI_.get ();
  }

  HBVLinkComplexType::INIType& HBVLinkComplexType::
  getINI ()
  {
    return this->INI_.get ();
  }

  void HBVLinkComplexType::
  setINI (const INIType& x)
  {
    this->INI_.set (x);
  }

  void HBVLinkComplexType::
  setINI (::std::auto_ptr< INIType > x)
  {
    this->INI_.set (x);
  }

  const HBVLinkComplexType::PERCType& HBVLinkComplexType::
  getPERC () const
  {
    return this->PERC_.get ();
  }

  HBVLinkComplexType::PERCType& HBVLinkComplexType::
  getPERC ()
  {
    return this->PERC_.get ();
  }

  void HBVLinkComplexType::
  setPERC (const PERCType& x)
  {
    this->PERC_.set (x);
  }

  void HBVLinkComplexType::
  setPERC (::std::auto_ptr< PERCType > x)
  {
    this->PERC_.set (x);
  }

  const HBVLinkComplexType::RType& HBVLinkComplexType::
  getR () const
  {
    return this->R_.get ();
  }

  HBVLinkComplexType::RType& HBVLinkComplexType::
  getR ()
  {
    return this->R_.get ();
  }

  void HBVLinkComplexType::
  setR (const RType& x)
  {
    this->R_.set (x);
  }

  void HBVLinkComplexType::
  setR (::std::auto_ptr< RType > x)
  {
    this->R_.set (x);
  }


  // HBVStateComplexType
  // 

  const HBVStateComplexType::ICType& HBVStateComplexType::
  getIC () const
  {
    return this->IC_.get ();
  }

  HBVStateComplexType::ICType& HBVStateComplexType::
  getIC ()
  {
    return this->IC_.get ();
  }

  void HBVStateComplexType::
  setIC (const ICType& x)
  {
    this->IC_.set (x);
  }

  void HBVStateComplexType::
  setIC (::std::auto_ptr< ICType > x)
  {
    this->IC_.set (x);
  }

  const HBVStateComplexType::LZType& HBVStateComplexType::
  getLZ () const
  {
    return this->LZ_.get ();
  }

  HBVStateComplexType::LZType& HBVStateComplexType::
  getLZ ()
  {
    return this->LZ_.get ();
  }

  void HBVStateComplexType::
  setLZ (const LZType& x)
  {
    this->LZ_.set (x);
  }

  void HBVStateComplexType::
  setLZ (::std::auto_ptr< LZType > x)
  {
    this->LZ_.set (x);
  }

  const HBVStateComplexType::SMType& HBVStateComplexType::
  getSM () const
  {
    return this->SM_.get ();
  }

  HBVStateComplexType::SMType& HBVStateComplexType::
  getSM ()
  {
    return this->SM_.get ();
  }

  void HBVStateComplexType::
  setSM (const SMType& x)
  {
    this->SM_.set (x);
  }

  void HBVStateComplexType::
  setSM (::std::auto_ptr< SMType > x)
  {
    this->SM_.set (x);
  }

  const HBVStateComplexType::SPType& HBVStateComplexType::
  getSP () const
  {
    return this->SP_.get ();
  }

  HBVStateComplexType::SPType& HBVStateComplexType::
  getSP ()
  {
    return this->SP_.get ();
  }

  void HBVStateComplexType::
  setSP (const SPType& x)
  {
    this->SP_.set (x);
  }

  void HBVStateComplexType::
  setSP (::std::auto_ptr< SPType > x)
  {
    this->SP_.set (x);
  }

  const HBVStateComplexType::UZType& HBVStateComplexType::
  getUZ () const
  {
    return this->UZ_.get ();
  }

  HBVStateComplexType::UZType& HBVStateComplexType::
  getUZ ()
  {
    return this->UZ_.get ();
  }

  void HBVStateComplexType::
  setUZ (const UZType& x)
  {
    this->UZ_.set (x);
  }

  void HBVStateComplexType::
  setUZ (::std::auto_ptr< UZType > x)
  {
    this->UZ_.set (x);
  }

  const HBVStateComplexType::WCType& HBVStateComplexType::
  getWC () const
  {
    return this->WC_.get ();
  }

  HBVStateComplexType::WCType& HBVStateComplexType::
  getWC ()
  {
    return this->WC_.get ();
  }

  void HBVStateComplexType::
  setWC (const WCType& x)
  {
    this->WC_.set (x);
  }

  void HBVStateComplexType::
  setWC (::std::auto_ptr< WCType > x)
  {
    this->WC_.set (x);
  }


  // HBVStateUpdateComplexType
  // 

  const HBVStateUpdateComplexType::ICOptional& HBVStateUpdateComplexType::
  getIC () const
  {
    return this->IC_;
  }

  HBVStateUpdateComplexType::ICOptional& HBVStateUpdateComplexType::
  getIC ()
  {
    return this->IC_;
  }

  void HBVStateUpdateComplexType::
  setIC (const ICType& x)
  {
    this->IC_.set (x);
  }

  void HBVStateUpdateComplexType::
  setIC (const ICOptional& x)
  {
    this->IC_ = x;
  }

  void HBVStateUpdateComplexType::
  setIC (::std::auto_ptr< ICType > x)
  {
    this->IC_.set (x);
  }

  const HBVStateUpdateComplexType::LZOptional& HBVStateUpdateComplexType::
  getLZ () const
  {
    return this->LZ_;
  }

  HBVStateUpdateComplexType::LZOptional& HBVStateUpdateComplexType::
  getLZ ()
  {
    return this->LZ_;
  }

  void HBVStateUpdateComplexType::
  setLZ (const LZType& x)
  {
    this->LZ_.set (x);
  }

  void HBVStateUpdateComplexType::
  setLZ (const LZOptional& x)
  {
    this->LZ_ = x;
  }

  void HBVStateUpdateComplexType::
  setLZ (::std::auto_ptr< LZType > x)
  {
    this->LZ_.set (x);
  }

  const HBVStateUpdateComplexType::SMOptional& HBVStateUpdateComplexType::
  getSM () const
  {
    return this->SM_;
  }

  HBVStateUpdateComplexType::SMOptional& HBVStateUpdateComplexType::
  getSM ()
  {
    return this->SM_;
  }

  void HBVStateUpdateComplexType::
  setSM (const SMType& x)
  {
    this->SM_.set (x);
  }

  void HBVStateUpdateComplexType::
  setSM (const SMOptional& x)
  {
    this->SM_ = x;
  }

  void HBVStateUpdateComplexType::
  setSM (::std::auto_ptr< SMType > x)
  {
    this->SM_.set (x);
  }

  const HBVStateUpdateComplexType::SPOptional& HBVStateUpdateComplexType::
  getSP () const
  {
    return this->SP_;
  }

  HBVStateUpdateComplexType::SPOptional& HBVStateUpdateComplexType::
  getSP ()
  {
    return this->SP_;
  }

  void HBVStateUpdateComplexType::
  setSP (const SPType& x)
  {
    this->SP_.set (x);
  }

  void HBVStateUpdateComplexType::
  setSP (const SPOptional& x)
  {
    this->SP_ = x;
  }

  void HBVStateUpdateComplexType::
  setSP (::std::auto_ptr< SPType > x)
  {
    this->SP_.set (x);
  }

  const HBVStateUpdateComplexType::UZOptional& HBVStateUpdateComplexType::
  getUZ () const
  {
    return this->UZ_;
  }

  HBVStateUpdateComplexType::UZOptional& HBVStateUpdateComplexType::
  getUZ ()
  {
    return this->UZ_;
  }

  void HBVStateUpdateComplexType::
  setUZ (const UZType& x)
  {
    this->UZ_.set (x);
  }

  void HBVStateUpdateComplexType::
  setUZ (const UZOptional& x)
  {
    this->UZ_ = x;
  }

  void HBVStateUpdateComplexType::
  setUZ (::std::auto_ptr< UZType > x)
  {
    this->UZ_.set (x);
  }

  const HBVStateUpdateComplexType::WCOptional& HBVStateUpdateComplexType::
  getWC () const
  {
    return this->WC_;
  }

  HBVStateUpdateComplexType::WCOptional& HBVStateUpdateComplexType::
  getWC ()
  {
    return this->WC_;
  }

  void HBVStateUpdateComplexType::
  setWC (const WCType& x)
  {
    this->WC_.set (x);
  }

  void HBVStateUpdateComplexType::
  setWC (const WCOptional& x)
  {
    this->WC_ = x;
  }

  void HBVStateUpdateComplexType::
  setWC (::std::auto_ptr< WCType > x)
  {
    this->WC_.set (x);
  }


  // HBVOutputComplexType
  // 

  const HBVOutputComplexType::QType& HBVOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  HBVOutputComplexType::QType& HBVOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void HBVOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void HBVOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }

  const HBVOutputComplexType::SMPercentageOptional& HBVOutputComplexType::
  getSMPercentage () const
  {
    return this->SMPercentage_;
  }

  HBVOutputComplexType::SMPercentageOptional& HBVOutputComplexType::
  getSMPercentage ()
  {
    return this->SMPercentage_;
  }

  void HBVOutputComplexType::
  setSMPercentage (const SMPercentageType& x)
  {
    this->SMPercentage_.set (x);
  }

  void HBVOutputComplexType::
  setSMPercentage (const SMPercentageOptional& x)
  {
    this->SMPercentage_ = x;
  }

  void HBVOutputComplexType::
  setSMPercentage (::std::auto_ptr< SMPercentageType > x)
  {
    this->SMPercentage_.set (x);
  }

  const HBVOutputComplexType::SWEOptional& HBVOutputComplexType::
  getSWE () const
  {
    return this->SWE_;
  }

  HBVOutputComplexType::SWEOptional& HBVOutputComplexType::
  getSWE ()
  {
    return this->SWE_;
  }

  void HBVOutputComplexType::
  setSWE (const SWEType& x)
  {
    this->SWE_.set (x);
  }

  void HBVOutputComplexType::
  setSWE (const SWEOptional& x)
  {
    this->SWE_ = x;
  }

  void HBVOutputComplexType::
  setSWE (::std::auto_ptr< SWEType > x)
  {
    this->SWE_.set (x);
  }


  // SRMComplexType
  // 

  const SRMComplexType::ParameterType& SRMComplexType::
  getParameter () const
  {
    return this->parameter_.get ();
  }

  SRMComplexType::ParameterType& SRMComplexType::
  getParameter ()
  {
    return this->parameter_.get ();
  }

  void SRMComplexType::
  setParameter (const ParameterType& x)
  {
    this->parameter_.set (x);
  }

  void SRMComplexType::
  setParameter (::std::auto_ptr< ParameterType > x)
  {
    this->parameter_.set (x);
  }

  const SRMComplexType::ParameterZoneSequence& SRMComplexType::
  getParameterZone () const
  {
    return this->parameterZone_;
  }

  SRMComplexType::ParameterZoneSequence& SRMComplexType::
  getParameterZone ()
  {
    return this->parameterZone_;
  }

  void SRMComplexType::
  setParameterZone (const ParameterZoneSequence& s)
  {
    this->parameterZone_ = s;
  }

  const SRMComplexType::InputType& SRMComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  SRMComplexType::InputType& SRMComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void SRMComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void SRMComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const SRMComplexType::StateType& SRMComplexType::
  getState () const
  {
    return this->state_.get ();
  }

  SRMComplexType::StateType& SRMComplexType::
  getState ()
  {
    return this->state_.get ();
  }

  void SRMComplexType::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void SRMComplexType::
  setState (::std::auto_ptr< StateType > x)
  {
    this->state_.set (x);
  }

  const SRMComplexType::OutputType& SRMComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  SRMComplexType::OutputType& SRMComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void SRMComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void SRMComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const SRMComplexType::IdType& SRMComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  SRMComplexType::IdType& SRMComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void SRMComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void SRMComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const SRMComplexType::NameOptional& SRMComplexType::
  getName () const
  {
    return this->name_;
  }

  SRMComplexType::NameOptional& SRMComplexType::
  getName ()
  {
    return this->name_;
  }

  void SRMComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void SRMComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void SRMComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // SRMParameterComplexType
  // 

  const SRMParameterComplexType::PtType& SRMParameterComplexType::
  getPt () const
  {
    return this->Pt_.get ();
  }

  SRMParameterComplexType::PtType& SRMParameterComplexType::
  getPt ()
  {
    return this->Pt_.get ();
  }

  void SRMParameterComplexType::
  setPt (const PtType& x)
  {
    this->Pt_.set (x);
  }

  void SRMParameterComplexType::
  setPt (::std::auto_ptr< PtType > x)
  {
    this->Pt_.set (x);
  }

  const SRMParameterComplexType::TLagType& SRMParameterComplexType::
  getTLag () const
  {
    return this->TLag_.get ();
  }

  SRMParameterComplexType::TLagType& SRMParameterComplexType::
  getTLag ()
  {
    return this->TLag_.get ();
  }

  void SRMParameterComplexType::
  setTLag (const TLagType& x)
  {
    this->TLag_.set (x);
  }

  void SRMParameterComplexType::
  setTLag (::std::auto_ptr< TLagType > x)
  {
    this->TLag_.set (x);
  }

  const SRMParameterComplexType::XType& SRMParameterComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  SRMParameterComplexType::XType& SRMParameterComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void SRMParameterComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void SRMParameterComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const SRMParameterComplexType::YType& SRMParameterComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  SRMParameterComplexType::YType& SRMParameterComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void SRMParameterComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void SRMParameterComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // SRMParameterZoneComplexType
  // 

  const SRMParameterZoneComplexType::AType& SRMParameterZoneComplexType::
  getA () const
  {
    return this->a_.get ();
  }

  SRMParameterZoneComplexType::AType& SRMParameterZoneComplexType::
  getA ()
  {
    return this->a_.get ();
  }

  void SRMParameterZoneComplexType::
  setA (const AType& x)
  {
    this->a_.set (x);
  }

  void SRMParameterZoneComplexType::
  setA (::std::auto_ptr< AType > x)
  {
    this->a_.set (x);
  }

  const SRMParameterZoneComplexType::AreaType& SRMParameterZoneComplexType::
  getArea () const
  {
    return this->area_.get ();
  }

  SRMParameterZoneComplexType::AreaType& SRMParameterZoneComplexType::
  getArea ()
  {
    return this->area_.get ();
  }

  void SRMParameterZoneComplexType::
  setArea (const AreaType& x)
  {
    this->area_.set (x);
  }

  void SRMParameterZoneComplexType::
  setArea (::std::auto_ptr< AreaType > x)
  {
    this->area_.set (x);
  }

  const SRMParameterZoneComplexType::Tcr1Type& SRMParameterZoneComplexType::
  getTcr1 () const
  {
    return this->Tcr1_.get ();
  }

  SRMParameterZoneComplexType::Tcr1Type& SRMParameterZoneComplexType::
  getTcr1 ()
  {
    return this->Tcr1_.get ();
  }

  void SRMParameterZoneComplexType::
  setTcr1 (const Tcr1Type& x)
  {
    this->Tcr1_.set (x);
  }

  void SRMParameterZoneComplexType::
  setTcr1 (::std::auto_ptr< Tcr1Type > x)
  {
    this->Tcr1_.set (x);
  }

  const SRMParameterZoneComplexType::Tcr2Type& SRMParameterZoneComplexType::
  getTcr2 () const
  {
    return this->Tcr2_.get ();
  }

  SRMParameterZoneComplexType::Tcr2Type& SRMParameterZoneComplexType::
  getTcr2 ()
  {
    return this->Tcr2_.get ();
  }

  void SRMParameterZoneComplexType::
  setTcr2 (const Tcr2Type& x)
  {
    this->Tcr2_.set (x);
  }

  void SRMParameterZoneComplexType::
  setTcr2 (::std::auto_ptr< Tcr2Type > x)
  {
    this->Tcr2_.set (x);
  }

  const SRMParameterZoneComplexType::IdOptional& SRMParameterZoneComplexType::
  getId () const
  {
    return this->id_;
  }

  SRMParameterZoneComplexType::IdOptional& SRMParameterZoneComplexType::
  getId ()
  {
    return this->id_;
  }

  void SRMParameterZoneComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void SRMParameterZoneComplexType::
  setId (const IdOptional& x)
  {
    this->id_ = x;
  }

  void SRMParameterZoneComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // SRMInputComplexType
  // 

  const SRMInputComplexType::POptional& SRMInputComplexType::
  getP () const
  {
    return this->P_;
  }

  SRMInputComplexType::POptional& SRMInputComplexType::
  getP ()
  {
    return this->P_;
  }

  void SRMInputComplexType::
  setP (const PType& x)
  {
    this->P_.set (x);
  }

  void SRMInputComplexType::
  setP (const POptional& x)
  {
    this->P_ = x;
  }

  void SRMInputComplexType::
  setP (::std::auto_ptr< PType > x)
  {
    this->P_.set (x);
  }

  const SRMInputComplexType::P_VectorOptional& SRMInputComplexType::
  getP_Vector () const
  {
    return this->P_Vector_;
  }

  SRMInputComplexType::P_VectorOptional& SRMInputComplexType::
  getP_Vector ()
  {
    return this->P_Vector_;
  }

  void SRMInputComplexType::
  setP_Vector (const P_VectorType& x)
  {
    this->P_Vector_.set (x);
  }

  void SRMInputComplexType::
  setP_Vector (const P_VectorOptional& x)
  {
    this->P_Vector_ = x;
  }

  void SRMInputComplexType::
  setP_Vector (::std::auto_ptr< P_VectorType > x)
  {
    this->P_Vector_.set (x);
  }

  const SRMInputComplexType::TOptional& SRMInputComplexType::
  getT () const
  {
    return this->T_;
  }

  SRMInputComplexType::TOptional& SRMInputComplexType::
  getT ()
  {
    return this->T_;
  }

  void SRMInputComplexType::
  setT (const TType& x)
  {
    this->T_.set (x);
  }

  void SRMInputComplexType::
  setT (const TOptional& x)
  {
    this->T_ = x;
  }

  void SRMInputComplexType::
  setT (::std::auto_ptr< TType > x)
  {
    this->T_.set (x);
  }

  const SRMInputComplexType::T_VectorOptional& SRMInputComplexType::
  getT_Vector () const
  {
    return this->T_Vector_;
  }

  SRMInputComplexType::T_VectorOptional& SRMInputComplexType::
  getT_Vector ()
  {
    return this->T_Vector_;
  }

  void SRMInputComplexType::
  setT_Vector (const T_VectorType& x)
  {
    this->T_Vector_.set (x);
  }

  void SRMInputComplexType::
  setT_Vector (const T_VectorOptional& x)
  {
    this->T_Vector_ = x;
  }

  void SRMInputComplexType::
  setT_Vector (::std::auto_ptr< T_VectorType > x)
  {
    this->T_Vector_.set (x);
  }

  const SRMInputComplexType::SCAOptional& SRMInputComplexType::
  getSCA () const
  {
    return this->SCA_;
  }

  SRMInputComplexType::SCAOptional& SRMInputComplexType::
  getSCA ()
  {
    return this->SCA_;
  }

  void SRMInputComplexType::
  setSCA (const SCAType& x)
  {
    this->SCA_.set (x);
  }

  void SRMInputComplexType::
  setSCA (const SCAOptional& x)
  {
    this->SCA_ = x;
  }

  void SRMInputComplexType::
  setSCA (::std::auto_ptr< SCAType > x)
  {
    this->SCA_.set (x);
  }

  const SRMInputComplexType::SCA_VectorOptional& SRMInputComplexType::
  getSCA_Vector () const
  {
    return this->SCA_Vector_;
  }

  SRMInputComplexType::SCA_VectorOptional& SRMInputComplexType::
  getSCA_Vector ()
  {
    return this->SCA_Vector_;
  }

  void SRMInputComplexType::
  setSCA_Vector (const SCA_VectorType& x)
  {
    this->SCA_Vector_.set (x);
  }

  void SRMInputComplexType::
  setSCA_Vector (const SCA_VectorOptional& x)
  {
    this->SCA_Vector_ = x;
  }

  void SRMInputComplexType::
  setSCA_Vector (::std::auto_ptr< SCA_VectorType > x)
  {
    this->SCA_Vector_.set (x);
  }

  const SRMInputComplexType::RCAOptional& SRMInputComplexType::
  getRCA () const
  {
    return this->RCA_;
  }

  SRMInputComplexType::RCAOptional& SRMInputComplexType::
  getRCA ()
  {
    return this->RCA_;
  }

  void SRMInputComplexType::
  setRCA (const RCAType& x)
  {
    this->RCA_.set (x);
  }

  void SRMInputComplexType::
  setRCA (const RCAOptional& x)
  {
    this->RCA_ = x;
  }

  void SRMInputComplexType::
  setRCA (::std::auto_ptr< RCAType > x)
  {
    this->RCA_.set (x);
  }

  const SRMInputComplexType::RCA_VectorOptional& SRMInputComplexType::
  getRCA_Vector () const
  {
    return this->RCA_Vector_;
  }

  SRMInputComplexType::RCA_VectorOptional& SRMInputComplexType::
  getRCA_Vector ()
  {
    return this->RCA_Vector_;
  }

  void SRMInputComplexType::
  setRCA_Vector (const RCA_VectorType& x)
  {
    this->RCA_Vector_.set (x);
  }

  void SRMInputComplexType::
  setRCA_Vector (const RCA_VectorOptional& x)
  {
    this->RCA_Vector_ = x;
  }

  void SRMInputComplexType::
  setRCA_Vector (::std::auto_ptr< RCA_VectorType > x)
  {
    this->RCA_Vector_.set (x);
  }

  const SRMInputComplexType::CrOptional& SRMInputComplexType::
  getCr () const
  {
    return this->cr_;
  }

  SRMInputComplexType::CrOptional& SRMInputComplexType::
  getCr ()
  {
    return this->cr_;
  }

  void SRMInputComplexType::
  setCr (const CrType& x)
  {
    this->cr_.set (x);
  }

  void SRMInputComplexType::
  setCr (const CrOptional& x)
  {
    this->cr_ = x;
  }

  void SRMInputComplexType::
  setCr (::std::auto_ptr< CrType > x)
  {
    this->cr_.set (x);
  }

  const SRMInputComplexType::Cr_VectorOptional& SRMInputComplexType::
  getCr_Vector () const
  {
    return this->cr_Vector_;
  }

  SRMInputComplexType::Cr_VectorOptional& SRMInputComplexType::
  getCr_Vector ()
  {
    return this->cr_Vector_;
  }

  void SRMInputComplexType::
  setCr_Vector (const Cr_VectorType& x)
  {
    this->cr_Vector_.set (x);
  }

  void SRMInputComplexType::
  setCr_Vector (const Cr_VectorOptional& x)
  {
    this->cr_Vector_ = x;
  }

  void SRMInputComplexType::
  setCr_Vector (::std::auto_ptr< Cr_VectorType > x)
  {
    this->cr_Vector_.set (x);
  }

  const SRMInputComplexType::CsOptional& SRMInputComplexType::
  getCs () const
  {
    return this->cs_;
  }

  SRMInputComplexType::CsOptional& SRMInputComplexType::
  getCs ()
  {
    return this->cs_;
  }

  void SRMInputComplexType::
  setCs (const CsType& x)
  {
    this->cs_.set (x);
  }

  void SRMInputComplexType::
  setCs (const CsOptional& x)
  {
    this->cs_ = x;
  }

  void SRMInputComplexType::
  setCs (::std::auto_ptr< CsType > x)
  {
    this->cs_.set (x);
  }

  const SRMInputComplexType::Cs_VectorOptional& SRMInputComplexType::
  getCs_Vector () const
  {
    return this->cs_Vector_;
  }

  SRMInputComplexType::Cs_VectorOptional& SRMInputComplexType::
  getCs_Vector ()
  {
    return this->cs_Vector_;
  }

  void SRMInputComplexType::
  setCs_Vector (const Cs_VectorType& x)
  {
    this->cs_Vector_.set (x);
  }

  void SRMInputComplexType::
  setCs_Vector (const Cs_VectorOptional& x)
  {
    this->cs_Vector_ = x;
  }

  void SRMInputComplexType::
  setCs_Vector (::std::auto_ptr< Cs_VectorType > x)
  {
    this->cs_Vector_.set (x);
  }


  // SRMStateComplexType
  // 

  const SRMStateComplexType::PStorage_VectorType& SRMStateComplexType::
  getPStorage_Vector () const
  {
    return this->PStorage_Vector_.get ();
  }

  SRMStateComplexType::PStorage_VectorType& SRMStateComplexType::
  getPStorage_Vector ()
  {
    return this->PStorage_Vector_.get ();
  }

  void SRMStateComplexType::
  setPStorage_Vector (const PStorage_VectorType& x)
  {
    this->PStorage_Vector_.set (x);
  }

  void SRMStateComplexType::
  setPStorage_Vector (::std::auto_ptr< PStorage_VectorType > x)
  {
    this->PStorage_Vector_.set (x);
  }

  const SRMStateComplexType::QType& SRMStateComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  SRMStateComplexType::QType& SRMStateComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void SRMStateComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void SRMStateComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }


  // SRMOutputComplexType
  // 

  const SRMOutputComplexType::QRain_VectorType& SRMOutputComplexType::
  getQRain_Vector () const
  {
    return this->QRain_Vector_.get ();
  }

  SRMOutputComplexType::QRain_VectorType& SRMOutputComplexType::
  getQRain_Vector ()
  {
    return this->QRain_Vector_.get ();
  }

  void SRMOutputComplexType::
  setQRain_Vector (const QRain_VectorType& x)
  {
    this->QRain_Vector_.set (x);
  }

  void SRMOutputComplexType::
  setQRain_Vector (::std::auto_ptr< QRain_VectorType > x)
  {
    this->QRain_Vector_.set (x);
  }

  const SRMOutputComplexType::QSnow_VectorType& SRMOutputComplexType::
  getQSnow_Vector () const
  {
    return this->QSnow_Vector_.get ();
  }

  SRMOutputComplexType::QSnow_VectorType& SRMOutputComplexType::
  getQSnow_Vector ()
  {
    return this->QSnow_Vector_.get ();
  }

  void SRMOutputComplexType::
  setQSnow_Vector (const QSnow_VectorType& x)
  {
    this->QSnow_Vector_.set (x);
  }

  void SRMOutputComplexType::
  setQSnow_Vector (::std::auto_ptr< QSnow_VectorType > x)
  {
    this->QSnow_Vector_.set (x);
  }

  const SRMOutputComplexType::QStorage_VectorType& SRMOutputComplexType::
  getQStorage_Vector () const
  {
    return this->QStorage_Vector_.get ();
  }

  SRMOutputComplexType::QStorage_VectorType& SRMOutputComplexType::
  getQStorage_Vector ()
  {
    return this->QStorage_Vector_.get ();
  }

  void SRMOutputComplexType::
  setQStorage_Vector (const QStorage_VectorType& x)
  {
    this->QStorage_Vector_.set (x);
  }

  void SRMOutputComplexType::
  setQStorage_Vector (::std::auto_ptr< QStorage_VectorType > x)
  {
    this->QStorage_Vector_.set (x);
  }


  // UnitDelayComplexType
  // 

  const UnitDelayComplexType::NStepOptional& UnitDelayComplexType::
  getNStep () const
  {
    return this->nStep_;
  }

  UnitDelayComplexType::NStepOptional& UnitDelayComplexType::
  getNStep ()
  {
    return this->nStep_;
  }

  void UnitDelayComplexType::
  setNStep (const NStepType& x)
  {
    this->nStep_.set (x);
  }

  void UnitDelayComplexType::
  setNStep (const NStepOptional& x)
  {
    this->nStep_ = x;
  }

  void UnitDelayComplexType::
  setNStep (::std::auto_ptr< NStepType > x)
  {
    this->nStep_.set (x);
  }

  const UnitDelayComplexType::InputType& UnitDelayComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  UnitDelayComplexType::InputType& UnitDelayComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void UnitDelayComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void UnitDelayComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const UnitDelayComplexType::OutputType& UnitDelayComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  UnitDelayComplexType::OutputType& UnitDelayComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void UnitDelayComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void UnitDelayComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const UnitDelayComplexType::IdType& UnitDelayComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  UnitDelayComplexType::IdType& UnitDelayComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void UnitDelayComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void UnitDelayComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const UnitDelayComplexType::NameOptional& UnitDelayComplexType::
  getName () const
  {
    return this->name_;
  }

  UnitDelayComplexType::NameOptional& UnitDelayComplexType::
  getName ()
  {
    return this->name_;
  }

  void UnitDelayComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void UnitDelayComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void UnitDelayComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // UnitDelayInputComplexType
  // 

  const UnitDelayInputComplexType::XType& UnitDelayInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  UnitDelayInputComplexType::XType& UnitDelayInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void UnitDelayInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void UnitDelayInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // UnitDelayOutputComplexType
  // 

  const UnitDelayOutputComplexType::YSequence& UnitDelayOutputComplexType::
  getY () const
  {
    return this->y_;
  }

  UnitDelayOutputComplexType::YSequence& UnitDelayOutputComplexType::
  getY ()
  {
    return this->y_;
  }

  void UnitDelayOutputComplexType::
  setY (const YSequence& s)
  {
    this->y_ = s;
  }

  const UnitDelayOutputComplexType::YVectorOptional& UnitDelayOutputComplexType::
  getYVector () const
  {
    return this->yVector_;
  }

  UnitDelayOutputComplexType::YVectorOptional& UnitDelayOutputComplexType::
  getYVector ()
  {
    return this->yVector_;
  }

  void UnitDelayOutputComplexType::
  setYVector (const YVectorType& x)
  {
    this->yVector_.set (x);
  }

  void UnitDelayOutputComplexType::
  setYVector (const YVectorOptional& x)
  {
    this->yVector_ = x;
  }

  void UnitDelayOutputComplexType::
  setYVector (::std::auto_ptr< YVectorType > x)
  {
    this->yVector_.set (x);
  }

  const UnitDelayOutputComplexType::YFinalOptional& UnitDelayOutputComplexType::
  getYFinal () const
  {
    return this->yFinal_;
  }

  UnitDelayOutputComplexType::YFinalOptional& UnitDelayOutputComplexType::
  getYFinal ()
  {
    return this->yFinal_;
  }

  void UnitDelayOutputComplexType::
  setYFinal (const YFinalType& x)
  {
    this->yFinal_.set (x);
  }

  void UnitDelayOutputComplexType::
  setYFinal (const YFinalOptional& x)
  {
    this->yFinal_ = x;
  }

  void UnitDelayOutputComplexType::
  setYFinal (::std::auto_ptr< YFinalType > x)
  {
    this->yFinal_.set (x);
  }

  const UnitDelayOutputComplexType::YMinOptional& UnitDelayOutputComplexType::
  getYMin () const
  {
    return this->yMin_;
  }

  UnitDelayOutputComplexType::YMinOptional& UnitDelayOutputComplexType::
  getYMin ()
  {
    return this->yMin_;
  }

  void UnitDelayOutputComplexType::
  setYMin (const YMinType& x)
  {
    this->yMin_.set (x);
  }

  void UnitDelayOutputComplexType::
  setYMin (const YMinOptional& x)
  {
    this->yMin_ = x;
  }

  void UnitDelayOutputComplexType::
  setYMin (::std::auto_ptr< YMinType > x)
  {
    this->yMin_.set (x);
  }

  const UnitDelayOutputComplexType::YMeanOptional& UnitDelayOutputComplexType::
  getYMean () const
  {
    return this->yMean_;
  }

  UnitDelayOutputComplexType::YMeanOptional& UnitDelayOutputComplexType::
  getYMean ()
  {
    return this->yMean_;
  }

  void UnitDelayOutputComplexType::
  setYMean (const YMeanType& x)
  {
    this->yMean_.set (x);
  }

  void UnitDelayOutputComplexType::
  setYMean (const YMeanOptional& x)
  {
    this->yMean_ = x;
  }

  void UnitDelayOutputComplexType::
  setYMean (::std::auto_ptr< YMeanType > x)
  {
    this->yMean_.set (x);
  }

  const UnitDelayOutputComplexType::YMaxOptional& UnitDelayOutputComplexType::
  getYMax () const
  {
    return this->yMax_;
  }

  UnitDelayOutputComplexType::YMaxOptional& UnitDelayOutputComplexType::
  getYMax ()
  {
    return this->yMax_;
  }

  void UnitDelayOutputComplexType::
  setYMax (const YMaxType& x)
  {
    this->yMax_.set (x);
  }

  void UnitDelayOutputComplexType::
  setYMax (const YMaxOptional& x)
  {
    this->yMax_ = x;
  }

  void UnitDelayOutputComplexType::
  setYMax (::std::auto_ptr< YMaxType > x)
  {
    this->yMax_.set (x);
  }

  const UnitDelayOutputComplexType::YSumOptional& UnitDelayOutputComplexType::
  getYSum () const
  {
    return this->ySum_;
  }

  UnitDelayOutputComplexType::YSumOptional& UnitDelayOutputComplexType::
  getYSum ()
  {
    return this->ySum_;
  }

  void UnitDelayOutputComplexType::
  setYSum (const YSumType& x)
  {
    this->ySum_.set (x);
  }

  void UnitDelayOutputComplexType::
  setYSum (const YSumOptional& x)
  {
    this->ySum_ = x;
  }

  void UnitDelayOutputComplexType::
  setYSum (::std::auto_ptr< YSumType > x)
  {
    this->ySum_.set (x);
  }


  // UnitHydrographComplexType
  // 

  const UnitHydrographComplexType::WeightsType& UnitHydrographComplexType::
  getWeights () const
  {
    return this->weights_.get ();
  }

  UnitHydrographComplexType::WeightsType& UnitHydrographComplexType::
  getWeights ()
  {
    return this->weights_.get ();
  }

  void UnitHydrographComplexType::
  setWeights (const WeightsType& x)
  {
    this->weights_.set (x);
  }

  void UnitHydrographComplexType::
  setWeights (::std::auto_ptr< WeightsType > x)
  {
    this->weights_.set (x);
  }

  const UnitHydrographComplexType::InputType& UnitHydrographComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  UnitHydrographComplexType::InputType& UnitHydrographComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void UnitHydrographComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void UnitHydrographComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const UnitHydrographComplexType::OutputType& UnitHydrographComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  UnitHydrographComplexType::OutputType& UnitHydrographComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void UnitHydrographComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void UnitHydrographComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const UnitHydrographComplexType::IdType& UnitHydrographComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  UnitHydrographComplexType::IdType& UnitHydrographComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void UnitHydrographComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void UnitHydrographComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const UnitHydrographComplexType::NameOptional& UnitHydrographComplexType::
  getName () const
  {
    return this->name_;
  }

  UnitHydrographComplexType::NameOptional& UnitHydrographComplexType::
  getName ()
  {
    return this->name_;
  }

  void UnitHydrographComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void UnitHydrographComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void UnitHydrographComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // UnitHydrographWeightComplexType
  // 

  const UnitHydrographWeightComplexType::TriangularOptional& UnitHydrographWeightComplexType::
  getTriangular () const
  {
    return this->triangular_;
  }

  UnitHydrographWeightComplexType::TriangularOptional& UnitHydrographWeightComplexType::
  getTriangular ()
  {
    return this->triangular_;
  }

  void UnitHydrographWeightComplexType::
  setTriangular (const TriangularType& x)
  {
    this->triangular_.set (x);
  }

  void UnitHydrographWeightComplexType::
  setTriangular (const TriangularOptional& x)
  {
    this->triangular_ = x;
  }

  void UnitHydrographWeightComplexType::
  setTriangular (::std::auto_ptr< TriangularType > x)
  {
    this->triangular_.set (x);
  }

  const UnitHydrographWeightComplexType::CustomOptional& UnitHydrographWeightComplexType::
  getCustom () const
  {
    return this->custom_;
  }

  UnitHydrographWeightComplexType::CustomOptional& UnitHydrographWeightComplexType::
  getCustom ()
  {
    return this->custom_;
  }

  void UnitHydrographWeightComplexType::
  setCustom (const CustomType& x)
  {
    this->custom_.set (x);
  }

  void UnitHydrographWeightComplexType::
  setCustom (const CustomOptional& x)
  {
    this->custom_ = x;
  }

  void UnitHydrographWeightComplexType::
  setCustom (::std::auto_ptr< CustomType > x)
  {
    this->custom_.set (x);
  }


  // UnitHydrographWeightTriangularComplexType
  // 

  const UnitHydrographWeightTriangularComplexType::NStepsType& UnitHydrographWeightTriangularComplexType::
  getNSteps () const
  {
    return this->nSteps_.get ();
  }

  UnitHydrographWeightTriangularComplexType::NStepsType& UnitHydrographWeightTriangularComplexType::
  getNSteps ()
  {
    return this->nSteps_.get ();
  }

  void UnitHydrographWeightTriangularComplexType::
  setNSteps (const NStepsType& x)
  {
    this->nSteps_.set (x);
  }

  void UnitHydrographWeightTriangularComplexType::
  setNSteps (::std::auto_ptr< NStepsType > x)
  {
    this->nSteps_.set (x);
  }

  const UnitHydrographWeightTriangularComplexType::FactorOptional& UnitHydrographWeightTriangularComplexType::
  getFactor () const
  {
    return this->factor_;
  }

  UnitHydrographWeightTriangularComplexType::FactorOptional& UnitHydrographWeightTriangularComplexType::
  getFactor ()
  {
    return this->factor_;
  }

  void UnitHydrographWeightTriangularComplexType::
  setFactor (const FactorType& x)
  {
    this->factor_.set (x);
  }

  void UnitHydrographWeightTriangularComplexType::
  setFactor (const FactorOptional& x)
  {
    this->factor_ = x;
  }

  UnitHydrographWeightTriangularComplexType::FactorType UnitHydrographWeightTriangularComplexType::
  getFactorDefaultValue ()
  {
    return FactorType (1.0);
  }


  // UnitHydrographWeightCustomComplexType
  // 

  const UnitHydrographWeightCustomComplexType::WeightSequence& UnitHydrographWeightCustomComplexType::
  getWeight () const
  {
    return this->weight_;
  }

  UnitHydrographWeightCustomComplexType::WeightSequence& UnitHydrographWeightCustomComplexType::
  getWeight ()
  {
    return this->weight_;
  }

  void UnitHydrographWeightCustomComplexType::
  setWeight (const WeightSequence& s)
  {
    this->weight_ = s;
  }


  // UnitHydrographInputComplexType
  // 

  const UnitHydrographInputComplexType::XType& UnitHydrographInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  UnitHydrographInputComplexType::XType& UnitHydrographInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void UnitHydrographInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void UnitHydrographInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // UnitHydrographOutputComplexType
  // 

  const UnitHydrographOutputComplexType::XDelaySequence& UnitHydrographOutputComplexType::
  getXDelay () const
  {
    return this->xDelay_;
  }

  UnitHydrographOutputComplexType::XDelaySequence& UnitHydrographOutputComplexType::
  getXDelay ()
  {
    return this->xDelay_;
  }

  void UnitHydrographOutputComplexType::
  setXDelay (const XDelaySequence& s)
  {
    this->xDelay_ = s;
  }

  const UnitHydrographOutputComplexType::XDelayVectorOptional& UnitHydrographOutputComplexType::
  getXDelayVector () const
  {
    return this->xDelayVector_;
  }

  UnitHydrographOutputComplexType::XDelayVectorOptional& UnitHydrographOutputComplexType::
  getXDelayVector ()
  {
    return this->xDelayVector_;
  }

  void UnitHydrographOutputComplexType::
  setXDelayVector (const XDelayVectorType& x)
  {
    this->xDelayVector_.set (x);
  }

  void UnitHydrographOutputComplexType::
  setXDelayVector (const XDelayVectorOptional& x)
  {
    this->xDelayVector_ = x;
  }

  void UnitHydrographOutputComplexType::
  setXDelayVector (::std::auto_ptr< XDelayVectorType > x)
  {
    this->xDelayVector_.set (x);
  }

  const UnitHydrographOutputComplexType::YType& UnitHydrographOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  UnitHydrographOutputComplexType::YType& UnitHydrographOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void UnitHydrographOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void UnitHydrographOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // ReservoirCompactComplexType
  // 

  const ReservoirCompactComplexType::UnitsOptional& ReservoirCompactComplexType::
  getUnits () const
  {
    return this->units_;
  }

  ReservoirCompactComplexType::UnitsOptional& ReservoirCompactComplexType::
  getUnits ()
  {
    return this->units_;
  }

  void ReservoirCompactComplexType::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void ReservoirCompactComplexType::
  setUnits (const UnitsOptional& x)
  {
    this->units_ = x;
  }

  void ReservoirCompactComplexType::
  setUnits (::std::auto_ptr< UnitsType > x)
  {
    this->units_.set (x);
  }

  const ReservoirCompactComplexType::UnitsType& ReservoirCompactComplexType::
  getUnitsDefaultValue ()
  {
    return units_default_value_;
  }

  const ReservoirCompactComplexType::LevelStorageTableOptional& ReservoirCompactComplexType::
  getLevelStorageTable () const
  {
    return this->levelStorageTable_;
  }

  ReservoirCompactComplexType::LevelStorageTableOptional& ReservoirCompactComplexType::
  getLevelStorageTable ()
  {
    return this->levelStorageTable_;
  }

  void ReservoirCompactComplexType::
  setLevelStorageTable (const LevelStorageTableType& x)
  {
    this->levelStorageTable_.set (x);
  }

  void ReservoirCompactComplexType::
  setLevelStorageTable (const LevelStorageTableOptional& x)
  {
    this->levelStorageTable_ = x;
  }

  void ReservoirCompactComplexType::
  setLevelStorageTable (::std::auto_ptr< LevelStorageTableType > x)
  {
    this->levelStorageTable_.set (x);
  }

  const ReservoirCompactComplexType::LevelStorageTableExternalOptional& ReservoirCompactComplexType::
  getLevelStorageTableExternal () const
  {
    return this->levelStorageTableExternal_;
  }

  ReservoirCompactComplexType::LevelStorageTableExternalOptional& ReservoirCompactComplexType::
  getLevelStorageTableExternal ()
  {
    return this->levelStorageTableExternal_;
  }

  void ReservoirCompactComplexType::
  setLevelStorageTableExternal (const LevelStorageTableExternalType& x)
  {
    this->levelStorageTableExternal_.set (x);
  }

  void ReservoirCompactComplexType::
  setLevelStorageTableExternal (const LevelStorageTableExternalOptional& x)
  {
    this->levelStorageTableExternal_ = x;
  }

  void ReservoirCompactComplexType::
  setLevelStorageTableExternal (::std::auto_ptr< LevelStorageTableExternalType > x)
  {
    this->levelStorageTableExternal_.set (x);
  }

  const ReservoirCompactComplexType::LevelStorageEquationOptional& ReservoirCompactComplexType::
  getLevelStorageEquation () const
  {
    return this->levelStorageEquation_;
  }

  ReservoirCompactComplexType::LevelStorageEquationOptional& ReservoirCompactComplexType::
  getLevelStorageEquation ()
  {
    return this->levelStorageEquation_;
  }

  void ReservoirCompactComplexType::
  setLevelStorageEquation (const LevelStorageEquationType& x)
  {
    this->levelStorageEquation_.set (x);
  }

  void ReservoirCompactComplexType::
  setLevelStorageEquation (const LevelStorageEquationOptional& x)
  {
    this->levelStorageEquation_ = x;
  }

  void ReservoirCompactComplexType::
  setLevelStorageEquation (::std::auto_ptr< LevelStorageEquationType > x)
  {
    this->levelStorageEquation_.set (x);
  }

  const ReservoirCompactComplexType::TailwaterTableOptional& ReservoirCompactComplexType::
  getTailwaterTable () const
  {
    return this->tailwaterTable_;
  }

  ReservoirCompactComplexType::TailwaterTableOptional& ReservoirCompactComplexType::
  getTailwaterTable ()
  {
    return this->tailwaterTable_;
  }

  void ReservoirCompactComplexType::
  setTailwaterTable (const TailwaterTableType& x)
  {
    this->tailwaterTable_.set (x);
  }

  void ReservoirCompactComplexType::
  setTailwaterTable (const TailwaterTableOptional& x)
  {
    this->tailwaterTable_ = x;
  }

  void ReservoirCompactComplexType::
  setTailwaterTable (::std::auto_ptr< TailwaterTableType > x)
  {
    this->tailwaterTable_.set (x);
  }

  const ReservoirCompactComplexType::TailwaterEquationOptional& ReservoirCompactComplexType::
  getTailwaterEquation () const
  {
    return this->tailwaterEquation_;
  }

  ReservoirCompactComplexType::TailwaterEquationOptional& ReservoirCompactComplexType::
  getTailwaterEquation ()
  {
    return this->tailwaterEquation_;
  }

  void ReservoirCompactComplexType::
  setTailwaterEquation (const TailwaterEquationType& x)
  {
    this->tailwaterEquation_.set (x);
  }

  void ReservoirCompactComplexType::
  setTailwaterEquation (const TailwaterEquationOptional& x)
  {
    this->tailwaterEquation_ = x;
  }

  void ReservoirCompactComplexType::
  setTailwaterEquation (::std::auto_ptr< TailwaterEquationType > x)
  {
    this->tailwaterEquation_.set (x);
  }

  const ReservoirCompactComplexType::TailwaterTidalEquationOptional& ReservoirCompactComplexType::
  getTailwaterTidalEquation () const
  {
    return this->tailwaterTidalEquation_;
  }

  ReservoirCompactComplexType::TailwaterTidalEquationOptional& ReservoirCompactComplexType::
  getTailwaterTidalEquation ()
  {
    return this->tailwaterTidalEquation_;
  }

  void ReservoirCompactComplexType::
  setTailwaterTidalEquation (const TailwaterTidalEquationType& x)
  {
    this->tailwaterTidalEquation_.set (x);
  }

  void ReservoirCompactComplexType::
  setTailwaterTidalEquation (const TailwaterTidalEquationOptional& x)
  {
    this->tailwaterTidalEquation_ = x;
  }

  void ReservoirCompactComplexType::
  setTailwaterTidalEquation (::std::auto_ptr< TailwaterTidalEquationType > x)
  {
    this->tailwaterTidalEquation_.set (x);
  }

  const ReservoirCompactComplexType::TailwaterExternalTableOptional& ReservoirCompactComplexType::
  getTailwaterExternalTable () const
  {
    return this->tailwaterExternalTable_;
  }

  ReservoirCompactComplexType::TailwaterExternalTableOptional& ReservoirCompactComplexType::
  getTailwaterExternalTable ()
  {
    return this->tailwaterExternalTable_;
  }

  void ReservoirCompactComplexType::
  setTailwaterExternalTable (const TailwaterExternalTableType& x)
  {
    this->tailwaterExternalTable_.set (x);
  }

  void ReservoirCompactComplexType::
  setTailwaterExternalTable (const TailwaterExternalTableOptional& x)
  {
    this->tailwaterExternalTable_ = x;
  }

  void ReservoirCompactComplexType::
  setTailwaterExternalTable (::std::auto_ptr< TailwaterExternalTableType > x)
  {
    this->tailwaterExternalTable_.set (x);
  }

  const ReservoirCompactComplexType::TailwaterExternalTimeSeriesOptional& ReservoirCompactComplexType::
  getTailwaterExternalTimeSeries () const
  {
    return this->tailwaterExternalTimeSeries_;
  }

  ReservoirCompactComplexType::TailwaterExternalTimeSeriesOptional& ReservoirCompactComplexType::
  getTailwaterExternalTimeSeries ()
  {
    return this->tailwaterExternalTimeSeries_;
  }

  void ReservoirCompactComplexType::
  setTailwaterExternalTimeSeries (const TailwaterExternalTimeSeriesType& x)
  {
    this->tailwaterExternalTimeSeries_.set (x);
  }

  void ReservoirCompactComplexType::
  setTailwaterExternalTimeSeries (const TailwaterExternalTimeSeriesOptional& x)
  {
    this->tailwaterExternalTimeSeries_ = x;
  }

  void ReservoirCompactComplexType::
  setTailwaterExternalTimeSeries (::std::auto_ptr< TailwaterExternalTimeSeriesType > x)
  {
    this->tailwaterExternalTimeSeries_.set (x);
  }

  const ReservoirCompactComplexType::TailwaterConstantOptional& ReservoirCompactComplexType::
  getTailwaterConstant () const
  {
    return this->tailwaterConstant_;
  }

  ReservoirCompactComplexType::TailwaterConstantOptional& ReservoirCompactComplexType::
  getTailwaterConstant ()
  {
    return this->tailwaterConstant_;
  }

  void ReservoirCompactComplexType::
  setTailwaterConstant (const TailwaterConstantType& x)
  {
    this->tailwaterConstant_.set (x);
  }

  void ReservoirCompactComplexType::
  setTailwaterConstant (const TailwaterConstantOptional& x)
  {
    this->tailwaterConstant_ = x;
  }

  void ReservoirCompactComplexType::
  setTailwaterConstant (::std::auto_ptr< TailwaterConstantType > x)
  {
    this->tailwaterConstant_.set (x);
  }

  const ReservoirCompactComplexType::TurbineEfficiencyConstantOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyConstant () const
  {
    return this->turbineEfficiencyConstant_;
  }

  ReservoirCompactComplexType::TurbineEfficiencyConstantOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyConstant ()
  {
    return this->turbineEfficiencyConstant_;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyConstant (const TurbineEfficiencyConstantType& x)
  {
    this->turbineEfficiencyConstant_.set (x);
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyConstant (const TurbineEfficiencyConstantOptional& x)
  {
    this->turbineEfficiencyConstant_ = x;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyConstant (::std::auto_ptr< TurbineEfficiencyConstantType > x)
  {
    this->turbineEfficiencyConstant_.set (x);
  }

  const ReservoirCompactComplexType::TurbineEfficiencyConstantType& ReservoirCompactComplexType::
  getTurbineEfficiencyConstantDefaultValue ()
  {
    return turbineEfficiencyConstant_default_value_;
  }

  const ReservoirCompactComplexType::TurbineEfficiencyTableOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTable () const
  {
    return this->turbineEfficiencyTable_;
  }

  ReservoirCompactComplexType::TurbineEfficiencyTableOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTable ()
  {
    return this->turbineEfficiencyTable_;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable (const TurbineEfficiencyTableType& x)
  {
    this->turbineEfficiencyTable_.set (x);
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable (const TurbineEfficiencyTableOptional& x)
  {
    this->turbineEfficiencyTable_ = x;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable (::std::auto_ptr< TurbineEfficiencyTableType > x)
  {
    this->turbineEfficiencyTable_.set (x);
  }

  const ReservoirCompactComplexType::TurbineEfficiencyTableExternalOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTableExternal () const
  {
    return this->turbineEfficiencyTableExternal_;
  }

  ReservoirCompactComplexType::TurbineEfficiencyTableExternalOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTableExternal ()
  {
    return this->turbineEfficiencyTableExternal_;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTableExternal (const TurbineEfficiencyTableExternalType& x)
  {
    this->turbineEfficiencyTableExternal_.set (x);
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTableExternal (const TurbineEfficiencyTableExternalOptional& x)
  {
    this->turbineEfficiencyTableExternal_ = x;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTableExternal (::std::auto_ptr< TurbineEfficiencyTableExternalType > x)
  {
    this->turbineEfficiencyTableExternal_.set (x);
  }

  const ReservoirCompactComplexType::TurbineEfficiencyTable2DOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTable2D () const
  {
    return this->turbineEfficiencyTable2D_;
  }

  ReservoirCompactComplexType::TurbineEfficiencyTable2DOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTable2D ()
  {
    return this->turbineEfficiencyTable2D_;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable2D (const TurbineEfficiencyTable2DType& x)
  {
    this->turbineEfficiencyTable2D_.set (x);
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable2D (const TurbineEfficiencyTable2DOptional& x)
  {
    this->turbineEfficiencyTable2D_ = x;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable2D (::std::auto_ptr< TurbineEfficiencyTable2DType > x)
  {
    this->turbineEfficiencyTable2D_.set (x);
  }

  const ReservoirCompactComplexType::TurbineEfficiencyTable2DExternalOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTable2DExternal () const
  {
    return this->turbineEfficiencyTable2DExternal_;
  }

  ReservoirCompactComplexType::TurbineEfficiencyTable2DExternalOptional& ReservoirCompactComplexType::
  getTurbineEfficiencyTable2DExternal ()
  {
    return this->turbineEfficiencyTable2DExternal_;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable2DExternal (const TurbineEfficiencyTable2DExternalType& x)
  {
    this->turbineEfficiencyTable2DExternal_.set (x);
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable2DExternal (const TurbineEfficiencyTable2DExternalOptional& x)
  {
    this->turbineEfficiencyTable2DExternal_ = x;
  }

  void ReservoirCompactComplexType::
  setTurbineEfficiencyTable2DExternal (::std::auto_ptr< TurbineEfficiencyTable2DExternalType > x)
  {
    this->turbineEfficiencyTable2DExternal_.set (x);
  }

  const ReservoirCompactComplexType::InputType& ReservoirCompactComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ReservoirCompactComplexType::InputType& ReservoirCompactComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ReservoirCompactComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ReservoirCompactComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ReservoirCompactComplexType::OutputType& ReservoirCompactComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ReservoirCompactComplexType::OutputType& ReservoirCompactComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ReservoirCompactComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ReservoirCompactComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ReservoirCompactComplexType::IdType& ReservoirCompactComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ReservoirCompactComplexType::IdType& ReservoirCompactComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ReservoirCompactComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ReservoirCompactComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ReservoirCompactComplexType::NameOptional& ReservoirCompactComplexType::
  getName () const
  {
    return this->name_;
  }

  ReservoirCompactComplexType::NameOptional& ReservoirCompactComplexType::
  getName ()
  {
    return this->name_;
  }

  void ReservoirCompactComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ReservoirCompactComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ReservoirCompactComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // LevelStorageEquationComplexType
  // 

  const LevelStorageEquationComplexType::A0Type& LevelStorageEquationComplexType::
  getA0 () const
  {
    return this->A0_.get ();
  }

  LevelStorageEquationComplexType::A0Type& LevelStorageEquationComplexType::
  getA0 ()
  {
    return this->A0_.get ();
  }

  void LevelStorageEquationComplexType::
  setA0 (const A0Type& x)
  {
    this->A0_.set (x);
  }

  const LevelStorageEquationComplexType::A1Type& LevelStorageEquationComplexType::
  getA1 () const
  {
    return this->A1_.get ();
  }

  LevelStorageEquationComplexType::A1Type& LevelStorageEquationComplexType::
  getA1 ()
  {
    return this->A1_.get ();
  }

  void LevelStorageEquationComplexType::
  setA1 (const A1Type& x)
  {
    this->A1_.set (x);
  }

  const LevelStorageEquationComplexType::A2Optional& LevelStorageEquationComplexType::
  getA2 () const
  {
    return this->A2_;
  }

  LevelStorageEquationComplexType::A2Optional& LevelStorageEquationComplexType::
  getA2 ()
  {
    return this->A2_;
  }

  void LevelStorageEquationComplexType::
  setA2 (const A2Type& x)
  {
    this->A2_.set (x);
  }

  void LevelStorageEquationComplexType::
  setA2 (const A2Optional& x)
  {
    this->A2_ = x;
  }

  LevelStorageEquationComplexType::A2Type LevelStorageEquationComplexType::
  getA2DefaultValue ()
  {
    return A2Type (.0);
  }

  const LevelStorageEquationComplexType::A3Optional& LevelStorageEquationComplexType::
  getA3 () const
  {
    return this->A3_;
  }

  LevelStorageEquationComplexType::A3Optional& LevelStorageEquationComplexType::
  getA3 ()
  {
    return this->A3_;
  }

  void LevelStorageEquationComplexType::
  setA3 (const A3Type& x)
  {
    this->A3_.set (x);
  }

  void LevelStorageEquationComplexType::
  setA3 (const A3Optional& x)
  {
    this->A3_ = x;
  }

  LevelStorageEquationComplexType::A3Type LevelStorageEquationComplexType::
  getA3DefaultValue ()
  {
    return A3Type (.0);
  }

  const LevelStorageEquationComplexType::A4Optional& LevelStorageEquationComplexType::
  getA4 () const
  {
    return this->A4_;
  }

  LevelStorageEquationComplexType::A4Optional& LevelStorageEquationComplexType::
  getA4 ()
  {
    return this->A4_;
  }

  void LevelStorageEquationComplexType::
  setA4 (const A4Type& x)
  {
    this->A4_.set (x);
  }

  void LevelStorageEquationComplexType::
  setA4 (const A4Optional& x)
  {
    this->A4_ = x;
  }

  LevelStorageEquationComplexType::A4Type LevelStorageEquationComplexType::
  getA4DefaultValue ()
  {
    return A4Type (.0);
  }


  // TailwaterEquationComplexType
  // 

  const TailwaterEquationComplexType::AType& TailwaterEquationComplexType::
  getA () const
  {
    return this->A_.get ();
  }

  TailwaterEquationComplexType::AType& TailwaterEquationComplexType::
  getA ()
  {
    return this->A_.get ();
  }

  void TailwaterEquationComplexType::
  setA (const AType& x)
  {
    this->A_.set (x);
  }

  void TailwaterEquationComplexType::
  setA (::std::auto_ptr< AType > x)
  {
    this->A_.set (x);
  }

  const TailwaterEquationComplexType::BType& TailwaterEquationComplexType::
  getB () const
  {
    return this->B_.get ();
  }

  TailwaterEquationComplexType::BType& TailwaterEquationComplexType::
  getB ()
  {
    return this->B_.get ();
  }

  void TailwaterEquationComplexType::
  setB (const BType& x)
  {
    this->B_.set (x);
  }

  void TailwaterEquationComplexType::
  setB (::std::auto_ptr< BType > x)
  {
    this->B_.set (x);
  }

  const TailwaterEquationComplexType::CType& TailwaterEquationComplexType::
  getC () const
  {
    return this->C_.get ();
  }

  TailwaterEquationComplexType::CType& TailwaterEquationComplexType::
  getC ()
  {
    return this->C_.get ();
  }

  void TailwaterEquationComplexType::
  setC (const CType& x)
  {
    this->C_.set (x);
  }

  void TailwaterEquationComplexType::
  setC (::std::auto_ptr< CType > x)
  {
    this->C_.set (x);
  }

  const TailwaterEquationComplexType::DOptional& TailwaterEquationComplexType::
  getD () const
  {
    return this->D_;
  }

  TailwaterEquationComplexType::DOptional& TailwaterEquationComplexType::
  getD ()
  {
    return this->D_;
  }

  void TailwaterEquationComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void TailwaterEquationComplexType::
  setD (const DOptional& x)
  {
    this->D_ = x;
  }

  void TailwaterEquationComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }

  const TailwaterEquationComplexType::DType& TailwaterEquationComplexType::
  getDDefaultValue ()
  {
    return D_default_value_;
  }

  const TailwaterEquationComplexType::FBDownOptional& TailwaterEquationComplexType::
  getFBDown () const
  {
    return this->FBDown_;
  }

  TailwaterEquationComplexType::FBDownOptional& TailwaterEquationComplexType::
  getFBDown ()
  {
    return this->FBDown_;
  }

  void TailwaterEquationComplexType::
  setFBDown (const FBDownType& x)
  {
    this->FBDown_.set (x);
  }

  void TailwaterEquationComplexType::
  setFBDown (const FBDownOptional& x)
  {
    this->FBDown_ = x;
  }

  void TailwaterEquationComplexType::
  setFBDown (::std::auto_ptr< FBDownType > x)
  {
    this->FBDown_.set (x);
  }


  // TailwaterTidalEquationComplexType
  // 

  const TailwaterTidalEquationComplexType::AType& TailwaterTidalEquationComplexType::
  getA () const
  {
    return this->A_.get ();
  }

  TailwaterTidalEquationComplexType::AType& TailwaterTidalEquationComplexType::
  getA ()
  {
    return this->A_.get ();
  }

  void TailwaterTidalEquationComplexType::
  setA (const AType& x)
  {
    this->A_.set (x);
  }

  void TailwaterTidalEquationComplexType::
  setA (::std::auto_ptr< AType > x)
  {
    this->A_.set (x);
  }

  const TailwaterTidalEquationComplexType::TWObsType& TailwaterTidalEquationComplexType::
  getTWObs () const
  {
    return this->TWObs_.get ();
  }

  TailwaterTidalEquationComplexType::TWObsType& TailwaterTidalEquationComplexType::
  getTWObs ()
  {
    return this->TWObs_.get ();
  }

  void TailwaterTidalEquationComplexType::
  setTWObs (const TWObsType& x)
  {
    this->TWObs_.set (x);
  }

  void TailwaterTidalEquationComplexType::
  setTWObs (::std::auto_ptr< TWObsType > x)
  {
    this->TWObs_.set (x);
  }

  const TailwaterTidalEquationComplexType::QObsType& TailwaterTidalEquationComplexType::
  getQObs () const
  {
    return this->QObs_.get ();
  }

  TailwaterTidalEquationComplexType::QObsType& TailwaterTidalEquationComplexType::
  getQObs ()
  {
    return this->QObs_.get ();
  }

  void TailwaterTidalEquationComplexType::
  setQObs (const QObsType& x)
  {
    this->QObs_.set (x);
  }

  void TailwaterTidalEquationComplexType::
  setQObs (::std::auto_ptr< QObsType > x)
  {
    this->QObs_.set (x);
  }


  // TurbineEfficiencyTableComplexType
  // 

  const TurbineEfficiencyTableComplexType::ColumnsType& TurbineEfficiencyTableComplexType::
  getColumns () const
  {
    return this->columns_.get ();
  }

  TurbineEfficiencyTableComplexType::ColumnsType& TurbineEfficiencyTableComplexType::
  getColumns ()
  {
    return this->columns_.get ();
  }

  void TurbineEfficiencyTableComplexType::
  setColumns (const ColumnsType& x)
  {
    this->columns_.set (x);
  }

  void TurbineEfficiencyTableComplexType::
  setColumns (::std::auto_ptr< ColumnsType > x)
  {
    this->columns_.set (x);
  }

  const TurbineEfficiencyTableComplexType::RowSequence& TurbineEfficiencyTableComplexType::
  getRow () const
  {
    return this->row_;
  }

  TurbineEfficiencyTableComplexType::RowSequence& TurbineEfficiencyTableComplexType::
  getRow ()
  {
    return this->row_;
  }

  void TurbineEfficiencyTableComplexType::
  setRow (const RowSequence& s)
  {
    this->row_ = s;
  }

  const TurbineEfficiencyTableComplexType::MaxFlowsType& TurbineEfficiencyTableComplexType::
  getMaxFlows () const
  {
    return this->maxFlows_.get ();
  }

  TurbineEfficiencyTableComplexType::MaxFlowsType& TurbineEfficiencyTableComplexType::
  getMaxFlows ()
  {
    return this->maxFlows_.get ();
  }

  void TurbineEfficiencyTableComplexType::
  setMaxFlows (const MaxFlowsType& x)
  {
    this->maxFlows_.set (x);
  }

  void TurbineEfficiencyTableComplexType::
  setMaxFlows (::std::auto_ptr< MaxFlowsType > x)
  {
    this->maxFlows_.set (x);
  }


  // ColumnsComplexType
  // 

  const ColumnsComplexType::Head01Type& ColumnsComplexType::
  getHead01 () const
  {
    return this->head01_.get ();
  }

  ColumnsComplexType::Head01Type& ColumnsComplexType::
  getHead01 ()
  {
    return this->head01_.get ();
  }

  void ColumnsComplexType::
  setHead01 (const Head01Type& x)
  {
    this->head01_.set (x);
  }

  const ColumnsComplexType::Head02Type& ColumnsComplexType::
  getHead02 () const
  {
    return this->head02_.get ();
  }

  ColumnsComplexType::Head02Type& ColumnsComplexType::
  getHead02 ()
  {
    return this->head02_.get ();
  }

  void ColumnsComplexType::
  setHead02 (const Head02Type& x)
  {
    this->head02_.set (x);
  }

  const ColumnsComplexType::Head03Optional& ColumnsComplexType::
  getHead03 () const
  {
    return this->head03_;
  }

  ColumnsComplexType::Head03Optional& ColumnsComplexType::
  getHead03 ()
  {
    return this->head03_;
  }

  void ColumnsComplexType::
  setHead03 (const Head03Type& x)
  {
    this->head03_.set (x);
  }

  void ColumnsComplexType::
  setHead03 (const Head03Optional& x)
  {
    this->head03_ = x;
  }

  const ColumnsComplexType::Head04Optional& ColumnsComplexType::
  getHead04 () const
  {
    return this->head04_;
  }

  ColumnsComplexType::Head04Optional& ColumnsComplexType::
  getHead04 ()
  {
    return this->head04_;
  }

  void ColumnsComplexType::
  setHead04 (const Head04Type& x)
  {
    this->head04_.set (x);
  }

  void ColumnsComplexType::
  setHead04 (const Head04Optional& x)
  {
    this->head04_ = x;
  }

  const ColumnsComplexType::Head05Optional& ColumnsComplexType::
  getHead05 () const
  {
    return this->head05_;
  }

  ColumnsComplexType::Head05Optional& ColumnsComplexType::
  getHead05 ()
  {
    return this->head05_;
  }

  void ColumnsComplexType::
  setHead05 (const Head05Type& x)
  {
    this->head05_.set (x);
  }

  void ColumnsComplexType::
  setHead05 (const Head05Optional& x)
  {
    this->head05_ = x;
  }

  const ColumnsComplexType::Head06Optional& ColumnsComplexType::
  getHead06 () const
  {
    return this->head06_;
  }

  ColumnsComplexType::Head06Optional& ColumnsComplexType::
  getHead06 ()
  {
    return this->head06_;
  }

  void ColumnsComplexType::
  setHead06 (const Head06Type& x)
  {
    this->head06_.set (x);
  }

  void ColumnsComplexType::
  setHead06 (const Head06Optional& x)
  {
    this->head06_ = x;
  }

  const ColumnsComplexType::Head07Optional& ColumnsComplexType::
  getHead07 () const
  {
    return this->head07_;
  }

  ColumnsComplexType::Head07Optional& ColumnsComplexType::
  getHead07 ()
  {
    return this->head07_;
  }

  void ColumnsComplexType::
  setHead07 (const Head07Type& x)
  {
    this->head07_.set (x);
  }

  void ColumnsComplexType::
  setHead07 (const Head07Optional& x)
  {
    this->head07_ = x;
  }

  const ColumnsComplexType::Head08Optional& ColumnsComplexType::
  getHead08 () const
  {
    return this->head08_;
  }

  ColumnsComplexType::Head08Optional& ColumnsComplexType::
  getHead08 ()
  {
    return this->head08_;
  }

  void ColumnsComplexType::
  setHead08 (const Head08Type& x)
  {
    this->head08_.set (x);
  }

  void ColumnsComplexType::
  setHead08 (const Head08Optional& x)
  {
    this->head08_ = x;
  }

  const ColumnsComplexType::Head09Optional& ColumnsComplexType::
  getHead09 () const
  {
    return this->head09_;
  }

  ColumnsComplexType::Head09Optional& ColumnsComplexType::
  getHead09 ()
  {
    return this->head09_;
  }

  void ColumnsComplexType::
  setHead09 (const Head09Type& x)
  {
    this->head09_.set (x);
  }

  void ColumnsComplexType::
  setHead09 (const Head09Optional& x)
  {
    this->head09_ = x;
  }

  const ColumnsComplexType::Head10Optional& ColumnsComplexType::
  getHead10 () const
  {
    return this->head10_;
  }

  ColumnsComplexType::Head10Optional& ColumnsComplexType::
  getHead10 ()
  {
    return this->head10_;
  }

  void ColumnsComplexType::
  setHead10 (const Head10Type& x)
  {
    this->head10_.set (x);
  }

  void ColumnsComplexType::
  setHead10 (const Head10Optional& x)
  {
    this->head10_ = x;
  }

  const ColumnsComplexType::Head11Optional& ColumnsComplexType::
  getHead11 () const
  {
    return this->head11_;
  }

  ColumnsComplexType::Head11Optional& ColumnsComplexType::
  getHead11 ()
  {
    return this->head11_;
  }

  void ColumnsComplexType::
  setHead11 (const Head11Type& x)
  {
    this->head11_.set (x);
  }

  void ColumnsComplexType::
  setHead11 (const Head11Optional& x)
  {
    this->head11_ = x;
  }

  const ColumnsComplexType::Head12Optional& ColumnsComplexType::
  getHead12 () const
  {
    return this->head12_;
  }

  ColumnsComplexType::Head12Optional& ColumnsComplexType::
  getHead12 ()
  {
    return this->head12_;
  }

  void ColumnsComplexType::
  setHead12 (const Head12Type& x)
  {
    this->head12_.set (x);
  }

  void ColumnsComplexType::
  setHead12 (const Head12Optional& x)
  {
    this->head12_ = x;
  }

  const ColumnsComplexType::Head13Optional& ColumnsComplexType::
  getHead13 () const
  {
    return this->head13_;
  }

  ColumnsComplexType::Head13Optional& ColumnsComplexType::
  getHead13 ()
  {
    return this->head13_;
  }

  void ColumnsComplexType::
  setHead13 (const Head13Type& x)
  {
    this->head13_.set (x);
  }

  void ColumnsComplexType::
  setHead13 (const Head13Optional& x)
  {
    this->head13_ = x;
  }

  const ColumnsComplexType::Head14Optional& ColumnsComplexType::
  getHead14 () const
  {
    return this->head14_;
  }

  ColumnsComplexType::Head14Optional& ColumnsComplexType::
  getHead14 ()
  {
    return this->head14_;
  }

  void ColumnsComplexType::
  setHead14 (const Head14Type& x)
  {
    this->head14_.set (x);
  }

  void ColumnsComplexType::
  setHead14 (const Head14Optional& x)
  {
    this->head14_ = x;
  }

  const ColumnsComplexType::Head15Optional& ColumnsComplexType::
  getHead15 () const
  {
    return this->head15_;
  }

  ColumnsComplexType::Head15Optional& ColumnsComplexType::
  getHead15 ()
  {
    return this->head15_;
  }

  void ColumnsComplexType::
  setHead15 (const Head15Type& x)
  {
    this->head15_.set (x);
  }

  void ColumnsComplexType::
  setHead15 (const Head15Optional& x)
  {
    this->head15_ = x;
  }

  const ColumnsComplexType::Head16Optional& ColumnsComplexType::
  getHead16 () const
  {
    return this->head16_;
  }

  ColumnsComplexType::Head16Optional& ColumnsComplexType::
  getHead16 ()
  {
    return this->head16_;
  }

  void ColumnsComplexType::
  setHead16 (const Head16Type& x)
  {
    this->head16_.set (x);
  }

  void ColumnsComplexType::
  setHead16 (const Head16Optional& x)
  {
    this->head16_ = x;
  }

  const ColumnsComplexType::Head17Optional& ColumnsComplexType::
  getHead17 () const
  {
    return this->head17_;
  }

  ColumnsComplexType::Head17Optional& ColumnsComplexType::
  getHead17 ()
  {
    return this->head17_;
  }

  void ColumnsComplexType::
  setHead17 (const Head17Type& x)
  {
    this->head17_.set (x);
  }

  void ColumnsComplexType::
  setHead17 (const Head17Optional& x)
  {
    this->head17_ = x;
  }

  const ColumnsComplexType::Head18Optional& ColumnsComplexType::
  getHead18 () const
  {
    return this->head18_;
  }

  ColumnsComplexType::Head18Optional& ColumnsComplexType::
  getHead18 ()
  {
    return this->head18_;
  }

  void ColumnsComplexType::
  setHead18 (const Head18Type& x)
  {
    this->head18_.set (x);
  }

  void ColumnsComplexType::
  setHead18 (const Head18Optional& x)
  {
    this->head18_ = x;
  }

  const ColumnsComplexType::Head19Optional& ColumnsComplexType::
  getHead19 () const
  {
    return this->head19_;
  }

  ColumnsComplexType::Head19Optional& ColumnsComplexType::
  getHead19 ()
  {
    return this->head19_;
  }

  void ColumnsComplexType::
  setHead19 (const Head19Type& x)
  {
    this->head19_.set (x);
  }

  void ColumnsComplexType::
  setHead19 (const Head19Optional& x)
  {
    this->head19_ = x;
  }

  const ColumnsComplexType::Head20Optional& ColumnsComplexType::
  getHead20 () const
  {
    return this->head20_;
  }

  ColumnsComplexType::Head20Optional& ColumnsComplexType::
  getHead20 ()
  {
    return this->head20_;
  }

  void ColumnsComplexType::
  setHead20 (const Head20Type& x)
  {
    this->head20_.set (x);
  }

  void ColumnsComplexType::
  setHead20 (const Head20Optional& x)
  {
    this->head20_ = x;
  }


  // RowComplexType
  // 

  const RowComplexType::FlowType& RowComplexType::
  getFlow () const
  {
    return this->flow_.get ();
  }

  RowComplexType::FlowType& RowComplexType::
  getFlow ()
  {
    return this->flow_.get ();
  }

  void RowComplexType::
  setFlow (const FlowType& x)
  {
    this->flow_.set (x);
  }

  const RowComplexType::Eta_head01Type& RowComplexType::
  getEta_head01 () const
  {
    return this->eta_head01_.get ();
  }

  RowComplexType::Eta_head01Type& RowComplexType::
  getEta_head01 ()
  {
    return this->eta_head01_.get ();
  }

  void RowComplexType::
  setEta_head01 (const Eta_head01Type& x)
  {
    this->eta_head01_.set (x);
  }

  const RowComplexType::Eta_head02Type& RowComplexType::
  getEta_head02 () const
  {
    return this->eta_head02_.get ();
  }

  RowComplexType::Eta_head02Type& RowComplexType::
  getEta_head02 ()
  {
    return this->eta_head02_.get ();
  }

  void RowComplexType::
  setEta_head02 (const Eta_head02Type& x)
  {
    this->eta_head02_.set (x);
  }

  const RowComplexType::Eta_head03Optional& RowComplexType::
  getEta_head03 () const
  {
    return this->eta_head03_;
  }

  RowComplexType::Eta_head03Optional& RowComplexType::
  getEta_head03 ()
  {
    return this->eta_head03_;
  }

  void RowComplexType::
  setEta_head03 (const Eta_head03Type& x)
  {
    this->eta_head03_.set (x);
  }

  void RowComplexType::
  setEta_head03 (const Eta_head03Optional& x)
  {
    this->eta_head03_ = x;
  }

  const RowComplexType::Eta_head04Optional& RowComplexType::
  getEta_head04 () const
  {
    return this->eta_head04_;
  }

  RowComplexType::Eta_head04Optional& RowComplexType::
  getEta_head04 ()
  {
    return this->eta_head04_;
  }

  void RowComplexType::
  setEta_head04 (const Eta_head04Type& x)
  {
    this->eta_head04_.set (x);
  }

  void RowComplexType::
  setEta_head04 (const Eta_head04Optional& x)
  {
    this->eta_head04_ = x;
  }

  const RowComplexType::Eta_head05Optional& RowComplexType::
  getEta_head05 () const
  {
    return this->eta_head05_;
  }

  RowComplexType::Eta_head05Optional& RowComplexType::
  getEta_head05 ()
  {
    return this->eta_head05_;
  }

  void RowComplexType::
  setEta_head05 (const Eta_head05Type& x)
  {
    this->eta_head05_.set (x);
  }

  void RowComplexType::
  setEta_head05 (const Eta_head05Optional& x)
  {
    this->eta_head05_ = x;
  }

  const RowComplexType::Eta_head06Optional& RowComplexType::
  getEta_head06 () const
  {
    return this->eta_head06_;
  }

  RowComplexType::Eta_head06Optional& RowComplexType::
  getEta_head06 ()
  {
    return this->eta_head06_;
  }

  void RowComplexType::
  setEta_head06 (const Eta_head06Type& x)
  {
    this->eta_head06_.set (x);
  }

  void RowComplexType::
  setEta_head06 (const Eta_head06Optional& x)
  {
    this->eta_head06_ = x;
  }

  const RowComplexType::Eta_head07Optional& RowComplexType::
  getEta_head07 () const
  {
    return this->eta_head07_;
  }

  RowComplexType::Eta_head07Optional& RowComplexType::
  getEta_head07 ()
  {
    return this->eta_head07_;
  }

  void RowComplexType::
  setEta_head07 (const Eta_head07Type& x)
  {
    this->eta_head07_.set (x);
  }

  void RowComplexType::
  setEta_head07 (const Eta_head07Optional& x)
  {
    this->eta_head07_ = x;
  }

  const RowComplexType::Eta_head08Optional& RowComplexType::
  getEta_head08 () const
  {
    return this->eta_head08_;
  }

  RowComplexType::Eta_head08Optional& RowComplexType::
  getEta_head08 ()
  {
    return this->eta_head08_;
  }

  void RowComplexType::
  setEta_head08 (const Eta_head08Type& x)
  {
    this->eta_head08_.set (x);
  }

  void RowComplexType::
  setEta_head08 (const Eta_head08Optional& x)
  {
    this->eta_head08_ = x;
  }

  const RowComplexType::Eta_head09Optional& RowComplexType::
  getEta_head09 () const
  {
    return this->eta_head09_;
  }

  RowComplexType::Eta_head09Optional& RowComplexType::
  getEta_head09 ()
  {
    return this->eta_head09_;
  }

  void RowComplexType::
  setEta_head09 (const Eta_head09Type& x)
  {
    this->eta_head09_.set (x);
  }

  void RowComplexType::
  setEta_head09 (const Eta_head09Optional& x)
  {
    this->eta_head09_ = x;
  }

  const RowComplexType::Eta_head10Optional& RowComplexType::
  getEta_head10 () const
  {
    return this->eta_head10_;
  }

  RowComplexType::Eta_head10Optional& RowComplexType::
  getEta_head10 ()
  {
    return this->eta_head10_;
  }

  void RowComplexType::
  setEta_head10 (const Eta_head10Type& x)
  {
    this->eta_head10_.set (x);
  }

  void RowComplexType::
  setEta_head10 (const Eta_head10Optional& x)
  {
    this->eta_head10_ = x;
  }

  const RowComplexType::Eta_head11Optional& RowComplexType::
  getEta_head11 () const
  {
    return this->eta_head11_;
  }

  RowComplexType::Eta_head11Optional& RowComplexType::
  getEta_head11 ()
  {
    return this->eta_head11_;
  }

  void RowComplexType::
  setEta_head11 (const Eta_head11Type& x)
  {
    this->eta_head11_.set (x);
  }

  void RowComplexType::
  setEta_head11 (const Eta_head11Optional& x)
  {
    this->eta_head11_ = x;
  }

  const RowComplexType::Eta_head12Optional& RowComplexType::
  getEta_head12 () const
  {
    return this->eta_head12_;
  }

  RowComplexType::Eta_head12Optional& RowComplexType::
  getEta_head12 ()
  {
    return this->eta_head12_;
  }

  void RowComplexType::
  setEta_head12 (const Eta_head12Type& x)
  {
    this->eta_head12_.set (x);
  }

  void RowComplexType::
  setEta_head12 (const Eta_head12Optional& x)
  {
    this->eta_head12_ = x;
  }

  const RowComplexType::Eta_head13Optional& RowComplexType::
  getEta_head13 () const
  {
    return this->eta_head13_;
  }

  RowComplexType::Eta_head13Optional& RowComplexType::
  getEta_head13 ()
  {
    return this->eta_head13_;
  }

  void RowComplexType::
  setEta_head13 (const Eta_head13Type& x)
  {
    this->eta_head13_.set (x);
  }

  void RowComplexType::
  setEta_head13 (const Eta_head13Optional& x)
  {
    this->eta_head13_ = x;
  }

  const RowComplexType::Eta_head14Optional& RowComplexType::
  getEta_head14 () const
  {
    return this->eta_head14_;
  }

  RowComplexType::Eta_head14Optional& RowComplexType::
  getEta_head14 ()
  {
    return this->eta_head14_;
  }

  void RowComplexType::
  setEta_head14 (const Eta_head14Type& x)
  {
    this->eta_head14_.set (x);
  }

  void RowComplexType::
  setEta_head14 (const Eta_head14Optional& x)
  {
    this->eta_head14_ = x;
  }

  const RowComplexType::Eta_head15Optional& RowComplexType::
  getEta_head15 () const
  {
    return this->eta_head15_;
  }

  RowComplexType::Eta_head15Optional& RowComplexType::
  getEta_head15 ()
  {
    return this->eta_head15_;
  }

  void RowComplexType::
  setEta_head15 (const Eta_head15Type& x)
  {
    this->eta_head15_.set (x);
  }

  void RowComplexType::
  setEta_head15 (const Eta_head15Optional& x)
  {
    this->eta_head15_ = x;
  }

  const RowComplexType::Eta_head16Optional& RowComplexType::
  getEta_head16 () const
  {
    return this->eta_head16_;
  }

  RowComplexType::Eta_head16Optional& RowComplexType::
  getEta_head16 ()
  {
    return this->eta_head16_;
  }

  void RowComplexType::
  setEta_head16 (const Eta_head16Type& x)
  {
    this->eta_head16_.set (x);
  }

  void RowComplexType::
  setEta_head16 (const Eta_head16Optional& x)
  {
    this->eta_head16_ = x;
  }

  const RowComplexType::Eta_head17Optional& RowComplexType::
  getEta_head17 () const
  {
    return this->eta_head17_;
  }

  RowComplexType::Eta_head17Optional& RowComplexType::
  getEta_head17 ()
  {
    return this->eta_head17_;
  }

  void RowComplexType::
  setEta_head17 (const Eta_head17Type& x)
  {
    this->eta_head17_.set (x);
  }

  void RowComplexType::
  setEta_head17 (const Eta_head17Optional& x)
  {
    this->eta_head17_ = x;
  }

  const RowComplexType::Eta_head18Optional& RowComplexType::
  getEta_head18 () const
  {
    return this->eta_head18_;
  }

  RowComplexType::Eta_head18Optional& RowComplexType::
  getEta_head18 ()
  {
    return this->eta_head18_;
  }

  void RowComplexType::
  setEta_head18 (const Eta_head18Type& x)
  {
    this->eta_head18_.set (x);
  }

  void RowComplexType::
  setEta_head18 (const Eta_head18Optional& x)
  {
    this->eta_head18_ = x;
  }

  const RowComplexType::Eta_head19Optional& RowComplexType::
  getEta_head19 () const
  {
    return this->eta_head19_;
  }

  RowComplexType::Eta_head19Optional& RowComplexType::
  getEta_head19 ()
  {
    return this->eta_head19_;
  }

  void RowComplexType::
  setEta_head19 (const Eta_head19Type& x)
  {
    this->eta_head19_.set (x);
  }

  void RowComplexType::
  setEta_head19 (const Eta_head19Optional& x)
  {
    this->eta_head19_ = x;
  }

  const RowComplexType::Eta_head20Optional& RowComplexType::
  getEta_head20 () const
  {
    return this->eta_head20_;
  }

  RowComplexType::Eta_head20Optional& RowComplexType::
  getEta_head20 ()
  {
    return this->eta_head20_;
  }

  void RowComplexType::
  setEta_head20 (const Eta_head20Type& x)
  {
    this->eta_head20_.set (x);
  }

  void RowComplexType::
  setEta_head20 (const Eta_head20Optional& x)
  {
    this->eta_head20_ = x;
  }


  // MaxFlowsComplexType
  // 

  const MaxFlowsComplexType::MaxFlow_head01Type& MaxFlowsComplexType::
  getMaxFlow_head01 () const
  {
    return this->maxFlow_head01_.get ();
  }

  MaxFlowsComplexType::MaxFlow_head01Type& MaxFlowsComplexType::
  getMaxFlow_head01 ()
  {
    return this->maxFlow_head01_.get ();
  }

  void MaxFlowsComplexType::
  setMaxFlow_head01 (const MaxFlow_head01Type& x)
  {
    this->maxFlow_head01_.set (x);
  }

  const MaxFlowsComplexType::MaxFlow_head02Type& MaxFlowsComplexType::
  getMaxFlow_head02 () const
  {
    return this->maxFlow_head02_.get ();
  }

  MaxFlowsComplexType::MaxFlow_head02Type& MaxFlowsComplexType::
  getMaxFlow_head02 ()
  {
    return this->maxFlow_head02_.get ();
  }

  void MaxFlowsComplexType::
  setMaxFlow_head02 (const MaxFlow_head02Type& x)
  {
    this->maxFlow_head02_.set (x);
  }

  const MaxFlowsComplexType::MaxFlow_head03Optional& MaxFlowsComplexType::
  getMaxFlow_head03 () const
  {
    return this->maxFlow_head03_;
  }

  MaxFlowsComplexType::MaxFlow_head03Optional& MaxFlowsComplexType::
  getMaxFlow_head03 ()
  {
    return this->maxFlow_head03_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head03 (const MaxFlow_head03Type& x)
  {
    this->maxFlow_head03_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head03 (const MaxFlow_head03Optional& x)
  {
    this->maxFlow_head03_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head04Optional& MaxFlowsComplexType::
  getMaxFlow_head04 () const
  {
    return this->maxFlow_head04_;
  }

  MaxFlowsComplexType::MaxFlow_head04Optional& MaxFlowsComplexType::
  getMaxFlow_head04 ()
  {
    return this->maxFlow_head04_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head04 (const MaxFlow_head04Type& x)
  {
    this->maxFlow_head04_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head04 (const MaxFlow_head04Optional& x)
  {
    this->maxFlow_head04_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head05Optional& MaxFlowsComplexType::
  getMaxFlow_head05 () const
  {
    return this->maxFlow_head05_;
  }

  MaxFlowsComplexType::MaxFlow_head05Optional& MaxFlowsComplexType::
  getMaxFlow_head05 ()
  {
    return this->maxFlow_head05_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head05 (const MaxFlow_head05Type& x)
  {
    this->maxFlow_head05_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head05 (const MaxFlow_head05Optional& x)
  {
    this->maxFlow_head05_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head06Optional& MaxFlowsComplexType::
  getMaxFlow_head06 () const
  {
    return this->maxFlow_head06_;
  }

  MaxFlowsComplexType::MaxFlow_head06Optional& MaxFlowsComplexType::
  getMaxFlow_head06 ()
  {
    return this->maxFlow_head06_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head06 (const MaxFlow_head06Type& x)
  {
    this->maxFlow_head06_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head06 (const MaxFlow_head06Optional& x)
  {
    this->maxFlow_head06_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head07Optional& MaxFlowsComplexType::
  getMaxFlow_head07 () const
  {
    return this->maxFlow_head07_;
  }

  MaxFlowsComplexType::MaxFlow_head07Optional& MaxFlowsComplexType::
  getMaxFlow_head07 ()
  {
    return this->maxFlow_head07_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head07 (const MaxFlow_head07Type& x)
  {
    this->maxFlow_head07_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head07 (const MaxFlow_head07Optional& x)
  {
    this->maxFlow_head07_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head08Optional& MaxFlowsComplexType::
  getMaxFlow_head08 () const
  {
    return this->maxFlow_head08_;
  }

  MaxFlowsComplexType::MaxFlow_head08Optional& MaxFlowsComplexType::
  getMaxFlow_head08 ()
  {
    return this->maxFlow_head08_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head08 (const MaxFlow_head08Type& x)
  {
    this->maxFlow_head08_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head08 (const MaxFlow_head08Optional& x)
  {
    this->maxFlow_head08_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head09Optional& MaxFlowsComplexType::
  getMaxFlow_head09 () const
  {
    return this->maxFlow_head09_;
  }

  MaxFlowsComplexType::MaxFlow_head09Optional& MaxFlowsComplexType::
  getMaxFlow_head09 ()
  {
    return this->maxFlow_head09_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head09 (const MaxFlow_head09Type& x)
  {
    this->maxFlow_head09_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head09 (const MaxFlow_head09Optional& x)
  {
    this->maxFlow_head09_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head10Optional& MaxFlowsComplexType::
  getMaxFlow_head10 () const
  {
    return this->maxFlow_head10_;
  }

  MaxFlowsComplexType::MaxFlow_head10Optional& MaxFlowsComplexType::
  getMaxFlow_head10 ()
  {
    return this->maxFlow_head10_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head10 (const MaxFlow_head10Type& x)
  {
    this->maxFlow_head10_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head10 (const MaxFlow_head10Optional& x)
  {
    this->maxFlow_head10_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head11Optional& MaxFlowsComplexType::
  getMaxFlow_head11 () const
  {
    return this->maxFlow_head11_;
  }

  MaxFlowsComplexType::MaxFlow_head11Optional& MaxFlowsComplexType::
  getMaxFlow_head11 ()
  {
    return this->maxFlow_head11_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head11 (const MaxFlow_head11Type& x)
  {
    this->maxFlow_head11_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head11 (const MaxFlow_head11Optional& x)
  {
    this->maxFlow_head11_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head12Optional& MaxFlowsComplexType::
  getMaxFlow_head12 () const
  {
    return this->maxFlow_head12_;
  }

  MaxFlowsComplexType::MaxFlow_head12Optional& MaxFlowsComplexType::
  getMaxFlow_head12 ()
  {
    return this->maxFlow_head12_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head12 (const MaxFlow_head12Type& x)
  {
    this->maxFlow_head12_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head12 (const MaxFlow_head12Optional& x)
  {
    this->maxFlow_head12_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head13Optional& MaxFlowsComplexType::
  getMaxFlow_head13 () const
  {
    return this->maxFlow_head13_;
  }

  MaxFlowsComplexType::MaxFlow_head13Optional& MaxFlowsComplexType::
  getMaxFlow_head13 ()
  {
    return this->maxFlow_head13_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head13 (const MaxFlow_head13Type& x)
  {
    this->maxFlow_head13_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head13 (const MaxFlow_head13Optional& x)
  {
    this->maxFlow_head13_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head14Optional& MaxFlowsComplexType::
  getMaxFlow_head14 () const
  {
    return this->maxFlow_head14_;
  }

  MaxFlowsComplexType::MaxFlow_head14Optional& MaxFlowsComplexType::
  getMaxFlow_head14 ()
  {
    return this->maxFlow_head14_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head14 (const MaxFlow_head14Type& x)
  {
    this->maxFlow_head14_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head14 (const MaxFlow_head14Optional& x)
  {
    this->maxFlow_head14_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head15Optional& MaxFlowsComplexType::
  getMaxFlow_head15 () const
  {
    return this->maxFlow_head15_;
  }

  MaxFlowsComplexType::MaxFlow_head15Optional& MaxFlowsComplexType::
  getMaxFlow_head15 ()
  {
    return this->maxFlow_head15_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head15 (const MaxFlow_head15Type& x)
  {
    this->maxFlow_head15_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head15 (const MaxFlow_head15Optional& x)
  {
    this->maxFlow_head15_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head16Optional& MaxFlowsComplexType::
  getMaxFlow_head16 () const
  {
    return this->maxFlow_head16_;
  }

  MaxFlowsComplexType::MaxFlow_head16Optional& MaxFlowsComplexType::
  getMaxFlow_head16 ()
  {
    return this->maxFlow_head16_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head16 (const MaxFlow_head16Type& x)
  {
    this->maxFlow_head16_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head16 (const MaxFlow_head16Optional& x)
  {
    this->maxFlow_head16_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head17Optional& MaxFlowsComplexType::
  getMaxFlow_head17 () const
  {
    return this->maxFlow_head17_;
  }

  MaxFlowsComplexType::MaxFlow_head17Optional& MaxFlowsComplexType::
  getMaxFlow_head17 ()
  {
    return this->maxFlow_head17_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head17 (const MaxFlow_head17Type& x)
  {
    this->maxFlow_head17_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head17 (const MaxFlow_head17Optional& x)
  {
    this->maxFlow_head17_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head18Optional& MaxFlowsComplexType::
  getMaxFlow_head18 () const
  {
    return this->maxFlow_head18_;
  }

  MaxFlowsComplexType::MaxFlow_head18Optional& MaxFlowsComplexType::
  getMaxFlow_head18 ()
  {
    return this->maxFlow_head18_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head18 (const MaxFlow_head18Type& x)
  {
    this->maxFlow_head18_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head18 (const MaxFlow_head18Optional& x)
  {
    this->maxFlow_head18_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head19Optional& MaxFlowsComplexType::
  getMaxFlow_head19 () const
  {
    return this->maxFlow_head19_;
  }

  MaxFlowsComplexType::MaxFlow_head19Optional& MaxFlowsComplexType::
  getMaxFlow_head19 ()
  {
    return this->maxFlow_head19_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head19 (const MaxFlow_head19Type& x)
  {
    this->maxFlow_head19_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head19 (const MaxFlow_head19Optional& x)
  {
    this->maxFlow_head19_ = x;
  }

  const MaxFlowsComplexType::MaxFlow_head20Optional& MaxFlowsComplexType::
  getMaxFlow_head20 () const
  {
    return this->maxFlow_head20_;
  }

  MaxFlowsComplexType::MaxFlow_head20Optional& MaxFlowsComplexType::
  getMaxFlow_head20 ()
  {
    return this->maxFlow_head20_;
  }

  void MaxFlowsComplexType::
  setMaxFlow_head20 (const MaxFlow_head20Type& x)
  {
    this->maxFlow_head20_.set (x);
  }

  void MaxFlowsComplexType::
  setMaxFlow_head20 (const MaxFlow_head20Optional& x)
  {
    this->maxFlow_head20_ = x;
  }


  // ReservoirCompactInputComplexType
  // 

  const ReservoirCompactInputComplexType::FBType& ReservoirCompactInputComplexType::
  getFB () const
  {
    return this->FB_.get ();
  }

  ReservoirCompactInputComplexType::FBType& ReservoirCompactInputComplexType::
  getFB ()
  {
    return this->FB_.get ();
  }

  void ReservoirCompactInputComplexType::
  setFB (const FBType& x)
  {
    this->FB_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setFB (::std::auto_ptr< FBType > x)
  {
    this->FB_.set (x);
  }

  const ReservoirCompactInputComplexType::QISequence& ReservoirCompactInputComplexType::
  getQI () const
  {
    return this->QI_;
  }

  ReservoirCompactInputComplexType::QISequence& ReservoirCompactInputComplexType::
  getQI ()
  {
    return this->QI_;
  }

  void ReservoirCompactInputComplexType::
  setQI (const QISequence& s)
  {
    this->QI_ = s;
  }

  const ReservoirCompactInputComplexType::QType& ReservoirCompactInputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  ReservoirCompactInputComplexType::QType& ReservoirCompactInputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void ReservoirCompactInputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }

  const ReservoirCompactInputComplexType::QSPercentageOptional& ReservoirCompactInputComplexType::
  getQSPercentage () const
  {
    return this->QSPercentage_;
  }

  ReservoirCompactInputComplexType::QSPercentageOptional& ReservoirCompactInputComplexType::
  getQSPercentage ()
  {
    return this->QSPercentage_;
  }

  void ReservoirCompactInputComplexType::
  setQSPercentage (const QSPercentageType& x)
  {
    this->QSPercentage_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQSPercentage (const QSPercentageOptional& x)
  {
    this->QSPercentage_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQSPercentage (::std::auto_ptr< QSPercentageType > x)
  {
    this->QSPercentage_.set (x);
  }

  const ReservoirCompactInputComplexType::QSPercentageValueOptional& ReservoirCompactInputComplexType::
  getQSPercentageValue () const
  {
    return this->QSPercentageValue_;
  }

  ReservoirCompactInputComplexType::QSPercentageValueOptional& ReservoirCompactInputComplexType::
  getQSPercentageValue ()
  {
    return this->QSPercentageValue_;
  }

  void ReservoirCompactInputComplexType::
  setQSPercentageValue (const QSPercentageValueType& x)
  {
    this->QSPercentageValue_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQSPercentageValue (const QSPercentageValueOptional& x)
  {
    this->QSPercentageValue_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQSPercentageValue (::std::auto_ptr< QSPercentageValueType > x)
  {
    this->QSPercentageValue_.set (x);
  }

  const ReservoirCompactInputComplexType::QSOptional& ReservoirCompactInputComplexType::
  getQS () const
  {
    return this->QS_;
  }

  ReservoirCompactInputComplexType::QSOptional& ReservoirCompactInputComplexType::
  getQS ()
  {
    return this->QS_;
  }

  void ReservoirCompactInputComplexType::
  setQS (const QSType& x)
  {
    this->QS_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQS (const QSOptional& x)
  {
    this->QS_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQS (::std::auto_ptr< QSType > x)
  {
    this->QS_.set (x);
  }

  const ReservoirCompactInputComplexType::QSValueOptional& ReservoirCompactInputComplexType::
  getQSValue () const
  {
    return this->QSValue_;
  }

  ReservoirCompactInputComplexType::QSValueOptional& ReservoirCompactInputComplexType::
  getQSValue ()
  {
    return this->QSValue_;
  }

  void ReservoirCompactInputComplexType::
  setQSValue (const QSValueType& x)
  {
    this->QSValue_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQSValue (const QSValueOptional& x)
  {
    this->QSValue_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQSValue (::std::auto_ptr< QSValueType > x)
  {
    this->QSValue_.set (x);
  }

  const ReservoirCompactInputComplexType::QMISCOptional& ReservoirCompactInputComplexType::
  getQMISC () const
  {
    return this->QMISC_;
  }

  ReservoirCompactInputComplexType::QMISCOptional& ReservoirCompactInputComplexType::
  getQMISC ()
  {
    return this->QMISC_;
  }

  void ReservoirCompactInputComplexType::
  setQMISC (const QMISCType& x)
  {
    this->QMISC_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQMISC (const QMISCOptional& x)
  {
    this->QMISC_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQMISC (::std::auto_ptr< QMISCType > x)
  {
    this->QMISC_.set (x);
  }

  const ReservoirCompactInputComplexType::PMOptional& ReservoirCompactInputComplexType::
  getPM () const
  {
    return this->PM_;
  }

  ReservoirCompactInputComplexType::PMOptional& ReservoirCompactInputComplexType::
  getPM ()
  {
    return this->PM_;
  }

  void ReservoirCompactInputComplexType::
  setPM (const PMType& x)
  {
    this->PM_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setPM (const PMOptional& x)
  {
    this->PM_ = x;
  }

  void ReservoirCompactInputComplexType::
  setPM (::std::auto_ptr< PMType > x)
  {
    this->PM_.set (x);
  }

  const ReservoirCompactInputComplexType::PMValueOptional& ReservoirCompactInputComplexType::
  getPMValue () const
  {
    return this->PMValue_;
  }

  ReservoirCompactInputComplexType::PMValueOptional& ReservoirCompactInputComplexType::
  getPMValue ()
  {
    return this->PMValue_;
  }

  void ReservoirCompactInputComplexType::
  setPMValue (const PMValueType& x)
  {
    this->PMValue_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setPMValue (const PMValueOptional& x)
  {
    this->PMValue_ = x;
  }

  void ReservoirCompactInputComplexType::
  setPMValue (::std::auto_ptr< PMValueType > x)
  {
    this->PMValue_.set (x);
  }

  const ReservoirCompactInputComplexType::PXOptional& ReservoirCompactInputComplexType::
  getPX () const
  {
    return this->PX_;
  }

  ReservoirCompactInputComplexType::PXOptional& ReservoirCompactInputComplexType::
  getPX ()
  {
    return this->PX_;
  }

  void ReservoirCompactInputComplexType::
  setPX (const PXType& x)
  {
    this->PX_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setPX (const PXOptional& x)
  {
    this->PX_ = x;
  }

  void ReservoirCompactInputComplexType::
  setPX (::std::auto_ptr< PXType > x)
  {
    this->PX_.set (x);
  }

  const ReservoirCompactInputComplexType::PXValueOptional& ReservoirCompactInputComplexType::
  getPXValue () const
  {
    return this->PXValue_;
  }

  ReservoirCompactInputComplexType::PXValueOptional& ReservoirCompactInputComplexType::
  getPXValue ()
  {
    return this->PXValue_;
  }

  void ReservoirCompactInputComplexType::
  setPXValue (const PXValueType& x)
  {
    this->PXValue_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setPXValue (const PXValueOptional& x)
  {
    this->PXValue_ = x;
  }

  void ReservoirCompactInputComplexType::
  setPXValue (::std::auto_ptr< PXValueType > x)
  {
    this->PXValue_.set (x);
  }

  const ReservoirCompactInputComplexType::QTXOptional& ReservoirCompactInputComplexType::
  getQTX () const
  {
    return this->QTX_;
  }

  ReservoirCompactInputComplexType::QTXOptional& ReservoirCompactInputComplexType::
  getQTX ()
  {
    return this->QTX_;
  }

  void ReservoirCompactInputComplexType::
  setQTX (const QTXType& x)
  {
    this->QTX_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQTX (const QTXOptional& x)
  {
    this->QTX_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQTX (::std::auto_ptr< QTXType > x)
  {
    this->QTX_.set (x);
  }

  const ReservoirCompactInputComplexType::QTXValueOptional& ReservoirCompactInputComplexType::
  getQTXValue () const
  {
    return this->QTXValue_;
  }

  ReservoirCompactInputComplexType::QTXValueOptional& ReservoirCompactInputComplexType::
  getQTXValue ()
  {
    return this->QTXValue_;
  }

  void ReservoirCompactInputComplexType::
  setQTXValue (const QTXValueType& x)
  {
    this->QTXValue_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setQTXValue (const QTXValueOptional& x)
  {
    this->QTXValue_ = x;
  }

  void ReservoirCompactInputComplexType::
  setQTXValue (::std::auto_ptr< QTXValueType > x)
  {
    this->QTXValue_.set (x);
  }

  const ReservoirCompactInputComplexType::OFOptional& ReservoirCompactInputComplexType::
  getOF () const
  {
    return this->OF_;
  }

  ReservoirCompactInputComplexType::OFOptional& ReservoirCompactInputComplexType::
  getOF ()
  {
    return this->OF_;
  }

  void ReservoirCompactInputComplexType::
  setOF (const OFType& x)
  {
    this->OF_.set (x);
  }

  void ReservoirCompactInputComplexType::
  setOF (const OFOptional& x)
  {
    this->OF_ = x;
  }

  void ReservoirCompactInputComplexType::
  setOF (::std::auto_ptr< OFType > x)
  {
    this->OF_.set (x);
  }


  // ReservoirCompactOutputComplexType
  // 

  const ReservoirCompactOutputComplexType::SType& ReservoirCompactOutputComplexType::
  getS () const
  {
    return this->S_.get ();
  }

  ReservoirCompactOutputComplexType::SType& ReservoirCompactOutputComplexType::
  getS ()
  {
    return this->S_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setS (const SType& x)
  {
    this->S_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setS (::std::auto_ptr< SType > x)
  {
    this->S_.set (x);
  }

  const ReservoirCompactOutputComplexType::FBType& ReservoirCompactOutputComplexType::
  getFB () const
  {
    return this->FB_.get ();
  }

  ReservoirCompactOutputComplexType::FBType& ReservoirCompactOutputComplexType::
  getFB ()
  {
    return this->FB_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setFB (const FBType& x)
  {
    this->FB_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setFB (::std::auto_ptr< FBType > x)
  {
    this->FB_.set (x);
  }

  const ReservoirCompactOutputComplexType::QType& ReservoirCompactOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  ReservoirCompactOutputComplexType::QType& ReservoirCompactOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }

  const ReservoirCompactOutputComplexType::QIType& ReservoirCompactOutputComplexType::
  getQI () const
  {
    return this->QI_.get ();
  }

  ReservoirCompactOutputComplexType::QIType& ReservoirCompactOutputComplexType::
  getQI ()
  {
    return this->QI_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setQI (const QIType& x)
  {
    this->QI_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQI (::std::auto_ptr< QIType > x)
  {
    this->QI_.set (x);
  }

  const ReservoirCompactOutputComplexType::QTType& ReservoirCompactOutputComplexType::
  getQT () const
  {
    return this->QT_.get ();
  }

  ReservoirCompactOutputComplexType::QTType& ReservoirCompactOutputComplexType::
  getQT ()
  {
    return this->QT_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setQT (const QTType& x)
  {
    this->QT_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQT (::std::auto_ptr< QTType > x)
  {
    this->QT_.set (x);
  }

  const ReservoirCompactOutputComplexType::QTXOptional& ReservoirCompactOutputComplexType::
  getQTX () const
  {
    return this->QTX_;
  }

  ReservoirCompactOutputComplexType::QTXOptional& ReservoirCompactOutputComplexType::
  getQTX ()
  {
    return this->QTX_;
  }

  void ReservoirCompactOutputComplexType::
  setQTX (const QTXType& x)
  {
    this->QTX_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQTX (const QTXOptional& x)
  {
    this->QTX_ = x;
  }

  void ReservoirCompactOutputComplexType::
  setQTX (::std::auto_ptr< QTXType > x)
  {
    this->QTX_.set (x);
  }

  const ReservoirCompactOutputComplexType::QSType& ReservoirCompactOutputComplexType::
  getQS () const
  {
    return this->QS_.get ();
  }

  ReservoirCompactOutputComplexType::QSType& ReservoirCompactOutputComplexType::
  getQS ()
  {
    return this->QS_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setQS (const QSType& x)
  {
    this->QS_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQS (::std::auto_ptr< QSType > x)
  {
    this->QS_.set (x);
  }

  const ReservoirCompactOutputComplexType::QSPercentageOptional& ReservoirCompactOutputComplexType::
  getQSPercentage () const
  {
    return this->QSPercentage_;
  }

  ReservoirCompactOutputComplexType::QSPercentageOptional& ReservoirCompactOutputComplexType::
  getQSPercentage ()
  {
    return this->QSPercentage_;
  }

  void ReservoirCompactOutputComplexType::
  setQSPercentage (const QSPercentageType& x)
  {
    this->QSPercentage_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQSPercentage (const QSPercentageOptional& x)
  {
    this->QSPercentage_ = x;
  }

  void ReservoirCompactOutputComplexType::
  setQSPercentage (::std::auto_ptr< QSPercentageType > x)
  {
    this->QSPercentage_.set (x);
  }

  const ReservoirCompactOutputComplexType::QMISCOptional& ReservoirCompactOutputComplexType::
  getQMISC () const
  {
    return this->QMISC_;
  }

  ReservoirCompactOutputComplexType::QMISCOptional& ReservoirCompactOutputComplexType::
  getQMISC ()
  {
    return this->QMISC_;
  }

  void ReservoirCompactOutputComplexType::
  setQMISC (const QMISCType& x)
  {
    this->QMISC_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setQMISC (const QMISCOptional& x)
  {
    this->QMISC_ = x;
  }

  void ReservoirCompactOutputComplexType::
  setQMISC (::std::auto_ptr< QMISCType > x)
  {
    this->QMISC_.set (x);
  }

  const ReservoirCompactOutputComplexType::DQType& ReservoirCompactOutputComplexType::
  getDQ () const
  {
    return this->DQ_.get ();
  }

  ReservoirCompactOutputComplexType::DQType& ReservoirCompactOutputComplexType::
  getDQ ()
  {
    return this->DQ_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setDQ (const DQType& x)
  {
    this->DQ_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setDQ (::std::auto_ptr< DQType > x)
  {
    this->DQ_.set (x);
  }

  const ReservoirCompactOutputComplexType::TWType& ReservoirCompactOutputComplexType::
  getTW () const
  {
    return this->TW_.get ();
  }

  ReservoirCompactOutputComplexType::TWType& ReservoirCompactOutputComplexType::
  getTW ()
  {
    return this->TW_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setTW (const TWType& x)
  {
    this->TW_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setTW (::std::auto_ptr< TWType > x)
  {
    this->TW_.set (x);
  }

  const ReservoirCompactOutputComplexType::HType& ReservoirCompactOutputComplexType::
  getH () const
  {
    return this->H_.get ();
  }

  ReservoirCompactOutputComplexType::HType& ReservoirCompactOutputComplexType::
  getH ()
  {
    return this->H_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setH (const HType& x)
  {
    this->H_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setH (::std::auto_ptr< HType > x)
  {
    this->H_.set (x);
  }

  const ReservoirCompactOutputComplexType::PType& ReservoirCompactOutputComplexType::
  getP () const
  {
    return this->P_.get ();
  }

  ReservoirCompactOutputComplexType::PType& ReservoirCompactOutputComplexType::
  getP ()
  {
    return this->P_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setP (const PType& x)
  {
    this->P_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setP (::std::auto_ptr< PType > x)
  {
    this->P_.set (x);
  }

  const ReservoirCompactOutputComplexType::PXOptional& ReservoirCompactOutputComplexType::
  getPX () const
  {
    return this->PX_;
  }

  ReservoirCompactOutputComplexType::PXOptional& ReservoirCompactOutputComplexType::
  getPX ()
  {
    return this->PX_;
  }

  void ReservoirCompactOutputComplexType::
  setPX (const PXType& x)
  {
    this->PX_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setPX (const PXOptional& x)
  {
    this->PX_ = x;
  }

  void ReservoirCompactOutputComplexType::
  setPX (::std::auto_ptr< PXType > x)
  {
    this->PX_.set (x);
  }

  const ReservoirCompactOutputComplexType::RType& ReservoirCompactOutputComplexType::
  getR () const
  {
    return this->R_.get ();
  }

  ReservoirCompactOutputComplexType::RType& ReservoirCompactOutputComplexType::
  getR ()
  {
    return this->R_.get ();
  }

  void ReservoirCompactOutputComplexType::
  setR (const RType& x)
  {
    this->R_.set (x);
  }

  void ReservoirCompactOutputComplexType::
  setR (::std::auto_ptr< RType > x)
  {
    this->R_.set (x);
  }


  // ReservoirComplexType
  // 

  const ReservoirComplexType::ModeType& ReservoirComplexType::
  getMode () const
  {
    return this->mode_.get ();
  }

  ReservoirComplexType::ModeType& ReservoirComplexType::
  getMode ()
  {
    return this->mode_.get ();
  }

  void ReservoirComplexType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void ReservoirComplexType::
  setMode (::std::auto_ptr< ModeType > x)
  {
    this->mode_.set (x);
  }

  const ReservoirComplexType::ThetaType& ReservoirComplexType::
  getTheta () const
  {
    return this->theta_.get ();
  }

  ReservoirComplexType::ThetaType& ReservoirComplexType::
  getTheta ()
  {
    return this->theta_.get ();
  }

  void ReservoirComplexType::
  setTheta (const ThetaType& x)
  {
    this->theta_.set (x);
  }

  const ReservoirComplexType::StorageCharacteristicsType& ReservoirComplexType::
  getStorageCharacteristics () const
  {
    return this->storageCharacteristics_.get ();
  }

  ReservoirComplexType::StorageCharacteristicsType& ReservoirComplexType::
  getStorageCharacteristics ()
  {
    return this->storageCharacteristics_.get ();
  }

  void ReservoirComplexType::
  setStorageCharacteristics (const StorageCharacteristicsType& x)
  {
    this->storageCharacteristics_.set (x);
  }

  void ReservoirComplexType::
  setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > x)
  {
    this->storageCharacteristics_.set (x);
  }

  const ReservoirComplexType::ControlledOutletSequence& ReservoirComplexType::
  getControlledOutlet () const
  {
    return this->controlledOutlet_;
  }

  ReservoirComplexType::ControlledOutletSequence& ReservoirComplexType::
  getControlledOutlet ()
  {
    return this->controlledOutlet_;
  }

  void ReservoirComplexType::
  setControlledOutlet (const ControlledOutletSequence& s)
  {
    this->controlledOutlet_ = s;
  }

  const ReservoirComplexType::UncontrolledOutletSequence& ReservoirComplexType::
  getUncontrolledOutlet () const
  {
    return this->uncontrolledOutlet_;
  }

  ReservoirComplexType::UncontrolledOutletSequence& ReservoirComplexType::
  getUncontrolledOutlet ()
  {
    return this->uncontrolledOutlet_;
  }

  void ReservoirComplexType::
  setUncontrolledOutlet (const UncontrolledOutletSequence& s)
  {
    this->uncontrolledOutlet_ = s;
  }

  const ReservoirComplexType::TailwaterOptional& ReservoirComplexType::
  getTailwater () const
  {
    return this->tailwater_;
  }

  ReservoirComplexType::TailwaterOptional& ReservoirComplexType::
  getTailwater ()
  {
    return this->tailwater_;
  }

  void ReservoirComplexType::
  setTailwater (const TailwaterType& x)
  {
    this->tailwater_.set (x);
  }

  void ReservoirComplexType::
  setTailwater (const TailwaterOptional& x)
  {
    this->tailwater_ = x;
  }

  void ReservoirComplexType::
  setTailwater (::std::auto_ptr< TailwaterType > x)
  {
    this->tailwater_.set (x);
  }

  const ReservoirComplexType::InputType& ReservoirComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ReservoirComplexType::InputType& ReservoirComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ReservoirComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ReservoirComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ReservoirComplexType::OutputType& ReservoirComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ReservoirComplexType::OutputType& ReservoirComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ReservoirComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ReservoirComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ReservoirComplexType::IdType& ReservoirComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ReservoirComplexType::IdType& ReservoirComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ReservoirComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ReservoirComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ReservoirComplexType::NameOptional& ReservoirComplexType::
  getName () const
  {
    return this->name_;
  }

  ReservoirComplexType::NameOptional& ReservoirComplexType::
  getName ()
  {
    return this->name_;
  }

  void ReservoirComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ReservoirComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ReservoirComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // RoutingComplexType
  // 

  const RoutingComplexType::InflowSequence& RoutingComplexType::
  getInflow () const
  {
    return this->inflow_;
  }

  RoutingComplexType::InflowSequence& RoutingComplexType::
  getInflow ()
  {
    return this->inflow_;
  }

  void RoutingComplexType::
  setInflow (const InflowSequence& s)
  {
    this->inflow_ = s;
  }

  const RoutingComplexType::ReservoirRoutingOptional& RoutingComplexType::
  getReservoirRouting () const
  {
    return this->reservoirRouting_;
  }

  RoutingComplexType::ReservoirRoutingOptional& RoutingComplexType::
  getReservoirRouting ()
  {
    return this->reservoirRouting_;
  }

  void RoutingComplexType::
  setReservoirRouting (const ReservoirRoutingType& x)
  {
    this->reservoirRouting_.set (x);
  }

  void RoutingComplexType::
  setReservoirRouting (const ReservoirRoutingOptional& x)
  {
    this->reservoirRouting_ = x;
  }

  void RoutingComplexType::
  setReservoirRouting (::std::auto_ptr< ReservoirRoutingType > x)
  {
    this->reservoirRouting_.set (x);
  }

  const RoutingComplexType::DischargeRefOptional& RoutingComplexType::
  getDischargeRef () const
  {
    return this->dischargeRef_;
  }

  RoutingComplexType::DischargeRefOptional& RoutingComplexType::
  getDischargeRef ()
  {
    return this->dischargeRef_;
  }

  void RoutingComplexType::
  setDischargeRef (const DischargeRefType& x)
  {
    this->dischargeRef_.set (x);
  }

  void RoutingComplexType::
  setDischargeRef (const DischargeRefOptional& x)
  {
    this->dischargeRef_ = x;
  }

  void RoutingComplexType::
  setDischargeRef (::std::auto_ptr< DischargeRefType > x)
  {
    this->dischargeRef_.set (x);
  }

  const RoutingComplexType::OutputReferencesType& RoutingComplexType::
  getOutputReferences () const
  {
    return this->outputReferences_.get ();
  }

  RoutingComplexType::OutputReferencesType& RoutingComplexType::
  getOutputReferences ()
  {
    return this->outputReferences_.get ();
  }

  void RoutingComplexType::
  setOutputReferences (const OutputReferencesType& x)
  {
    this->outputReferences_.set (x);
  }

  void RoutingComplexType::
  setOutputReferences (::std::auto_ptr< OutputReferencesType > x)
  {
    this->outputReferences_.set (x);
  }

  const RoutingComplexType::IdType& RoutingComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  RoutingComplexType::IdType& RoutingComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void RoutingComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void RoutingComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const RoutingComplexType::NameOptional& RoutingComplexType::
  getName () const
  {
    return this->name_;
  }

  RoutingComplexType::NameOptional& RoutingComplexType::
  getName ()
  {
    return this->name_;
  }

  void RoutingComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void RoutingComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void RoutingComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // NeuralNetworkComplexType
  // 

  const NeuralNetworkComplexType::LayerSequence& NeuralNetworkComplexType::
  getLayer () const
  {
    return this->layer_;
  }

  NeuralNetworkComplexType::LayerSequence& NeuralNetworkComplexType::
  getLayer ()
  {
    return this->layer_;
  }

  void NeuralNetworkComplexType::
  setLayer (const LayerSequence& s)
  {
    this->layer_ = s;
  }

  const NeuralNetworkComplexType::IdType& NeuralNetworkComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  NeuralNetworkComplexType::IdType& NeuralNetworkComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void NeuralNetworkComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void NeuralNetworkComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const NeuralNetworkComplexType::NameOptional& NeuralNetworkComplexType::
  getName () const
  {
    return this->name_;
  }

  NeuralNetworkComplexType::NameOptional& NeuralNetworkComplexType::
  getName ()
  {
    return this->name_;
  }

  void NeuralNetworkComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void NeuralNetworkComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void NeuralNetworkComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // LayerComplexType
  // 

  const LayerComplexType::NeuronSequence& LayerComplexType::
  getNeuron () const
  {
    return this->neuron_;
  }

  LayerComplexType::NeuronSequence& LayerComplexType::
  getNeuron ()
  {
    return this->neuron_;
  }

  void LayerComplexType::
  setNeuron (const NeuronSequence& s)
  {
    this->neuron_ = s;
  }

  const LayerComplexType::IdType& LayerComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  LayerComplexType::IdType& LayerComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void LayerComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void LayerComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const LayerComplexType::NameOptional& LayerComplexType::
  getName () const
  {
    return this->name_;
  }

  LayerComplexType::NameOptional& LayerComplexType::
  getName ()
  {
    return this->name_;
  }

  void LayerComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void LayerComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void LayerComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // NeuronComplexType
  // 

  const NeuronComplexType::BiasType& NeuronComplexType::
  getBias () const
  {
    return this->bias_.get ();
  }

  NeuronComplexType::BiasType& NeuronComplexType::
  getBias ()
  {
    return this->bias_.get ();
  }

  void NeuronComplexType::
  setBias (const BiasType& x)
  {
    this->bias_.set (x);
  }

  void NeuronComplexType::
  setBias (::std::auto_ptr< BiasType > x)
  {
    this->bias_.set (x);
  }

  const NeuronComplexType::TransferFunctionType& NeuronComplexType::
  getTransferFunction () const
  {
    return this->transferFunction_.get ();
  }

  NeuronComplexType::TransferFunctionType& NeuronComplexType::
  getTransferFunction ()
  {
    return this->transferFunction_.get ();
  }

  void NeuronComplexType::
  setTransferFunction (const TransferFunctionType& x)
  {
    this->transferFunction_.set (x);
  }

  void NeuronComplexType::
  setTransferFunction (::std::auto_ptr< TransferFunctionType > x)
  {
    this->transferFunction_.set (x);
  }

  const NeuronComplexType::InputType& NeuronComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  NeuronComplexType::InputType& NeuronComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void NeuronComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void NeuronComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const NeuronComplexType::OutputType& NeuronComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  NeuronComplexType::OutputType& NeuronComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void NeuronComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void NeuronComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const NeuronComplexType::IdType& NeuronComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  NeuronComplexType::IdType& NeuronComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void NeuronComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void NeuronComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const NeuronComplexType::NameOptional& NeuronComplexType::
  getName () const
  {
    return this->name_;
  }

  NeuronComplexType::NameOptional& NeuronComplexType::
  getName ()
  {
    return this->name_;
  }

  void NeuronComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void NeuronComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void NeuronComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // NeuronInputComplexType
  // 

  const NeuronInputComplexType::ExternalSequence& NeuronInputComplexType::
  getExternal () const
  {
    return this->external_;
  }

  NeuronInputComplexType::ExternalSequence& NeuronInputComplexType::
  getExternal ()
  {
    return this->external_;
  }

  void NeuronInputComplexType::
  setExternal (const ExternalSequence& s)
  {
    this->external_ = s;
  }

  const NeuronInputComplexType::InternalSequence& NeuronInputComplexType::
  getInternal () const
  {
    return this->internal_;
  }

  NeuronInputComplexType::InternalSequence& NeuronInputComplexType::
  getInternal ()
  {
    return this->internal_;
  }

  void NeuronInputComplexType::
  setInternal (const InternalSequence& s)
  {
    this->internal_ = s;
  }


  // NeuronOutputComplexType
  // 

  const NeuronOutputComplexType::XType& NeuronOutputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  NeuronOutputComplexType::XType& NeuronOutputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void NeuronOutputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void NeuronOutputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const NeuronOutputComplexType::YType& NeuronOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  NeuronOutputComplexType::YType& NeuronOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void NeuronOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void NeuronOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // HydraulicModelComplexType
  // 

  const HydraulicModelComplexType::ModeType& HydraulicModelComplexType::
  getMode () const
  {
    return this->mode_.get ();
  }

  HydraulicModelComplexType::ModeType& HydraulicModelComplexType::
  getMode ()
  {
    return this->mode_.get ();
  }

  void HydraulicModelComplexType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void HydraulicModelComplexType::
  setMode (::std::auto_ptr< ModeType > x)
  {
    this->mode_.set (x);
  }

  const HydraulicModelComplexType::SequentialImplicitSettingsOptional& HydraulicModelComplexType::
  getSequentialImplicitSettings () const
  {
    return this->sequentialImplicitSettings_;
  }

  HydraulicModelComplexType::SequentialImplicitSettingsOptional& HydraulicModelComplexType::
  getSequentialImplicitSettings ()
  {
    return this->sequentialImplicitSettings_;
  }

  void HydraulicModelComplexType::
  setSequentialImplicitSettings (const SequentialImplicitSettingsType& x)
  {
    this->sequentialImplicitSettings_.set (x);
  }

  void HydraulicModelComplexType::
  setSequentialImplicitSettings (const SequentialImplicitSettingsOptional& x)
  {
    this->sequentialImplicitSettings_ = x;
  }

  void HydraulicModelComplexType::
  setSequentialImplicitSettings (::std::auto_ptr< SequentialImplicitSettingsType > x)
  {
    this->sequentialImplicitSettings_.set (x);
  }

  const HydraulicModelComplexType::SimultaneousSettingsOptional& HydraulicModelComplexType::
  getSimultaneousSettings () const
  {
    return this->simultaneousSettings_;
  }

  HydraulicModelComplexType::SimultaneousSettingsOptional& HydraulicModelComplexType::
  getSimultaneousSettings ()
  {
    return this->simultaneousSettings_;
  }

  void HydraulicModelComplexType::
  setSimultaneousSettings (const SimultaneousSettingsType& x)
  {
    this->simultaneousSettings_.set (x);
  }

  void HydraulicModelComplexType::
  setSimultaneousSettings (const SimultaneousSettingsOptional& x)
  {
    this->simultaneousSettings_ = x;
  }

  void HydraulicModelComplexType::
  setSimultaneousSettings (::std::auto_ptr< SimultaneousSettingsType > x)
  {
    this->simultaneousSettings_.set (x);
  }

  const HydraulicModelComplexType::NumericalToleranceType& HydraulicModelComplexType::
  getNumericalTolerance () const
  {
    return this->numericalTolerance_.get ();
  }

  HydraulicModelComplexType::NumericalToleranceType& HydraulicModelComplexType::
  getNumericalTolerance ()
  {
    return this->numericalTolerance_.get ();
  }

  void HydraulicModelComplexType::
  setNumericalTolerance (const NumericalToleranceType& x)
  {
    this->numericalTolerance_.set (x);
  }

  HydraulicModelComplexType::NumericalToleranceType HydraulicModelComplexType::
  getNumericalToleranceDefaultValue ()
  {
    return NumericalToleranceType (1e-20);
  }

  const HydraulicModelComplexType::NodeSequence& HydraulicModelComplexType::
  getNode () const
  {
    return this->node_;
  }

  HydraulicModelComplexType::NodeSequence& HydraulicModelComplexType::
  getNode ()
  {
    return this->node_;
  }

  void HydraulicModelComplexType::
  setNode (const NodeSequence& s)
  {
    this->node_ = s;
  }

  const HydraulicModelComplexType::BranchSequence& HydraulicModelComplexType::
  getBranch () const
  {
    return this->branch_;
  }

  HydraulicModelComplexType::BranchSequence& HydraulicModelComplexType::
  getBranch ()
  {
    return this->branch_;
  }

  void HydraulicModelComplexType::
  setBranch (const BranchSequence& s)
  {
    this->branch_ = s;
  }

  const HydraulicModelComplexType::HydraulicStructureSequence& HydraulicModelComplexType::
  getHydraulicStructure () const
  {
    return this->hydraulicStructure_;
  }

  HydraulicModelComplexType::HydraulicStructureSequence& HydraulicModelComplexType::
  getHydraulicStructure ()
  {
    return this->hydraulicStructure_;
  }

  void HydraulicModelComplexType::
  setHydraulicStructure (const HydraulicStructureSequence& s)
  {
    this->hydraulicStructure_ = s;
  }

  const HydraulicModelComplexType::OutputOptional& HydraulicModelComplexType::
  getOutput () const
  {
    return this->output_;
  }

  HydraulicModelComplexType::OutputOptional& HydraulicModelComplexType::
  getOutput ()
  {
    return this->output_;
  }

  void HydraulicModelComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void HydraulicModelComplexType::
  setOutput (const OutputOptional& x)
  {
    this->output_ = x;
  }

  void HydraulicModelComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const HydraulicModelComplexType::IdType& HydraulicModelComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  HydraulicModelComplexType::IdType& HydraulicModelComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void HydraulicModelComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void HydraulicModelComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const HydraulicModelComplexType::NameOptional& HydraulicModelComplexType::
  getName () const
  {
    return this->name_;
  }

  HydraulicModelComplexType::NameOptional& HydraulicModelComplexType::
  getName ()
  {
    return this->name_;
  }

  void HydraulicModelComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void HydraulicModelComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void HydraulicModelComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // HydraulicModelSequentialImplicitComplexType
  // 

  const HydraulicModelSequentialImplicitComplexType::ThetaType& HydraulicModelSequentialImplicitComplexType::
  getTheta () const
  {
    return this->theta_.get ();
  }

  HydraulicModelSequentialImplicitComplexType::ThetaType& HydraulicModelSequentialImplicitComplexType::
  getTheta ()
  {
    return this->theta_.get ();
  }

  void HydraulicModelSequentialImplicitComplexType::
  setTheta (const ThetaType& x)
  {
    this->theta_.set (x);
  }

  HydraulicModelSequentialImplicitComplexType::ThetaType HydraulicModelSequentialImplicitComplexType::
  getThetaDefaultValue ()
  {
    return ThetaType (1.0);
  }

  const HydraulicModelSequentialImplicitComplexType::ConvergenceThresholdType& HydraulicModelSequentialImplicitComplexType::
  getConvergenceThreshold () const
  {
    return this->convergenceThreshold_.get ();
  }

  HydraulicModelSequentialImplicitComplexType::ConvergenceThresholdType& HydraulicModelSequentialImplicitComplexType::
  getConvergenceThreshold ()
  {
    return this->convergenceThreshold_.get ();
  }

  void HydraulicModelSequentialImplicitComplexType::
  setConvergenceThreshold (const ConvergenceThresholdType& x)
  {
    this->convergenceThreshold_.set (x);
  }

  HydraulicModelSequentialImplicitComplexType::ConvergenceThresholdType HydraulicModelSequentialImplicitComplexType::
  getConvergenceThresholdDefaultValue ()
  {
    return ConvergenceThresholdType (1e-4);
  }

  const HydraulicModelSequentialImplicitComplexType::TreatNonConvergenceAsErrorType& HydraulicModelSequentialImplicitComplexType::
  getTreatNonConvergenceAsError () const
  {
    return this->treatNonConvergenceAsError_.get ();
  }

  HydraulicModelSequentialImplicitComplexType::TreatNonConvergenceAsErrorType& HydraulicModelSequentialImplicitComplexType::
  getTreatNonConvergenceAsError ()
  {
    return this->treatNonConvergenceAsError_.get ();
  }

  void HydraulicModelSequentialImplicitComplexType::
  setTreatNonConvergenceAsError (const TreatNonConvergenceAsErrorType& x)
  {
    this->treatNonConvergenceAsError_.set (x);
  }

  HydraulicModelSequentialImplicitComplexType::TreatNonConvergenceAsErrorType HydraulicModelSequentialImplicitComplexType::
  getTreatNonConvergenceAsErrorDefaultValue ()
  {
    return TreatNonConvergenceAsErrorType (true);
  }


  // HydraulicModelSimultaneousComplexType
  // 

  const HydraulicModelSimultaneousComplexType::ThetaType& HydraulicModelSimultaneousComplexType::
  getTheta () const
  {
    return this->theta_.get ();
  }

  HydraulicModelSimultaneousComplexType::ThetaType& HydraulicModelSimultaneousComplexType::
  getTheta ()
  {
    return this->theta_.get ();
  }

  void HydraulicModelSimultaneousComplexType::
  setTheta (const ThetaType& x)
  {
    this->theta_.set (x);
  }

  HydraulicModelSimultaneousComplexType::ThetaType HydraulicModelSimultaneousComplexType::
  getThetaDefaultValue ()
  {
    return ThetaType (1.0);
  }


  // HydraulicModelOutputComplexType
  // 

  const HydraulicModelOutputComplexType::NJacType& HydraulicModelOutputComplexType::
  getNJac () const
  {
    return this->nJac_.get ();
  }

  HydraulicModelOutputComplexType::NJacType& HydraulicModelOutputComplexType::
  getNJac ()
  {
    return this->nJac_.get ();
  }

  void HydraulicModelOutputComplexType::
  setNJac (const NJacType& x)
  {
    this->nJac_.set (x);
  }

  void HydraulicModelOutputComplexType::
  setNJac (::std::auto_ptr< NJacType > x)
  {
    this->nJac_.set (x);
  }

  const HydraulicModelOutputComplexType::NFunType& HydraulicModelOutputComplexType::
  getNFun () const
  {
    return this->nFun_.get ();
  }

  HydraulicModelOutputComplexType::NFunType& HydraulicModelOutputComplexType::
  getNFun ()
  {
    return this->nFun_.get ();
  }

  void HydraulicModelOutputComplexType::
  setNFun (const NFunType& x)
  {
    this->nFun_.set (x);
  }

  void HydraulicModelOutputComplexType::
  setNFun (::std::auto_ptr< NFunType > x)
  {
    this->nFun_.set (x);
  }

  const HydraulicModelOutputComplexType::ResType& HydraulicModelOutputComplexType::
  getRes () const
  {
    return this->res_.get ();
  }

  HydraulicModelOutputComplexType::ResType& HydraulicModelOutputComplexType::
  getRes ()
  {
    return this->res_.get ();
  }

  void HydraulicModelOutputComplexType::
  setRes (const ResType& x)
  {
    this->res_.set (x);
  }

  void HydraulicModelOutputComplexType::
  setRes (::std::auto_ptr< ResType > x)
  {
    this->res_.set (x);
  }


  // ConnectionInputComplexType
  // 

  const ConnectionInputComplexType::UpstreamLevelType& ConnectionInputComplexType::
  getUpstreamLevel () const
  {
    return this->upstreamLevel_.get ();
  }

  ConnectionInputComplexType::UpstreamLevelType& ConnectionInputComplexType::
  getUpstreamLevel ()
  {
    return this->upstreamLevel_.get ();
  }

  void ConnectionInputComplexType::
  setUpstreamLevel (const UpstreamLevelType& x)
  {
    this->upstreamLevel_.set (x);
  }

  void ConnectionInputComplexType::
  setUpstreamLevel (::std::auto_ptr< UpstreamLevelType > x)
  {
    this->upstreamLevel_.set (x);
  }

  const ConnectionInputComplexType::DownstreamLevelType& ConnectionInputComplexType::
  getDownstreamLevel () const
  {
    return this->downstreamLevel_.get ();
  }

  ConnectionInputComplexType::DownstreamLevelType& ConnectionInputComplexType::
  getDownstreamLevel ()
  {
    return this->downstreamLevel_.get ();
  }

  void ConnectionInputComplexType::
  setDownstreamLevel (const DownstreamLevelType& x)
  {
    this->downstreamLevel_.set (x);
  }

  void ConnectionInputComplexType::
  setDownstreamLevel (::std::auto_ptr< DownstreamLevelType > x)
  {
    this->downstreamLevel_.set (x);
  }

  const ConnectionInputComplexType::DischargeType& ConnectionInputComplexType::
  getDischarge () const
  {
    return this->discharge_.get ();
  }

  ConnectionInputComplexType::DischargeType& ConnectionInputComplexType::
  getDischarge ()
  {
    return this->discharge_.get ();
  }

  void ConnectionInputComplexType::
  setDischarge (const DischargeType& x)
  {
    this->discharge_.set (x);
  }

  void ConnectionInputComplexType::
  setDischarge (::std::auto_ptr< DischargeType > x)
  {
    this->discharge_.set (x);
  }


  // ConnectionOutputComplexType
  // 

  const ConnectionOutputComplexType::DischargeType& ConnectionOutputComplexType::
  getDischarge () const
  {
    return this->discharge_.get ();
  }

  ConnectionOutputComplexType::DischargeType& ConnectionOutputComplexType::
  getDischarge ()
  {
    return this->discharge_.get ();
  }

  void ConnectionOutputComplexType::
  setDischarge (const DischargeType& x)
  {
    this->discharge_.set (x);
  }

  void ConnectionOutputComplexType::
  setDischarge (::std::auto_ptr< DischargeType > x)
  {
    this->discharge_.set (x);
  }


  // RoutingOutputComplexType
  // 

  const RoutingOutputComplexType::DischargeOptional& RoutingOutputComplexType::
  getDischarge () const
  {
    return this->discharge_;
  }

  RoutingOutputComplexType::DischargeOptional& RoutingOutputComplexType::
  getDischarge ()
  {
    return this->discharge_;
  }

  void RoutingOutputComplexType::
  setDischarge (const DischargeType& x)
  {
    this->discharge_.set (x);
  }

  void RoutingOutputComplexType::
  setDischarge (const DischargeOptional& x)
  {
    this->discharge_ = x;
  }

  void RoutingOutputComplexType::
  setDischarge (::std::auto_ptr< DischargeType > x)
  {
    this->discharge_.set (x);
  }

  const RoutingOutputComplexType::ErrorOptional& RoutingOutputComplexType::
  getError () const
  {
    return this->error_;
  }

  RoutingOutputComplexType::ErrorOptional& RoutingOutputComplexType::
  getError ()
  {
    return this->error_;
  }

  void RoutingOutputComplexType::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void RoutingOutputComplexType::
  setError (const ErrorOptional& x)
  {
    this->error_ = x;
  }

  void RoutingOutputComplexType::
  setError (::std::auto_ptr< ErrorType > x)
  {
    this->error_.set (x);
  }


  // ReservoirRoutingComplexType
  // 

  const ReservoirRoutingComplexType::SimpleReservoirSequence& ReservoirRoutingComplexType::
  getSimpleReservoir () const
  {
    return this->simpleReservoir_;
  }

  ReservoirRoutingComplexType::SimpleReservoirSequence& ReservoirRoutingComplexType::
  getSimpleReservoir ()
  {
    return this->simpleReservoir_;
  }

  void ReservoirRoutingComplexType::
  setSimpleReservoir (const SimpleReservoirSequence& s)
  {
    this->simpleReservoir_ = s;
  }


  // SimpleReservoirComplexType
  // 

  const SimpleReservoirComplexType::StorageCharacteristicsType& SimpleReservoirComplexType::
  getStorageCharacteristics () const
  {
    return this->storageCharacteristics_.get ();
  }

  SimpleReservoirComplexType::StorageCharacteristicsType& SimpleReservoirComplexType::
  getStorageCharacteristics ()
  {
    return this->storageCharacteristics_.get ();
  }

  void SimpleReservoirComplexType::
  setStorageCharacteristics (const StorageCharacteristicsType& x)
  {
    this->storageCharacteristics_.set (x);
  }

  void SimpleReservoirComplexType::
  setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > x)
  {
    this->storageCharacteristics_.set (x);
  }

  const SimpleReservoirComplexType::CapacityCharacteristicsType& SimpleReservoirComplexType::
  getCapacityCharacteristics () const
  {
    return this->capacityCharacteristics_.get ();
  }

  SimpleReservoirComplexType::CapacityCharacteristicsType& SimpleReservoirComplexType::
  getCapacityCharacteristics ()
  {
    return this->capacityCharacteristics_.get ();
  }

  void SimpleReservoirComplexType::
  setCapacityCharacteristics (const CapacityCharacteristicsType& x)
  {
    this->capacityCharacteristics_.set (x);
  }

  void SimpleReservoirComplexType::
  setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > x)
  {
    this->capacityCharacteristics_.set (x);
  }

  const SimpleReservoirComplexType::MultiplierType& SimpleReservoirComplexType::
  getMultiplier () const
  {
    return this->multiplier_.get ();
  }

  SimpleReservoirComplexType::MultiplierType& SimpleReservoirComplexType::
  getMultiplier ()
  {
    return this->multiplier_.get ();
  }

  void SimpleReservoirComplexType::
  setMultiplier (const MultiplierType& x)
  {
    this->multiplier_.set (x);
  }

  void SimpleReservoirComplexType::
  setMultiplier (::std::auto_ptr< MultiplierType > x)
  {
    this->multiplier_.set (x);
  }

  SimpleReservoirComplexType::MultiplierType SimpleReservoirComplexType::
  getMultiplierDefaultValue ()
  {
    return MultiplierType (1LL);
  }


  // ConnectionCoefficientsComplexType
  // 

  const ConnectionCoefficientsComplexType::AType& ConnectionCoefficientsComplexType::
  getA () const
  {
    return this->a_.get ();
  }

  ConnectionCoefficientsComplexType::AType& ConnectionCoefficientsComplexType::
  getA ()
  {
    return this->a_.get ();
  }

  void ConnectionCoefficientsComplexType::
  setA (const AType& x)
  {
    this->a_.set (x);
  }

  void ConnectionCoefficientsComplexType::
  setA (::std::auto_ptr< AType > x)
  {
    this->a_.set (x);
  }

  const ConnectionCoefficientsComplexType::BType& ConnectionCoefficientsComplexType::
  getB () const
  {
    return this->b_.get ();
  }

  ConnectionCoefficientsComplexType::BType& ConnectionCoefficientsComplexType::
  getB ()
  {
    return this->b_.get ();
  }

  void ConnectionCoefficientsComplexType::
  setB (const BType& x)
  {
    this->b_.set (x);
  }

  void ConnectionCoefficientsComplexType::
  setB (::std::auto_ptr< BType > x)
  {
    this->b_.set (x);
  }

  const ConnectionCoefficientsComplexType::CType& ConnectionCoefficientsComplexType::
  getC () const
  {
    return this->c_.get ();
  }

  ConnectionCoefficientsComplexType::CType& ConnectionCoefficientsComplexType::
  getC ()
  {
    return this->c_.get ();
  }

  void ConnectionCoefficientsComplexType::
  setC (const CType& x)
  {
    this->c_.set (x);
  }

  void ConnectionCoefficientsComplexType::
  setC (::std::auto_ptr< CType > x)
  {
    this->c_.set (x);
  }

  const ConnectionCoefficientsComplexType::DType& ConnectionCoefficientsComplexType::
  getD () const
  {
    return this->d_.get ();
  }

  ConnectionCoefficientsComplexType::DType& ConnectionCoefficientsComplexType::
  getD ()
  {
    return this->d_.get ();
  }

  void ConnectionCoefficientsComplexType::
  setD (const DType& x)
  {
    this->d_.set (x);
  }

  void ConnectionCoefficientsComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->d_.set (x);
  }


  // RulesComplexType
  // 

  const RulesComplexType::RuleSequence& RulesComplexType::
  getRule () const
  {
    return this->rule_;
  }

  RulesComplexType::RuleSequence& RulesComplexType::
  getRule ()
  {
    return this->rule_;
  }

  void RulesComplexType::
  setRule (const RuleSequence& s)
  {
    this->rule_ = s;
  }


  // RuleComplexType
  // 

  const RuleComplexType::ConstantOptional& RuleComplexType::
  getConstant () const
  {
    return this->constant_;
  }

  RuleComplexType::ConstantOptional& RuleComplexType::
  getConstant ()
  {
    return this->constant_;
  }

  void RuleComplexType::
  setConstant (const ConstantType& x)
  {
    this->constant_.set (x);
  }

  void RuleComplexType::
  setConstant (const ConstantOptional& x)
  {
    this->constant_ = x;
  }

  void RuleComplexType::
  setConstant (::std::auto_ptr< ConstantType > x)
  {
    this->constant_.set (x);
  }

  const RuleComplexType::DateLookupTableOptional& RuleComplexType::
  getDateLookupTable () const
  {
    return this->dateLookupTable_;
  }

  RuleComplexType::DateLookupTableOptional& RuleComplexType::
  getDateLookupTable ()
  {
    return this->dateLookupTable_;
  }

  void RuleComplexType::
  setDateLookupTable (const DateLookupTableType& x)
  {
    this->dateLookupTable_.set (x);
  }

  void RuleComplexType::
  setDateLookupTable (const DateLookupTableOptional& x)
  {
    this->dateLookupTable_ = x;
  }

  void RuleComplexType::
  setDateLookupTable (::std::auto_ptr< DateLookupTableType > x)
  {
    this->dateLookupTable_.set (x);
  }

  const RuleComplexType::DeadBandValueOptional& RuleComplexType::
  getDeadBandValue () const
  {
    return this->deadBandValue_;
  }

  RuleComplexType::DeadBandValueOptional& RuleComplexType::
  getDeadBandValue ()
  {
    return this->deadBandValue_;
  }

  void RuleComplexType::
  setDeadBandValue (const DeadBandValueType& x)
  {
    this->deadBandValue_.set (x);
  }

  void RuleComplexType::
  setDeadBandValue (const DeadBandValueOptional& x)
  {
    this->deadBandValue_ = x;
  }

  void RuleComplexType::
  setDeadBandValue (::std::auto_ptr< DeadBandValueType > x)
  {
    this->deadBandValue_.set (x);
  }

  const RuleComplexType::DeadBandTimeOptional& RuleComplexType::
  getDeadBandTime () const
  {
    return this->deadBandTime_;
  }

  RuleComplexType::DeadBandTimeOptional& RuleComplexType::
  getDeadBandTime ()
  {
    return this->deadBandTime_;
  }

  void RuleComplexType::
  setDeadBandTime (const DeadBandTimeType& x)
  {
    this->deadBandTime_.set (x);
  }

  void RuleComplexType::
  setDeadBandTime (const DeadBandTimeOptional& x)
  {
    this->deadBandTime_ = x;
  }

  void RuleComplexType::
  setDeadBandTime (::std::auto_ptr< DeadBandTimeType > x)
  {
    this->deadBandTime_.set (x);
  }

  const RuleComplexType::Dedicated_AebiOptional& RuleComplexType::
  getDedicated_Aebi () const
  {
    return this->dedicated_Aebi_;
  }

  RuleComplexType::Dedicated_AebiOptional& RuleComplexType::
  getDedicated_Aebi ()
  {
    return this->dedicated_Aebi_;
  }

  void RuleComplexType::
  setDedicated_Aebi (const Dedicated_AebiType& x)
  {
    this->dedicated_Aebi_.set (x);
  }

  void RuleComplexType::
  setDedicated_Aebi (const Dedicated_AebiOptional& x)
  {
    this->dedicated_Aebi_ = x;
  }

  void RuleComplexType::
  setDedicated_Aebi (::std::auto_ptr< Dedicated_AebiType > x)
  {
    this->dedicated_Aebi_.set (x);
  }

  const RuleComplexType::Dedicated_ThunerseeOptional& RuleComplexType::
  getDedicated_Thunersee () const
  {
    return this->dedicated_Thunersee_;
  }

  RuleComplexType::Dedicated_ThunerseeOptional& RuleComplexType::
  getDedicated_Thunersee ()
  {
    return this->dedicated_Thunersee_;
  }

  void RuleComplexType::
  setDedicated_Thunersee (const Dedicated_ThunerseeType& x)
  {
    this->dedicated_Thunersee_.set (x);
  }

  void RuleComplexType::
  setDedicated_Thunersee (const Dedicated_ThunerseeOptional& x)
  {
    this->dedicated_Thunersee_ = x;
  }

  void RuleComplexType::
  setDedicated_Thunersee (::std::auto_ptr< Dedicated_ThunerseeType > x)
  {
    this->dedicated_Thunersee_.set (x);
  }

  const RuleComplexType::ExpressionOptional& RuleComplexType::
  getExpression () const
  {
    return this->expression_;
  }

  RuleComplexType::ExpressionOptional& RuleComplexType::
  getExpression ()
  {
    return this->expression_;
  }

  void RuleComplexType::
  setExpression (const ExpressionType& x)
  {
    this->expression_.set (x);
  }

  void RuleComplexType::
  setExpression (const ExpressionOptional& x)
  {
    this->expression_ = x;
  }

  void RuleComplexType::
  setExpression (::std::auto_ptr< ExpressionType > x)
  {
    this->expression_.set (x);
  }

  const RuleComplexType::GuidebandOptional& RuleComplexType::
  getGuideband () const
  {
    return this->guideband_;
  }

  RuleComplexType::GuidebandOptional& RuleComplexType::
  getGuideband ()
  {
    return this->guideband_;
  }

  void RuleComplexType::
  setGuideband (const GuidebandType& x)
  {
    this->guideband_.set (x);
  }

  void RuleComplexType::
  setGuideband (const GuidebandOptional& x)
  {
    this->guideband_ = x;
  }

  void RuleComplexType::
  setGuideband (::std::auto_ptr< GuidebandType > x)
  {
    this->guideband_.set (x);
  }

  const RuleComplexType::IntervalOptional& RuleComplexType::
  getInterval () const
  {
    return this->interval_;
  }

  RuleComplexType::IntervalOptional& RuleComplexType::
  getInterval ()
  {
    return this->interval_;
  }

  void RuleComplexType::
  setInterval (const IntervalType& x)
  {
    this->interval_.set (x);
  }

  void RuleComplexType::
  setInterval (const IntervalOptional& x)
  {
    this->interval_ = x;
  }

  void RuleComplexType::
  setInterval (::std::auto_ptr< IntervalType > x)
  {
    this->interval_.set (x);
  }

  const RuleComplexType::LimiterOptional& RuleComplexType::
  getLimiter () const
  {
    return this->limiter_;
  }

  RuleComplexType::LimiterOptional& RuleComplexType::
  getLimiter ()
  {
    return this->limiter_;
  }

  void RuleComplexType::
  setLimiter (const LimiterType& x)
  {
    this->limiter_.set (x);
  }

  void RuleComplexType::
  setLimiter (const LimiterOptional& x)
  {
    this->limiter_ = x;
  }

  void RuleComplexType::
  setLimiter (::std::auto_ptr< LimiterType > x)
  {
    this->limiter_.set (x);
  }

  const RuleComplexType::LookupTableOptional& RuleComplexType::
  getLookupTable () const
  {
    return this->lookupTable_;
  }

  RuleComplexType::LookupTableOptional& RuleComplexType::
  getLookupTable ()
  {
    return this->lookupTable_;
  }

  void RuleComplexType::
  setLookupTable (const LookupTableType& x)
  {
    this->lookupTable_.set (x);
  }

  void RuleComplexType::
  setLookupTable (const LookupTableOptional& x)
  {
    this->lookupTable_ = x;
  }

  void RuleComplexType::
  setLookupTable (::std::auto_ptr< LookupTableType > x)
  {
    this->lookupTable_.set (x);
  }

  const RuleComplexType::Lookup2DTableOptional& RuleComplexType::
  getLookup2DTable () const
  {
    return this->lookup2DTable_;
  }

  RuleComplexType::Lookup2DTableOptional& RuleComplexType::
  getLookup2DTable ()
  {
    return this->lookup2DTable_;
  }

  void RuleComplexType::
  setLookup2DTable (const Lookup2DTableType& x)
  {
    this->lookup2DTable_.set (x);
  }

  void RuleComplexType::
  setLookup2DTable (const Lookup2DTableOptional& x)
  {
    this->lookup2DTable_ = x;
  }

  void RuleComplexType::
  setLookup2DTable (::std::auto_ptr< Lookup2DTableType > x)
  {
    this->lookup2DTable_.set (x);
  }

  const RuleComplexType::MergerOptional& RuleComplexType::
  getMerger () const
  {
    return this->merger_;
  }

  RuleComplexType::MergerOptional& RuleComplexType::
  getMerger ()
  {
    return this->merger_;
  }

  void RuleComplexType::
  setMerger (const MergerType& x)
  {
    this->merger_.set (x);
  }

  void RuleComplexType::
  setMerger (const MergerOptional& x)
  {
    this->merger_ = x;
  }

  void RuleComplexType::
  setMerger (::std::auto_ptr< MergerType > x)
  {
    this->merger_.set (x);
  }

  const RuleComplexType::PidOptional& RuleComplexType::
  getPid () const
  {
    return this->pid_;
  }

  RuleComplexType::PidOptional& RuleComplexType::
  getPid ()
  {
    return this->pid_;
  }

  void RuleComplexType::
  setPid (const PidType& x)
  {
    this->pid_.set (x);
  }

  void RuleComplexType::
  setPid (const PidOptional& x)
  {
    this->pid_ = x;
  }

  void RuleComplexType::
  setPid (::std::auto_ptr< PidType > x)
  {
    this->pid_.set (x);
  }

  const RuleComplexType::TimeAbsoluteOptional& RuleComplexType::
  getTimeAbsolute () const
  {
    return this->timeAbsolute_;
  }

  RuleComplexType::TimeAbsoluteOptional& RuleComplexType::
  getTimeAbsolute ()
  {
    return this->timeAbsolute_;
  }

  void RuleComplexType::
  setTimeAbsolute (const TimeAbsoluteType& x)
  {
    this->timeAbsolute_.set (x);
  }

  void RuleComplexType::
  setTimeAbsolute (const TimeAbsoluteOptional& x)
  {
    this->timeAbsolute_ = x;
  }

  void RuleComplexType::
  setTimeAbsolute (::std::auto_ptr< TimeAbsoluteType > x)
  {
    this->timeAbsolute_.set (x);
  }

  const RuleComplexType::TimeRelativeOptional& RuleComplexType::
  getTimeRelative () const
  {
    return this->timeRelative_;
  }

  RuleComplexType::TimeRelativeOptional& RuleComplexType::
  getTimeRelative ()
  {
    return this->timeRelative_;
  }

  void RuleComplexType::
  setTimeRelative (const TimeRelativeType& x)
  {
    this->timeRelative_.set (x);
  }

  void RuleComplexType::
  setTimeRelative (const TimeRelativeOptional& x)
  {
    this->timeRelative_ = x;
  }

  void RuleComplexType::
  setTimeRelative (::std::auto_ptr< TimeRelativeType > x)
  {
    this->timeRelative_.set (x);
  }

  const RuleComplexType::UnitDelayOptional& RuleComplexType::
  getUnitDelay () const
  {
    return this->unitDelay_;
  }

  RuleComplexType::UnitDelayOptional& RuleComplexType::
  getUnitDelay ()
  {
    return this->unitDelay_;
  }

  void RuleComplexType::
  setUnitDelay (const UnitDelayType& x)
  {
    this->unitDelay_.set (x);
  }

  void RuleComplexType::
  setUnitDelay (const UnitDelayOptional& x)
  {
    this->unitDelay_ = x;
  }

  void RuleComplexType::
  setUnitDelay (::std::auto_ptr< UnitDelayType > x)
  {
    this->unitDelay_.set (x);
  }


  // ThunerseeRuleComplexType
  // 

  const ThunerseeRuleComplexType::LevelSetpointType& ThunerseeRuleComplexType::
  getLevelSetpoint () const
  {
    return this->levelSetpoint_.get ();
  }

  ThunerseeRuleComplexType::LevelSetpointType& ThunerseeRuleComplexType::
  getLevelSetpoint ()
  {
    return this->levelSetpoint_.get ();
  }

  void ThunerseeRuleComplexType::
  setLevelSetpoint (const LevelSetpointType& x)
  {
    this->levelSetpoint_.set (x);
  }

  const ThunerseeRuleComplexType::ReleaseLimiterPercentageType& ThunerseeRuleComplexType::
  getReleaseLimiterPercentage () const
  {
    return this->releaseLimiterPercentage_.get ();
  }

  ThunerseeRuleComplexType::ReleaseLimiterPercentageType& ThunerseeRuleComplexType::
  getReleaseLimiterPercentage ()
  {
    return this->releaseLimiterPercentage_.get ();
  }

  void ThunerseeRuleComplexType::
  setReleaseLimiterPercentage (const ReleaseLimiterPercentageType& x)
  {
    this->releaseLimiterPercentage_.set (x);
  }

  const ThunerseeRuleComplexType::ReservoirType& ThunerseeRuleComplexType::
  getReservoir () const
  {
    return this->reservoir_.get ();
  }

  ThunerseeRuleComplexType::ReservoirType& ThunerseeRuleComplexType::
  getReservoir ()
  {
    return this->reservoir_.get ();
  }

  void ThunerseeRuleComplexType::
  setReservoir (const ReservoirType& x)
  {
    this->reservoir_.set (x);
  }

  void ThunerseeRuleComplexType::
  setReservoir (::std::auto_ptr< ReservoirType > x)
  {
    this->reservoir_.set (x);
  }

  const ThunerseeRuleComplexType::WeirType& ThunerseeRuleComplexType::
  getWeir () const
  {
    return this->weir_.get ();
  }

  ThunerseeRuleComplexType::WeirType& ThunerseeRuleComplexType::
  getWeir ()
  {
    return this->weir_.get ();
  }

  void ThunerseeRuleComplexType::
  setWeir (const WeirType& x)
  {
    this->weir_.set (x);
  }

  void ThunerseeRuleComplexType::
  setWeir (::std::auto_ptr< WeirType > x)
  {
    this->weir_.set (x);
  }

  const ThunerseeRuleComplexType::TunnelType& ThunerseeRuleComplexType::
  getTunnel () const
  {
    return this->tunnel_.get ();
  }

  ThunerseeRuleComplexType::TunnelType& ThunerseeRuleComplexType::
  getTunnel ()
  {
    return this->tunnel_.get ();
  }

  void ThunerseeRuleComplexType::
  setTunnel (const TunnelType& x)
  {
    this->tunnel_.set (x);
  }

  void ThunerseeRuleComplexType::
  setTunnel (::std::auto_ptr< TunnelType > x)
  {
    this->tunnel_.set (x);
  }

  const ThunerseeRuleComplexType::InputType& ThunerseeRuleComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ThunerseeRuleComplexType::InputType& ThunerseeRuleComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ThunerseeRuleComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ThunerseeRuleComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ThunerseeRuleComplexType::OutputType& ThunerseeRuleComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ThunerseeRuleComplexType::OutputType& ThunerseeRuleComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ThunerseeRuleComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ThunerseeRuleComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ThunerseeRuleComplexType::IdType& ThunerseeRuleComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ThunerseeRuleComplexType::IdType& ThunerseeRuleComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ThunerseeRuleComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ThunerseeRuleComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ThunerseeRuleComplexType::NameOptional& ThunerseeRuleComplexType::
  getName () const
  {
    return this->name_;
  }

  ThunerseeRuleComplexType::NameOptional& ThunerseeRuleComplexType::
  getName ()
  {
    return this->name_;
  }

  void ThunerseeRuleComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ThunerseeRuleComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ThunerseeRuleComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ReservoirThunerseeRuleComplexType
  // 

  const ReservoirThunerseeRuleComplexType::StorageCharacteristicsType& ReservoirThunerseeRuleComplexType::
  getStorageCharacteristics () const
  {
    return this->storageCharacteristics_.get ();
  }

  ReservoirThunerseeRuleComplexType::StorageCharacteristicsType& ReservoirThunerseeRuleComplexType::
  getStorageCharacteristics ()
  {
    return this->storageCharacteristics_.get ();
  }

  void ReservoirThunerseeRuleComplexType::
  setStorageCharacteristics (const StorageCharacteristicsType& x)
  {
    this->storageCharacteristics_.set (x);
  }

  void ReservoirThunerseeRuleComplexType::
  setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > x)
  {
    this->storageCharacteristics_.set (x);
  }


  // WeirThunerseeRuleComplexType
  // 

  const WeirThunerseeRuleComplexType::CapacityCharacteristicsType& WeirThunerseeRuleComplexType::
  getCapacityCharacteristics () const
  {
    return this->capacityCharacteristics_.get ();
  }

  WeirThunerseeRuleComplexType::CapacityCharacteristicsType& WeirThunerseeRuleComplexType::
  getCapacityCharacteristics ()
  {
    return this->capacityCharacteristics_.get ();
  }

  void WeirThunerseeRuleComplexType::
  setCapacityCharacteristics (const CapacityCharacteristicsType& x)
  {
    this->capacityCharacteristics_.set (x);
  }

  void WeirThunerseeRuleComplexType::
  setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > x)
  {
    this->capacityCharacteristics_.set (x);
  }


  // TunnelThunerseeRuleComplexType
  // 

  const TunnelThunerseeRuleComplexType::LevelThresholdType& TunnelThunerseeRuleComplexType::
  getLevelThreshold () const
  {
    return this->levelThreshold_.get ();
  }

  TunnelThunerseeRuleComplexType::LevelThresholdType& TunnelThunerseeRuleComplexType::
  getLevelThreshold ()
  {
    return this->levelThreshold_.get ();
  }

  void TunnelThunerseeRuleComplexType::
  setLevelThreshold (const LevelThresholdType& x)
  {
    this->levelThreshold_.set (x);
  }

  const TunnelThunerseeRuleComplexType::CapacityCharacteristicsType& TunnelThunerseeRuleComplexType::
  getCapacityCharacteristics () const
  {
    return this->capacityCharacteristics_.get ();
  }

  TunnelThunerseeRuleComplexType::CapacityCharacteristicsType& TunnelThunerseeRuleComplexType::
  getCapacityCharacteristics ()
  {
    return this->capacityCharacteristics_.get ();
  }

  void TunnelThunerseeRuleComplexType::
  setCapacityCharacteristics (const CapacityCharacteristicsType& x)
  {
    this->capacityCharacteristics_.set (x);
  }

  void TunnelThunerseeRuleComplexType::
  setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > x)
  {
    this->capacityCharacteristics_.set (x);
  }


  // ThunerseeRuleInputComplexType
  // 

  const ThunerseeRuleInputComplexType::InflowType& ThunerseeRuleInputComplexType::
  getInflow () const
  {
    return this->inflow_.get ();
  }

  ThunerseeRuleInputComplexType::InflowType& ThunerseeRuleInputComplexType::
  getInflow ()
  {
    return this->inflow_.get ();
  }

  void ThunerseeRuleInputComplexType::
  setInflow (const InflowType& x)
  {
    this->inflow_.set (x);
  }

  void ThunerseeRuleInputComplexType::
  setInflow (::std::auto_ptr< InflowType > x)
  {
    this->inflow_.set (x);
  }

  const ThunerseeRuleInputComplexType::LevelType& ThunerseeRuleInputComplexType::
  getLevel () const
  {
    return this->level_.get ();
  }

  ThunerseeRuleInputComplexType::LevelType& ThunerseeRuleInputComplexType::
  getLevel ()
  {
    return this->level_.get ();
  }

  void ThunerseeRuleInputComplexType::
  setLevel (const LevelType& x)
  {
    this->level_.set (x);
  }

  void ThunerseeRuleInputComplexType::
  setLevel (::std::auto_ptr< LevelType > x)
  {
    this->level_.set (x);
  }

  const ThunerseeRuleInputComplexType::CatchmentType& ThunerseeRuleInputComplexType::
  getCatchment () const
  {
    return this->catchment_.get ();
  }

  ThunerseeRuleInputComplexType::CatchmentType& ThunerseeRuleInputComplexType::
  getCatchment ()
  {
    return this->catchment_.get ();
  }

  void ThunerseeRuleInputComplexType::
  setCatchment (const CatchmentType& x)
  {
    this->catchment_.set (x);
  }

  void ThunerseeRuleInputComplexType::
  setCatchment (::std::auto_ptr< CatchmentType > x)
  {
    this->catchment_.set (x);
  }


  // ThunerseeRuleOutputComplexType
  // 

  const ThunerseeRuleOutputComplexType::ReleaseWeirType& ThunerseeRuleOutputComplexType::
  getReleaseWeir () const
  {
    return this->releaseWeir_.get ();
  }

  ThunerseeRuleOutputComplexType::ReleaseWeirType& ThunerseeRuleOutputComplexType::
  getReleaseWeir ()
  {
    return this->releaseWeir_.get ();
  }

  void ThunerseeRuleOutputComplexType::
  setReleaseWeir (const ReleaseWeirType& x)
  {
    this->releaseWeir_.set (x);
  }

  void ThunerseeRuleOutputComplexType::
  setReleaseWeir (::std::auto_ptr< ReleaseWeirType > x)
  {
    this->releaseWeir_.set (x);
  }

  const ThunerseeRuleOutputComplexType::ReleaseTunnelType& ThunerseeRuleOutputComplexType::
  getReleaseTunnel () const
  {
    return this->releaseTunnel_.get ();
  }

  ThunerseeRuleOutputComplexType::ReleaseTunnelType& ThunerseeRuleOutputComplexType::
  getReleaseTunnel ()
  {
    return this->releaseTunnel_.get ();
  }

  void ThunerseeRuleOutputComplexType::
  setReleaseTunnel (const ReleaseTunnelType& x)
  {
    this->releaseTunnel_.set (x);
  }

  void ThunerseeRuleOutputComplexType::
  setReleaseTunnel (::std::auto_ptr< ReleaseTunnelType > x)
  {
    this->releaseTunnel_.set (x);
  }

  const ThunerseeRuleOutputComplexType::ReleaseTotalType& ThunerseeRuleOutputComplexType::
  getReleaseTotal () const
  {
    return this->releaseTotal_.get ();
  }

  ThunerseeRuleOutputComplexType::ReleaseTotalType& ThunerseeRuleOutputComplexType::
  getReleaseTotal ()
  {
    return this->releaseTotal_.get ();
  }

  void ThunerseeRuleOutputComplexType::
  setReleaseTotal (const ReleaseTotalType& x)
  {
    this->releaseTotal_.set (x);
  }

  void ThunerseeRuleOutputComplexType::
  setReleaseTotal (::std::auto_ptr< ReleaseTotalType > x)
  {
    this->releaseTotal_.set (x);
  }

  const ThunerseeRuleOutputComplexType::ActiveOptional& ThunerseeRuleOutputComplexType::
  getActive () const
  {
    return this->active_;
  }

  ThunerseeRuleOutputComplexType::ActiveOptional& ThunerseeRuleOutputComplexType::
  getActive ()
  {
    return this->active_;
  }

  void ThunerseeRuleOutputComplexType::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void ThunerseeRuleOutputComplexType::
  setActive (const ActiveOptional& x)
  {
    this->active_ = x;
  }

  void ThunerseeRuleOutputComplexType::
  setActive (::std::auto_ptr< ActiveType > x)
  {
    this->active_.set (x);
  }


  // AebiRuleComplexType
  // 

  const AebiRuleComplexType::FactorRTGType& AebiRuleComplexType::
  getFactorRTG () const
  {
    return this->FactorRTG_.get ();
  }

  AebiRuleComplexType::FactorRTGType& AebiRuleComplexType::
  getFactorRTG ()
  {
    return this->FactorRTG_.get ();
  }

  void AebiRuleComplexType::
  setFactorRTG (const FactorRTGType& x)
  {
    this->FactorRTG_.set (x);
  }

  AebiRuleComplexType::FactorRTGType AebiRuleComplexType::
  getFactorRTGDefaultValue ()
  {
    return FactorRTGType (1.0);
  }

  const AebiRuleComplexType::LangeteFallType& AebiRuleComplexType::
  getLangeteFall () const
  {
    return this->LangeteFall_.get ();
  }

  AebiRuleComplexType::LangeteFallType& AebiRuleComplexType::
  getLangeteFall ()
  {
    return this->LangeteFall_.get ();
  }

  void AebiRuleComplexType::
  setLangeteFall (const LangeteFallType& x)
  {
    this->LangeteFall_.set (x);
  }

  void AebiRuleComplexType::
  setLangeteFall (::std::auto_ptr< LangeteFallType > x)
  {
    this->LangeteFall_.set (x);
  }

  const AebiRuleComplexType::InputType& AebiRuleComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  AebiRuleComplexType::InputType& AebiRuleComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void AebiRuleComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void AebiRuleComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const AebiRuleComplexType::OutputType& AebiRuleComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  AebiRuleComplexType::OutputType& AebiRuleComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void AebiRuleComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void AebiRuleComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const AebiRuleComplexType::IdType& AebiRuleComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  AebiRuleComplexType::IdType& AebiRuleComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void AebiRuleComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void AebiRuleComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const AebiRuleComplexType::NameOptional& AebiRuleComplexType::
  getName () const
  {
    return this->name_;
  }

  AebiRuleComplexType::NameOptional& AebiRuleComplexType::
  getName ()
  {
    return this->name_;
  }

  void AebiRuleComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void AebiRuleComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void AebiRuleComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // AebiRuleInputComplexType
  // 

  const AebiRuleInputComplexType::AareBrueggType& AebiRuleInputComplexType::
  getAareBruegg () const
  {
    return this->AareBruegg_.get ();
  }

  AebiRuleInputComplexType::AareBrueggType& AebiRuleInputComplexType::
  getAareBruegg ()
  {
    return this->AareBruegg_.get ();
  }

  void AebiRuleInputComplexType::
  setAareBruegg (const AareBrueggType& x)
  {
    this->AareBruegg_.set (x);
  }

  void AebiRuleInputComplexType::
  setAareBruegg (::std::auto_ptr< AareBrueggType > x)
  {
    this->AareBruegg_.set (x);
  }

  const AebiRuleInputComplexType::AareBrueggMin2Type& AebiRuleInputComplexType::
  getAareBrueggMin2 () const
  {
    return this->AareBrueggMin2_.get ();
  }

  AebiRuleInputComplexType::AareBrueggMin2Type& AebiRuleInputComplexType::
  getAareBrueggMin2 ()
  {
    return this->AareBrueggMin2_.get ();
  }

  void AebiRuleInputComplexType::
  setAareBrueggMin2 (const AareBrueggMin2Type& x)
  {
    this->AareBrueggMin2_.set (x);
  }

  void AebiRuleInputComplexType::
  setAareBrueggMin2 (::std::auto_ptr< AareBrueggMin2Type > x)
  {
    this->AareBrueggMin2_.set (x);
  }

  const AebiRuleInputComplexType::EmenmattType& AebiRuleInputComplexType::
  getEmenmatt () const
  {
    return this->Emenmatt_.get ();
  }

  AebiRuleInputComplexType::EmenmattType& AebiRuleInputComplexType::
  getEmenmatt ()
  {
    return this->Emenmatt_.get ();
  }

  void AebiRuleInputComplexType::
  setEmenmatt (const EmenmattType& x)
  {
    this->Emenmatt_.set (x);
  }

  void AebiRuleInputComplexType::
  setEmenmatt (::std::auto_ptr< EmenmattType > x)
  {
    this->Emenmatt_.set (x);
  }

  const AebiRuleInputComplexType::EmenmattMin4Type& AebiRuleInputComplexType::
  getEmenmattMin4 () const
  {
    return this->EmenmattMin4_.get ();
  }

  AebiRuleInputComplexType::EmenmattMin4Type& AebiRuleInputComplexType::
  getEmenmattMin4 ()
  {
    return this->EmenmattMin4_.get ();
  }

  void AebiRuleInputComplexType::
  setEmenmattMin4 (const EmenmattMin4Type& x)
  {
    this->EmenmattMin4_.set (x);
  }

  void AebiRuleInputComplexType::
  setEmenmattMin4 (::std::auto_ptr< EmenmattMin4Type > x)
  {
    this->EmenmattMin4_.set (x);
  }

  const AebiRuleInputComplexType::LangetenType& AebiRuleInputComplexType::
  getLangeten () const
  {
    return this->Langeten_.get ();
  }

  AebiRuleInputComplexType::LangetenType& AebiRuleInputComplexType::
  getLangeten ()
  {
    return this->Langeten_.get ();
  }

  void AebiRuleInputComplexType::
  setLangeten (const LangetenType& x)
  {
    this->Langeten_.set (x);
  }

  void AebiRuleInputComplexType::
  setLangeten (::std::auto_ptr< LangetenType > x)
  {
    this->Langeten_.set (x);
  }

  const AebiRuleInputComplexType::LangetenMin4Type& AebiRuleInputComplexType::
  getLangetenMin4 () const
  {
    return this->LangetenMin4_.get ();
  }

  AebiRuleInputComplexType::LangetenMin4Type& AebiRuleInputComplexType::
  getLangetenMin4 ()
  {
    return this->LangetenMin4_.get ();
  }

  void AebiRuleInputComplexType::
  setLangetenMin4 (const LangetenMin4Type& x)
  {
    this->LangetenMin4_.set (x);
  }

  void AebiRuleInputComplexType::
  setLangetenMin4 (::std::auto_ptr< LangetenMin4Type > x)
  {
    this->LangetenMin4_.set (x);
  }

  const AebiRuleInputComplexType::AareMurgType& AebiRuleInputComplexType::
  getAareMurg () const
  {
    return this->AareMurg_.get ();
  }

  AebiRuleInputComplexType::AareMurgType& AebiRuleInputComplexType::
  getAareMurg ()
  {
    return this->AareMurg_.get ();
  }

  void AebiRuleInputComplexType::
  setAareMurg (const AareMurgType& x)
  {
    this->AareMurg_.set (x);
  }

  void AebiRuleInputComplexType::
  setAareMurg (::std::auto_ptr< AareMurgType > x)
  {
    this->AareMurg_.set (x);
  }

  const AebiRuleInputComplexType::PegelBielerseeType& AebiRuleInputComplexType::
  getPegelBielersee () const
  {
    return this->PegelBielersee_.get ();
  }

  AebiRuleInputComplexType::PegelBielerseeType& AebiRuleInputComplexType::
  getPegelBielersee ()
  {
    return this->PegelBielersee_.get ();
  }

  void AebiRuleInputComplexType::
  setPegelBielersee (const PegelBielerseeType& x)
  {
    this->PegelBielersee_.set (x);
  }

  void AebiRuleInputComplexType::
  setPegelBielersee (::std::auto_ptr< PegelBielerseeType > x)
  {
    this->PegelBielersee_.set (x);
  }

  const AebiRuleInputComplexType::AbflussReglementPortType& AebiRuleInputComplexType::
  getAbflussReglementPort () const
  {
    return this->AbflussReglementPort_.get ();
  }

  AebiRuleInputComplexType::AbflussReglementPortType& AebiRuleInputComplexType::
  getAbflussReglementPort ()
  {
    return this->AbflussReglementPort_.get ();
  }

  void AebiRuleInputComplexType::
  setAbflussReglementPort (const AbflussReglementPortType& x)
  {
    this->AbflussReglementPort_.set (x);
  }

  void AebiRuleInputComplexType::
  setAbflussReglementPort (::std::auto_ptr< AbflussReglementPortType > x)
  {
    this->AbflussReglementPort_.set (x);
  }


  // AebiRuleOutputComplexType
  // 

  const AebiRuleOutputComplexType::RTGType& AebiRuleOutputComplexType::
  getRTG () const
  {
    return this->RTG_.get ();
  }

  AebiRuleOutputComplexType::RTGType& AebiRuleOutputComplexType::
  getRTG ()
  {
    return this->RTG_.get ();
  }

  void AebiRuleOutputComplexType::
  setRTG (const RTGType& x)
  {
    this->RTG_.set (x);
  }

  void AebiRuleOutputComplexType::
  setRTG (::std::auto_ptr< RTGType > x)
  {
    this->RTG_.set (x);
  }

  const AebiRuleOutputComplexType::AareMurg_oKWMin1Type& AebiRuleOutputComplexType::
  getAareMurg_oKWMin1 () const
  {
    return this->AareMurg_oKWMin1_.get ();
  }

  AebiRuleOutputComplexType::AareMurg_oKWMin1Type& AebiRuleOutputComplexType::
  getAareMurg_oKWMin1 ()
  {
    return this->AareMurg_oKWMin1_.get ();
  }

  void AebiRuleOutputComplexType::
  setAareMurg_oKWMin1 (const AareMurg_oKWMin1Type& x)
  {
    this->AareMurg_oKWMin1_.set (x);
  }

  void AebiRuleOutputComplexType::
  setAareMurg_oKWMin1 (::std::auto_ptr< AareMurg_oKWMin1Type > x)
  {
    this->AareMurg_oKWMin1_.set (x);
  }

  const AebiRuleOutputComplexType::ProvMaxAbflussPortType& AebiRuleOutputComplexType::
  getProvMaxAbflussPort () const
  {
    return this->ProvMaxAbflussPort_.get ();
  }

  AebiRuleOutputComplexType::ProvMaxAbflussPortType& AebiRuleOutputComplexType::
  getProvMaxAbflussPort ()
  {
    return this->ProvMaxAbflussPort_.get ();
  }

  void AebiRuleOutputComplexType::
  setProvMaxAbflussPort (const ProvMaxAbflussPortType& x)
  {
    this->ProvMaxAbflussPort_.set (x);
  }

  void AebiRuleOutputComplexType::
  setProvMaxAbflussPort (::std::auto_ptr< ProvMaxAbflussPortType > x)
  {
    this->ProvMaxAbflussPort_.set (x);
  }

  const AebiRuleOutputComplexType::MaxAbflussPortType& AebiRuleOutputComplexType::
  getMaxAbflussPort () const
  {
    return this->MaxAbflussPort_.get ();
  }

  AebiRuleOutputComplexType::MaxAbflussPortType& AebiRuleOutputComplexType::
  getMaxAbflussPort ()
  {
    return this->MaxAbflussPort_.get ();
  }

  void AebiRuleOutputComplexType::
  setMaxAbflussPort (const MaxAbflussPortType& x)
  {
    this->MaxAbflussPort_.set (x);
  }

  void AebiRuleOutputComplexType::
  setMaxAbflussPort (::std::auto_ptr< MaxAbflussPortType > x)
  {
    this->MaxAbflussPort_.set (x);
  }

  const AebiRuleOutputComplexType::AbflussaenderungPortType& AebiRuleOutputComplexType::
  getAbflussaenderungPort () const
  {
    return this->AbflussaenderungPort_.get ();
  }

  AebiRuleOutputComplexType::AbflussaenderungPortType& AebiRuleOutputComplexType::
  getAbflussaenderungPort ()
  {
    return this->AbflussaenderungPort_.get ();
  }

  void AebiRuleOutputComplexType::
  setAbflussaenderungPort (const AbflussaenderungPortType& x)
  {
    this->AbflussaenderungPort_.set (x);
  }

  void AebiRuleOutputComplexType::
  setAbflussaenderungPort (::std::auto_ptr< AbflussaenderungPortType > x)
  {
    this->AbflussaenderungPort_.set (x);
  }


  // LookupTableComplexType
  // 

  const LookupTableComplexType::PropertySequence& LookupTableComplexType::
  getProperty () const
  {
    return this->property_;
  }

  LookupTableComplexType::PropertySequence& LookupTableComplexType::
  getProperty ()
  {
    return this->property_;
  }

  void LookupTableComplexType::
  setProperty (const PropertySequence& s)
  {
    this->property_ = s;
  }

  const LookupTableComplexType::TableOptional& LookupTableComplexType::
  getTable () const
  {
    return this->table_;
  }

  LookupTableComplexType::TableOptional& LookupTableComplexType::
  getTable ()
  {
    return this->table_;
  }

  void LookupTableComplexType::
  setTable (const TableType& x)
  {
    this->table_.set (x);
  }

  void LookupTableComplexType::
  setTable (const TableOptional& x)
  {
    this->table_ = x;
  }

  void LookupTableComplexType::
  setTable (::std::auto_ptr< TableType > x)
  {
    this->table_.set (x);
  }

  const LookupTableComplexType::TableExternalOptional& LookupTableComplexType::
  getTableExternal () const
  {
    return this->tableExternal_;
  }

  LookupTableComplexType::TableExternalOptional& LookupTableComplexType::
  getTableExternal ()
  {
    return this->tableExternal_;
  }

  void LookupTableComplexType::
  setTableExternal (const TableExternalType& x)
  {
    this->tableExternal_.set (x);
  }

  void LookupTableComplexType::
  setTableExternal (const TableExternalOptional& x)
  {
    this->tableExternal_ = x;
  }

  void LookupTableComplexType::
  setTableExternal (::std::auto_ptr< TableExternalType > x)
  {
    this->tableExternal_.set (x);
  }

  const LookupTableComplexType::InterpolationOptionOptional& LookupTableComplexType::
  getInterpolationOption () const
  {
    return this->interpolationOption_;
  }

  LookupTableComplexType::InterpolationOptionOptional& LookupTableComplexType::
  getInterpolationOption ()
  {
    return this->interpolationOption_;
  }

  void LookupTableComplexType::
  setInterpolationOption (const InterpolationOptionType& x)
  {
    this->interpolationOption_.set (x);
  }

  void LookupTableComplexType::
  setInterpolationOption (const InterpolationOptionOptional& x)
  {
    this->interpolationOption_ = x;
  }

  void LookupTableComplexType::
  setInterpolationOption (::std::auto_ptr< InterpolationOptionType > x)
  {
    this->interpolationOption_.set (x);
  }

  const LookupTableComplexType::ExtrapolationOptionOptional& LookupTableComplexType::
  getExtrapolationOption () const
  {
    return this->extrapolationOption_;
  }

  LookupTableComplexType::ExtrapolationOptionOptional& LookupTableComplexType::
  getExtrapolationOption ()
  {
    return this->extrapolationOption_;
  }

  void LookupTableComplexType::
  setExtrapolationOption (const ExtrapolationOptionType& x)
  {
    this->extrapolationOption_.set (x);
  }

  void LookupTableComplexType::
  setExtrapolationOption (const ExtrapolationOptionOptional& x)
  {
    this->extrapolationOption_ = x;
  }

  void LookupTableComplexType::
  setExtrapolationOption (::std::auto_ptr< ExtrapolationOptionType > x)
  {
    this->extrapolationOption_.set (x);
  }

  const LookupTableComplexType::InputType& LookupTableComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  LookupTableComplexType::InputType& LookupTableComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void LookupTableComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void LookupTableComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const LookupTableComplexType::OutputType& LookupTableComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  LookupTableComplexType::OutputType& LookupTableComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void LookupTableComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void LookupTableComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const LookupTableComplexType::IdType& LookupTableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  LookupTableComplexType::IdType& LookupTableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void LookupTableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void LookupTableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const LookupTableComplexType::NameOptional& LookupTableComplexType::
  getName () const
  {
    return this->name_;
  }

  LookupTableComplexType::NameOptional& LookupTableComplexType::
  getName ()
  {
    return this->name_;
  }

  void LookupTableComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void LookupTableComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void LookupTableComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // TableLookupTableComplexType
  // 

  const TableLookupTableComplexType::RecordSequence& TableLookupTableComplexType::
  getRecord () const
  {
    return this->record_;
  }

  TableLookupTableComplexType::RecordSequence& TableLookupTableComplexType::
  getRecord ()
  {
    return this->record_;
  }

  void TableLookupTableComplexType::
  setRecord (const RecordSequence& s)
  {
    this->record_ = s;
  }


  // Lookup2DTableComplexType
  // 

  const Lookup2DTableComplexType::TableType& Lookup2DTableComplexType::
  getTable () const
  {
    return this->table_.get ();
  }

  Lookup2DTableComplexType::TableType& Lookup2DTableComplexType::
  getTable ()
  {
    return this->table_.get ();
  }

  void Lookup2DTableComplexType::
  setTable (const TableType& x)
  {
    this->table_.set (x);
  }

  void Lookup2DTableComplexType::
  setTable (::std::auto_ptr< TableType > x)
  {
    this->table_.set (x);
  }

  const Lookup2DTableComplexType::InputType& Lookup2DTableComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  Lookup2DTableComplexType::InputType& Lookup2DTableComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void Lookup2DTableComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void Lookup2DTableComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const Lookup2DTableComplexType::OutputType& Lookup2DTableComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  Lookup2DTableComplexType::OutputType& Lookup2DTableComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void Lookup2DTableComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void Lookup2DTableComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const Lookup2DTableComplexType::IdType& Lookup2DTableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  Lookup2DTableComplexType::IdType& Lookup2DTableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void Lookup2DTableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void Lookup2DTableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const Lookup2DTableComplexType::NameOptional& Lookup2DTableComplexType::
  getName () const
  {
    return this->name_;
  }

  Lookup2DTableComplexType::NameOptional& Lookup2DTableComplexType::
  getName ()
  {
    return this->name_;
  }

  void Lookup2DTableComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Lookup2DTableComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void Lookup2DTableComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // Table2DLookupTableComplexType
  // 

  const Table2DLookupTableComplexType::XType& Table2DLookupTableComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  Table2DLookupTableComplexType::XType& Table2DLookupTableComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void Table2DLookupTableComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void Table2DLookupTableComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const Table2DLookupTableComplexType::YType& Table2DLookupTableComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  Table2DLookupTableComplexType::YType& Table2DLookupTableComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void Table2DLookupTableComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void Table2DLookupTableComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const Table2DLookupTableComplexType::MatrixType& Table2DLookupTableComplexType::
  getMatrix () const
  {
    return this->matrix_.get ();
  }

  Table2DLookupTableComplexType::MatrixType& Table2DLookupTableComplexType::
  getMatrix ()
  {
    return this->matrix_.get ();
  }

  void Table2DLookupTableComplexType::
  setMatrix (const MatrixType& x)
  {
    this->matrix_.set (x);
  }

  void Table2DLookupTableComplexType::
  setMatrix (::std::auto_ptr< MatrixType > x)
  {
    this->matrix_.set (x);
  }


  // XDimComplexType
  // 

  const XDimComplexType::XDimSequence& XDimComplexType::
  getXDim () const
  {
    return this->xDim_;
  }

  XDimComplexType::XDimSequence& XDimComplexType::
  getXDim ()
  {
    return this->xDim_;
  }

  void XDimComplexType::
  setXDim (const XDimSequence& s)
  {
    this->xDim_ = s;
  }


  // YDimComplexType
  // 

  const YDimComplexType::YDimSequence& YDimComplexType::
  getYDim () const
  {
    return this->yDim_;
  }

  YDimComplexType::YDimSequence& YDimComplexType::
  getYDim ()
  {
    return this->yDim_;
  }

  void YDimComplexType::
  setYDim (const YDimSequence& s)
  {
    this->yDim_ = s;
  }


  // ValueArrayComplexType
  // 

  const ValueArrayComplexType::ValueSequence& ValueArrayComplexType::
  getValue () const
  {
    return this->value_;
  }

  ValueArrayComplexType::ValueSequence& ValueArrayComplexType::
  getValue ()
  {
    return this->value_;
  }

  void ValueArrayComplexType::
  setValue (const ValueSequence& s)
  {
    this->value_ = s;
  }


  // IntervalComplexType
  // 

  const IntervalComplexType::SettingBelowType& IntervalComplexType::
  getSettingBelow () const
  {
    return this->settingBelow_.get ();
  }

  IntervalComplexType::SettingBelowType& IntervalComplexType::
  getSettingBelow ()
  {
    return this->settingBelow_.get ();
  }

  void IntervalComplexType::
  setSettingBelow (const SettingBelowType& x)
  {
    this->settingBelow_.set (x);
  }

  const IntervalComplexType::SettingAboveType& IntervalComplexType::
  getSettingAbove () const
  {
    return this->settingAbove_.get ();
  }

  IntervalComplexType::SettingAboveType& IntervalComplexType::
  getSettingAbove ()
  {
    return this->settingAbove_.get ();
  }

  void IntervalComplexType::
  setSettingAbove (const SettingAboveType& x)
  {
    this->settingAbove_.set (x);
  }

  const IntervalComplexType::SettingMaxSpeedOptional& IntervalComplexType::
  getSettingMaxSpeed () const
  {
    return this->settingMaxSpeed_;
  }

  IntervalComplexType::SettingMaxSpeedOptional& IntervalComplexType::
  getSettingMaxSpeed ()
  {
    return this->settingMaxSpeed_;
  }

  void IntervalComplexType::
  setSettingMaxSpeed (const SettingMaxSpeedType& x)
  {
    this->settingMaxSpeed_.set (x);
  }

  void IntervalComplexType::
  setSettingMaxSpeed (const SettingMaxSpeedOptional& x)
  {
    this->settingMaxSpeed_ = x;
  }

  const IntervalComplexType::SettingMaxStepOptional& IntervalComplexType::
  getSettingMaxStep () const
  {
    return this->settingMaxStep_;
  }

  IntervalComplexType::SettingMaxStepOptional& IntervalComplexType::
  getSettingMaxStep ()
  {
    return this->settingMaxStep_;
  }

  void IntervalComplexType::
  setSettingMaxStep (const SettingMaxStepType& x)
  {
    this->settingMaxStep_.set (x);
  }

  void IntervalComplexType::
  setSettingMaxStep (const SettingMaxStepOptional& x)
  {
    this->settingMaxStep_ = x;
  }

  const IntervalComplexType::DeadbandSetpointAbsoluteOptional& IntervalComplexType::
  getDeadbandSetpointAbsolute () const
  {
    return this->deadbandSetpointAbsolute_;
  }

  IntervalComplexType::DeadbandSetpointAbsoluteOptional& IntervalComplexType::
  getDeadbandSetpointAbsolute ()
  {
    return this->deadbandSetpointAbsolute_;
  }

  void IntervalComplexType::
  setDeadbandSetpointAbsolute (const DeadbandSetpointAbsoluteType& x)
  {
    this->deadbandSetpointAbsolute_.set (x);
  }

  void IntervalComplexType::
  setDeadbandSetpointAbsolute (const DeadbandSetpointAbsoluteOptional& x)
  {
    this->deadbandSetpointAbsolute_ = x;
  }

  const IntervalComplexType::DeadbandSetpointRelativeOptional& IntervalComplexType::
  getDeadbandSetpointRelative () const
  {
    return this->deadbandSetpointRelative_;
  }

  IntervalComplexType::DeadbandSetpointRelativeOptional& IntervalComplexType::
  getDeadbandSetpointRelative ()
  {
    return this->deadbandSetpointRelative_;
  }

  void IntervalComplexType::
  setDeadbandSetpointRelative (const DeadbandSetpointRelativeType& x)
  {
    this->deadbandSetpointRelative_.set (x);
  }

  void IntervalComplexType::
  setDeadbandSetpointRelative (const DeadbandSetpointRelativeOptional& x)
  {
    this->deadbandSetpointRelative_ = x;
  }

  const IntervalComplexType::InputType& IntervalComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  IntervalComplexType::InputType& IntervalComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void IntervalComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void IntervalComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const IntervalComplexType::OutputType& IntervalComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  IntervalComplexType::OutputType& IntervalComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void IntervalComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void IntervalComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const IntervalComplexType::IdType& IntervalComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  IntervalComplexType::IdType& IntervalComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void IntervalComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void IntervalComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const IntervalComplexType::NameOptional& IntervalComplexType::
  getName () const
  {
    return this->name_;
  }

  IntervalComplexType::NameOptional& IntervalComplexType::
  getName ()
  {
    return this->name_;
  }

  void IntervalComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void IntervalComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void IntervalComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // IntervalInputComplexType
  // 

  const IntervalInputComplexType::XType& IntervalInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  IntervalInputComplexType::XType& IntervalInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void IntervalInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void IntervalInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const IntervalInputComplexType::SetpointType& IntervalInputComplexType::
  getSetpoint () const
  {
    return this->setpoint_.get ();
  }

  IntervalInputComplexType::SetpointType& IntervalInputComplexType::
  getSetpoint ()
  {
    return this->setpoint_.get ();
  }

  void IntervalInputComplexType::
  setSetpoint (const SetpointType& x)
  {
    this->setpoint_.set (x);
  }

  void IntervalInputComplexType::
  setSetpoint (::std::auto_ptr< SetpointType > x)
  {
    this->setpoint_.set (x);
  }


  // IntervalOutputComplexType
  // 

  const IntervalOutputComplexType::YType& IntervalOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  IntervalOutputComplexType::YType& IntervalOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void IntervalOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void IntervalOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const IntervalOutputComplexType::StatusType& IntervalOutputComplexType::
  getStatus () const
  {
    return this->status_.get ();
  }

  IntervalOutputComplexType::StatusType& IntervalOutputComplexType::
  getStatus ()
  {
    return this->status_.get ();
  }

  void IntervalOutputComplexType::
  setStatus (const StatusType& x)
  {
    this->status_.set (x);
  }

  void IntervalOutputComplexType::
  setStatus (::std::auto_ptr< StatusType > x)
  {
    this->status_.set (x);
  }


  // DateLookupTableComplexType
  // 

  const DateLookupTableComplexType::InterpolationOptionsType& DateLookupTableComplexType::
  getInterpolationOptions () const
  {
    return this->interpolationOptions_.get ();
  }

  DateLookupTableComplexType::InterpolationOptionsType& DateLookupTableComplexType::
  getInterpolationOptions ()
  {
    return this->interpolationOptions_.get ();
  }

  void DateLookupTableComplexType::
  setInterpolationOptions (const InterpolationOptionsType& x)
  {
    this->interpolationOptions_.set (x);
  }

  void DateLookupTableComplexType::
  setInterpolationOptions (::std::auto_ptr< InterpolationOptionsType > x)
  {
    this->interpolationOptions_.set (x);
  }

  const DateLookupTableComplexType::DateRecordSequence& DateLookupTableComplexType::
  getDateRecord () const
  {
    return this->dateRecord_;
  }

  DateLookupTableComplexType::DateRecordSequence& DateLookupTableComplexType::
  getDateRecord ()
  {
    return this->dateRecord_;
  }

  void DateLookupTableComplexType::
  setDateRecord (const DateRecordSequence& s)
  {
    this->dateRecord_ = s;
  }

  const DateLookupTableComplexType::InputType& DateLookupTableComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  DateLookupTableComplexType::InputType& DateLookupTableComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void DateLookupTableComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void DateLookupTableComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const DateLookupTableComplexType::OutputType& DateLookupTableComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  DateLookupTableComplexType::OutputType& DateLookupTableComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void DateLookupTableComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void DateLookupTableComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const DateLookupTableComplexType::IdType& DateLookupTableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  DateLookupTableComplexType::IdType& DateLookupTableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void DateLookupTableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void DateLookupTableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const DateLookupTableComplexType::NameOptional& DateLookupTableComplexType::
  getName () const
  {
    return this->name_;
  }

  DateLookupTableComplexType::NameOptional& DateLookupTableComplexType::
  getName ()
  {
    return this->name_;
  }

  void DateLookupTableComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DateLookupTableComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DateLookupTableComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InterpolationOptionsComplexType
  // 

  const InterpolationOptionsComplexType::DateType& InterpolationOptionsComplexType::
  getDate () const
  {
    return this->date_.get ();
  }

  InterpolationOptionsComplexType::DateType& InterpolationOptionsComplexType::
  getDate ()
  {
    return this->date_.get ();
  }

  void InterpolationOptionsComplexType::
  setDate (const DateType& x)
  {
    this->date_.set (x);
  }

  void InterpolationOptionsComplexType::
  setDate (::std::auto_ptr< DateType > x)
  {
    this->date_.set (x);
  }

  const InterpolationOptionsComplexType::ValueType& InterpolationOptionsComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  InterpolationOptionsComplexType::ValueType& InterpolationOptionsComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void InterpolationOptionsComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  void InterpolationOptionsComplexType::
  setValue (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }


  // DateRecord2ComplexType
  // 

  const DateRecord2ComplexType::RecordSequence& DateRecord2ComplexType::
  getRecord () const
  {
    return this->record_;
  }

  DateRecord2ComplexType::RecordSequence& DateRecord2ComplexType::
  getRecord ()
  {
    return this->record_;
  }

  void DateRecord2ComplexType::
  setRecord (const RecordSequence& s)
  {
    this->record_ = s;
  }

  const DateRecord2ComplexType::MonthDayType& DateRecord2ComplexType::
  getMonthDay () const
  {
    return this->monthDay_.get ();
  }

  DateRecord2ComplexType::MonthDayType& DateRecord2ComplexType::
  getMonthDay ()
  {
    return this->monthDay_.get ();
  }

  void DateRecord2ComplexType::
  setMonthDay (const MonthDayType& x)
  {
    this->monthDay_.set (x);
  }

  void DateRecord2ComplexType::
  setMonthDay (::std::auto_ptr< MonthDayType > x)
  {
    this->monthDay_.set (x);
  }


  // DateRecord2DataComplexType
  // 

  const DateRecord2DataComplexType::XType& DateRecord2DataComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  DateRecord2DataComplexType::XType& DateRecord2DataComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void DateRecord2DataComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  const DateRecord2DataComplexType::YType& DateRecord2DataComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  DateRecord2DataComplexType::YType& DateRecord2DataComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void DateRecord2DataComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }


  // DateLookupTableInputComplexType
  // 

  const DateLookupTableInputComplexType::XType& DateLookupTableInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  DateLookupTableInputComplexType::XType& DateLookupTableInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void DateLookupTableInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void DateLookupTableInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const DateLookupTableInputComplexType::YOptional& DateLookupTableInputComplexType::
  getY () const
  {
    return this->y_;
  }

  DateLookupTableInputComplexType::YOptional& DateLookupTableInputComplexType::
  getY ()
  {
    return this->y_;
  }

  void DateLookupTableInputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void DateLookupTableInputComplexType::
  setY (const YOptional& x)
  {
    this->y_ = x;
  }

  void DateLookupTableInputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // DateLookupTableOutputComplexType
  // 

  const DateLookupTableOutputComplexType::YType& DateLookupTableOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  DateLookupTableOutputComplexType::YType& DateLookupTableOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void DateLookupTableOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void DateLookupTableOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const DateLookupTableOutputComplexType::ActiveOptional& DateLookupTableOutputComplexType::
  getActive () const
  {
    return this->active_;
  }

  DateLookupTableOutputComplexType::ActiveOptional& DateLookupTableOutputComplexType::
  getActive ()
  {
    return this->active_;
  }

  void DateLookupTableOutputComplexType::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void DateLookupTableOutputComplexType::
  setActive (const ActiveOptional& x)
  {
    this->active_ = x;
  }

  void DateLookupTableOutputComplexType::
  setActive (::std::auto_ptr< ActiveType > x)
  {
    this->active_.set (x);
  }


  // LookupTableInputComplexType
  // 

  const LookupTableInputComplexType::XType& LookupTableInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  LookupTableInputComplexType::XType& LookupTableInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void LookupTableInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void LookupTableInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const LookupTableInputComplexType::YOptional& LookupTableInputComplexType::
  getY () const
  {
    return this->y_;
  }

  LookupTableInputComplexType::YOptional& LookupTableInputComplexType::
  getY ()
  {
    return this->y_;
  }

  void LookupTableInputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void LookupTableInputComplexType::
  setY (const YOptional& x)
  {
    this->y_ = x;
  }

  void LookupTableInputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // LookupTableOutputComplexType
  // 

  const LookupTableOutputComplexType::YType& LookupTableOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  LookupTableOutputComplexType::YType& LookupTableOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void LookupTableOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void LookupTableOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // Lookup2DTableInputComplexType
  // 

  const Lookup2DTableInputComplexType::XType& Lookup2DTableInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  Lookup2DTableInputComplexType::XType& Lookup2DTableInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void Lookup2DTableInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void Lookup2DTableInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const Lookup2DTableInputComplexType::YType& Lookup2DTableInputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  Lookup2DTableInputComplexType::YType& Lookup2DTableInputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void Lookup2DTableInputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void Lookup2DTableInputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const Lookup2DTableInputComplexType::ZOptional& Lookup2DTableInputComplexType::
  getZ () const
  {
    return this->z_;
  }

  Lookup2DTableInputComplexType::ZOptional& Lookup2DTableInputComplexType::
  getZ ()
  {
    return this->z_;
  }

  void Lookup2DTableInputComplexType::
  setZ (const ZType& x)
  {
    this->z_.set (x);
  }

  void Lookup2DTableInputComplexType::
  setZ (const ZOptional& x)
  {
    this->z_ = x;
  }

  void Lookup2DTableInputComplexType::
  setZ (::std::auto_ptr< ZType > x)
  {
    this->z_.set (x);
  }


  // Lookup2DTableOutputComplexType
  // 

  const Lookup2DTableOutputComplexType::ZType& Lookup2DTableOutputComplexType::
  getZ () const
  {
    return this->z_.get ();
  }

  Lookup2DTableOutputComplexType::ZType& Lookup2DTableOutputComplexType::
  getZ ()
  {
    return this->z_.get ();
  }

  void Lookup2DTableOutputComplexType::
  setZ (const ZType& x)
  {
    this->z_.set (x);
  }

  void Lookup2DTableOutputComplexType::
  setZ (::std::auto_ptr< ZType > x)
  {
    this->z_.set (x);
  }


  // PolygonLookupComplexType
  // 

  const PolygonLookupComplexType::PolygonsType& PolygonLookupComplexType::
  getPolygons () const
  {
    return this->polygons_.get ();
  }

  PolygonLookupComplexType::PolygonsType& PolygonLookupComplexType::
  getPolygons ()
  {
    return this->polygons_.get ();
  }

  void PolygonLookupComplexType::
  setPolygons (const PolygonsType& x)
  {
    this->polygons_.set (x);
  }

  void PolygonLookupComplexType::
  setPolygons (::std::auto_ptr< PolygonsType > x)
  {
    this->polygons_.set (x);
  }

  const PolygonLookupComplexType::DefaultOptional& PolygonLookupComplexType::
  getDefault () const
  {
    return this->default__;
  }

  PolygonLookupComplexType::DefaultOptional& PolygonLookupComplexType::
  getDefault ()
  {
    return this->default__;
  }

  void PolygonLookupComplexType::
  setDefault (const DefaultType& x)
  {
    this->default__.set (x);
  }

  void PolygonLookupComplexType::
  setDefault (const DefaultOptional& x)
  {
    this->default__ = x;
  }

  PolygonLookupComplexType::DefaultType PolygonLookupComplexType::
  getDefaultDefaultValue ()
  {
    return DefaultType (.0);
  }

  const PolygonLookupComplexType::TrueOptional& PolygonLookupComplexType::
  getTrue () const
  {
    return this->true__;
  }

  PolygonLookupComplexType::TrueOptional& PolygonLookupComplexType::
  getTrue ()
  {
    return this->true__;
  }

  void PolygonLookupComplexType::
  setTrue (const TrueType& x)
  {
    this->true__.set (x);
  }

  void PolygonLookupComplexType::
  setTrue (const TrueOptional& x)
  {
    this->true__ = x;
  }

  void PolygonLookupComplexType::
  setTrue (::std::auto_ptr< TrueType > x)
  {
    this->true__.set (x);
  }

  const PolygonLookupComplexType::FalseOptional& PolygonLookupComplexType::
  getFalse () const
  {
    return this->false__;
  }

  PolygonLookupComplexType::FalseOptional& PolygonLookupComplexType::
  getFalse ()
  {
    return this->false__;
  }

  void PolygonLookupComplexType::
  setFalse (const FalseType& x)
  {
    this->false__.set (x);
  }

  void PolygonLookupComplexType::
  setFalse (const FalseOptional& x)
  {
    this->false__ = x;
  }

  void PolygonLookupComplexType::
  setFalse (::std::auto_ptr< FalseType > x)
  {
    this->false__.set (x);
  }

  const PolygonLookupComplexType::InputType& PolygonLookupComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  PolygonLookupComplexType::InputType& PolygonLookupComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void PolygonLookupComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void PolygonLookupComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const PolygonLookupComplexType::OutputType& PolygonLookupComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  PolygonLookupComplexType::OutputType& PolygonLookupComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void PolygonLookupComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void PolygonLookupComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const PolygonLookupComplexType::IdType& PolygonLookupComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  PolygonLookupComplexType::IdType& PolygonLookupComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void PolygonLookupComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void PolygonLookupComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const PolygonLookupComplexType::NameOptional& PolygonLookupComplexType::
  getName () const
  {
    return this->name_;
  }

  PolygonLookupComplexType::NameOptional& PolygonLookupComplexType::
  getName ()
  {
    return this->name_;
  }

  void PolygonLookupComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void PolygonLookupComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void PolygonLookupComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // PolygonsComplexType
  // 

  const PolygonsComplexType::PolygonSequence& PolygonsComplexType::
  getPolygon () const
  {
    return this->polygon_;
  }

  PolygonsComplexType::PolygonSequence& PolygonsComplexType::
  getPolygon ()
  {
    return this->polygon_;
  }

  void PolygonsComplexType::
  setPolygon (const PolygonSequence& s)
  {
    this->polygon_ = s;
  }


  // PolygonComplexType
  // 

  const PolygonComplexType::ValueOptional& PolygonComplexType::
  getValue () const
  {
    return this->value_;
  }

  PolygonComplexType::ValueOptional& PolygonComplexType::
  getValue ()
  {
    return this->value_;
  }

  void PolygonComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  void PolygonComplexType::
  setValue (const ValueOptional& x)
  {
    this->value_ = x;
  }

  PolygonComplexType::ValueType PolygonComplexType::
  getValueDefaultValue ()
  {
    return ValueType (1.0);
  }

  const PolygonComplexType::EdgesType& PolygonComplexType::
  getEdges () const
  {
    return this->edges_.get ();
  }

  PolygonComplexType::EdgesType& PolygonComplexType::
  getEdges ()
  {
    return this->edges_.get ();
  }

  void PolygonComplexType::
  setEdges (const EdgesType& x)
  {
    this->edges_.set (x);
  }

  void PolygonComplexType::
  setEdges (::std::auto_ptr< EdgesType > x)
  {
    this->edges_.set (x);
  }

  const PolygonComplexType::IdOptional& PolygonComplexType::
  getId () const
  {
    return this->id_;
  }

  PolygonComplexType::IdOptional& PolygonComplexType::
  getId ()
  {
    return this->id_;
  }

  void PolygonComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void PolygonComplexType::
  setId (const IdOptional& x)
  {
    this->id_ = x;
  }

  void PolygonComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // EdgesComplexType
  // 

  const EdgesComplexType::EdgeSequence& EdgesComplexType::
  getEdge () const
  {
    return this->edge_;
  }

  EdgesComplexType::EdgeSequence& EdgesComplexType::
  getEdge ()
  {
    return this->edge_;
  }

  void EdgesComplexType::
  setEdge (const EdgeSequence& s)
  {
    this->edge_ = s;
  }


  // EdgeComplexType
  // 

  const EdgeComplexType::X1Type& EdgeComplexType::
  getX1 () const
  {
    return this->x1_.get ();
  }

  EdgeComplexType::X1Type& EdgeComplexType::
  getX1 ()
  {
    return this->x1_.get ();
  }

  void EdgeComplexType::
  setX1 (const X1Type& x)
  {
    this->x1_.set (x);
  }

  const EdgeComplexType::X2Type& EdgeComplexType::
  getX2 () const
  {
    return this->x2_.get ();
  }

  EdgeComplexType::X2Type& EdgeComplexType::
  getX2 ()
  {
    return this->x2_.get ();
  }

  void EdgeComplexType::
  setX2 (const X2Type& x)
  {
    this->x2_.set (x);
  }


  // PolygonLookupInputComplexType
  // 

  const PolygonLookupInputComplexType::X1Type& PolygonLookupInputComplexType::
  getX1 () const
  {
    return this->x1_.get ();
  }

  PolygonLookupInputComplexType::X1Type& PolygonLookupInputComplexType::
  getX1 ()
  {
    return this->x1_.get ();
  }

  void PolygonLookupInputComplexType::
  setX1 (const X1Type& x)
  {
    this->x1_.set (x);
  }

  void PolygonLookupInputComplexType::
  setX1 (::std::auto_ptr< X1Type > x)
  {
    this->x1_.set (x);
  }

  const PolygonLookupInputComplexType::X2Type& PolygonLookupInputComplexType::
  getX2 () const
  {
    return this->x2_.get ();
  }

  PolygonLookupInputComplexType::X2Type& PolygonLookupInputComplexType::
  getX2 ()
  {
    return this->x2_.get ();
  }

  void PolygonLookupInputComplexType::
  setX2 (const X2Type& x)
  {
    this->x2_.set (x);
  }

  void PolygonLookupInputComplexType::
  setX2 (::std::auto_ptr< X2Type > x)
  {
    this->x2_.set (x);
  }


  // PolygonLookupOutputComplexType
  // 

  const PolygonLookupOutputComplexType::StatusType& PolygonLookupOutputComplexType::
  getStatus () const
  {
    return this->status_.get ();
  }

  PolygonLookupOutputComplexType::StatusType& PolygonLookupOutputComplexType::
  getStatus ()
  {
    return this->status_.get ();
  }

  void PolygonLookupOutputComplexType::
  setStatus (const StatusType& x)
  {
    this->status_.set (x);
  }

  void PolygonLookupOutputComplexType::
  setStatus (::std::auto_ptr< StatusType > x)
  {
    this->status_.set (x);
  }


  // SpreadsheetComplexType
  // 

  const SpreadsheetComplexType::ValidPeriodsOptional& SpreadsheetComplexType::
  getValidPeriods () const
  {
    return this->validPeriods_;
  }

  SpreadsheetComplexType::ValidPeriodsOptional& SpreadsheetComplexType::
  getValidPeriods ()
  {
    return this->validPeriods_;
  }

  void SpreadsheetComplexType::
  setValidPeriods (const ValidPeriodsType& x)
  {
    this->validPeriods_.set (x);
  }

  void SpreadsheetComplexType::
  setValidPeriods (const ValidPeriodsOptional& x)
  {
    this->validPeriods_ = x;
  }

  void SpreadsheetComplexType::
  setValidPeriods (::std::auto_ptr< ValidPeriodsType > x)
  {
    this->validPeriods_.set (x);
  }

  const SpreadsheetComplexType::DefaultInputValueOptional& SpreadsheetComplexType::
  getDefaultInputValue () const
  {
    return this->defaultInputValue_;
  }

  SpreadsheetComplexType::DefaultInputValueOptional& SpreadsheetComplexType::
  getDefaultInputValue ()
  {
    return this->defaultInputValue_;
  }

  void SpreadsheetComplexType::
  setDefaultInputValue (const DefaultInputValueType& x)
  {
    this->defaultInputValue_.set (x);
  }

  void SpreadsheetComplexType::
  setDefaultInputValue (const DefaultInputValueOptional& x)
  {
    this->defaultInputValue_ = x;
  }

  const SpreadsheetComplexType::DefaultOutputValueOptional& SpreadsheetComplexType::
  getDefaultOutputValue () const
  {
    return this->defaultOutputValue_;
  }

  SpreadsheetComplexType::DefaultOutputValueOptional& SpreadsheetComplexType::
  getDefaultOutputValue ()
  {
    return this->defaultOutputValue_;
  }

  void SpreadsheetComplexType::
  setDefaultOutputValue (const DefaultOutputValueType& x)
  {
    this->defaultOutputValue_.set (x);
  }

  void SpreadsheetComplexType::
  setDefaultOutputValue (const DefaultOutputValueOptional& x)
  {
    this->defaultOutputValue_ = x;
  }

  const SpreadsheetComplexType::ToleranceType& SpreadsheetComplexType::
  getTolerance () const
  {
    return this->tolerance_.get ();
  }

  SpreadsheetComplexType::ToleranceType& SpreadsheetComplexType::
  getTolerance ()
  {
    return this->tolerance_.get ();
  }

  void SpreadsheetComplexType::
  setTolerance (const ToleranceType& x)
  {
    this->tolerance_.set (x);
  }

  const SpreadsheetComplexType::TablesType& SpreadsheetComplexType::
  getTables () const
  {
    return this->tables_.get ();
  }

  SpreadsheetComplexType::TablesType& SpreadsheetComplexType::
  getTables ()
  {
    return this->tables_.get ();
  }

  void SpreadsheetComplexType::
  setTables (const TablesType& x)
  {
    this->tables_.set (x);
  }

  void SpreadsheetComplexType::
  setTables (::std::auto_ptr< TablesType > x)
  {
    this->tables_.set (x);
  }

  const SpreadsheetComplexType::TrueOptional& SpreadsheetComplexType::
  getTrue () const
  {
    return this->true__;
  }

  SpreadsheetComplexType::TrueOptional& SpreadsheetComplexType::
  getTrue ()
  {
    return this->true__;
  }

  void SpreadsheetComplexType::
  setTrue (const TrueType& x)
  {
    this->true__.set (x);
  }

  void SpreadsheetComplexType::
  setTrue (const TrueOptional& x)
  {
    this->true__ = x;
  }

  void SpreadsheetComplexType::
  setTrue (::std::auto_ptr< TrueType > x)
  {
    this->true__.set (x);
  }

  const SpreadsheetComplexType::FalseOptional& SpreadsheetComplexType::
  getFalse () const
  {
    return this->false__;
  }

  SpreadsheetComplexType::FalseOptional& SpreadsheetComplexType::
  getFalse ()
  {
    return this->false__;
  }

  void SpreadsheetComplexType::
  setFalse (const FalseType& x)
  {
    this->false__.set (x);
  }

  void SpreadsheetComplexType::
  setFalse (const FalseOptional& x)
  {
    this->false__ = x;
  }

  void SpreadsheetComplexType::
  setFalse (::std::auto_ptr< FalseType > x)
  {
    this->false__.set (x);
  }

  const SpreadsheetComplexType::InputType& SpreadsheetComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  SpreadsheetComplexType::InputType& SpreadsheetComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void SpreadsheetComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void SpreadsheetComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const SpreadsheetComplexType::OutputType& SpreadsheetComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  SpreadsheetComplexType::OutputType& SpreadsheetComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void SpreadsheetComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void SpreadsheetComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const SpreadsheetComplexType::IdType& SpreadsheetComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  SpreadsheetComplexType::IdType& SpreadsheetComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void SpreadsheetComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void SpreadsheetComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const SpreadsheetComplexType::NameOptional& SpreadsheetComplexType::
  getName () const
  {
    return this->name_;
  }

  SpreadsheetComplexType::NameOptional& SpreadsheetComplexType::
  getName ()
  {
    return this->name_;
  }

  void SpreadsheetComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void SpreadsheetComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void SpreadsheetComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ValidPeriodsComplexType
  // 

  const ValidPeriodsComplexType::ValidPeriodSequence& ValidPeriodsComplexType::
  getValidPeriod () const
  {
    return this->validPeriod_;
  }

  ValidPeriodsComplexType::ValidPeriodSequence& ValidPeriodsComplexType::
  getValidPeriod ()
  {
    return this->validPeriod_;
  }

  void ValidPeriodsComplexType::
  setValidPeriod (const ValidPeriodSequence& s)
  {
    this->validPeriod_ = s;
  }


  // ValidPeriodComplexType
  // 

  const ValidPeriodComplexType::StartDateType& ValidPeriodComplexType::
  getStartDate () const
  {
    return this->startDate_.get ();
  }

  ValidPeriodComplexType::StartDateType& ValidPeriodComplexType::
  getStartDate ()
  {
    return this->startDate_.get ();
  }

  void ValidPeriodComplexType::
  setStartDate (const StartDateType& x)
  {
    this->startDate_.set (x);
  }

  void ValidPeriodComplexType::
  setStartDate (::std::auto_ptr< StartDateType > x)
  {
    this->startDate_.set (x);
  }

  const ValidPeriodComplexType::EndDateType& ValidPeriodComplexType::
  getEndDate () const
  {
    return this->endDate_.get ();
  }

  ValidPeriodComplexType::EndDateType& ValidPeriodComplexType::
  getEndDate ()
  {
    return this->endDate_.get ();
  }

  void ValidPeriodComplexType::
  setEndDate (const EndDateType& x)
  {
    this->endDate_.set (x);
  }

  void ValidPeriodComplexType::
  setEndDate (::std::auto_ptr< EndDateType > x)
  {
    this->endDate_.set (x);
  }


  // DateComplexType
  // 

  const DateComplexType::MonthDayType& DateComplexType::
  getMonthDay () const
  {
    return this->monthDay_.get ();
  }

  DateComplexType::MonthDayType& DateComplexType::
  getMonthDay ()
  {
    return this->monthDay_.get ();
  }

  void DateComplexType::
  setMonthDay (const MonthDayType& x)
  {
    this->monthDay_.set (x);
  }

  void DateComplexType::
  setMonthDay (::std::auto_ptr< MonthDayType > x)
  {
    this->monthDay_.set (x);
  }


  // SpreadsheetTablesComplexType
  // 

  const SpreadsheetTablesComplexType::TableSequence& SpreadsheetTablesComplexType::
  getTable () const
  {
    return this->table_;
  }

  SpreadsheetTablesComplexType::TableSequence& SpreadsheetTablesComplexType::
  getTable ()
  {
    return this->table_;
  }

  void SpreadsheetTablesComplexType::
  setTable (const TableSequence& s)
  {
    this->table_ = s;
  }


  // SpreadsheetTableComplexType
  // 

  const SpreadsheetTableComplexType::RecordSequence& SpreadsheetTableComplexType::
  getRecord () const
  {
    return this->record_;
  }

  SpreadsheetTableComplexType::RecordSequence& SpreadsheetTableComplexType::
  getRecord ()
  {
    return this->record_;
  }

  void SpreadsheetTableComplexType::
  setRecord (const RecordSequence& s)
  {
    this->record_ = s;
  }

  const SpreadsheetTableComplexType::InitialStateOptional& SpreadsheetTableComplexType::
  getInitialState () const
  {
    return this->initialState_;
  }

  SpreadsheetTableComplexType::InitialStateOptional& SpreadsheetTableComplexType::
  getInitialState ()
  {
    return this->initialState_;
  }

  void SpreadsheetTableComplexType::
  setInitialState (const InitialStateType& x)
  {
    this->initialState_.set (x);
  }

  void SpreadsheetTableComplexType::
  setInitialState (const InitialStateOptional& x)
  {
    this->initialState_ = x;
  }


  // SpreadsheetRecordComplexType
  // 

  const SpreadsheetRecordComplexType::X1Type& SpreadsheetRecordComplexType::
  getX1 () const
  {
    return this->x1_.get ();
  }

  SpreadsheetRecordComplexType::X1Type& SpreadsheetRecordComplexType::
  getX1 ()
  {
    return this->x1_.get ();
  }

  void SpreadsheetRecordComplexType::
  setX1 (const X1Type& x)
  {
    this->x1_.set (x);
  }

  const SpreadsheetRecordComplexType::X2Type& SpreadsheetRecordComplexType::
  getX2 () const
  {
    return this->x2_.get ();
  }

  SpreadsheetRecordComplexType::X2Type& SpreadsheetRecordComplexType::
  getX2 ()
  {
    return this->x2_.get ();
  }

  void SpreadsheetRecordComplexType::
  setX2 (const X2Type& x)
  {
    this->x2_.set (x);
  }

  const SpreadsheetRecordComplexType::X3Optional& SpreadsheetRecordComplexType::
  getX3 () const
  {
    return this->x3_;
  }

  SpreadsheetRecordComplexType::X3Optional& SpreadsheetRecordComplexType::
  getX3 ()
  {
    return this->x3_;
  }

  void SpreadsheetRecordComplexType::
  setX3 (const X3Type& x)
  {
    this->x3_.set (x);
  }

  void SpreadsheetRecordComplexType::
  setX3 (const X3Optional& x)
  {
    this->x3_ = x;
  }

  const SpreadsheetRecordComplexType::YType& SpreadsheetRecordComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  SpreadsheetRecordComplexType::YType& SpreadsheetRecordComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void SpreadsheetRecordComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }


  // SpreadsheetInputComplexType
  // 

  const SpreadsheetInputComplexType::X1Type& SpreadsheetInputComplexType::
  getX1 () const
  {
    return this->x1_.get ();
  }

  SpreadsheetInputComplexType::X1Type& SpreadsheetInputComplexType::
  getX1 ()
  {
    return this->x1_.get ();
  }

  void SpreadsheetInputComplexType::
  setX1 (const X1Type& x)
  {
    this->x1_.set (x);
  }

  void SpreadsheetInputComplexType::
  setX1 (::std::auto_ptr< X1Type > x)
  {
    this->x1_.set (x);
  }

  const SpreadsheetInputComplexType::X2Type& SpreadsheetInputComplexType::
  getX2 () const
  {
    return this->x2_.get ();
  }

  SpreadsheetInputComplexType::X2Type& SpreadsheetInputComplexType::
  getX2 ()
  {
    return this->x2_.get ();
  }

  void SpreadsheetInputComplexType::
  setX2 (const X2Type& x)
  {
    this->x2_.set (x);
  }

  void SpreadsheetInputComplexType::
  setX2 (::std::auto_ptr< X2Type > x)
  {
    this->x2_.set (x);
  }

  const SpreadsheetInputComplexType::X3Optional& SpreadsheetInputComplexType::
  getX3 () const
  {
    return this->x3_;
  }

  SpreadsheetInputComplexType::X3Optional& SpreadsheetInputComplexType::
  getX3 ()
  {
    return this->x3_;
  }

  void SpreadsheetInputComplexType::
  setX3 (const X3Type& x)
  {
    this->x3_.set (x);
  }

  void SpreadsheetInputComplexType::
  setX3 (const X3Optional& x)
  {
    this->x3_ = x;
  }

  void SpreadsheetInputComplexType::
  setX3 (::std::auto_ptr< X3Type > x)
  {
    this->x3_.set (x);
  }


  // SpreadsheetOutputComplexType
  // 

  const SpreadsheetOutputComplexType::StatusType& SpreadsheetOutputComplexType::
  getStatus () const
  {
    return this->status_.get ();
  }

  SpreadsheetOutputComplexType::StatusType& SpreadsheetOutputComplexType::
  getStatus ()
  {
    return this->status_.get ();
  }

  void SpreadsheetOutputComplexType::
  setStatus (const StatusType& x)
  {
    this->status_.set (x);
  }

  void SpreadsheetOutputComplexType::
  setStatus (::std::auto_ptr< StatusType > x)
  {
    this->status_.set (x);
  }


  // MergerComplexType
  // 

  const MergerComplexType::InputType& MergerComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  MergerComplexType::InputType& MergerComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void MergerComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void MergerComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const MergerComplexType::OutputType& MergerComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  MergerComplexType::OutputType& MergerComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void MergerComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void MergerComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const MergerComplexType::IdType& MergerComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  MergerComplexType::IdType& MergerComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void MergerComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void MergerComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const MergerComplexType::NameOptional& MergerComplexType::
  getName () const
  {
    return this->name_;
  }

  MergerComplexType::NameOptional& MergerComplexType::
  getName ()
  {
    return this->name_;
  }

  void MergerComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void MergerComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void MergerComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // MergerInputComplexType
  // 

  const MergerInputComplexType::XSequence& MergerInputComplexType::
  getX () const
  {
    return this->x_;
  }

  MergerInputComplexType::XSequence& MergerInputComplexType::
  getX ()
  {
    return this->x_;
  }

  void MergerInputComplexType::
  setX (const XSequence& s)
  {
    this->x_ = s;
  }


  // MergerOutputComplexType
  // 

  const MergerOutputComplexType::YOptional& MergerOutputComplexType::
  getY () const
  {
    return this->y_;
  }

  MergerOutputComplexType::YOptional& MergerOutputComplexType::
  getY ()
  {
    return this->y_;
  }

  void MergerOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void MergerOutputComplexType::
  setY (const YOptional& x)
  {
    this->y_ = x;
  }

  void MergerOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const MergerOutputComplexType::YSumOptional& MergerOutputComplexType::
  getYSum () const
  {
    return this->ySum_;
  }

  MergerOutputComplexType::YSumOptional& MergerOutputComplexType::
  getYSum ()
  {
    return this->ySum_;
  }

  void MergerOutputComplexType::
  setYSum (const YSumType& x)
  {
    this->ySum_.set (x);
  }

  void MergerOutputComplexType::
  setYSum (const YSumOptional& x)
  {
    this->ySum_ = x;
  }

  void MergerOutputComplexType::
  setYSum (::std::auto_ptr< YSumType > x)
  {
    this->ySum_.set (x);
  }


  // MergerSplitterComplexType
  // 

  const MergerSplitterComplexType::ModeType& MergerSplitterComplexType::
  getMode () const
  {
    return this->mode_.get ();
  }

  MergerSplitterComplexType::ModeType& MergerSplitterComplexType::
  getMode ()
  {
    return this->mode_.get ();
  }

  void MergerSplitterComplexType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void MergerSplitterComplexType::
  setMode (::std::auto_ptr< ModeType > x)
  {
    this->mode_.set (x);
  }

  const MergerSplitterComplexType::InputType& MergerSplitterComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  MergerSplitterComplexType::InputType& MergerSplitterComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void MergerSplitterComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void MergerSplitterComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const MergerSplitterComplexType::OutputType& MergerSplitterComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  MergerSplitterComplexType::OutputType& MergerSplitterComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void MergerSplitterComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void MergerSplitterComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const MergerSplitterComplexType::IdType& MergerSplitterComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  MergerSplitterComplexType::IdType& MergerSplitterComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void MergerSplitterComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void MergerSplitterComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const MergerSplitterComplexType::NameOptional& MergerSplitterComplexType::
  getName () const
  {
    return this->name_;
  }

  MergerSplitterComplexType::NameOptional& MergerSplitterComplexType::
  getName ()
  {
    return this->name_;
  }

  void MergerSplitterComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void MergerSplitterComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void MergerSplitterComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // MergerSplitterInputComplexType
  // 

  const MergerSplitterInputComplexType::XSequence& MergerSplitterInputComplexType::
  getX () const
  {
    return this->x_;
  }

  MergerSplitterInputComplexType::XSequence& MergerSplitterInputComplexType::
  getX ()
  {
    return this->x_;
  }

  void MergerSplitterInputComplexType::
  setX (const XSequence& s)
  {
    this->x_ = s;
  }

  const MergerSplitterInputComplexType::XVectorOptional& MergerSplitterInputComplexType::
  getXVector () const
  {
    return this->xVector_;
  }

  MergerSplitterInputComplexType::XVectorOptional& MergerSplitterInputComplexType::
  getXVector ()
  {
    return this->xVector_;
  }

  void MergerSplitterInputComplexType::
  setXVector (const XVectorType& x)
  {
    this->xVector_.set (x);
  }

  void MergerSplitterInputComplexType::
  setXVector (const XVectorOptional& x)
  {
    this->xVector_ = x;
  }

  void MergerSplitterInputComplexType::
  setXVector (::std::auto_ptr< XVectorType > x)
  {
    this->xVector_.set (x);
  }


  // MergerSplitterOutputComplexType
  // 

  const MergerSplitterOutputComplexType::YSequence& MergerSplitterOutputComplexType::
  getY () const
  {
    return this->y_;
  }

  MergerSplitterOutputComplexType::YSequence& MergerSplitterOutputComplexType::
  getY ()
  {
    return this->y_;
  }

  void MergerSplitterOutputComplexType::
  setY (const YSequence& s)
  {
    this->y_ = s;
  }


  // TimeAbsoluteComplexType
  // 

  const TimeAbsoluteComplexType::InputType& TimeAbsoluteComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TimeAbsoluteComplexType::InputType& TimeAbsoluteComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TimeAbsoluteComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TimeAbsoluteComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TimeAbsoluteComplexType::OutputType& TimeAbsoluteComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  TimeAbsoluteComplexType::OutputType& TimeAbsoluteComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void TimeAbsoluteComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void TimeAbsoluteComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const TimeAbsoluteComplexType::IdType& TimeAbsoluteComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TimeAbsoluteComplexType::IdType& TimeAbsoluteComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TimeAbsoluteComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TimeAbsoluteComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const TimeAbsoluteComplexType::NameOptional& TimeAbsoluteComplexType::
  getName () const
  {
    return this->name_;
  }

  TimeAbsoluteComplexType::NameOptional& TimeAbsoluteComplexType::
  getName ()
  {
    return this->name_;
  }

  void TimeAbsoluteComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void TimeAbsoluteComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void TimeAbsoluteComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // TimeAbsoluteInputComplexType
  // 

  const TimeAbsoluteInputComplexType::XType& TimeAbsoluteInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  TimeAbsoluteInputComplexType::XType& TimeAbsoluteInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void TimeAbsoluteInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void TimeAbsoluteInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // TimeAbsoluteOutputComplexType
  // 

  const TimeAbsoluteOutputComplexType::YType& TimeAbsoluteOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  TimeAbsoluteOutputComplexType::YType& TimeAbsoluteOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void TimeAbsoluteOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void TimeAbsoluteOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // TimeRelativeComplexType
  // 

  const TimeRelativeComplexType::ModeOptional& TimeRelativeComplexType::
  getMode () const
  {
    return this->mode_;
  }

  TimeRelativeComplexType::ModeOptional& TimeRelativeComplexType::
  getMode ()
  {
    return this->mode_;
  }

  void TimeRelativeComplexType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void TimeRelativeComplexType::
  setMode (const ModeOptional& x)
  {
    this->mode_ = x;
  }

  void TimeRelativeComplexType::
  setMode (::std::auto_ptr< ModeType > x)
  {
    this->mode_.set (x);
  }

  const TimeRelativeComplexType::ModeType& TimeRelativeComplexType::
  getModeDefaultValue ()
  {
    return mode_default_value_;
  }

  const TimeRelativeComplexType::ValueOptionType& TimeRelativeComplexType::
  getValueOption () const
  {
    return this->valueOption_.get ();
  }

  TimeRelativeComplexType::ValueOptionType& TimeRelativeComplexType::
  getValueOption ()
  {
    return this->valueOption_.get ();
  }

  void TimeRelativeComplexType::
  setValueOption (const ValueOptionType& x)
  {
    this->valueOption_.set (x);
  }

  void TimeRelativeComplexType::
  setValueOption (::std::auto_ptr< ValueOptionType > x)
  {
    this->valueOption_.set (x);
  }

  const TimeRelativeComplexType::MaximumPeriodOptional& TimeRelativeComplexType::
  getMaximumPeriod () const
  {
    return this->maximumPeriod_;
  }

  TimeRelativeComplexType::MaximumPeriodOptional& TimeRelativeComplexType::
  getMaximumPeriod ()
  {
    return this->maximumPeriod_;
  }

  void TimeRelativeComplexType::
  setMaximumPeriod (const MaximumPeriodType& x)
  {
    this->maximumPeriod_.set (x);
  }

  void TimeRelativeComplexType::
  setMaximumPeriod (const MaximumPeriodOptional& x)
  {
    this->maximumPeriod_ = x;
  }

  const TimeRelativeComplexType::InterpolationOptionOptional& TimeRelativeComplexType::
  getInterpolationOption () const
  {
    return this->interpolationOption_;
  }

  TimeRelativeComplexType::InterpolationOptionOptional& TimeRelativeComplexType::
  getInterpolationOption ()
  {
    return this->interpolationOption_;
  }

  void TimeRelativeComplexType::
  setInterpolationOption (const InterpolationOptionType& x)
  {
    this->interpolationOption_.set (x);
  }

  void TimeRelativeComplexType::
  setInterpolationOption (const InterpolationOptionOptional& x)
  {
    this->interpolationOption_ = x;
  }

  void TimeRelativeComplexType::
  setInterpolationOption (::std::auto_ptr< InterpolationOptionType > x)
  {
    this->interpolationOption_.set (x);
  }

  const TimeRelativeComplexType::ControlTableType& TimeRelativeComplexType::
  getControlTable () const
  {
    return this->controlTable_.get ();
  }

  TimeRelativeComplexType::ControlTableType& TimeRelativeComplexType::
  getControlTable ()
  {
    return this->controlTable_.get ();
  }

  void TimeRelativeComplexType::
  setControlTable (const ControlTableType& x)
  {
    this->controlTable_.set (x);
  }

  void TimeRelativeComplexType::
  setControlTable (::std::auto_ptr< ControlTableType > x)
  {
    this->controlTable_.set (x);
  }

  const TimeRelativeComplexType::InputOptional& TimeRelativeComplexType::
  getInput () const
  {
    return this->input_;
  }

  TimeRelativeComplexType::InputOptional& TimeRelativeComplexType::
  getInput ()
  {
    return this->input_;
  }

  void TimeRelativeComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TimeRelativeComplexType::
  setInput (const InputOptional& x)
  {
    this->input_ = x;
  }

  void TimeRelativeComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TimeRelativeComplexType::OutputType& TimeRelativeComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  TimeRelativeComplexType::OutputType& TimeRelativeComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void TimeRelativeComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void TimeRelativeComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const TimeRelativeComplexType::IdType& TimeRelativeComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TimeRelativeComplexType::IdType& TimeRelativeComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TimeRelativeComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TimeRelativeComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const TimeRelativeComplexType::NameOptional& TimeRelativeComplexType::
  getName () const
  {
    return this->name_;
  }

  TimeRelativeComplexType::NameOptional& TimeRelativeComplexType::
  getName ()
  {
    return this->name_;
  }

  void TimeRelativeComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void TimeRelativeComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void TimeRelativeComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // TimeRelativeControlTableComplexType
  // 

  const TimeRelativeControlTableComplexType::RecordSequence& TimeRelativeControlTableComplexType::
  getRecord () const
  {
    return this->record_;
  }

  TimeRelativeControlTableComplexType::RecordSequence& TimeRelativeControlTableComplexType::
  getRecord ()
  {
    return this->record_;
  }

  void TimeRelativeControlTableComplexType::
  setRecord (const RecordSequence& s)
  {
    this->record_ = s;
  }


  // TimeRelativeControlTableRecordComplexType
  // 

  const TimeRelativeControlTableRecordComplexType::TimeType& TimeRelativeControlTableRecordComplexType::
  getTime () const
  {
    return this->time_.get ();
  }

  TimeRelativeControlTableRecordComplexType::TimeType& TimeRelativeControlTableRecordComplexType::
  getTime ()
  {
    return this->time_.get ();
  }

  void TimeRelativeControlTableRecordComplexType::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  const TimeRelativeControlTableRecordComplexType::ValueType& TimeRelativeControlTableRecordComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  TimeRelativeControlTableRecordComplexType::ValueType& TimeRelativeControlTableRecordComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void TimeRelativeControlTableRecordComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // TimeRelativeInputComplexType
  // 

  const TimeRelativeInputComplexType::YType& TimeRelativeInputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  TimeRelativeInputComplexType::YType& TimeRelativeInputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void TimeRelativeInputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void TimeRelativeInputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // TimeRelativeOutputComplexType
  // 

  const TimeRelativeOutputComplexType::YType& TimeRelativeOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  TimeRelativeOutputComplexType::YType& TimeRelativeOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void TimeRelativeOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void TimeRelativeOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const TimeRelativeOutputComplexType::TimeActiveType& TimeRelativeOutputComplexType::
  getTimeActive () const
  {
    return this->timeActive_.get ();
  }

  TimeRelativeOutputComplexType::TimeActiveType& TimeRelativeOutputComplexType::
  getTimeActive ()
  {
    return this->timeActive_.get ();
  }

  void TimeRelativeOutputComplexType::
  setTimeActive (const TimeActiveType& x)
  {
    this->timeActive_.set (x);
  }

  void TimeRelativeOutputComplexType::
  setTimeActive (::std::auto_ptr< TimeActiveType > x)
  {
    this->timeActive_.set (x);
  }


  // ExpressionComplexType
  // 

  const ExpressionComplexType::X1ValueOptional& ExpressionComplexType::
  getX1Value () const
  {
    return this->x1Value_;
  }

  ExpressionComplexType::X1ValueOptional& ExpressionComplexType::
  getX1Value ()
  {
    return this->x1Value_;
  }

  void ExpressionComplexType::
  setX1Value (const X1ValueType& x)
  {
    this->x1Value_.set (x);
  }

  void ExpressionComplexType::
  setX1Value (const X1ValueOptional& x)
  {
    this->x1Value_ = x;
  }

  void ExpressionComplexType::
  setX1Value (::std::auto_ptr< X1ValueType > x)
  {
    this->x1Value_.set (x);
  }

  const ExpressionComplexType::X1SeriesOptional& ExpressionComplexType::
  getX1Series () const
  {
    return this->x1Series_;
  }

  ExpressionComplexType::X1SeriesOptional& ExpressionComplexType::
  getX1Series ()
  {
    return this->x1Series_;
  }

  void ExpressionComplexType::
  setX1Series (const X1SeriesType& x)
  {
    this->x1Series_.set (x);
  }

  void ExpressionComplexType::
  setX1Series (const X1SeriesOptional& x)
  {
    this->x1Series_ = x;
  }

  void ExpressionComplexType::
  setX1Series (::std::auto_ptr< X1SeriesType > x)
  {
    this->x1Series_.set (x);
  }

  const ExpressionComplexType::X1SeriesVectorOptional& ExpressionComplexType::
  getX1SeriesVector () const
  {
    return this->x1SeriesVector_;
  }

  ExpressionComplexType::X1SeriesVectorOptional& ExpressionComplexType::
  getX1SeriesVector ()
  {
    return this->x1SeriesVector_;
  }

  void ExpressionComplexType::
  setX1SeriesVector (const X1SeriesVectorType& x)
  {
    this->x1SeriesVector_.set (x);
  }

  void ExpressionComplexType::
  setX1SeriesVector (const X1SeriesVectorOptional& x)
  {
    this->x1SeriesVector_ = x;
  }

  void ExpressionComplexType::
  setX1SeriesVector (::std::auto_ptr< X1SeriesVectorType > x)
  {
    this->x1SeriesVector_.set (x);
  }

  const ExpressionComplexType::MathematicalOperatorType& ExpressionComplexType::
  getMathematicalOperator () const
  {
    return this->mathematicalOperator_.get ();
  }

  ExpressionComplexType::MathematicalOperatorType& ExpressionComplexType::
  getMathematicalOperator ()
  {
    return this->mathematicalOperator_.get ();
  }

  void ExpressionComplexType::
  setMathematicalOperator (const MathematicalOperatorType& x)
  {
    this->mathematicalOperator_.set (x);
  }

  void ExpressionComplexType::
  setMathematicalOperator (::std::auto_ptr< MathematicalOperatorType > x)
  {
    this->mathematicalOperator_.set (x);
  }

  const ExpressionComplexType::X2ValueOptional& ExpressionComplexType::
  getX2Value () const
  {
    return this->x2Value_;
  }

  ExpressionComplexType::X2ValueOptional& ExpressionComplexType::
  getX2Value ()
  {
    return this->x2Value_;
  }

  void ExpressionComplexType::
  setX2Value (const X2ValueType& x)
  {
    this->x2Value_.set (x);
  }

  void ExpressionComplexType::
  setX2Value (const X2ValueOptional& x)
  {
    this->x2Value_ = x;
  }

  void ExpressionComplexType::
  setX2Value (::std::auto_ptr< X2ValueType > x)
  {
    this->x2Value_.set (x);
  }

  const ExpressionComplexType::X2SeriesOptional& ExpressionComplexType::
  getX2Series () const
  {
    return this->x2Series_;
  }

  ExpressionComplexType::X2SeriesOptional& ExpressionComplexType::
  getX2Series ()
  {
    return this->x2Series_;
  }

  void ExpressionComplexType::
  setX2Series (const X2SeriesType& x)
  {
    this->x2Series_.set (x);
  }

  void ExpressionComplexType::
  setX2Series (const X2SeriesOptional& x)
  {
    this->x2Series_ = x;
  }

  void ExpressionComplexType::
  setX2Series (::std::auto_ptr< X2SeriesType > x)
  {
    this->x2Series_.set (x);
  }

  const ExpressionComplexType::X2SeriesVectorOptional& ExpressionComplexType::
  getX2SeriesVector () const
  {
    return this->x2SeriesVector_;
  }

  ExpressionComplexType::X2SeriesVectorOptional& ExpressionComplexType::
  getX2SeriesVector ()
  {
    return this->x2SeriesVector_;
  }

  void ExpressionComplexType::
  setX2SeriesVector (const X2SeriesVectorType& x)
  {
    this->x2SeriesVector_.set (x);
  }

  void ExpressionComplexType::
  setX2SeriesVector (const X2SeriesVectorOptional& x)
  {
    this->x2SeriesVector_ = x;
  }

  void ExpressionComplexType::
  setX2SeriesVector (::std::auto_ptr< X2SeriesVectorType > x)
  {
    this->x2SeriesVector_.set (x);
  }

  const ExpressionComplexType::YOptional& ExpressionComplexType::
  getY () const
  {
    return this->y_;
  }

  ExpressionComplexType::YOptional& ExpressionComplexType::
  getY ()
  {
    return this->y_;
  }

  void ExpressionComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void ExpressionComplexType::
  setY (const YOptional& x)
  {
    this->y_ = x;
  }

  void ExpressionComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const ExpressionComplexType::YVectorOptional& ExpressionComplexType::
  getYVector () const
  {
    return this->yVector_;
  }

  ExpressionComplexType::YVectorOptional& ExpressionComplexType::
  getYVector ()
  {
    return this->yVector_;
  }

  void ExpressionComplexType::
  setYVector (const YVectorType& x)
  {
    this->yVector_.set (x);
  }

  void ExpressionComplexType::
  setYVector (const YVectorOptional& x)
  {
    this->yVector_ = x;
  }

  void ExpressionComplexType::
  setYVector (::std::auto_ptr< YVectorType > x)
  {
    this->yVector_.set (x);
  }

  const ExpressionComplexType::IdType& ExpressionComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ExpressionComplexType::IdType& ExpressionComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ExpressionComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ExpressionComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ExpressionComplexType::NameOptional& ExpressionComplexType::
  getName () const
  {
    return this->name_;
  }

  ExpressionComplexType::NameOptional& ExpressionComplexType::
  getName ()
  {
    return this->name_;
  }

  void ExpressionComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ExpressionComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ExpressionComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // DeadBandValueComplexType
  // 

  const DeadBandValueComplexType::ThresholdType& DeadBandValueComplexType::
  getThreshold () const
  {
    return this->threshold_.get ();
  }

  DeadBandValueComplexType::ThresholdType& DeadBandValueComplexType::
  getThreshold ()
  {
    return this->threshold_.get ();
  }

  void DeadBandValueComplexType::
  setThreshold (const ThresholdType& x)
  {
    this->threshold_.set (x);
  }

  const DeadBandValueComplexType::InputType& DeadBandValueComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  DeadBandValueComplexType::InputType& DeadBandValueComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void DeadBandValueComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void DeadBandValueComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const DeadBandValueComplexType::IdType& DeadBandValueComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  DeadBandValueComplexType::IdType& DeadBandValueComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void DeadBandValueComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void DeadBandValueComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const DeadBandValueComplexType::NameOptional& DeadBandValueComplexType::
  getName () const
  {
    return this->name_;
  }

  DeadBandValueComplexType::NameOptional& DeadBandValueComplexType::
  getName ()
  {
    return this->name_;
  }

  void DeadBandValueComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DeadBandValueComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DeadBandValueComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // DeadBandValueInputComplexType
  // 

  const DeadBandValueInputComplexType::XType& DeadBandValueInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  DeadBandValueInputComplexType::XType& DeadBandValueInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void DeadBandValueInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void DeadBandValueInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // DeadBandTimeComplexType
  // 

  const DeadBandTimeComplexType::DiscreteType& DeadBandTimeComplexType::
  getDiscrete () const
  {
    return this->discrete_.get ();
  }

  DeadBandTimeComplexType::DiscreteType& DeadBandTimeComplexType::
  getDiscrete ()
  {
    return this->discrete_.get ();
  }

  void DeadBandTimeComplexType::
  setDiscrete (const DiscreteType& x)
  {
    this->discrete_.set (x);
  }

  void DeadBandTimeComplexType::
  setDiscrete (::std::auto_ptr< DiscreteType > x)
  {
    this->discrete_.set (x);
  }

  const DeadBandTimeComplexType::TrueOptional& DeadBandTimeComplexType::
  getTrue () const
  {
    return this->true__;
  }

  DeadBandTimeComplexType::TrueOptional& DeadBandTimeComplexType::
  getTrue ()
  {
    return this->true__;
  }

  void DeadBandTimeComplexType::
  setTrue (const TrueType& x)
  {
    this->true__.set (x);
  }

  void DeadBandTimeComplexType::
  setTrue (const TrueOptional& x)
  {
    this->true__ = x;
  }

  void DeadBandTimeComplexType::
  setTrue (::std::auto_ptr< TrueType > x)
  {
    this->true__.set (x);
  }

  const DeadBandTimeComplexType::FalseOptional& DeadBandTimeComplexType::
  getFalse () const
  {
    return this->false__;
  }

  DeadBandTimeComplexType::FalseOptional& DeadBandTimeComplexType::
  getFalse ()
  {
    return this->false__;
  }

  void DeadBandTimeComplexType::
  setFalse (const FalseType& x)
  {
    this->false__.set (x);
  }

  void DeadBandTimeComplexType::
  setFalse (const FalseOptional& x)
  {
    this->false__ = x;
  }

  void DeadBandTimeComplexType::
  setFalse (::std::auto_ptr< FalseType > x)
  {
    this->false__.set (x);
  }

  const DeadBandTimeComplexType::InputType& DeadBandTimeComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  DeadBandTimeComplexType::InputType& DeadBandTimeComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void DeadBandTimeComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void DeadBandTimeComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const DeadBandTimeComplexType::OutputType& DeadBandTimeComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  DeadBandTimeComplexType::OutputType& DeadBandTimeComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void DeadBandTimeComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void DeadBandTimeComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const DeadBandTimeComplexType::IdType& DeadBandTimeComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  DeadBandTimeComplexType::IdType& DeadBandTimeComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void DeadBandTimeComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void DeadBandTimeComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const DeadBandTimeComplexType::NameOptional& DeadBandTimeComplexType::
  getName () const
  {
    return this->name_;
  }

  DeadBandTimeComplexType::NameOptional& DeadBandTimeComplexType::
  getName ()
  {
    return this->name_;
  }

  void DeadBandTimeComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DeadBandTimeComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DeadBandTimeComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // DeadBandTimeDiscreteComplexType
  // 

  const DeadBandTimeDiscreteComplexType::NumberOfStepsUpType& DeadBandTimeDiscreteComplexType::
  getNumberOfStepsUp () const
  {
    return this->numberOfStepsUp_.get ();
  }

  DeadBandTimeDiscreteComplexType::NumberOfStepsUpType& DeadBandTimeDiscreteComplexType::
  getNumberOfStepsUp ()
  {
    return this->numberOfStepsUp_.get ();
  }

  void DeadBandTimeDiscreteComplexType::
  setNumberOfStepsUp (const NumberOfStepsUpType& x)
  {
    this->numberOfStepsUp_.set (x);
  }

  const DeadBandTimeDiscreteComplexType::NumberOfStepsDownType& DeadBandTimeDiscreteComplexType::
  getNumberOfStepsDown () const
  {
    return this->numberOfStepsDown_.get ();
  }

  DeadBandTimeDiscreteComplexType::NumberOfStepsDownType& DeadBandTimeDiscreteComplexType::
  getNumberOfStepsDown ()
  {
    return this->numberOfStepsDown_.get ();
  }

  void DeadBandTimeDiscreteComplexType::
  setNumberOfStepsDown (const NumberOfStepsDownType& x)
  {
    this->numberOfStepsDown_.set (x);
  }


  // DeadBandTimeInputComplexType
  // 

  const DeadBandTimeInputComplexType::XType& DeadBandTimeInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  DeadBandTimeInputComplexType::XType& DeadBandTimeInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void DeadBandTimeInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void DeadBandTimeInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // DeadBandTimeOutputComplexType
  // 

  const DeadBandTimeOutputComplexType::StatusType& DeadBandTimeOutputComplexType::
  getStatus () const
  {
    return this->status_.get ();
  }

  DeadBandTimeOutputComplexType::StatusType& DeadBandTimeOutputComplexType::
  getStatus ()
  {
    return this->status_.get ();
  }

  void DeadBandTimeOutputComplexType::
  setStatus (const StatusType& x)
  {
    this->status_.set (x);
  }

  void DeadBandTimeOutputComplexType::
  setStatus (::std::auto_ptr< StatusType > x)
  {
    this->status_.set (x);
  }

  const DeadBandTimeOutputComplexType::StepsUpType& DeadBandTimeOutputComplexType::
  getStepsUp () const
  {
    return this->stepsUp_.get ();
  }

  DeadBandTimeOutputComplexType::StepsUpType& DeadBandTimeOutputComplexType::
  getStepsUp ()
  {
    return this->stepsUp_.get ();
  }

  void DeadBandTimeOutputComplexType::
  setStepsUp (const StepsUpType& x)
  {
    this->stepsUp_.set (x);
  }

  void DeadBandTimeOutputComplexType::
  setStepsUp (::std::auto_ptr< StepsUpType > x)
  {
    this->stepsUp_.set (x);
  }

  const DeadBandTimeOutputComplexType::StepsDownType& DeadBandTimeOutputComplexType::
  getStepsDown () const
  {
    return this->stepsDown_.get ();
  }

  DeadBandTimeOutputComplexType::StepsDownType& DeadBandTimeOutputComplexType::
  getStepsDown ()
  {
    return this->stepsDown_.get ();
  }

  void DeadBandTimeOutputComplexType::
  setStepsDown (const StepsDownType& x)
  {
    this->stepsDown_.set (x);
  }

  void DeadBandTimeOutputComplexType::
  setStepsDown (::std::auto_ptr< StepsDownType > x)
  {
    this->stepsDown_.set (x);
  }

  const DeadBandTimeOutputComplexType::TimeTrueOptional& DeadBandTimeOutputComplexType::
  getTimeTrue () const
  {
    return this->timeTrue_;
  }

  DeadBandTimeOutputComplexType::TimeTrueOptional& DeadBandTimeOutputComplexType::
  getTimeTrue ()
  {
    return this->timeTrue_;
  }

  void DeadBandTimeOutputComplexType::
  setTimeTrue (const TimeTrueType& x)
  {
    this->timeTrue_.set (x);
  }

  void DeadBandTimeOutputComplexType::
  setTimeTrue (const TimeTrueOptional& x)
  {
    this->timeTrue_ = x;
  }

  void DeadBandTimeOutputComplexType::
  setTimeTrue (::std::auto_ptr< TimeTrueType > x)
  {
    this->timeTrue_.set (x);
  }

  const DeadBandTimeOutputComplexType::TimeFalseOptional& DeadBandTimeOutputComplexType::
  getTimeFalse () const
  {
    return this->timeFalse_;
  }

  DeadBandTimeOutputComplexType::TimeFalseOptional& DeadBandTimeOutputComplexType::
  getTimeFalse ()
  {
    return this->timeFalse_;
  }

  void DeadBandTimeOutputComplexType::
  setTimeFalse (const TimeFalseType& x)
  {
    this->timeFalse_.set (x);
  }

  void DeadBandTimeOutputComplexType::
  setTimeFalse (const TimeFalseOptional& x)
  {
    this->timeFalse_ = x;
  }

  void DeadBandTimeOutputComplexType::
  setTimeFalse (::std::auto_ptr< TimeFalseType > x)
  {
    this->timeFalse_.set (x);
  }


  // LimiterComplexType
  // 

  const LimiterComplexType::ModeType& LimiterComplexType::
  getMode () const
  {
    return this->mode_.get ();
  }

  LimiterComplexType::ModeType& LimiterComplexType::
  getMode ()
  {
    return this->mode_.get ();
  }

  void LimiterComplexType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void LimiterComplexType::
  setMode (::std::auto_ptr< ModeType > x)
  {
    this->mode_.set (x);
  }

  const LimiterComplexType::InputType& LimiterComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  LimiterComplexType::InputType& LimiterComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void LimiterComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void LimiterComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const LimiterComplexType::IdType& LimiterComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  LimiterComplexType::IdType& LimiterComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void LimiterComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void LimiterComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const LimiterComplexType::NameOptional& LimiterComplexType::
  getName () const
  {
    return this->name_;
  }

  LimiterComplexType::NameOptional& LimiterComplexType::
  getName ()
  {
    return this->name_;
  }

  void LimiterComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void LimiterComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void LimiterComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // LimiterInputComplexType
  // 

  const LimiterInputComplexType::ThresholdSeriesOptional& LimiterInputComplexType::
  getThresholdSeries () const
  {
    return this->thresholdSeries_;
  }

  LimiterInputComplexType::ThresholdSeriesOptional& LimiterInputComplexType::
  getThresholdSeries ()
  {
    return this->thresholdSeries_;
  }

  void LimiterInputComplexType::
  setThresholdSeries (const ThresholdSeriesType& x)
  {
    this->thresholdSeries_.set (x);
  }

  void LimiterInputComplexType::
  setThresholdSeries (const ThresholdSeriesOptional& x)
  {
    this->thresholdSeries_ = x;
  }

  void LimiterInputComplexType::
  setThresholdSeries (::std::auto_ptr< ThresholdSeriesType > x)
  {
    this->thresholdSeries_.set (x);
  }

  const LimiterInputComplexType::ThresholdValueOptional& LimiterInputComplexType::
  getThresholdValue () const
  {
    return this->thresholdValue_;
  }

  LimiterInputComplexType::ThresholdValueOptional& LimiterInputComplexType::
  getThresholdValue ()
  {
    return this->thresholdValue_;
  }

  void LimiterInputComplexType::
  setThresholdValue (const ThresholdValueType& x)
  {
    this->thresholdValue_.set (x);
  }

  void LimiterInputComplexType::
  setThresholdValue (const ThresholdValueOptional& x)
  {
    this->thresholdValue_ = x;
  }

  const LimiterInputComplexType::XType& LimiterInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  LimiterInputComplexType::XType& LimiterInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void LimiterInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void LimiterInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }


  // TriggersComplexType
  // 

  const TriggersComplexType::TriggerSequence& TriggersComplexType::
  getTrigger () const
  {
    return this->trigger_;
  }

  TriggersComplexType::TriggerSequence& TriggersComplexType::
  getTrigger ()
  {
    return this->trigger_;
  }

  void TriggersComplexType::
  setTrigger (const TriggerSequence& s)
  {
    this->trigger_ = s;
  }


  // TriggerComplexType
  // 

  const TriggerComplexType::StandardOptional& TriggerComplexType::
  getStandard () const
  {
    return this->standard_;
  }

  TriggerComplexType::StandardOptional& TriggerComplexType::
  getStandard ()
  {
    return this->standard_;
  }

  void TriggerComplexType::
  setStandard (const StandardType& x)
  {
    this->standard_.set (x);
  }

  void TriggerComplexType::
  setStandard (const StandardOptional& x)
  {
    this->standard_ = x;
  }

  void TriggerComplexType::
  setStandard (::std::auto_ptr< StandardType > x)
  {
    this->standard_.set (x);
  }

  const TriggerComplexType::DeadBandOptional& TriggerComplexType::
  getDeadBand () const
  {
    return this->deadBand_;
  }

  TriggerComplexType::DeadBandOptional& TriggerComplexType::
  getDeadBand ()
  {
    return this->deadBand_;
  }

  void TriggerComplexType::
  setDeadBand (const DeadBandType& x)
  {
    this->deadBand_.set (x);
  }

  void TriggerComplexType::
  setDeadBand (const DeadBandOptional& x)
  {
    this->deadBand_ = x;
  }

  void TriggerComplexType::
  setDeadBand (::std::auto_ptr< DeadBandType > x)
  {
    this->deadBand_.set (x);
  }

  const TriggerComplexType::DeadBandTimeOptional& TriggerComplexType::
  getDeadBandTime () const
  {
    return this->deadBandTime_;
  }

  TriggerComplexType::DeadBandTimeOptional& TriggerComplexType::
  getDeadBandTime ()
  {
    return this->deadBandTime_;
  }

  void TriggerComplexType::
  setDeadBandTime (const DeadBandTimeType& x)
  {
    this->deadBandTime_.set (x);
  }

  void TriggerComplexType::
  setDeadBandTime (const DeadBandTimeOptional& x)
  {
    this->deadBandTime_ = x;
  }

  void TriggerComplexType::
  setDeadBandTime (::std::auto_ptr< DeadBandTimeType > x)
  {
    this->deadBandTime_.set (x);
  }

  const TriggerComplexType::ExpressionOptional& TriggerComplexType::
  getExpression () const
  {
    return this->expression_;
  }

  TriggerComplexType::ExpressionOptional& TriggerComplexType::
  getExpression ()
  {
    return this->expression_;
  }

  void TriggerComplexType::
  setExpression (const ExpressionType& x)
  {
    this->expression_.set (x);
  }

  void TriggerComplexType::
  setExpression (const ExpressionOptional& x)
  {
    this->expression_ = x;
  }

  void TriggerComplexType::
  setExpression (::std::auto_ptr< ExpressionType > x)
  {
    this->expression_.set (x);
  }

  const TriggerComplexType::LookupTableOptional& TriggerComplexType::
  getLookupTable () const
  {
    return this->lookupTable_;
  }

  TriggerComplexType::LookupTableOptional& TriggerComplexType::
  getLookupTable ()
  {
    return this->lookupTable_;
  }

  void TriggerComplexType::
  setLookupTable (const LookupTableType& x)
  {
    this->lookupTable_.set (x);
  }

  void TriggerComplexType::
  setLookupTable (const LookupTableOptional& x)
  {
    this->lookupTable_ = x;
  }

  void TriggerComplexType::
  setLookupTable (::std::auto_ptr< LookupTableType > x)
  {
    this->lookupTable_.set (x);
  }

  const TriggerComplexType::MergerOptional& TriggerComplexType::
  getMerger () const
  {
    return this->merger_;
  }

  TriggerComplexType::MergerOptional& TriggerComplexType::
  getMerger ()
  {
    return this->merger_;
  }

  void TriggerComplexType::
  setMerger (const MergerType& x)
  {
    this->merger_.set (x);
  }

  void TriggerComplexType::
  setMerger (const MergerOptional& x)
  {
    this->merger_ = x;
  }

  void TriggerComplexType::
  setMerger (::std::auto_ptr< MergerType > x)
  {
    this->merger_.set (x);
  }

  const TriggerComplexType::PolygonLookupOptional& TriggerComplexType::
  getPolygonLookup () const
  {
    return this->polygonLookup_;
  }

  TriggerComplexType::PolygonLookupOptional& TriggerComplexType::
  getPolygonLookup ()
  {
    return this->polygonLookup_;
  }

  void TriggerComplexType::
  setPolygonLookup (const PolygonLookupType& x)
  {
    this->polygonLookup_.set (x);
  }

  void TriggerComplexType::
  setPolygonLookup (const PolygonLookupOptional& x)
  {
    this->polygonLookup_ = x;
  }

  void TriggerComplexType::
  setPolygonLookup (::std::auto_ptr< PolygonLookupType > x)
  {
    this->polygonLookup_.set (x);
  }

  const TriggerComplexType::RuleReferenceOptional& TriggerComplexType::
  getRuleReference () const
  {
    return this->ruleReference_;
  }

  TriggerComplexType::RuleReferenceOptional& TriggerComplexType::
  getRuleReference ()
  {
    return this->ruleReference_;
  }

  void TriggerComplexType::
  setRuleReference (const RuleReferenceType& x)
  {
    this->ruleReference_.set (x);
  }

  void TriggerComplexType::
  setRuleReference (const RuleReferenceOptional& x)
  {
    this->ruleReference_ = x;
  }

  void TriggerComplexType::
  setRuleReference (::std::auto_ptr< RuleReferenceType > x)
  {
    this->ruleReference_.set (x);
  }

  const TriggerComplexType::SetOptional& TriggerComplexType::
  getSet () const
  {
    return this->set_;
  }

  TriggerComplexType::SetOptional& TriggerComplexType::
  getSet ()
  {
    return this->set_;
  }

  void TriggerComplexType::
  setSet (const SetType& x)
  {
    this->set_.set (x);
  }

  void TriggerComplexType::
  setSet (const SetOptional& x)
  {
    this->set_ = x;
  }

  void TriggerComplexType::
  setSet (::std::auto_ptr< SetType > x)
  {
    this->set_.set (x);
  }

  const TriggerComplexType::SpreadsheetOptional& TriggerComplexType::
  getSpreadsheet () const
  {
    return this->spreadsheet_;
  }

  TriggerComplexType::SpreadsheetOptional& TriggerComplexType::
  getSpreadsheet ()
  {
    return this->spreadsheet_;
  }

  void TriggerComplexType::
  setSpreadsheet (const SpreadsheetType& x)
  {
    this->spreadsheet_.set (x);
  }

  void TriggerComplexType::
  setSpreadsheet (const SpreadsheetOptional& x)
  {
    this->spreadsheet_ = x;
  }

  void TriggerComplexType::
  setSpreadsheet (::std::auto_ptr< SpreadsheetType > x)
  {
    this->spreadsheet_.set (x);
  }


  // EifelRurRuleComplexType
  // 

  const EifelRurRuleComplexType::AType& EifelRurRuleComplexType::
  getA () const
  {
    return this->a_.get ();
  }

  EifelRurRuleComplexType::AType& EifelRurRuleComplexType::
  getA ()
  {
    return this->a_.get ();
  }

  void EifelRurRuleComplexType::
  setA (const AType& x)
  {
    this->a_.set (x);
  }

  const EifelRurRuleComplexType::BType& EifelRurRuleComplexType::
  getB () const
  {
    return this->b_.get ();
  }

  EifelRurRuleComplexType::BType& EifelRurRuleComplexType::
  getB ()
  {
    return this->b_.get ();
  }

  void EifelRurRuleComplexType::
  setB (const BType& x)
  {
    this->b_.set (x);
  }

  const EifelRurRuleComplexType::MinimumRelativeStorageType& EifelRurRuleComplexType::
  getMinimumRelativeStorage () const
  {
    return this->minimumRelativeStorage_.get ();
  }

  EifelRurRuleComplexType::MinimumRelativeStorageType& EifelRurRuleComplexType::
  getMinimumRelativeStorage ()
  {
    return this->minimumRelativeStorage_.get ();
  }

  void EifelRurRuleComplexType::
  setMinimumRelativeStorage (const MinimumRelativeStorageType& x)
  {
    this->minimumRelativeStorage_.set (x);
  }

  void EifelRurRuleComplexType::
  setMinimumRelativeStorage (::std::auto_ptr< MinimumRelativeStorageType > x)
  {
    this->minimumRelativeStorage_.set (x);
  }

  const EifelRurRuleComplexType::IdType& EifelRurRuleComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  EifelRurRuleComplexType::IdType& EifelRurRuleComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void EifelRurRuleComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void EifelRurRuleComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const EifelRurRuleComplexType::NameOptional& EifelRurRuleComplexType::
  getName () const
  {
    return this->name_;
  }

  EifelRurRuleComplexType::NameOptional& EifelRurRuleComplexType::
  getName ()
  {
    return this->name_;
  }

  void EifelRurRuleComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void EifelRurRuleComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void EifelRurRuleComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // GuideBandRuleComplexType
  // 

  const GuideBandRuleComplexType::XMinType& GuideBandRuleComplexType::
  getXMin () const
  {
    return this->xMin_.get ();
  }

  GuideBandRuleComplexType::XMinType& GuideBandRuleComplexType::
  getXMin ()
  {
    return this->xMin_.get ();
  }

  void GuideBandRuleComplexType::
  setXMin (const XMinType& x)
  {
    this->xMin_.set (x);
  }

  void GuideBandRuleComplexType::
  setXMin (::std::auto_ptr< XMinType > x)
  {
    this->xMin_.set (x);
  }

  const GuideBandRuleComplexType::XMaxType& GuideBandRuleComplexType::
  getXMax () const
  {
    return this->xMax_.get ();
  }

  GuideBandRuleComplexType::XMaxType& GuideBandRuleComplexType::
  getXMax ()
  {
    return this->xMax_.get ();
  }

  void GuideBandRuleComplexType::
  setXMax (const XMaxType& x)
  {
    this->xMax_.set (x);
  }

  void GuideBandRuleComplexType::
  setXMax (::std::auto_ptr< XMaxType > x)
  {
    this->xMax_.set (x);
  }

  const GuideBandRuleComplexType::YMinOptional& GuideBandRuleComplexType::
  getYMin () const
  {
    return this->yMin_;
  }

  GuideBandRuleComplexType::YMinOptional& GuideBandRuleComplexType::
  getYMin ()
  {
    return this->yMin_;
  }

  void GuideBandRuleComplexType::
  setYMin (const YMinType& x)
  {
    this->yMin_.set (x);
  }

  void GuideBandRuleComplexType::
  setYMin (const YMinOptional& x)
  {
    this->yMin_ = x;
  }

  const GuideBandRuleComplexType::YMinSeriesOptional& GuideBandRuleComplexType::
  getYMinSeries () const
  {
    return this->yMinSeries_;
  }

  GuideBandRuleComplexType::YMinSeriesOptional& GuideBandRuleComplexType::
  getYMinSeries ()
  {
    return this->yMinSeries_;
  }

  void GuideBandRuleComplexType::
  setYMinSeries (const YMinSeriesType& x)
  {
    this->yMinSeries_.set (x);
  }

  void GuideBandRuleComplexType::
  setYMinSeries (const YMinSeriesOptional& x)
  {
    this->yMinSeries_ = x;
  }

  void GuideBandRuleComplexType::
  setYMinSeries (::std::auto_ptr< YMinSeriesType > x)
  {
    this->yMinSeries_.set (x);
  }

  const GuideBandRuleComplexType::YMaxOptional& GuideBandRuleComplexType::
  getYMax () const
  {
    return this->yMax_;
  }

  GuideBandRuleComplexType::YMaxOptional& GuideBandRuleComplexType::
  getYMax ()
  {
    return this->yMax_;
  }

  void GuideBandRuleComplexType::
  setYMax (const YMaxType& x)
  {
    this->yMax_.set (x);
  }

  void GuideBandRuleComplexType::
  setYMax (const YMaxOptional& x)
  {
    this->yMax_ = x;
  }

  const GuideBandRuleComplexType::YMaxSeriesOptional& GuideBandRuleComplexType::
  getYMaxSeries () const
  {
    return this->yMaxSeries_;
  }

  GuideBandRuleComplexType::YMaxSeriesOptional& GuideBandRuleComplexType::
  getYMaxSeries ()
  {
    return this->yMaxSeries_;
  }

  void GuideBandRuleComplexType::
  setYMaxSeries (const YMaxSeriesType& x)
  {
    this->yMaxSeries_.set (x);
  }

  void GuideBandRuleComplexType::
  setYMaxSeries (const YMaxSeriesOptional& x)
  {
    this->yMaxSeries_ = x;
  }

  void GuideBandRuleComplexType::
  setYMaxSeries (::std::auto_ptr< YMaxSeriesType > x)
  {
    this->yMaxSeries_.set (x);
  }

  const GuideBandRuleComplexType::InputType& GuideBandRuleComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  GuideBandRuleComplexType::InputType& GuideBandRuleComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void GuideBandRuleComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void GuideBandRuleComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const GuideBandRuleComplexType::OutputType& GuideBandRuleComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  GuideBandRuleComplexType::OutputType& GuideBandRuleComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void GuideBandRuleComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void GuideBandRuleComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const GuideBandRuleComplexType::IdType& GuideBandRuleComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  GuideBandRuleComplexType::IdType& GuideBandRuleComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void GuideBandRuleComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void GuideBandRuleComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const GuideBandRuleComplexType::NameOptional& GuideBandRuleComplexType::
  getName () const
  {
    return this->name_;
  }

  GuideBandRuleComplexType::NameOptional& GuideBandRuleComplexType::
  getName ()
  {
    return this->name_;
  }

  void GuideBandRuleComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void GuideBandRuleComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void GuideBandRuleComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // GuideBandRuleInputComplexType
  // 

  const GuideBandRuleInputComplexType::XType& GuideBandRuleInputComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  GuideBandRuleInputComplexType::XType& GuideBandRuleInputComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void GuideBandRuleInputComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void GuideBandRuleInputComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const GuideBandRuleInputComplexType::YOptional& GuideBandRuleInputComplexType::
  getY () const
  {
    return this->y_;
  }

  GuideBandRuleInputComplexType::YOptional& GuideBandRuleInputComplexType::
  getY ()
  {
    return this->y_;
  }

  void GuideBandRuleInputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void GuideBandRuleInputComplexType::
  setY (const YOptional& x)
  {
    this->y_ = x;
  }

  void GuideBandRuleInputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // GuideBandRuleOutputComplexType
  // 

  const GuideBandRuleOutputComplexType::YType& GuideBandRuleOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  GuideBandRuleOutputComplexType::YType& GuideBandRuleOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void GuideBandRuleOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void GuideBandRuleOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // ConstantRuleComplexType
  // 

  const ConstantRuleComplexType::ConstantType& ConstantRuleComplexType::
  getConstant () const
  {
    return this->constant_.get ();
  }

  ConstantRuleComplexType::ConstantType& ConstantRuleComplexType::
  getConstant ()
  {
    return this->constant_.get ();
  }

  void ConstantRuleComplexType::
  setConstant (const ConstantType& x)
  {
    this->constant_.set (x);
  }

  const ConstantRuleComplexType::OutputType& ConstantRuleComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ConstantRuleComplexType::OutputType& ConstantRuleComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ConstantRuleComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ConstantRuleComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ConstantRuleComplexType::IdType& ConstantRuleComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ConstantRuleComplexType::IdType& ConstantRuleComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ConstantRuleComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ConstantRuleComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ConstantRuleComplexType::NameOptional& ConstantRuleComplexType::
  getName () const
  {
    return this->name_;
  }

  ConstantRuleComplexType::NameOptional& ConstantRuleComplexType::
  getName ()
  {
    return this->name_;
  }

  void ConstantRuleComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ConstantRuleComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ConstantRuleComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // ConstantRuleOutputComplexType
  // 

  const ConstantRuleOutputComplexType::YType& ConstantRuleOutputComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  ConstantRuleOutputComplexType::YType& ConstantRuleOutputComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void ConstantRuleOutputComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void ConstantRuleOutputComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }


  // MinSimpleRuleComplexType
  // 

  const MinSimpleRuleComplexType::ZonesOptional& MinSimpleRuleComplexType::
  getZones () const
  {
    return this->zones_;
  }

  MinSimpleRuleComplexType::ZonesOptional& MinSimpleRuleComplexType::
  getZones ()
  {
    return this->zones_;
  }

  void MinSimpleRuleComplexType::
  setZones (const ZonesType& x)
  {
    this->zones_.set (x);
  }

  void MinSimpleRuleComplexType::
  setZones (const ZonesOptional& x)
  {
    this->zones_ = x;
  }

  void MinSimpleRuleComplexType::
  setZones (::std::auto_ptr< ZonesType > x)
  {
    this->zones_.set (x);
  }

  const MinSimpleRuleComplexType::DateTableOptional& MinSimpleRuleComplexType::
  getDateTable () const
  {
    return this->dateTable_;
  }

  MinSimpleRuleComplexType::DateTableOptional& MinSimpleRuleComplexType::
  getDateTable ()
  {
    return this->dateTable_;
  }

  void MinSimpleRuleComplexType::
  setDateTable (const DateTableType& x)
  {
    this->dateTable_.set (x);
  }

  void MinSimpleRuleComplexType::
  setDateTable (const DateTableOptional& x)
  {
    this->dateTable_ = x;
  }

  void MinSimpleRuleComplexType::
  setDateTable (::std::auto_ptr< DateTableType > x)
  {
    this->dateTable_.set (x);
  }

  const MinSimpleRuleComplexType::IdType& MinSimpleRuleComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  MinSimpleRuleComplexType::IdType& MinSimpleRuleComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void MinSimpleRuleComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void MinSimpleRuleComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const MinSimpleRuleComplexType::NameOptional& MinSimpleRuleComplexType::
  getName () const
  {
    return this->name_;
  }

  MinSimpleRuleComplexType::NameOptional& MinSimpleRuleComplexType::
  getName ()
  {
    return this->name_;
  }

  void MinSimpleRuleComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void MinSimpleRuleComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void MinSimpleRuleComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // StorageCharacteristicsComplexType
  // 

  const StorageCharacteristicsComplexType::StorageTableOptional& StorageCharacteristicsComplexType::
  getStorageTable () const
  {
    return this->storageTable_;
  }

  StorageCharacteristicsComplexType::StorageTableOptional& StorageCharacteristicsComplexType::
  getStorageTable ()
  {
    return this->storageTable_;
  }

  void StorageCharacteristicsComplexType::
  setStorageTable (const StorageTableType& x)
  {
    this->storageTable_.set (x);
  }

  void StorageCharacteristicsComplexType::
  setStorageTable (const StorageTableOptional& x)
  {
    this->storageTable_ = x;
  }

  void StorageCharacteristicsComplexType::
  setStorageTable (::std::auto_ptr< StorageTableType > x)
  {
    this->storageTable_.set (x);
  }

  const StorageCharacteristicsComplexType::StorageEquationOptional& StorageCharacteristicsComplexType::
  getStorageEquation () const
  {
    return this->storageEquation_;
  }

  StorageCharacteristicsComplexType::StorageEquationOptional& StorageCharacteristicsComplexType::
  getStorageEquation ()
  {
    return this->storageEquation_;
  }

  void StorageCharacteristicsComplexType::
  setStorageEquation (const StorageEquationType& x)
  {
    this->storageEquation_.set (x);
  }

  void StorageCharacteristicsComplexType::
  setStorageEquation (const StorageEquationOptional& x)
  {
    this->storageEquation_ = x;
  }

  void StorageCharacteristicsComplexType::
  setStorageEquation (::std::auto_ptr< StorageEquationType > x)
  {
    this->storageEquation_.set (x);
  }

  const StorageCharacteristicsComplexType::MaximumLevelOptional& StorageCharacteristicsComplexType::
  getMaximumLevel () const
  {
    return this->maximumLevel_;
  }

  StorageCharacteristicsComplexType::MaximumLevelOptional& StorageCharacteristicsComplexType::
  getMaximumLevel ()
  {
    return this->maximumLevel_;
  }

  void StorageCharacteristicsComplexType::
  setMaximumLevel (const MaximumLevelType& x)
  {
    this->maximumLevel_.set (x);
  }

  void StorageCharacteristicsComplexType::
  setMaximumLevel (const MaximumLevelOptional& x)
  {
    this->maximumLevel_ = x;
  }


  // CapacityCharacteristicsComplexType
  // 

  const CapacityCharacteristicsComplexType::CapacityTableOptional& CapacityCharacteristicsComplexType::
  getCapacityTable () const
  {
    return this->capacityTable_;
  }

  CapacityCharacteristicsComplexType::CapacityTableOptional& CapacityCharacteristicsComplexType::
  getCapacityTable ()
  {
    return this->capacityTable_;
  }

  void CapacityCharacteristicsComplexType::
  setCapacityTable (const CapacityTableType& x)
  {
    this->capacityTable_.set (x);
  }

  void CapacityCharacteristicsComplexType::
  setCapacityTable (const CapacityTableOptional& x)
  {
    this->capacityTable_ = x;
  }

  void CapacityCharacteristicsComplexType::
  setCapacityTable (::std::auto_ptr< CapacityTableType > x)
  {
    this->capacityTable_.set (x);
  }

  const CapacityCharacteristicsComplexType::CapacityEquationOptional& CapacityCharacteristicsComplexType::
  getCapacityEquation () const
  {
    return this->capacityEquation_;
  }

  CapacityCharacteristicsComplexType::CapacityEquationOptional& CapacityCharacteristicsComplexType::
  getCapacityEquation ()
  {
    return this->capacityEquation_;
  }

  void CapacityCharacteristicsComplexType::
  setCapacityEquation (const CapacityEquationType& x)
  {
    this->capacityEquation_.set (x);
  }

  void CapacityCharacteristicsComplexType::
  setCapacityEquation (const CapacityEquationOptional& x)
  {
    this->capacityEquation_ = x;
  }

  void CapacityCharacteristicsComplexType::
  setCapacityEquation (::std::auto_ptr< CapacityEquationType > x)
  {
    this->capacityEquation_.set (x);
  }

  const CapacityCharacteristicsComplexType::ReferenceOptional& CapacityCharacteristicsComplexType::
  getReference () const
  {
    return this->reference_;
  }

  CapacityCharacteristicsComplexType::ReferenceOptional& CapacityCharacteristicsComplexType::
  getReference ()
  {
    return this->reference_;
  }

  void CapacityCharacteristicsComplexType::
  setReference (const ReferenceType& x)
  {
    this->reference_.set (x);
  }

  void CapacityCharacteristicsComplexType::
  setReference (const ReferenceOptional& x)
  {
    this->reference_ = x;
  }

  void CapacityCharacteristicsComplexType::
  setReference (::std::auto_ptr< ReferenceType > x)
  {
    this->reference_.set (x);
  }


  // TurbineCharacteristicsComplexType
  // 

  const TurbineCharacteristicsComplexType::EfficiencyTableType& TurbineCharacteristicsComplexType::
  getEfficiencyTable () const
  {
    return this->efficiencyTable_.get ();
  }

  TurbineCharacteristicsComplexType::EfficiencyTableType& TurbineCharacteristicsComplexType::
  getEfficiencyTable ()
  {
    return this->efficiencyTable_.get ();
  }

  void TurbineCharacteristicsComplexType::
  setEfficiencyTable (const EfficiencyTableType& x)
  {
    this->efficiencyTable_.set (x);
  }

  void TurbineCharacteristicsComplexType::
  setEfficiencyTable (::std::auto_ptr< EfficiencyTableType > x)
  {
    this->efficiencyTable_.set (x);
  }

  const TurbineCharacteristicsComplexType::OutputType& TurbineCharacteristicsComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  TurbineCharacteristicsComplexType::OutputType& TurbineCharacteristicsComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void TurbineCharacteristicsComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void TurbineCharacteristicsComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // TurbineOutputCharacteristicsComplexType
  // 

  const TurbineOutputCharacteristicsComplexType::PowerType& TurbineOutputCharacteristicsComplexType::
  getPower () const
  {
    return this->power_.get ();
  }

  TurbineOutputCharacteristicsComplexType::PowerType& TurbineOutputCharacteristicsComplexType::
  getPower ()
  {
    return this->power_.get ();
  }

  void TurbineOutputCharacteristicsComplexType::
  setPower (const PowerType& x)
  {
    this->power_.set (x);
  }

  void TurbineOutputCharacteristicsComplexType::
  setPower (::std::auto_ptr< PowerType > x)
  {
    this->power_.set (x);
  }


  // ElevationTableComplexType
  // 

  const ElevationTableComplexType::ElevationRecordSequence& ElevationTableComplexType::
  getElevationRecord () const
  {
    return this->elevationRecord_;
  }

  ElevationTableComplexType::ElevationRecordSequence& ElevationTableComplexType::
  getElevationRecord ()
  {
    return this->elevationRecord_;
  }

  void ElevationTableComplexType::
  setElevationRecord (const ElevationRecordSequence& s)
  {
    this->elevationRecord_ = s;
  }


  // TailwaterComplexType
  // 

  const TailwaterComplexType::ConstantOptional& TailwaterComplexType::
  getConstant () const
  {
    return this->constant_;
  }

  TailwaterComplexType::ConstantOptional& TailwaterComplexType::
  getConstant ()
  {
    return this->constant_;
  }

  void TailwaterComplexType::
  setConstant (const ConstantType& x)
  {
    this->constant_.set (x);
  }

  void TailwaterComplexType::
  setConstant (const ConstantOptional& x)
  {
    this->constant_ = x;
  }

  const TailwaterComplexType::RatingCurveOptional& TailwaterComplexType::
  getRatingCurve () const
  {
    return this->ratingCurve_;
  }

  TailwaterComplexType::RatingCurveOptional& TailwaterComplexType::
  getRatingCurve ()
  {
    return this->ratingCurve_;
  }

  void TailwaterComplexType::
  setRatingCurve (const RatingCurveType& x)
  {
    this->ratingCurve_.set (x);
  }

  void TailwaterComplexType::
  setRatingCurve (const RatingCurveOptional& x)
  {
    this->ratingCurve_ = x;
  }

  void TailwaterComplexType::
  setRatingCurve (::std::auto_ptr< RatingCurveType > x)
  {
    this->ratingCurve_.set (x);
  }

  const TailwaterComplexType::OutputType& TailwaterComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  TailwaterComplexType::OutputType& TailwaterComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void TailwaterComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void TailwaterComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // TailwaterOutputComplexType
  // 

  const TailwaterOutputComplexType::LevelType& TailwaterOutputComplexType::
  getLevel () const
  {
    return this->level_.get ();
  }

  TailwaterOutputComplexType::LevelType& TailwaterOutputComplexType::
  getLevel ()
  {
    return this->level_.get ();
  }

  void TailwaterOutputComplexType::
  setLevel (const LevelType& x)
  {
    this->level_.set (x);
  }

  void TailwaterOutputComplexType::
  setLevel (::std::auto_ptr< LevelType > x)
  {
    this->level_.set (x);
  }

  const TailwaterOutputComplexType::HeadType& TailwaterOutputComplexType::
  getHead () const
  {
    return this->head_.get ();
  }

  TailwaterOutputComplexType::HeadType& TailwaterOutputComplexType::
  getHead ()
  {
    return this->head_.get ();
  }

  void TailwaterOutputComplexType::
  setHead (const HeadType& x)
  {
    this->head_.set (x);
  }

  void TailwaterOutputComplexType::
  setHead (::std::auto_ptr< HeadType > x)
  {
    this->head_.set (x);
  }


  // ElevationRecordComplexType
  // 

  const ElevationRecordComplexType::ElevationType& ElevationRecordComplexType::
  getElevation () const
  {
    return this->elevation_.get ();
  }

  ElevationRecordComplexType::ElevationType& ElevationRecordComplexType::
  getElevation ()
  {
    return this->elevation_.get ();
  }

  void ElevationRecordComplexType::
  setElevation (const ElevationType& x)
  {
    this->elevation_.set (x);
  }

  const ElevationRecordComplexType::ValueType& ElevationRecordComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  ElevationRecordComplexType::ValueType& ElevationRecordComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void ElevationRecordComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  void ElevationRecordComplexType::
  setValue (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }


  // ControlledOutletComplexType
  // 

  const ControlledOutletComplexType::CapacityCharacteristicsType& ControlledOutletComplexType::
  getCapacityCharacteristics () const
  {
    return this->capacityCharacteristics_.get ();
  }

  ControlledOutletComplexType::CapacityCharacteristicsType& ControlledOutletComplexType::
  getCapacityCharacteristics ()
  {
    return this->capacityCharacteristics_.get ();
  }

  void ControlledOutletComplexType::
  setCapacityCharacteristics (const CapacityCharacteristicsType& x)
  {
    this->capacityCharacteristics_.set (x);
  }

  void ControlledOutletComplexType::
  setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > x)
  {
    this->capacityCharacteristics_.set (x);
  }

  const ControlledOutletComplexType::TurbineCharacteristicsOptional& ControlledOutletComplexType::
  getTurbineCharacteristics () const
  {
    return this->turbineCharacteristics_;
  }

  ControlledOutletComplexType::TurbineCharacteristicsOptional& ControlledOutletComplexType::
  getTurbineCharacteristics ()
  {
    return this->turbineCharacteristics_;
  }

  void ControlledOutletComplexType::
  setTurbineCharacteristics (const TurbineCharacteristicsType& x)
  {
    this->turbineCharacteristics_.set (x);
  }

  void ControlledOutletComplexType::
  setTurbineCharacteristics (const TurbineCharacteristicsOptional& x)
  {
    this->turbineCharacteristics_ = x;
  }

  void ControlledOutletComplexType::
  setTurbineCharacteristics (::std::auto_ptr< TurbineCharacteristicsType > x)
  {
    this->turbineCharacteristics_.set (x);
  }

  const ControlledOutletComplexType::InputType& ControlledOutletComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ControlledOutletComplexType::InputType& ControlledOutletComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ControlledOutletComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ControlledOutletComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ControlledOutletComplexType::OutputType& ControlledOutletComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ControlledOutletComplexType::OutputType& ControlledOutletComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ControlledOutletComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ControlledOutletComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ControlledOutletComplexType::IdType& ControlledOutletComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ControlledOutletComplexType::IdType& ControlledOutletComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ControlledOutletComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ControlledOutletComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ControlledOutletComplexType::NameOptional& ControlledOutletComplexType::
  getName () const
  {
    return this->name_;
  }

  ControlledOutletComplexType::NameOptional& ControlledOutletComplexType::
  getName ()
  {
    return this->name_;
  }

  void ControlledOutletComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ControlledOutletComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ControlledOutletComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // UncontrolledOutletComplexType
  // 

  const UncontrolledOutletComplexType::CapacityCharacteristicsType& UncontrolledOutletComplexType::
  getCapacityCharacteristics () const
  {
    return this->capacityCharacteristics_.get ();
  }

  UncontrolledOutletComplexType::CapacityCharacteristicsType& UncontrolledOutletComplexType::
  getCapacityCharacteristics ()
  {
    return this->capacityCharacteristics_.get ();
  }

  void UncontrolledOutletComplexType::
  setCapacityCharacteristics (const CapacityCharacteristicsType& x)
  {
    this->capacityCharacteristics_.set (x);
  }

  void UncontrolledOutletComplexType::
  setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > x)
  {
    this->capacityCharacteristics_.set (x);
  }

  const UncontrolledOutletComplexType::InputOptional& UncontrolledOutletComplexType::
  getInput () const
  {
    return this->input_;
  }

  UncontrolledOutletComplexType::InputOptional& UncontrolledOutletComplexType::
  getInput ()
  {
    return this->input_;
  }

  void UncontrolledOutletComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void UncontrolledOutletComplexType::
  setInput (const InputOptional& x)
  {
    this->input_ = x;
  }

  void UncontrolledOutletComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const UncontrolledOutletComplexType::OutputType& UncontrolledOutletComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  UncontrolledOutletComplexType::OutputType& UncontrolledOutletComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void UncontrolledOutletComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void UncontrolledOutletComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const UncontrolledOutletComplexType::IdType& UncontrolledOutletComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  UncontrolledOutletComplexType::IdType& UncontrolledOutletComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void UncontrolledOutletComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void UncontrolledOutletComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const UncontrolledOutletComplexType::NameOptional& UncontrolledOutletComplexType::
  getName () const
  {
    return this->name_;
  }

  UncontrolledOutletComplexType::NameOptional& UncontrolledOutletComplexType::
  getName ()
  {
    return this->name_;
  }

  void UncontrolledOutletComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void UncontrolledOutletComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void UncontrolledOutletComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // UOutletInputComplexType
  // 

  const UOutletInputComplexType::ReleaseType& UOutletInputComplexType::
  getRelease () const
  {
    return this->release_.get ();
  }

  UOutletInputComplexType::ReleaseType& UOutletInputComplexType::
  getRelease ()
  {
    return this->release_.get ();
  }

  void UOutletInputComplexType::
  setRelease (const ReleaseType& x)
  {
    this->release_.set (x);
  }

  void UOutletInputComplexType::
  setRelease (::std::auto_ptr< ReleaseType > x)
  {
    this->release_.set (x);
  }


  // EquationsComplexType
  // 

  const EquationsComplexType::EquationSequence& EquationsComplexType::
  getEquation () const
  {
    return this->equation_;
  }

  EquationsComplexType::EquationSequence& EquationsComplexType::
  getEquation ()
  {
    return this->equation_;
  }

  void EquationsComplexType::
  setEquation (const EquationSequence& s)
  {
    this->equation_ = s;
  }


  // EquationComplexType
  // 

  const EquationComplexType::LowerLevelOptional& EquationComplexType::
  getLowerLevel () const
  {
    return this->lowerLevel_;
  }

  EquationComplexType::LowerLevelOptional& EquationComplexType::
  getLowerLevel ()
  {
    return this->lowerLevel_;
  }

  void EquationComplexType::
  setLowerLevel (const LowerLevelType& x)
  {
    this->lowerLevel_.set (x);
  }

  void EquationComplexType::
  setLowerLevel (const LowerLevelOptional& x)
  {
    this->lowerLevel_ = x;
  }

  const EquationComplexType::UpperLevelOptional& EquationComplexType::
  getUpperLevel () const
  {
    return this->upperLevel_;
  }

  EquationComplexType::UpperLevelOptional& EquationComplexType::
  getUpperLevel ()
  {
    return this->upperLevel_;
  }

  void EquationComplexType::
  setUpperLevel (const UpperLevelType& x)
  {
    this->upperLevel_.set (x);
  }

  void EquationComplexType::
  setUpperLevel (const UpperLevelOptional& x)
  {
    this->upperLevel_ = x;
  }

  const EquationComplexType::AType& EquationComplexType::
  getA () const
  {
    return this->a_.get ();
  }

  EquationComplexType::AType& EquationComplexType::
  getA ()
  {
    return this->a_.get ();
  }

  void EquationComplexType::
  setA (const AType& x)
  {
    this->a_.set (x);
  }

  void EquationComplexType::
  setA (::std::auto_ptr< AType > x)
  {
    this->a_.set (x);
  }

  const EquationComplexType::BType& EquationComplexType::
  getB () const
  {
    return this->b_.get ();
  }

  EquationComplexType::BType& EquationComplexType::
  getB ()
  {
    return this->b_.get ();
  }

  void EquationComplexType::
  setB (const BType& x)
  {
    this->b_.set (x);
  }

  void EquationComplexType::
  setB (::std::auto_ptr< BType > x)
  {
    this->b_.set (x);
  }

  const EquationComplexType::CType& EquationComplexType::
  getC () const
  {
    return this->c_.get ();
  }

  EquationComplexType::CType& EquationComplexType::
  getC ()
  {
    return this->c_.get ();
  }

  void EquationComplexType::
  setC (const CType& x)
  {
    this->c_.set (x);
  }

  void EquationComplexType::
  setC (::std::auto_ptr< CType > x)
  {
    this->c_.set (x);
  }


  // ZonesComplexType
  // 

  const ZonesComplexType::ZoneSequence& ZonesComplexType::
  getZone () const
  {
    return this->zone_;
  }

  ZonesComplexType::ZoneSequence& ZonesComplexType::
  getZone ()
  {
    return this->zone_;
  }

  void ZonesComplexType::
  setZone (const ZoneSequence& s)
  {
    this->zone_ = s;
  }


  // ZoneComplexType
  // 

  const ZoneComplexType::DateTableType& ZoneComplexType::
  getDateTable () const
  {
    return this->dateTable_.get ();
  }

  ZoneComplexType::DateTableType& ZoneComplexType::
  getDateTable ()
  {
    return this->dateTable_.get ();
  }

  void ZoneComplexType::
  setDateTable (const DateTableType& x)
  {
    this->dateTable_.set (x);
  }

  void ZoneComplexType::
  setDateTable (::std::auto_ptr< DateTableType > x)
  {
    this->dateTable_.set (x);
  }

  const ZoneComplexType::MinOptional& ZoneComplexType::
  getMin () const
  {
    return this->min_;
  }

  ZoneComplexType::MinOptional& ZoneComplexType::
  getMin ()
  {
    return this->min_;
  }

  void ZoneComplexType::
  setMin (const MinType& x)
  {
    this->min_.set (x);
  }

  void ZoneComplexType::
  setMin (const MinOptional& x)
  {
    this->min_ = x;
  }

  void ZoneComplexType::
  setMin (::std::auto_ptr< MinType > x)
  {
    this->min_.set (x);
  }

  const ZoneComplexType::MaxOptional& ZoneComplexType::
  getMax () const
  {
    return this->max_;
  }

  ZoneComplexType::MaxOptional& ZoneComplexType::
  getMax ()
  {
    return this->max_;
  }

  void ZoneComplexType::
  setMax (const MaxType& x)
  {
    this->max_.set (x);
  }

  void ZoneComplexType::
  setMax (const MaxOptional& x)
  {
    this->max_ = x;
  }

  void ZoneComplexType::
  setMax (::std::auto_ptr< MaxType > x)
  {
    this->max_.set (x);
  }


  // DateTableComplexType
  // 

  const DateTableComplexType::DataSequence& DateTableComplexType::
  getData () const
  {
    return this->data_;
  }

  DateTableComplexType::DataSequence& DateTableComplexType::
  getData ()
  {
    return this->data_;
  }

  void DateTableComplexType::
  setData (const DataSequence& s)
  {
    this->data_ = s;
  }


  // DateRecordComplexType
  // 

  const DateRecordComplexType::MonthDayOptional& DateRecordComplexType::
  getMonthDay () const
  {
    return this->monthDay_;
  }

  DateRecordComplexType::MonthDayOptional& DateRecordComplexType::
  getMonthDay ()
  {
    return this->monthDay_;
  }

  void DateRecordComplexType::
  setMonthDay (const MonthDayType& x)
  {
    this->monthDay_.set (x);
  }

  void DateRecordComplexType::
  setMonthDay (const MonthDayOptional& x)
  {
    this->monthDay_ = x;
  }

  void DateRecordComplexType::
  setMonthDay (::std::auto_ptr< MonthDayType > x)
  {
    this->monthDay_.set (x);
  }

  const DateRecordComplexType::DateTimeOptional& DateRecordComplexType::
  getDateTime () const
  {
    return this->dateTime_;
  }

  DateRecordComplexType::DateTimeOptional& DateRecordComplexType::
  getDateTime ()
  {
    return this->dateTime_;
  }

  void DateRecordComplexType::
  setDateTime (const DateTimeType& x)
  {
    this->dateTime_.set (x);
  }

  void DateRecordComplexType::
  setDateTime (const DateTimeOptional& x)
  {
    this->dateTime_ = x;
  }

  void DateRecordComplexType::
  setDateTime (::std::auto_ptr< DateTimeType > x)
  {
    this->dateTime_.set (x);
  }

  const DateRecordComplexType::TimeOptional& DateRecordComplexType::
  getTime () const
  {
    return this->time_;
  }

  DateRecordComplexType::TimeOptional& DateRecordComplexType::
  getTime ()
  {
    return this->time_;
  }

  void DateRecordComplexType::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void DateRecordComplexType::
  setTime (const TimeOptional& x)
  {
    this->time_ = x;
  }

  void DateRecordComplexType::
  setTime (::std::auto_ptr< TimeType > x)
  {
    this->time_.set (x);
  }

  const DateRecordComplexType::ValueType& DateRecordComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  DateRecordComplexType::ValueType& DateRecordComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void DateRecordComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  const DateRecordComplexType::CommentOptional& DateRecordComplexType::
  getComment () const
  {
    return this->comment_;
  }

  DateRecordComplexType::CommentOptional& DateRecordComplexType::
  getComment ()
  {
    return this->comment_;
  }

  void DateRecordComplexType::
  setComment (const CommentType& x)
  {
    this->comment_.set (x);
  }

  void DateRecordComplexType::
  setComment (const CommentOptional& x)
  {
    this->comment_ = x;
  }

  void DateRecordComplexType::
  setComment (::std::auto_ptr< CommentType > x)
  {
    this->comment_.set (x);
  }


  // ReservoirInputComplexType
  // 

  const ReservoirInputComplexType::InflowSequence& ReservoirInputComplexType::
  getInflow () const
  {
    return this->inflow_;
  }

  ReservoirInputComplexType::InflowSequence& ReservoirInputComplexType::
  getInflow ()
  {
    return this->inflow_;
  }

  void ReservoirInputComplexType::
  setInflow (const InflowSequence& s)
  {
    this->inflow_ = s;
  }

  const ReservoirInputComplexType::LevelOptional& ReservoirInputComplexType::
  getLevel () const
  {
    return this->level_;
  }

  ReservoirInputComplexType::LevelOptional& ReservoirInputComplexType::
  getLevel ()
  {
    return this->level_;
  }

  void ReservoirInputComplexType::
  setLevel (const LevelType& x)
  {
    this->level_.set (x);
  }

  void ReservoirInputComplexType::
  setLevel (const LevelOptional& x)
  {
    this->level_ = x;
  }

  void ReservoirInputComplexType::
  setLevel (::std::auto_ptr< LevelType > x)
  {
    this->level_.set (x);
  }

  const ReservoirInputComplexType::PrecipitationOptional& ReservoirInputComplexType::
  getPrecipitation () const
  {
    return this->precipitation_;
  }

  ReservoirInputComplexType::PrecipitationOptional& ReservoirInputComplexType::
  getPrecipitation ()
  {
    return this->precipitation_;
  }

  void ReservoirInputComplexType::
  setPrecipitation (const PrecipitationType& x)
  {
    this->precipitation_.set (x);
  }

  void ReservoirInputComplexType::
  setPrecipitation (const PrecipitationOptional& x)
  {
    this->precipitation_ = x;
  }

  void ReservoirInputComplexType::
  setPrecipitation (::std::auto_ptr< PrecipitationType > x)
  {
    this->precipitation_.set (x);
  }

  const ReservoirInputComplexType::EvaporationOptional& ReservoirInputComplexType::
  getEvaporation () const
  {
    return this->evaporation_;
  }

  ReservoirInputComplexType::EvaporationOptional& ReservoirInputComplexType::
  getEvaporation ()
  {
    return this->evaporation_;
  }

  void ReservoirInputComplexType::
  setEvaporation (const EvaporationType& x)
  {
    this->evaporation_.set (x);
  }

  void ReservoirInputComplexType::
  setEvaporation (const EvaporationOptional& x)
  {
    this->evaporation_ = x;
  }

  void ReservoirInputComplexType::
  setEvaporation (::std::auto_ptr< EvaporationType > x)
  {
    this->evaporation_.set (x);
  }


  // ReservoirOutputComplexType
  // 

  const ReservoirOutputComplexType::InflowType& ReservoirOutputComplexType::
  getInflow () const
  {
    return this->inflow_.get ();
  }

  ReservoirOutputComplexType::InflowType& ReservoirOutputComplexType::
  getInflow ()
  {
    return this->inflow_.get ();
  }

  void ReservoirOutputComplexType::
  setInflow (const InflowType& x)
  {
    this->inflow_.set (x);
  }

  void ReservoirOutputComplexType::
  setInflow (::std::auto_ptr< InflowType > x)
  {
    this->inflow_.set (x);
  }

  const ReservoirOutputComplexType::ReleaseType& ReservoirOutputComplexType::
  getRelease () const
  {
    return this->release_.get ();
  }

  ReservoirOutputComplexType::ReleaseType& ReservoirOutputComplexType::
  getRelease ()
  {
    return this->release_.get ();
  }

  void ReservoirOutputComplexType::
  setRelease (const ReleaseType& x)
  {
    this->release_.set (x);
  }

  void ReservoirOutputComplexType::
  setRelease (::std::auto_ptr< ReleaseType > x)
  {
    this->release_.set (x);
  }

  const ReservoirOutputComplexType::StorageType& ReservoirOutputComplexType::
  getStorage () const
  {
    return this->storage_.get ();
  }

  ReservoirOutputComplexType::StorageType& ReservoirOutputComplexType::
  getStorage ()
  {
    return this->storage_.get ();
  }

  void ReservoirOutputComplexType::
  setStorage (const StorageType& x)
  {
    this->storage_.set (x);
  }

  void ReservoirOutputComplexType::
  setStorage (::std::auto_ptr< StorageType > x)
  {
    this->storage_.set (x);
  }

  const ReservoirOutputComplexType::RelativeStorageOptional& ReservoirOutputComplexType::
  getRelativeStorage () const
  {
    return this->relativeStorage_;
  }

  ReservoirOutputComplexType::RelativeStorageOptional& ReservoirOutputComplexType::
  getRelativeStorage ()
  {
    return this->relativeStorage_;
  }

  void ReservoirOutputComplexType::
  setRelativeStorage (const RelativeStorageType& x)
  {
    this->relativeStorage_.set (x);
  }

  void ReservoirOutputComplexType::
  setRelativeStorage (const RelativeStorageOptional& x)
  {
    this->relativeStorage_ = x;
  }

  void ReservoirOutputComplexType::
  setRelativeStorage (::std::auto_ptr< RelativeStorageType > x)
  {
    this->relativeStorage_.set (x);
  }

  const ReservoirOutputComplexType::LevelType& ReservoirOutputComplexType::
  getLevel () const
  {
    return this->level_.get ();
  }

  ReservoirOutputComplexType::LevelType& ReservoirOutputComplexType::
  getLevel ()
  {
    return this->level_.get ();
  }

  void ReservoirOutputComplexType::
  setLevel (const LevelType& x)
  {
    this->level_.set (x);
  }

  void ReservoirOutputComplexType::
  setLevel (::std::auto_ptr< LevelType > x)
  {
    this->level_.set (x);
  }

  const ReservoirOutputComplexType::ErrorOptional& ReservoirOutputComplexType::
  getError () const
  {
    return this->error_;
  }

  ReservoirOutputComplexType::ErrorOptional& ReservoirOutputComplexType::
  getError ()
  {
    return this->error_;
  }

  void ReservoirOutputComplexType::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void ReservoirOutputComplexType::
  setError (const ErrorOptional& x)
  {
    this->error_ = x;
  }

  void ReservoirOutputComplexType::
  setError (::std::auto_ptr< ErrorType > x)
  {
    this->error_.set (x);
  }

  const ReservoirOutputComplexType::ResiduumOptional& ReservoirOutputComplexType::
  getResiduum () const
  {
    return this->residuum_;
  }

  ReservoirOutputComplexType::ResiduumOptional& ReservoirOutputComplexType::
  getResiduum ()
  {
    return this->residuum_;
  }

  void ReservoirOutputComplexType::
  setResiduum (const ResiduumType& x)
  {
    this->residuum_.set (x);
  }

  void ReservoirOutputComplexType::
  setResiduum (const ResiduumOptional& x)
  {
    this->residuum_ = x;
  }

  void ReservoirOutputComplexType::
  setResiduum (::std::auto_ptr< ResiduumType > x)
  {
    this->residuum_.set (x);
  }


  // ReservoirGradientComplexType
  // 

  const ReservoirGradientComplexType::LambdaType& ReservoirGradientComplexType::
  getLambda () const
  {
    return this->lambda_.get ();
  }

  ReservoirGradientComplexType::LambdaType& ReservoirGradientComplexType::
  getLambda ()
  {
    return this->lambda_.get ();
  }

  void ReservoirGradientComplexType::
  setLambda (const LambdaType& x)
  {
    this->lambda_.set (x);
  }

  void ReservoirGradientComplexType::
  setLambda (::std::auto_ptr< LambdaType > x)
  {
    this->lambda_.set (x);
  }

  const ReservoirGradientComplexType::LambdaDownOptional& ReservoirGradientComplexType::
  getLambdaDown () const
  {
    return this->lambdaDown_;
  }

  ReservoirGradientComplexType::LambdaDownOptional& ReservoirGradientComplexType::
  getLambdaDown ()
  {
    return this->lambdaDown_;
  }

  void ReservoirGradientComplexType::
  setLambdaDown (const LambdaDownType& x)
  {
    this->lambdaDown_.set (x);
  }

  void ReservoirGradientComplexType::
  setLambdaDown (const LambdaDownOptional& x)
  {
    this->lambdaDown_ = x;
  }

  void ReservoirGradientComplexType::
  setLambdaDown (::std::auto_ptr< LambdaDownType > x)
  {
    this->lambdaDown_.set (x);
  }


  // NodeGradientComplexType
  // 

  const NodeGradientComplexType::LambdaType& NodeGradientComplexType::
  getLambda () const
  {
    return this->lambda_.get ();
  }

  NodeGradientComplexType::LambdaType& NodeGradientComplexType::
  getLambda ()
  {
    return this->lambda_.get ();
  }

  void NodeGradientComplexType::
  setLambda (const LambdaType& x)
  {
    this->lambda_.set (x);
  }

  void NodeGradientComplexType::
  setLambda (::std::auto_ptr< LambdaType > x)
  {
    this->lambda_.set (x);
  }

  const NodeGradientComplexType::SurfaceAreaType& NodeGradientComplexType::
  getSurfaceArea () const
  {
    return this->surfaceArea_.get ();
  }

  NodeGradientComplexType::SurfaceAreaType& NodeGradientComplexType::
  getSurfaceArea ()
  {
    return this->surfaceArea_.get ();
  }

  void NodeGradientComplexType::
  setSurfaceArea (const SurfaceAreaType& x)
  {
    this->surfaceArea_.set (x);
  }

  void NodeGradientComplexType::
  setSurfaceArea (::std::auto_ptr< SurfaceAreaType > x)
  {
    this->surfaceArea_.set (x);
  }


  // OutletInputComplexType
  // 

  const OutletInputComplexType::ReleaseOptional& OutletInputComplexType::
  getRelease () const
  {
    return this->release_;
  }

  OutletInputComplexType::ReleaseOptional& OutletInputComplexType::
  getRelease ()
  {
    return this->release_;
  }

  void OutletInputComplexType::
  setRelease (const ReleaseType& x)
  {
    this->release_.set (x);
  }

  void OutletInputComplexType::
  setRelease (const ReleaseOptional& x)
  {
    this->release_ = x;
  }

  void OutletInputComplexType::
  setRelease (::std::auto_ptr< ReleaseType > x)
  {
    this->release_.set (x);
  }

  const OutletInputComplexType::RelativeReleaseSequence& OutletInputComplexType::
  getRelativeRelease () const
  {
    return this->relativeRelease_;
  }

  OutletInputComplexType::RelativeReleaseSequence& OutletInputComplexType::
  getRelativeRelease ()
  {
    return this->relativeRelease_;
  }

  void OutletInputComplexType::
  setRelativeRelease (const RelativeReleaseSequence& s)
  {
    this->relativeRelease_ = s;
  }


  // OutletOutputComplexType
  // 

  const OutletOutputComplexType::ReleaseType& OutletOutputComplexType::
  getRelease () const
  {
    return this->release_.get ();
  }

  OutletOutputComplexType::ReleaseType& OutletOutputComplexType::
  getRelease ()
  {
    return this->release_.get ();
  }

  void OutletOutputComplexType::
  setRelease (const ReleaseType& x)
  {
    this->release_.set (x);
  }

  void OutletOutputComplexType::
  setRelease (::std::auto_ptr< ReleaseType > x)
  {
    this->release_.set (x);
  }


  // DeadBandTriggerComplexType
  // 

  const DeadBandTriggerComplexType::ConditionOnType& DeadBandTriggerComplexType::
  getConditionOn () const
  {
    return this->conditionOn_.get ();
  }

  DeadBandTriggerComplexType::ConditionOnType& DeadBandTriggerComplexType::
  getConditionOn ()
  {
    return this->conditionOn_.get ();
  }

  void DeadBandTriggerComplexType::
  setConditionOn (const ConditionOnType& x)
  {
    this->conditionOn_.set (x);
  }

  void DeadBandTriggerComplexType::
  setConditionOn (::std::auto_ptr< ConditionOnType > x)
  {
    this->conditionOn_.set (x);
  }

  const DeadBandTriggerComplexType::ConditionOffType& DeadBandTriggerComplexType::
  getConditionOff () const
  {
    return this->conditionOff_.get ();
  }

  DeadBandTriggerComplexType::ConditionOffType& DeadBandTriggerComplexType::
  getConditionOff ()
  {
    return this->conditionOff_.get ();
  }

  void DeadBandTriggerComplexType::
  setConditionOff (const ConditionOffType& x)
  {
    this->conditionOff_.set (x);
  }

  void DeadBandTriggerComplexType::
  setConditionOff (::std::auto_ptr< ConditionOffType > x)
  {
    this->conditionOff_.set (x);
  }

  const DeadBandTriggerComplexType::DefaultOptional& DeadBandTriggerComplexType::
  getDefault () const
  {
    return this->default__;
  }

  DeadBandTriggerComplexType::DefaultOptional& DeadBandTriggerComplexType::
  getDefault ()
  {
    return this->default__;
  }

  void DeadBandTriggerComplexType::
  setDefault (const DefaultType& x)
  {
    this->default__.set (x);
  }

  void DeadBandTriggerComplexType::
  setDefault (const DefaultOptional& x)
  {
    this->default__ = x;
  }

  const DeadBandTriggerComplexType::TrueOptional& DeadBandTriggerComplexType::
  getTrue () const
  {
    return this->true__;
  }

  DeadBandTriggerComplexType::TrueOptional& DeadBandTriggerComplexType::
  getTrue ()
  {
    return this->true__;
  }

  void DeadBandTriggerComplexType::
  setTrue (const TrueType& x)
  {
    this->true__.set (x);
  }

  void DeadBandTriggerComplexType::
  setTrue (const TrueOptional& x)
  {
    this->true__ = x;
  }

  void DeadBandTriggerComplexType::
  setTrue (::std::auto_ptr< TrueType > x)
  {
    this->true__.set (x);
  }

  const DeadBandTriggerComplexType::FalseOptional& DeadBandTriggerComplexType::
  getFalse () const
  {
    return this->false__;
  }

  DeadBandTriggerComplexType::FalseOptional& DeadBandTriggerComplexType::
  getFalse ()
  {
    return this->false__;
  }

  void DeadBandTriggerComplexType::
  setFalse (const FalseType& x)
  {
    this->false__.set (x);
  }

  void DeadBandTriggerComplexType::
  setFalse (const FalseOptional& x)
  {
    this->false__ = x;
  }

  void DeadBandTriggerComplexType::
  setFalse (::std::auto_ptr< FalseType > x)
  {
    this->false__.set (x);
  }

  const DeadBandTriggerComplexType::OutputType& DeadBandTriggerComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  DeadBandTriggerComplexType::OutputType& DeadBandTriggerComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void DeadBandTriggerComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void DeadBandTriggerComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const DeadBandTriggerComplexType::IdType& DeadBandTriggerComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  DeadBandTriggerComplexType::IdType& DeadBandTriggerComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void DeadBandTriggerComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void DeadBandTriggerComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const DeadBandTriggerComplexType::NameOptional& DeadBandTriggerComplexType::
  getName () const
  {
    return this->name_;
  }

  DeadBandTriggerComplexType::NameOptional& DeadBandTriggerComplexType::
  getName ()
  {
    return this->name_;
  }

  void DeadBandTriggerComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DeadBandTriggerComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DeadBandTriggerComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // TriggerInputComplexType
  // 

  const TriggerInputComplexType::StatusType& TriggerInputComplexType::
  getStatus () const
  {
    return this->status_.get ();
  }

  TriggerInputComplexType::StatusType& TriggerInputComplexType::
  getStatus ()
  {
    return this->status_.get ();
  }

  void TriggerInputComplexType::
  setStatus (const StatusType& x)
  {
    this->status_.set (x);
  }

  void TriggerInputComplexType::
  setStatus (::std::auto_ptr< StatusType > x)
  {
    this->status_.set (x);
  }


  // TriggerOutputComplexType
  // 

  const TriggerOutputComplexType::StatusType& TriggerOutputComplexType::
  getStatus () const
  {
    return this->status_.get ();
  }

  TriggerOutputComplexType::StatusType& TriggerOutputComplexType::
  getStatus ()
  {
    return this->status_.get ();
  }

  void TriggerOutputComplexType::
  setStatus (const StatusType& x)
  {
    this->status_.set (x);
  }

  void TriggerOutputComplexType::
  setStatus (::std::auto_ptr< StatusType > x)
  {
    this->status_.set (x);
  }

  const TriggerOutputComplexType::TimeTrueOptional& TriggerOutputComplexType::
  getTimeTrue () const
  {
    return this->timeTrue_;
  }

  TriggerOutputComplexType::TimeTrueOptional& TriggerOutputComplexType::
  getTimeTrue ()
  {
    return this->timeTrue_;
  }

  void TriggerOutputComplexType::
  setTimeTrue (const TimeTrueType& x)
  {
    this->timeTrue_.set (x);
  }

  void TriggerOutputComplexType::
  setTimeTrue (const TimeTrueOptional& x)
  {
    this->timeTrue_ = x;
  }

  void TriggerOutputComplexType::
  setTimeTrue (::std::auto_ptr< TimeTrueType > x)
  {
    this->timeTrue_.set (x);
  }

  const TriggerOutputComplexType::TimeFalseOptional& TriggerOutputComplexType::
  getTimeFalse () const
  {
    return this->timeFalse_;
  }

  TriggerOutputComplexType::TimeFalseOptional& TriggerOutputComplexType::
  getTimeFalse ()
  {
    return this->timeFalse_;
  }

  void TriggerOutputComplexType::
  setTimeFalse (const TimeFalseType& x)
  {
    this->timeFalse_.set (x);
  }

  void TriggerOutputComplexType::
  setTimeFalse (const TimeFalseOptional& x)
  {
    this->timeFalse_ = x;
  }

  void TriggerOutputComplexType::
  setTimeFalse (::std::auto_ptr< TimeFalseType > x)
  {
    this->timeFalse_.set (x);
  }


  // StandardTriggerComplexType
  // 

  const StandardTriggerComplexType::ConditionType& StandardTriggerComplexType::
  getCondition () const
  {
    return this->condition_.get ();
  }

  StandardTriggerComplexType::ConditionType& StandardTriggerComplexType::
  getCondition ()
  {
    return this->condition_.get ();
  }

  void StandardTriggerComplexType::
  setCondition (const ConditionType& x)
  {
    this->condition_.set (x);
  }

  void StandardTriggerComplexType::
  setCondition (::std::auto_ptr< ConditionType > x)
  {
    this->condition_.set (x);
  }

  const StandardTriggerComplexType::DefaultOptional& StandardTriggerComplexType::
  getDefault () const
  {
    return this->default__;
  }

  StandardTriggerComplexType::DefaultOptional& StandardTriggerComplexType::
  getDefault ()
  {
    return this->default__;
  }

  void StandardTriggerComplexType::
  setDefault (const DefaultType& x)
  {
    this->default__.set (x);
  }

  void StandardTriggerComplexType::
  setDefault (const DefaultOptional& x)
  {
    this->default__ = x;
  }

  const StandardTriggerComplexType::TrueOptional& StandardTriggerComplexType::
  getTrue () const
  {
    return this->true__;
  }

  StandardTriggerComplexType::TrueOptional& StandardTriggerComplexType::
  getTrue ()
  {
    return this->true__;
  }

  void StandardTriggerComplexType::
  setTrue (const TrueType& x)
  {
    this->true__.set (x);
  }

  void StandardTriggerComplexType::
  setTrue (const TrueOptional& x)
  {
    this->true__ = x;
  }

  void StandardTriggerComplexType::
  setTrue (::std::auto_ptr< TrueType > x)
  {
    this->true__.set (x);
  }

  const StandardTriggerComplexType::FalseOptional& StandardTriggerComplexType::
  getFalse () const
  {
    return this->false__;
  }

  StandardTriggerComplexType::FalseOptional& StandardTriggerComplexType::
  getFalse ()
  {
    return this->false__;
  }

  void StandardTriggerComplexType::
  setFalse (const FalseType& x)
  {
    this->false__.set (x);
  }

  void StandardTriggerComplexType::
  setFalse (const FalseOptional& x)
  {
    this->false__ = x;
  }

  void StandardTriggerComplexType::
  setFalse (::std::auto_ptr< FalseType > x)
  {
    this->false__.set (x);
  }

  const StandardTriggerComplexType::OutputType& StandardTriggerComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  StandardTriggerComplexType::OutputType& StandardTriggerComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void StandardTriggerComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void StandardTriggerComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const StandardTriggerComplexType::IdType& StandardTriggerComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  StandardTriggerComplexType::IdType& StandardTriggerComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void StandardTriggerComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void StandardTriggerComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const StandardTriggerComplexType::NameOptional& StandardTriggerComplexType::
  getName () const
  {
    return this->name_;
  }

  StandardTriggerComplexType::NameOptional& StandardTriggerComplexType::
  getName ()
  {
    return this->name_;
  }

  void StandardTriggerComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void StandardTriggerComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void StandardTriggerComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // RelationalConditionComplexType
  // 

  const RelationalConditionComplexType::X1ValueOptional& RelationalConditionComplexType::
  getX1Value () const
  {
    return this->x1Value_;
  }

  RelationalConditionComplexType::X1ValueOptional& RelationalConditionComplexType::
  getX1Value ()
  {
    return this->x1Value_;
  }

  void RelationalConditionComplexType::
  setX1Value (const X1ValueType& x)
  {
    this->x1Value_.set (x);
  }

  void RelationalConditionComplexType::
  setX1Value (const X1ValueOptional& x)
  {
    this->x1Value_ = x;
  }

  void RelationalConditionComplexType::
  setX1Value (::std::auto_ptr< X1ValueType > x)
  {
    this->x1Value_.set (x);
  }

  const RelationalConditionComplexType::X1SeriesOptional& RelationalConditionComplexType::
  getX1Series () const
  {
    return this->x1Series_;
  }

  RelationalConditionComplexType::X1SeriesOptional& RelationalConditionComplexType::
  getX1Series ()
  {
    return this->x1Series_;
  }

  void RelationalConditionComplexType::
  setX1Series (const X1SeriesType& x)
  {
    this->x1Series_.set (x);
  }

  void RelationalConditionComplexType::
  setX1Series (const X1SeriesOptional& x)
  {
    this->x1Series_ = x;
  }

  void RelationalConditionComplexType::
  setX1Series (::std::auto_ptr< X1SeriesType > x)
  {
    this->x1Series_.set (x);
  }

  const RelationalConditionComplexType::RelationalOperatorType& RelationalConditionComplexType::
  getRelationalOperator () const
  {
    return this->relationalOperator_.get ();
  }

  RelationalConditionComplexType::RelationalOperatorType& RelationalConditionComplexType::
  getRelationalOperator ()
  {
    return this->relationalOperator_.get ();
  }

  void RelationalConditionComplexType::
  setRelationalOperator (const RelationalOperatorType& x)
  {
    this->relationalOperator_.set (x);
  }

  void RelationalConditionComplexType::
  setRelationalOperator (::std::auto_ptr< RelationalOperatorType > x)
  {
    this->relationalOperator_.set (x);
  }

  const RelationalConditionComplexType::X2ValueOptional& RelationalConditionComplexType::
  getX2Value () const
  {
    return this->x2Value_;
  }

  RelationalConditionComplexType::X2ValueOptional& RelationalConditionComplexType::
  getX2Value ()
  {
    return this->x2Value_;
  }

  void RelationalConditionComplexType::
  setX2Value (const X2ValueType& x)
  {
    this->x2Value_.set (x);
  }

  void RelationalConditionComplexType::
  setX2Value (const X2ValueOptional& x)
  {
    this->x2Value_ = x;
  }

  void RelationalConditionComplexType::
  setX2Value (::std::auto_ptr< X2ValueType > x)
  {
    this->x2Value_.set (x);
  }

  const RelationalConditionComplexType::X2SeriesOptional& RelationalConditionComplexType::
  getX2Series () const
  {
    return this->x2Series_;
  }

  RelationalConditionComplexType::X2SeriesOptional& RelationalConditionComplexType::
  getX2Series ()
  {
    return this->x2Series_;
  }

  void RelationalConditionComplexType::
  setX2Series (const X2SeriesType& x)
  {
    this->x2Series_.set (x);
  }

  void RelationalConditionComplexType::
  setX2Series (const X2SeriesOptional& x)
  {
    this->x2Series_ = x;
  }

  void RelationalConditionComplexType::
  setX2Series (::std::auto_ptr< X2SeriesType > x)
  {
    this->x2Series_.set (x);
  }


  // SetTriggerComplexType
  // 

  const SetTriggerComplexType::X1ValueOptional& SetTriggerComplexType::
  getX1Value () const
  {
    return this->x1Value_;
  }

  SetTriggerComplexType::X1ValueOptional& SetTriggerComplexType::
  getX1Value ()
  {
    return this->x1Value_;
  }

  void SetTriggerComplexType::
  setX1Value (const X1ValueType& x)
  {
    this->x1Value_.set (x);
  }

  void SetTriggerComplexType::
  setX1Value (const X1ValueOptional& x)
  {
    this->x1Value_ = x;
  }

  const SetTriggerComplexType::X1SeriesOptional& SetTriggerComplexType::
  getX1Series () const
  {
    return this->x1Series_;
  }

  SetTriggerComplexType::X1SeriesOptional& SetTriggerComplexType::
  getX1Series ()
  {
    return this->x1Series_;
  }

  void SetTriggerComplexType::
  setX1Series (const X1SeriesType& x)
  {
    this->x1Series_.set (x);
  }

  void SetTriggerComplexType::
  setX1Series (const X1SeriesOptional& x)
  {
    this->x1Series_ = x;
  }

  void SetTriggerComplexType::
  setX1Series (::std::auto_ptr< X1SeriesType > x)
  {
    this->x1Series_.set (x);
  }

  const SetTriggerComplexType::X1TriggerOptional& SetTriggerComplexType::
  getX1Trigger () const
  {
    return this->x1Trigger_;
  }

  SetTriggerComplexType::X1TriggerOptional& SetTriggerComplexType::
  getX1Trigger ()
  {
    return this->x1Trigger_;
  }

  void SetTriggerComplexType::
  setX1Trigger (const X1TriggerType& x)
  {
    this->x1Trigger_.set (x);
  }

  void SetTriggerComplexType::
  setX1Trigger (const X1TriggerOptional& x)
  {
    this->x1Trigger_ = x;
  }

  void SetTriggerComplexType::
  setX1Trigger (::std::auto_ptr< X1TriggerType > x)
  {
    this->x1Trigger_.set (x);
  }

  const SetTriggerComplexType::LogicalOperatorType& SetTriggerComplexType::
  getLogicalOperator () const
  {
    return this->logicalOperator_.get ();
  }

  SetTriggerComplexType::LogicalOperatorType& SetTriggerComplexType::
  getLogicalOperator ()
  {
    return this->logicalOperator_.get ();
  }

  void SetTriggerComplexType::
  setLogicalOperator (const LogicalOperatorType& x)
  {
    this->logicalOperator_.set (x);
  }

  void SetTriggerComplexType::
  setLogicalOperator (::std::auto_ptr< LogicalOperatorType > x)
  {
    this->logicalOperator_.set (x);
  }

  const SetTriggerComplexType::X2ValueOptional& SetTriggerComplexType::
  getX2Value () const
  {
    return this->x2Value_;
  }

  SetTriggerComplexType::X2ValueOptional& SetTriggerComplexType::
  getX2Value ()
  {
    return this->x2Value_;
  }

  void SetTriggerComplexType::
  setX2Value (const X2ValueType& x)
  {
    this->x2Value_.set (x);
  }

  void SetTriggerComplexType::
  setX2Value (const X2ValueOptional& x)
  {
    this->x2Value_ = x;
  }

  const SetTriggerComplexType::X2SeriesOptional& SetTriggerComplexType::
  getX2Series () const
  {
    return this->x2Series_;
  }

  SetTriggerComplexType::X2SeriesOptional& SetTriggerComplexType::
  getX2Series ()
  {
    return this->x2Series_;
  }

  void SetTriggerComplexType::
  setX2Series (const X2SeriesType& x)
  {
    this->x2Series_.set (x);
  }

  void SetTriggerComplexType::
  setX2Series (const X2SeriesOptional& x)
  {
    this->x2Series_ = x;
  }

  void SetTriggerComplexType::
  setX2Series (::std::auto_ptr< X2SeriesType > x)
  {
    this->x2Series_.set (x);
  }

  const SetTriggerComplexType::X2TriggerOptional& SetTriggerComplexType::
  getX2Trigger () const
  {
    return this->x2Trigger_;
  }

  SetTriggerComplexType::X2TriggerOptional& SetTriggerComplexType::
  getX2Trigger ()
  {
    return this->x2Trigger_;
  }

  void SetTriggerComplexType::
  setX2Trigger (const X2TriggerType& x)
  {
    this->x2Trigger_.set (x);
  }

  void SetTriggerComplexType::
  setX2Trigger (const X2TriggerOptional& x)
  {
    this->x2Trigger_ = x;
  }

  void SetTriggerComplexType::
  setX2Trigger (::std::auto_ptr< X2TriggerType > x)
  {
    this->x2Trigger_.set (x);
  }

  const SetTriggerComplexType::DefaultOptional& SetTriggerComplexType::
  getDefault () const
  {
    return this->default__;
  }

  SetTriggerComplexType::DefaultOptional& SetTriggerComplexType::
  getDefault ()
  {
    return this->default__;
  }

  void SetTriggerComplexType::
  setDefault (const DefaultType& x)
  {
    this->default__.set (x);
  }

  void SetTriggerComplexType::
  setDefault (const DefaultOptional& x)
  {
    this->default__ = x;
  }

  const SetTriggerComplexType::TrueOptional& SetTriggerComplexType::
  getTrue () const
  {
    return this->true__;
  }

  SetTriggerComplexType::TrueOptional& SetTriggerComplexType::
  getTrue ()
  {
    return this->true__;
  }

  void SetTriggerComplexType::
  setTrue (const TrueType& x)
  {
    this->true__.set (x);
  }

  void SetTriggerComplexType::
  setTrue (const TrueOptional& x)
  {
    this->true__ = x;
  }

  void SetTriggerComplexType::
  setTrue (::std::auto_ptr< TrueType > x)
  {
    this->true__.set (x);
  }

  const SetTriggerComplexType::FalseOptional& SetTriggerComplexType::
  getFalse () const
  {
    return this->false__;
  }

  SetTriggerComplexType::FalseOptional& SetTriggerComplexType::
  getFalse ()
  {
    return this->false__;
  }

  void SetTriggerComplexType::
  setFalse (const FalseType& x)
  {
    this->false__.set (x);
  }

  void SetTriggerComplexType::
  setFalse (const FalseOptional& x)
  {
    this->false__ = x;
  }

  void SetTriggerComplexType::
  setFalse (::std::auto_ptr< FalseType > x)
  {
    this->false__.set (x);
  }

  const SetTriggerComplexType::OutputType& SetTriggerComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  SetTriggerComplexType::OutputType& SetTriggerComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void SetTriggerComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void SetTriggerComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const SetTriggerComplexType::IdType& SetTriggerComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  SetTriggerComplexType::IdType& SetTriggerComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void SetTriggerComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void SetTriggerComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const SetTriggerComplexType::NameOptional& SetTriggerComplexType::
  getName () const
  {
    return this->name_;
  }

  SetTriggerComplexType::NameOptional& SetTriggerComplexType::
  getName ()
  {
    return this->name_;
  }

  void SetTriggerComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void SetTriggerComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void SetTriggerComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // RuleTriggerComplexType
  // 

  const RuleTriggerComplexType::TriggerSequence& RuleTriggerComplexType::
  getTrigger () const
  {
    return this->trigger_;
  }

  RuleTriggerComplexType::TriggerSequence& RuleTriggerComplexType::
  getTrigger ()
  {
    return this->trigger_;
  }

  void RuleTriggerComplexType::
  setTrigger (const TriggerSequence& s)
  {
    this->trigger_ = s;
  }


  // ResultComplexType
  // 

  const ResultComplexType::OutputType& ResultComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  ResultComplexType::OutputType& ResultComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void ResultComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void ResultComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const ResultComplexType::ValueType& ResultComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  ResultComplexType::ValueType& ResultComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void ResultComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // ConditionComplexType
  // 

  const ConditionComplexType::LessThanOptional& ConditionComplexType::
  getLessThan () const
  {
    return this->lessThan_;
  }

  ConditionComplexType::LessThanOptional& ConditionComplexType::
  getLessThan ()
  {
    return this->lessThan_;
  }

  void ConditionComplexType::
  setLessThan (const LessThanType& x)
  {
    this->lessThan_.set (x);
  }

  void ConditionComplexType::
  setLessThan (const LessThanOptional& x)
  {
    this->lessThan_ = x;
  }

  const ConditionComplexType::GreaterThanOptional& ConditionComplexType::
  getGreaterThan () const
  {
    return this->greaterThan_;
  }

  ConditionComplexType::GreaterThanOptional& ConditionComplexType::
  getGreaterThan ()
  {
    return this->greaterThan_;
  }

  void ConditionComplexType::
  setGreaterThan (const GreaterThanType& x)
  {
    this->greaterThan_.set (x);
  }

  void ConditionComplexType::
  setGreaterThan (const GreaterThanOptional& x)
  {
    this->greaterThan_ = x;
  }


  // RuleStateTriggerComplexType
  // 

  const RuleStateTriggerComplexType::RuleIdType& RuleStateTriggerComplexType::
  getRuleId () const
  {
    return this->ruleId_.get ();
  }

  RuleStateTriggerComplexType::RuleIdType& RuleStateTriggerComplexType::
  getRuleId ()
  {
    return this->ruleId_.get ();
  }

  void RuleStateTriggerComplexType::
  setRuleId (const RuleIdType& x)
  {
    this->ruleId_.set (x);
  }

  void RuleStateTriggerComplexType::
  setRuleId (::std::auto_ptr< RuleIdType > x)
  {
    this->ruleId_.set (x);
  }

  const RuleStateTriggerComplexType::IdType& RuleStateTriggerComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  RuleStateTriggerComplexType::IdType& RuleStateTriggerComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void RuleStateTriggerComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void RuleStateTriggerComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const RuleStateTriggerComplexType::NameOptional& RuleStateTriggerComplexType::
  getName () const
  {
    return this->name_;
  }

  RuleStateTriggerComplexType::NameOptional& RuleStateTriggerComplexType::
  getName ()
  {
    return this->name_;
  }

  void RuleStateTriggerComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void RuleStateTriggerComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void RuleStateTriggerComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InflowComplexType
  // 

  const InflowComplexType::FactorOptional& InflowComplexType::
  getFactor () const
  {
    return this->factor_;
  }

  InflowComplexType::FactorOptional& InflowComplexType::
  getFactor ()
  {
    return this->factor_;
  }

  void InflowComplexType::
  setFactor (const FactorType& x)
  {
    this->factor_.set (x);
  }

  void InflowComplexType::
  setFactor (const FactorOptional& x)
  {
    this->factor_ = x;
  }


  // NodeComplexType
  // 

  const NodeComplexType::StorageCharacteristicsType& NodeComplexType::
  getStorageCharacteristics () const
  {
    return this->storageCharacteristics_.get ();
  }

  NodeComplexType::StorageCharacteristicsType& NodeComplexType::
  getStorageCharacteristics ()
  {
    return this->storageCharacteristics_.get ();
  }

  void NodeComplexType::
  setStorageCharacteristics (const StorageCharacteristicsType& x)
  {
    this->storageCharacteristics_.set (x);
  }

  void NodeComplexType::
  setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > x)
  {
    this->storageCharacteristics_.set (x);
  }

  const NodeComplexType::InputOptional& NodeComplexType::
  getInput () const
  {
    return this->input_;
  }

  NodeComplexType::InputOptional& NodeComplexType::
  getInput ()
  {
    return this->input_;
  }

  void NodeComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void NodeComplexType::
  setInput (const InputOptional& x)
  {
    this->input_ = x;
  }

  void NodeComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const NodeComplexType::OutputType& NodeComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  NodeComplexType::OutputType& NodeComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void NodeComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void NodeComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const NodeComplexType::IdType& NodeComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  NodeComplexType::IdType& NodeComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void NodeComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void NodeComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const NodeComplexType::XOptional& NodeComplexType::
  getX () const
  {
    return this->x_;
  }

  NodeComplexType::XOptional& NodeComplexType::
  getX ()
  {
    return this->x_;
  }

  void NodeComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void NodeComplexType::
  setX (const XOptional& x)
  {
    this->x_ = x;
  }

  const NodeComplexType::YOptional& NodeComplexType::
  getY () const
  {
    return this->y_;
  }

  NodeComplexType::YOptional& NodeComplexType::
  getY ()
  {
    return this->y_;
  }

  void NodeComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void NodeComplexType::
  setY (const YOptional& x)
  {
    this->y_ = x;
  }


  // NodeInputComplexType
  // 

  const NodeInputComplexType::HBCOptional& NodeInputComplexType::
  getHBC () const
  {
    return this->HBC_;
  }

  NodeInputComplexType::HBCOptional& NodeInputComplexType::
  getHBC ()
  {
    return this->HBC_;
  }

  void NodeInputComplexType::
  setHBC (const HBCType& x)
  {
    this->HBC_.set (x);
  }

  void NodeInputComplexType::
  setHBC (const HBCOptional& x)
  {
    this->HBC_ = x;
  }

  void NodeInputComplexType::
  setHBC (::std::auto_ptr< HBCType > x)
  {
    this->HBC_.set (x);
  }

  const NodeInputComplexType::HUpdateOptional& NodeInputComplexType::
  getHUpdate () const
  {
    return this->HUpdate_;
  }

  NodeInputComplexType::HUpdateOptional& NodeInputComplexType::
  getHUpdate ()
  {
    return this->HUpdate_;
  }

  void NodeInputComplexType::
  setHUpdate (const HUpdateType& x)
  {
    this->HUpdate_.set (x);
  }

  void NodeInputComplexType::
  setHUpdate (const HUpdateOptional& x)
  {
    this->HUpdate_ = x;
  }

  void NodeInputComplexType::
  setHUpdate (::std::auto_ptr< HUpdateType > x)
  {
    this->HUpdate_.set (x);
  }

  const NodeInputComplexType::QBCSequence& NodeInputComplexType::
  getQBC () const
  {
    return this->QBC_;
  }

  NodeInputComplexType::QBCSequence& NodeInputComplexType::
  getQBC ()
  {
    return this->QBC_;
  }

  void NodeInputComplexType::
  setQBC (const QBCSequence& s)
  {
    this->QBC_ = s;
  }


  // NodeOutputComplexType
  // 

  const NodeOutputComplexType::HType& NodeOutputComplexType::
  getH () const
  {
    return this->H_.get ();
  }

  NodeOutputComplexType::HType& NodeOutputComplexType::
  getH ()
  {
    return this->H_.get ();
  }

  void NodeOutputComplexType::
  setH (const HType& x)
  {
    this->H_.set (x);
  }

  void NodeOutputComplexType::
  setH (::std::auto_ptr< HType > x)
  {
    this->H_.set (x);
  }

  const NodeOutputComplexType::SType& NodeOutputComplexType::
  getS () const
  {
    return this->S_.get ();
  }

  NodeOutputComplexType::SType& NodeOutputComplexType::
  getS ()
  {
    return this->S_.get ();
  }

  void NodeOutputComplexType::
  setS (const SType& x)
  {
    this->S_.set (x);
  }

  void NodeOutputComplexType::
  setS (::std::auto_ptr< SType > x)
  {
    this->S_.set (x);
  }

  const NodeOutputComplexType::ROptional& NodeOutputComplexType::
  getR () const
  {
    return this->R_;
  }

  NodeOutputComplexType::ROptional& NodeOutputComplexType::
  getR ()
  {
    return this->R_;
  }

  void NodeOutputComplexType::
  setR (const RType& x)
  {
    this->R_.set (x);
  }

  void NodeOutputComplexType::
  setR (const ROptional& x)
  {
    this->R_ = x;
  }

  void NodeOutputComplexType::
  setR (::std::auto_ptr< RType > x)
  {
    this->R_.set (x);
  }


  // BranchComplexType
  // 

  const BranchComplexType::EquationTypeOptional& BranchComplexType::
  getEquationType () const
  {
    return this->equationType_;
  }

  BranchComplexType::EquationTypeOptional& BranchComplexType::
  getEquationType ()
  {
    return this->equationType_;
  }

  void BranchComplexType::
  setEquationType (const EquationTypeType& x)
  {
    this->equationType_.set (x);
  }

  void BranchComplexType::
  setEquationType (const EquationTypeOptional& x)
  {
    this->equationType_ = x;
  }

  void BranchComplexType::
  setEquationType (::std::auto_ptr< EquationTypeType > x)
  {
    this->equationType_.set (x);
  }

  const BranchComplexType::SpatialSchemeOptional& BranchComplexType::
  getSpatialScheme () const
  {
    return this->spatialScheme_;
  }

  BranchComplexType::SpatialSchemeOptional& BranchComplexType::
  getSpatialScheme ()
  {
    return this->spatialScheme_;
  }

  void BranchComplexType::
  setSpatialScheme (const SpatialSchemeType& x)
  {
    this->spatialScheme_.set (x);
  }

  void BranchComplexType::
  setSpatialScheme (const SpatialSchemeOptional& x)
  {
    this->spatialScheme_ = x;
  }

  void BranchComplexType::
  setSpatialScheme (::std::auto_ptr< SpatialSchemeType > x)
  {
    this->spatialScheme_.set (x);
  }

  const BranchComplexType::CrossSectionType& BranchComplexType::
  getCrossSection () const
  {
    return this->crossSection_.get ();
  }

  BranchComplexType::CrossSectionType& BranchComplexType::
  getCrossSection ()
  {
    return this->crossSection_.get ();
  }

  void BranchComplexType::
  setCrossSection (const CrossSectionType& x)
  {
    this->crossSection_.set (x);
  }

  void BranchComplexType::
  setCrossSection (::std::auto_ptr< CrossSectionType > x)
  {
    this->crossSection_.set (x);
  }

  const BranchComplexType::RoughnessType& BranchComplexType::
  getRoughness () const
  {
    return this->roughness_.get ();
  }

  BranchComplexType::RoughnessType& BranchComplexType::
  getRoughness ()
  {
    return this->roughness_.get ();
  }

  void BranchComplexType::
  setRoughness (const RoughnessType& x)
  {
    this->roughness_.set (x);
  }

  void BranchComplexType::
  setRoughness (::std::auto_ptr< RoughnessType > x)
  {
    this->roughness_.set (x);
  }

  const BranchComplexType::LengthType& BranchComplexType::
  getLength () const
  {
    return this->length_.get ();
  }

  BranchComplexType::LengthType& BranchComplexType::
  getLength ()
  {
    return this->length_.get ();
  }

  void BranchComplexType::
  setLength (const LengthType& x)
  {
    this->length_.set (x);
  }

  const BranchComplexType::SlopeOptional& BranchComplexType::
  getSlope () const
  {
    return this->slope_;
  }

  BranchComplexType::SlopeOptional& BranchComplexType::
  getSlope ()
  {
    return this->slope_;
  }

  void BranchComplexType::
  setSlope (const SlopeType& x)
  {
    this->slope_.set (x);
  }

  void BranchComplexType::
  setSlope (const SlopeOptional& x)
  {
    this->slope_ = x;
  }

  BranchComplexType::SlopeType BranchComplexType::
  getSlopeDefaultValue ()
  {
    return SlopeType (.0005);
  }

  const BranchComplexType::Alpha1Optional& BranchComplexType::
  getAlpha1 () const
  {
    return this->alpha1_;
  }

  BranchComplexType::Alpha1Optional& BranchComplexType::
  getAlpha1 ()
  {
    return this->alpha1_;
  }

  void BranchComplexType::
  setAlpha1 (const Alpha1Type& x)
  {
    this->alpha1_.set (x);
  }

  void BranchComplexType::
  setAlpha1 (const Alpha1Optional& x)
  {
    this->alpha1_ = x;
  }

  BranchComplexType::Alpha1Type BranchComplexType::
  getAlpha1DefaultValue ()
  {
    return Alpha1Type (.00006);
  }

  const BranchComplexType::Alpha2Optional& BranchComplexType::
  getAlpha2 () const
  {
    return this->alpha2_;
  }

  BranchComplexType::Alpha2Optional& BranchComplexType::
  getAlpha2 ()
  {
    return this->alpha2_;
  }

  void BranchComplexType::
  setAlpha2 (const Alpha2Type& x)
  {
    this->alpha2_.set (x);
  }

  void BranchComplexType::
  setAlpha2 (const Alpha2Optional& x)
  {
    this->alpha2_ = x;
  }

  const BranchComplexType::InputType& BranchComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  BranchComplexType::InputType& BranchComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void BranchComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void BranchComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const BranchComplexType::OutputType& BranchComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  BranchComplexType::OutputType& BranchComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void BranchComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void BranchComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const BranchComplexType::IdType& BranchComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  BranchComplexType::IdType& BranchComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void BranchComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void BranchComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // CrossSectionComplexType
  // 

  const CrossSectionComplexType::CrossSectionTableType& CrossSectionComplexType::
  getCrossSectionTable () const
  {
    return this->crossSectionTable_.get ();
  }

  CrossSectionComplexType::CrossSectionTableType& CrossSectionComplexType::
  getCrossSectionTable ()
  {
    return this->crossSectionTable_.get ();
  }

  void CrossSectionComplexType::
  setCrossSectionTable (const CrossSectionTableType& x)
  {
    this->crossSectionTable_.set (x);
  }

  void CrossSectionComplexType::
  setCrossSectionTable (::std::auto_ptr< CrossSectionTableType > x)
  {
    this->crossSectionTable_.set (x);
  }


  // CrossSectionRoughnessComplexType
  // 

  const CrossSectionRoughnessComplexType::RoughnessTableType& CrossSectionRoughnessComplexType::
  getRoughnessTable () const
  {
    return this->roughnessTable_.get ();
  }

  CrossSectionRoughnessComplexType::RoughnessTableType& CrossSectionRoughnessComplexType::
  getRoughnessTable ()
  {
    return this->roughnessTable_.get ();
  }

  void CrossSectionRoughnessComplexType::
  setRoughnessTable (const RoughnessTableType& x)
  {
    this->roughnessTable_.set (x);
  }

  void CrossSectionRoughnessComplexType::
  setRoughnessTable (::std::auto_ptr< RoughnessTableType > x)
  {
    this->roughnessTable_.set (x);
  }


  // BranchInputComplexType
  // 

  const BranchInputComplexType::HUpType& BranchInputComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  BranchInputComplexType::HUpType& BranchInputComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void BranchInputComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void BranchInputComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const BranchInputComplexType::HDownType& BranchInputComplexType::
  getHDown () const
  {
    return this->HDown_.get ();
  }

  BranchInputComplexType::HDownType& BranchInputComplexType::
  getHDown ()
  {
    return this->HDown_.get ();
  }

  void BranchInputComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void BranchInputComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }

  const BranchInputComplexType::UxOptional& BranchInputComplexType::
  getUx () const
  {
    return this->ux_;
  }

  BranchInputComplexType::UxOptional& BranchInputComplexType::
  getUx ()
  {
    return this->ux_;
  }

  void BranchInputComplexType::
  setUx (const UxType& x)
  {
    this->ux_.set (x);
  }

  void BranchInputComplexType::
  setUx (const UxOptional& x)
  {
    this->ux_ = x;
  }

  void BranchInputComplexType::
  setUx (::std::auto_ptr< UxType > x)
  {
    this->ux_.set (x);
  }

  const BranchInputComplexType::UyOptional& BranchInputComplexType::
  getUy () const
  {
    return this->uy_;
  }

  BranchInputComplexType::UyOptional& BranchInputComplexType::
  getUy ()
  {
    return this->uy_;
  }

  void BranchInputComplexType::
  setUy (const UyType& x)
  {
    this->uy_.set (x);
  }

  void BranchInputComplexType::
  setUy (const UyOptional& x)
  {
    this->uy_ = x;
  }

  void BranchInputComplexType::
  setUy (::std::auto_ptr< UyType > x)
  {
    this->uy_.set (x);
  }


  // BranchOutputComplexType
  // 

  const BranchOutputComplexType::QType& BranchOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  BranchOutputComplexType::QType& BranchOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void BranchOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void BranchOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }


  // HydraulicStructureComplexType
  // 

  const HydraulicStructureComplexType::OrificeOptional& HydraulicStructureComplexType::
  getOrifice () const
  {
    return this->orifice_;
  }

  HydraulicStructureComplexType::OrificeOptional& HydraulicStructureComplexType::
  getOrifice ()
  {
    return this->orifice_;
  }

  void HydraulicStructureComplexType::
  setOrifice (const OrificeType& x)
  {
    this->orifice_.set (x);
  }

  void HydraulicStructureComplexType::
  setOrifice (const OrificeOptional& x)
  {
    this->orifice_ = x;
  }

  void HydraulicStructureComplexType::
  setOrifice (::std::auto_ptr< OrificeType > x)
  {
    this->orifice_.set (x);
  }

  const HydraulicStructureComplexType::WeirOptional& HydraulicStructureComplexType::
  getWeir () const
  {
    return this->weir_;
  }

  HydraulicStructureComplexType::WeirOptional& HydraulicStructureComplexType::
  getWeir ()
  {
    return this->weir_;
  }

  void HydraulicStructureComplexType::
  setWeir (const WeirType& x)
  {
    this->weir_.set (x);
  }

  void HydraulicStructureComplexType::
  setWeir (const WeirOptional& x)
  {
    this->weir_ = x;
  }

  void HydraulicStructureComplexType::
  setWeir (::std::auto_ptr< WeirType > x)
  {
    this->weir_.set (x);
  }

  const HydraulicStructureComplexType::PumpOptional& HydraulicStructureComplexType::
  getPump () const
  {
    return this->pump_;
  }

  HydraulicStructureComplexType::PumpOptional& HydraulicStructureComplexType::
  getPump ()
  {
    return this->pump_;
  }

  void HydraulicStructureComplexType::
  setPump (const PumpType& x)
  {
    this->pump_.set (x);
  }

  void HydraulicStructureComplexType::
  setPump (const PumpOptional& x)
  {
    this->pump_ = x;
  }

  void HydraulicStructureComplexType::
  setPump (::std::auto_ptr< PumpType > x)
  {
    this->pump_.set (x);
  }

  const HydraulicStructureComplexType::IdType& HydraulicStructureComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  HydraulicStructureComplexType::IdType& HydraulicStructureComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void HydraulicStructureComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void HydraulicStructureComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // PumpComplexType
  // 

  const PumpComplexType::InputType& PumpComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  PumpComplexType::InputType& PumpComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void PumpComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void PumpComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const PumpComplexType::OutputType& PumpComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  PumpComplexType::OutputType& PumpComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void PumpComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void PumpComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // PumpInputComplexType
  // 

  const PumpInputComplexType::HUpType& PumpInputComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  PumpInputComplexType::HUpType& PumpInputComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void PumpInputComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void PumpInputComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const PumpInputComplexType::HDownType& PumpInputComplexType::
  getHDown () const
  {
    return this->HDown_.get ();
  }

  PumpInputComplexType::HDownType& PumpInputComplexType::
  getHDown ()
  {
    return this->HDown_.get ();
  }

  void PumpInputComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void PumpInputComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }

  const PumpInputComplexType::QType& PumpInputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  PumpInputComplexType::QType& PumpInputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void PumpInputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void PumpInputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }


  // PumpOutputComplexType
  // 

  const PumpOutputComplexType::QType& PumpOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  PumpOutputComplexType::QType& PumpOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void PumpOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void PumpOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }


  // PumpGradientComplexType
  // 

  const PumpGradientComplexType::StorageUpType& PumpGradientComplexType::
  getStorageUp () const
  {
    return this->storageUp_.get ();
  }

  PumpGradientComplexType::StorageUpType& PumpGradientComplexType::
  getStorageUp ()
  {
    return this->storageUp_.get ();
  }

  void PumpGradientComplexType::
  setStorageUp (const StorageUpType& x)
  {
    this->storageUp_.set (x);
  }

  void PumpGradientComplexType::
  setStorageUp (::std::auto_ptr< StorageUpType > x)
  {
    this->storageUp_.set (x);
  }

  const PumpGradientComplexType::StorageDownType& PumpGradientComplexType::
  getStorageDown () const
  {
    return this->storageDown_.get ();
  }

  PumpGradientComplexType::StorageDownType& PumpGradientComplexType::
  getStorageDown ()
  {
    return this->storageDown_.get ();
  }

  void PumpGradientComplexType::
  setStorageDown (const StorageDownType& x)
  {
    this->storageDown_.set (x);
  }

  void PumpGradientComplexType::
  setStorageDown (::std::auto_ptr< StorageDownType > x)
  {
    this->storageDown_.set (x);
  }


  // TurbineComplexType
  // 

  const TurbineComplexType::NodeUpType& TurbineComplexType::
  getNodeUp () const
  {
    return this->nodeUp_.get ();
  }

  TurbineComplexType::NodeUpType& TurbineComplexType::
  getNodeUp ()
  {
    return this->nodeUp_.get ();
  }

  void TurbineComplexType::
  setNodeUp (const NodeUpType& x)
  {
    this->nodeUp_.set (x);
  }

  void TurbineComplexType::
  setNodeUp (::std::auto_ptr< NodeUpType > x)
  {
    this->nodeUp_.set (x);
  }

  const TurbineComplexType::NodeDownType& TurbineComplexType::
  getNodeDown () const
  {
    return this->nodeDown_.get ();
  }

  TurbineComplexType::NodeDownType& TurbineComplexType::
  getNodeDown ()
  {
    return this->nodeDown_.get ();
  }

  void TurbineComplexType::
  setNodeDown (const NodeDownType& x)
  {
    this->nodeDown_.set (x);
  }

  void TurbineComplexType::
  setNodeDown (::std::auto_ptr< NodeDownType > x)
  {
    this->nodeDown_.set (x);
  }

  const TurbineComplexType::CapacityCharacteristicsType& TurbineComplexType::
  getCapacityCharacteristics () const
  {
    return this->capacityCharacteristics_.get ();
  }

  TurbineComplexType::CapacityCharacteristicsType& TurbineComplexType::
  getCapacityCharacteristics ()
  {
    return this->capacityCharacteristics_.get ();
  }

  void TurbineComplexType::
  setCapacityCharacteristics (const CapacityCharacteristicsType& x)
  {
    this->capacityCharacteristics_.set (x);
  }

  void TurbineComplexType::
  setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > x)
  {
    this->capacityCharacteristics_.set (x);
  }

  const TurbineComplexType::EfficiencyCharacteristicsType& TurbineComplexType::
  getEfficiencyCharacteristics () const
  {
    return this->efficiencyCharacteristics_.get ();
  }

  TurbineComplexType::EfficiencyCharacteristicsType& TurbineComplexType::
  getEfficiencyCharacteristics ()
  {
    return this->efficiencyCharacteristics_.get ();
  }

  void TurbineComplexType::
  setEfficiencyCharacteristics (const EfficiencyCharacteristicsType& x)
  {
    this->efficiencyCharacteristics_.set (x);
  }

  void TurbineComplexType::
  setEfficiencyCharacteristics (::std::auto_ptr< EfficiencyCharacteristicsType > x)
  {
    this->efficiencyCharacteristics_.set (x);
  }

  const TurbineComplexType::InputType& TurbineComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TurbineComplexType::InputType& TurbineComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TurbineComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TurbineComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TurbineComplexType::OutputType& TurbineComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  TurbineComplexType::OutputType& TurbineComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void TurbineComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void TurbineComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // TurbineCapacityCharacteristicsComplexType
  // 

  const TurbineCapacityCharacteristicsComplexType::CapacityTableOptional& TurbineCapacityCharacteristicsComplexType::
  getCapacityTable () const
  {
    return this->capacityTable_;
  }

  TurbineCapacityCharacteristicsComplexType::CapacityTableOptional& TurbineCapacityCharacteristicsComplexType::
  getCapacityTable ()
  {
    return this->capacityTable_;
  }

  void TurbineCapacityCharacteristicsComplexType::
  setCapacityTable (const CapacityTableType& x)
  {
    this->capacityTable_.set (x);
  }

  void TurbineCapacityCharacteristicsComplexType::
  setCapacityTable (const CapacityTableOptional& x)
  {
    this->capacityTable_ = x;
  }

  void TurbineCapacityCharacteristicsComplexType::
  setCapacityTable (::std::auto_ptr< CapacityTableType > x)
  {
    this->capacityTable_.set (x);
  }

  const TurbineCapacityCharacteristicsComplexType::CapacityEquationOptional& TurbineCapacityCharacteristicsComplexType::
  getCapacityEquation () const
  {
    return this->capacityEquation_;
  }

  TurbineCapacityCharacteristicsComplexType::CapacityEquationOptional& TurbineCapacityCharacteristicsComplexType::
  getCapacityEquation ()
  {
    return this->capacityEquation_;
  }

  void TurbineCapacityCharacteristicsComplexType::
  setCapacityEquation (const CapacityEquationType& x)
  {
    this->capacityEquation_.set (x);
  }

  void TurbineCapacityCharacteristicsComplexType::
  setCapacityEquation (const CapacityEquationOptional& x)
  {
    this->capacityEquation_ = x;
  }

  void TurbineCapacityCharacteristicsComplexType::
  setCapacityEquation (::std::auto_ptr< CapacityEquationType > x)
  {
    this->capacityEquation_.set (x);
  }


  // TurbineEfficiencyCharacteristicsComplexType
  // 

  const TurbineEfficiencyCharacteristicsComplexType::EfficiencyConstantType& TurbineEfficiencyCharacteristicsComplexType::
  getEfficiencyConstant () const
  {
    return this->efficiencyConstant_.get ();
  }

  TurbineEfficiencyCharacteristicsComplexType::EfficiencyConstantType& TurbineEfficiencyCharacteristicsComplexType::
  getEfficiencyConstant ()
  {
    return this->efficiencyConstant_.get ();
  }

  void TurbineEfficiencyCharacteristicsComplexType::
  setEfficiencyConstant (const EfficiencyConstantType& x)
  {
    this->efficiencyConstant_.set (x);
  }


  // TurbineInputComplexType
  // 

  const TurbineInputComplexType::ReleaseOptional& TurbineInputComplexType::
  getRelease () const
  {
    return this->release_;
  }

  TurbineInputComplexType::ReleaseOptional& TurbineInputComplexType::
  getRelease ()
  {
    return this->release_;
  }

  void TurbineInputComplexType::
  setRelease (const ReleaseType& x)
  {
    this->release_.set (x);
  }

  void TurbineInputComplexType::
  setRelease (const ReleaseOptional& x)
  {
    this->release_ = x;
  }

  void TurbineInputComplexType::
  setRelease (::std::auto_ptr< ReleaseType > x)
  {
    this->release_.set (x);
  }

  const TurbineInputComplexType::RelativeReleaseOptional& TurbineInputComplexType::
  getRelativeRelease () const
  {
    return this->relativeRelease_;
  }

  TurbineInputComplexType::RelativeReleaseOptional& TurbineInputComplexType::
  getRelativeRelease ()
  {
    return this->relativeRelease_;
  }

  void TurbineInputComplexType::
  setRelativeRelease (const RelativeReleaseType& x)
  {
    this->relativeRelease_.set (x);
  }

  void TurbineInputComplexType::
  setRelativeRelease (const RelativeReleaseOptional& x)
  {
    this->relativeRelease_ = x;
  }

  void TurbineInputComplexType::
  setRelativeRelease (::std::auto_ptr< RelativeReleaseType > x)
  {
    this->relativeRelease_.set (x);
  }


  // TurbineOutputComplexType
  // 

  const TurbineOutputComplexType::DischargeType& TurbineOutputComplexType::
  getDischarge () const
  {
    return this->discharge_.get ();
  }

  TurbineOutputComplexType::DischargeType& TurbineOutputComplexType::
  getDischarge ()
  {
    return this->discharge_.get ();
  }

  void TurbineOutputComplexType::
  setDischarge (const DischargeType& x)
  {
    this->discharge_.set (x);
  }

  void TurbineOutputComplexType::
  setDischarge (::std::auto_ptr< DischargeType > x)
  {
    this->discharge_.set (x);
  }

  const TurbineOutputComplexType::PowerProductionType& TurbineOutputComplexType::
  getPowerProduction () const
  {
    return this->powerProduction_.get ();
  }

  TurbineOutputComplexType::PowerProductionType& TurbineOutputComplexType::
  getPowerProduction ()
  {
    return this->powerProduction_.get ();
  }

  void TurbineOutputComplexType::
  setPowerProduction (const PowerProductionType& x)
  {
    this->powerProduction_.set (x);
  }

  void TurbineOutputComplexType::
  setPowerProduction (::std::auto_ptr< PowerProductionType > x)
  {
    this->powerProduction_.set (x);
  }


  // OrificeComplexType
  // 

  const OrificeComplexType::WidthType& OrificeComplexType::
  getWidth () const
  {
    return this->width_.get ();
  }

  OrificeComplexType::WidthType& OrificeComplexType::
  getWidth ()
  {
    return this->width_.get ();
  }

  void OrificeComplexType::
  setWidth (const WidthType& x)
  {
    this->width_.set (x);
  }

  const OrificeComplexType::CrestLevelType& OrificeComplexType::
  getCrestLevel () const
  {
    return this->crestLevel_.get ();
  }

  OrificeComplexType::CrestLevelType& OrificeComplexType::
  getCrestLevel ()
  {
    return this->crestLevel_.get ();
  }

  void OrificeComplexType::
  setCrestLevel (const CrestLevelType& x)
  {
    this->crestLevel_.set (x);
  }

  const OrificeComplexType::ContractionCoefficientType& OrificeComplexType::
  getContractionCoefficient () const
  {
    return this->contractionCoefficient_.get ();
  }

  OrificeComplexType::ContractionCoefficientType& OrificeComplexType::
  getContractionCoefficient ()
  {
    return this->contractionCoefficient_.get ();
  }

  void OrificeComplexType::
  setContractionCoefficient (const ContractionCoefficientType& x)
  {
    this->contractionCoefficient_.set (x);
  }

  const OrificeComplexType::ExponentGateFormulaOptional& OrificeComplexType::
  getExponentGateFormula () const
  {
    return this->exponentGateFormula_;
  }

  OrificeComplexType::ExponentGateFormulaOptional& OrificeComplexType::
  getExponentGateFormula ()
  {
    return this->exponentGateFormula_;
  }

  void OrificeComplexType::
  setExponentGateFormula (const ExponentGateFormulaType& x)
  {
    this->exponentGateFormula_.set (x);
  }

  void OrificeComplexType::
  setExponentGateFormula (const ExponentGateFormulaOptional& x)
  {
    this->exponentGateFormula_ = x;
  }

  OrificeComplexType::ExponentGateFormulaType OrificeComplexType::
  getExponentGateFormulaDefaultValue ()
  {
    return ExponentGateFormulaType (.5);
  }

  const OrificeComplexType::ExponentWeirFormulaOptional& OrificeComplexType::
  getExponentWeirFormula () const
  {
    return this->exponentWeirFormula_;
  }

  OrificeComplexType::ExponentWeirFormulaOptional& OrificeComplexType::
  getExponentWeirFormula ()
  {
    return this->exponentWeirFormula_;
  }

  void OrificeComplexType::
  setExponentWeirFormula (const ExponentWeirFormulaType& x)
  {
    this->exponentWeirFormula_.set (x);
  }

  void OrificeComplexType::
  setExponentWeirFormula (const ExponentWeirFormulaOptional& x)
  {
    this->exponentWeirFormula_ = x;
  }

  OrificeComplexType::ExponentWeirFormulaType OrificeComplexType::
  getExponentWeirFormulaDefaultValue ()
  {
    return ExponentWeirFormulaType (1.5);
  }

  const OrificeComplexType::FlowDirectionOptional& OrificeComplexType::
  getFlowDirection () const
  {
    return this->flowDirection_;
  }

  OrificeComplexType::FlowDirectionOptional& OrificeComplexType::
  getFlowDirection ()
  {
    return this->flowDirection_;
  }

  void OrificeComplexType::
  setFlowDirection (const FlowDirectionType& x)
  {
    this->flowDirection_.set (x);
  }

  void OrificeComplexType::
  setFlowDirection (const FlowDirectionOptional& x)
  {
    this->flowDirection_ = x;
  }

  void OrificeComplexType::
  setFlowDirection (::std::auto_ptr< FlowDirectionType > x)
  {
    this->flowDirection_.set (x);
  }

  const OrificeComplexType::InputType& OrificeComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  OrificeComplexType::InputType& OrificeComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void OrificeComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void OrificeComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const OrificeComplexType::OutputType& OrificeComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  OrificeComplexType::OutputType& OrificeComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void OrificeComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void OrificeComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // OrificeInputComplexType
  // 

  const OrificeInputComplexType::HUpType& OrificeInputComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  OrificeInputComplexType::HUpType& OrificeInputComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void OrificeInputComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void OrificeInputComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const OrificeInputComplexType::DeltaHUpOptional& OrificeInputComplexType::
  getDeltaHUp () const
  {
    return this->DeltaHUp_;
  }

  OrificeInputComplexType::DeltaHUpOptional& OrificeInputComplexType::
  getDeltaHUp ()
  {
    return this->DeltaHUp_;
  }

  void OrificeInputComplexType::
  setDeltaHUp (const DeltaHUpType& x)
  {
    this->DeltaHUp_.set (x);
  }

  void OrificeInputComplexType::
  setDeltaHUp (const DeltaHUpOptional& x)
  {
    this->DeltaHUp_ = x;
  }

  void OrificeInputComplexType::
  setDeltaHUp (::std::auto_ptr< DeltaHUpType > x)
  {
    this->DeltaHUp_.set (x);
  }

  const OrificeInputComplexType::HDownType& OrificeInputComplexType::
  getHDown () const
  {
    return this->HDown_.get ();
  }

  OrificeInputComplexType::HDownType& OrificeInputComplexType::
  getHDown ()
  {
    return this->HDown_.get ();
  }

  void OrificeInputComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void OrificeInputComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }

  const OrificeInputComplexType::DeltaHDownOptional& OrificeInputComplexType::
  getDeltaHDown () const
  {
    return this->DeltaHDown_;
  }

  OrificeInputComplexType::DeltaHDownOptional& OrificeInputComplexType::
  getDeltaHDown ()
  {
    return this->DeltaHDown_;
  }

  void OrificeInputComplexType::
  setDeltaHDown (const DeltaHDownType& x)
  {
    this->DeltaHDown_.set (x);
  }

  void OrificeInputComplexType::
  setDeltaHDown (const DeltaHDownOptional& x)
  {
    this->DeltaHDown_ = x;
  }

  void OrificeInputComplexType::
  setDeltaHDown (::std::auto_ptr< DeltaHDownType > x)
  {
    this->DeltaHDown_.set (x);
  }

  const OrificeInputComplexType::DConstOptional& OrificeInputComplexType::
  getDConst () const
  {
    return this->DConst_;
  }

  OrificeInputComplexType::DConstOptional& OrificeInputComplexType::
  getDConst ()
  {
    return this->DConst_;
  }

  void OrificeInputComplexType::
  setDConst (const DConstType& x)
  {
    this->DConst_.set (x);
  }

  void OrificeInputComplexType::
  setDConst (const DConstOptional& x)
  {
    this->DConst_ = x;
  }

  const OrificeInputComplexType::DSeriesOptional& OrificeInputComplexType::
  getDSeries () const
  {
    return this->DSeries_;
  }

  OrificeInputComplexType::DSeriesOptional& OrificeInputComplexType::
  getDSeries ()
  {
    return this->DSeries_;
  }

  void OrificeInputComplexType::
  setDSeries (const DSeriesType& x)
  {
    this->DSeries_.set (x);
  }

  void OrificeInputComplexType::
  setDSeries (const DSeriesOptional& x)
  {
    this->DSeries_ = x;
  }

  void OrificeInputComplexType::
  setDSeries (::std::auto_ptr< DSeriesType > x)
  {
    this->DSeries_.set (x);
  }

  const OrificeInputComplexType::DOptional& OrificeInputComplexType::
  getD () const
  {
    return this->D_;
  }

  OrificeInputComplexType::DOptional& OrificeInputComplexType::
  getD ()
  {
    return this->D_;
  }

  void OrificeInputComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void OrificeInputComplexType::
  setD (const DOptional& x)
  {
    this->D_ = x;
  }

  void OrificeInputComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }


  // OrificeOutputComplexType
  // 

  const OrificeOutputComplexType::QType& OrificeOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  OrificeOutputComplexType::QType& OrificeOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void OrificeOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void OrificeOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }

  const OrificeOutputComplexType::DType& OrificeOutputComplexType::
  getD () const
  {
    return this->D_.get ();
  }

  OrificeOutputComplexType::DType& OrificeOutputComplexType::
  getD ()
  {
    return this->D_.get ();
  }

  void OrificeOutputComplexType::
  setD (const DType& x)
  {
    this->D_.set (x);
  }

  void OrificeOutputComplexType::
  setD (::std::auto_ptr< DType > x)
  {
    this->D_.set (x);
  }

  const OrificeOutputComplexType::FlowTypeOptional& OrificeOutputComplexType::
  getFlowType () const
  {
    return this->flowType_;
  }

  OrificeOutputComplexType::FlowTypeOptional& OrificeOutputComplexType::
  getFlowType ()
  {
    return this->flowType_;
  }

  void OrificeOutputComplexType::
  setFlowType (const FlowTypeType& x)
  {
    this->flowType_.set (x);
  }

  void OrificeOutputComplexType::
  setFlowType (const FlowTypeOptional& x)
  {
    this->flowType_ = x;
  }

  void OrificeOutputComplexType::
  setFlowType (::std::auto_ptr< FlowTypeType > x)
  {
    this->flowType_.set (x);
  }


  // BranchGradientComplexType
  // 

  const BranchGradientComplexType::StorageUpType& BranchGradientComplexType::
  getStorageUp () const
  {
    return this->storageUp_.get ();
  }

  BranchGradientComplexType::StorageUpType& BranchGradientComplexType::
  getStorageUp ()
  {
    return this->storageUp_.get ();
  }

  void BranchGradientComplexType::
  setStorageUp (const StorageUpType& x)
  {
    this->storageUp_.set (x);
  }

  void BranchGradientComplexType::
  setStorageUp (::std::auto_ptr< StorageUpType > x)
  {
    this->storageUp_.set (x);
  }

  const BranchGradientComplexType::SurfaceAreaUpType& BranchGradientComplexType::
  getSurfaceAreaUp () const
  {
    return this->surfaceAreaUp_.get ();
  }

  BranchGradientComplexType::SurfaceAreaUpType& BranchGradientComplexType::
  getSurfaceAreaUp ()
  {
    return this->surfaceAreaUp_.get ();
  }

  void BranchGradientComplexType::
  setSurfaceAreaUp (const SurfaceAreaUpType& x)
  {
    this->surfaceAreaUp_.set (x);
  }

  void BranchGradientComplexType::
  setSurfaceAreaUp (::std::auto_ptr< SurfaceAreaUpType > x)
  {
    this->surfaceAreaUp_.set (x);
  }

  const BranchGradientComplexType::StorageDownType& BranchGradientComplexType::
  getStorageDown () const
  {
    return this->storageDown_.get ();
  }

  BranchGradientComplexType::StorageDownType& BranchGradientComplexType::
  getStorageDown ()
  {
    return this->storageDown_.get ();
  }

  void BranchGradientComplexType::
  setStorageDown (const StorageDownType& x)
  {
    this->storageDown_.set (x);
  }

  void BranchGradientComplexType::
  setStorageDown (::std::auto_ptr< StorageDownType > x)
  {
    this->storageDown_.set (x);
  }

  const BranchGradientComplexType::SurfaceAreaDownType& BranchGradientComplexType::
  getSurfaceAreaDown () const
  {
    return this->surfaceAreaDown_.get ();
  }

  BranchGradientComplexType::SurfaceAreaDownType& BranchGradientComplexType::
  getSurfaceAreaDown ()
  {
    return this->surfaceAreaDown_.get ();
  }

  void BranchGradientComplexType::
  setSurfaceAreaDown (const SurfaceAreaDownType& x)
  {
    this->surfaceAreaDown_.set (x);
  }

  void BranchGradientComplexType::
  setSurfaceAreaDown (::std::auto_ptr< SurfaceAreaDownType > x)
  {
    this->surfaceAreaDown_.set (x);
  }


  // RiverWeirComplexType
  // 

  const RiverWeirComplexType::WidthType& RiverWeirComplexType::
  getWidth () const
  {
    return this->width_.get ();
  }

  RiverWeirComplexType::WidthType& RiverWeirComplexType::
  getWidth ()
  {
    return this->width_.get ();
  }

  void RiverWeirComplexType::
  setWidth (const WidthType& x)
  {
    this->width_.set (x);
  }

  const RiverWeirComplexType::ExponentWeirFormulaOptional& RiverWeirComplexType::
  getExponentWeirFormula () const
  {
    return this->exponentWeirFormula_;
  }

  RiverWeirComplexType::ExponentWeirFormulaOptional& RiverWeirComplexType::
  getExponentWeirFormula ()
  {
    return this->exponentWeirFormula_;
  }

  void RiverWeirComplexType::
  setExponentWeirFormula (const ExponentWeirFormulaType& x)
  {
    this->exponentWeirFormula_.set (x);
  }

  void RiverWeirComplexType::
  setExponentWeirFormula (const ExponentWeirFormulaOptional& x)
  {
    this->exponentWeirFormula_ = x;
  }

  RiverWeirComplexType::ExponentWeirFormulaType RiverWeirComplexType::
  getExponentWeirFormulaDefaultValue ()
  {
    return ExponentWeirFormulaType (1.5);
  }

  const RiverWeirComplexType::SubmergedFlowRatioOptional& RiverWeirComplexType::
  getSubmergedFlowRatio () const
  {
    return this->submergedFlowRatio_;
  }

  RiverWeirComplexType::SubmergedFlowRatioOptional& RiverWeirComplexType::
  getSubmergedFlowRatio ()
  {
    return this->submergedFlowRatio_;
  }

  void RiverWeirComplexType::
  setSubmergedFlowRatio (const SubmergedFlowRatioType& x)
  {
    this->submergedFlowRatio_.set (x);
  }

  void RiverWeirComplexType::
  setSubmergedFlowRatio (const SubmergedFlowRatioOptional& x)
  {
    this->submergedFlowRatio_ = x;
  }

  RiverWeirComplexType::SubmergedFlowRatioType RiverWeirComplexType::
  getSubmergedFlowRatioDefaultValue ()
  {
    return SubmergedFlowRatioType (1.5);
  }

  const RiverWeirComplexType::SubmergedFlowFactorOptional& RiverWeirComplexType::
  getSubmergedFlowFactor () const
  {
    return this->submergedFlowFactor_;
  }

  RiverWeirComplexType::SubmergedFlowFactorOptional& RiverWeirComplexType::
  getSubmergedFlowFactor ()
  {
    return this->submergedFlowFactor_;
  }

  void RiverWeirComplexType::
  setSubmergedFlowFactor (const SubmergedFlowFactorType& x)
  {
    this->submergedFlowFactor_.set (x);
  }

  void RiverWeirComplexType::
  setSubmergedFlowFactor (const SubmergedFlowFactorOptional& x)
  {
    this->submergedFlowFactor_ = x;
  }

  RiverWeirComplexType::SubmergedFlowFactorType RiverWeirComplexType::
  getSubmergedFlowFactorDefaultValue ()
  {
    return SubmergedFlowFactorType (1.0);
  }

  const RiverWeirComplexType::FlowDirectionOptional& RiverWeirComplexType::
  getFlowDirection () const
  {
    return this->flowDirection_;
  }

  RiverWeirComplexType::FlowDirectionOptional& RiverWeirComplexType::
  getFlowDirection ()
  {
    return this->flowDirection_;
  }

  void RiverWeirComplexType::
  setFlowDirection (const FlowDirectionType& x)
  {
    this->flowDirection_.set (x);
  }

  void RiverWeirComplexType::
  setFlowDirection (const FlowDirectionOptional& x)
  {
    this->flowDirection_ = x;
  }

  void RiverWeirComplexType::
  setFlowDirection (::std::auto_ptr< FlowDirectionType > x)
  {
    this->flowDirection_.set (x);
  }

  const RiverWeirComplexType::InputType& RiverWeirComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  RiverWeirComplexType::InputType& RiverWeirComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void RiverWeirComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void RiverWeirComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const RiverWeirComplexType::OutputType& RiverWeirComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  RiverWeirComplexType::OutputType& RiverWeirComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void RiverWeirComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void RiverWeirComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // RiverWeirInputComplexType
  // 

  const RiverWeirInputComplexType::HUpType& RiverWeirInputComplexType::
  getHUp () const
  {
    return this->HUp_.get ();
  }

  RiverWeirInputComplexType::HUpType& RiverWeirInputComplexType::
  getHUp ()
  {
    return this->HUp_.get ();
  }

  void RiverWeirInputComplexType::
  setHUp (const HUpType& x)
  {
    this->HUp_.set (x);
  }

  void RiverWeirInputComplexType::
  setHUp (::std::auto_ptr< HUpType > x)
  {
    this->HUp_.set (x);
  }

  const RiverWeirInputComplexType::DeltaHUpOptional& RiverWeirInputComplexType::
  getDeltaHUp () const
  {
    return this->DeltaHUp_;
  }

  RiverWeirInputComplexType::DeltaHUpOptional& RiverWeirInputComplexType::
  getDeltaHUp ()
  {
    return this->DeltaHUp_;
  }

  void RiverWeirInputComplexType::
  setDeltaHUp (const DeltaHUpType& x)
  {
    this->DeltaHUp_.set (x);
  }

  void RiverWeirInputComplexType::
  setDeltaHUp (const DeltaHUpOptional& x)
  {
    this->DeltaHUp_ = x;
  }

  void RiverWeirInputComplexType::
  setDeltaHUp (::std::auto_ptr< DeltaHUpType > x)
  {
    this->DeltaHUp_.set (x);
  }

  const RiverWeirInputComplexType::HDownType& RiverWeirInputComplexType::
  getHDown () const
  {
    return this->HDown_.get ();
  }

  RiverWeirInputComplexType::HDownType& RiverWeirInputComplexType::
  getHDown ()
  {
    return this->HDown_.get ();
  }

  void RiverWeirInputComplexType::
  setHDown (const HDownType& x)
  {
    this->HDown_.set (x);
  }

  void RiverWeirInputComplexType::
  setHDown (::std::auto_ptr< HDownType > x)
  {
    this->HDown_.set (x);
  }

  const RiverWeirInputComplexType::DeltaHDownOptional& RiverWeirInputComplexType::
  getDeltaHDown () const
  {
    return this->DeltaHDown_;
  }

  RiverWeirInputComplexType::DeltaHDownOptional& RiverWeirInputComplexType::
  getDeltaHDown ()
  {
    return this->DeltaHDown_;
  }

  void RiverWeirInputComplexType::
  setDeltaHDown (const DeltaHDownType& x)
  {
    this->DeltaHDown_.set (x);
  }

  void RiverWeirInputComplexType::
  setDeltaHDown (const DeltaHDownOptional& x)
  {
    this->DeltaHDown_ = x;
  }

  void RiverWeirInputComplexType::
  setDeltaHDown (::std::auto_ptr< DeltaHDownType > x)
  {
    this->DeltaHDown_.set (x);
  }

  const RiverWeirInputComplexType::CConstOptional& RiverWeirInputComplexType::
  getCConst () const
  {
    return this->CConst_;
  }

  RiverWeirInputComplexType::CConstOptional& RiverWeirInputComplexType::
  getCConst ()
  {
    return this->CConst_;
  }

  void RiverWeirInputComplexType::
  setCConst (const CConstType& x)
  {
    this->CConst_.set (x);
  }

  void RiverWeirInputComplexType::
  setCConst (const CConstOptional& x)
  {
    this->CConst_ = x;
  }

  const RiverWeirInputComplexType::CSeriesOptional& RiverWeirInputComplexType::
  getCSeries () const
  {
    return this->CSeries_;
  }

  RiverWeirInputComplexType::CSeriesOptional& RiverWeirInputComplexType::
  getCSeries ()
  {
    return this->CSeries_;
  }

  void RiverWeirInputComplexType::
  setCSeries (const CSeriesType& x)
  {
    this->CSeries_.set (x);
  }

  void RiverWeirInputComplexType::
  setCSeries (const CSeriesOptional& x)
  {
    this->CSeries_ = x;
  }

  void RiverWeirInputComplexType::
  setCSeries (::std::auto_ptr< CSeriesType > x)
  {
    this->CSeries_.set (x);
  }


  // RiverWeirOutputComplexType
  // 

  const RiverWeirOutputComplexType::QType& RiverWeirOutputComplexType::
  getQ () const
  {
    return this->Q_.get ();
  }

  RiverWeirOutputComplexType::QType& RiverWeirOutputComplexType::
  getQ ()
  {
    return this->Q_.get ();
  }

  void RiverWeirOutputComplexType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void RiverWeirOutputComplexType::
  setQ (::std::auto_ptr< QType > x)
  {
    this->Q_.set (x);
  }

  const RiverWeirOutputComplexType::CType& RiverWeirOutputComplexType::
  getC () const
  {
    return this->C_.get ();
  }

  RiverWeirOutputComplexType::CType& RiverWeirOutputComplexType::
  getC ()
  {
    return this->C_.get ();
  }

  void RiverWeirOutputComplexType::
  setC (const CType& x)
  {
    this->C_.set (x);
  }

  void RiverWeirOutputComplexType::
  setC (::std::auto_ptr< CType > x)
  {
    this->C_.set (x);
  }

  const RiverWeirOutputComplexType::FlowTypeOptional& RiverWeirOutputComplexType::
  getFlowType () const
  {
    return this->flowType_;
  }

  RiverWeirOutputComplexType::FlowTypeOptional& RiverWeirOutputComplexType::
  getFlowType ()
  {
    return this->flowType_;
  }

  void RiverWeirOutputComplexType::
  setFlowType (const FlowTypeType& x)
  {
    this->flowType_.set (x);
  }

  void RiverWeirOutputComplexType::
  setFlowType (const FlowTypeOptional& x)
  {
    this->flowType_ = x;
  }

  void RiverWeirOutputComplexType::
  setFlowType (::std::auto_ptr< FlowTypeType > x)
  {
    this->flowType_.set (x);
  }


  // PoolRoutingEnumStringType
  // 

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (Value v)
  : ::xml_schema::String (_xsd_PoolRoutingEnumStringType_literals_[v])
  {
  }

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const PoolRoutingEnumStringType& v,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PoolRoutingEnumStringType& PoolRoutingEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PoolRoutingEnumStringType_literals_[v]);

    return *this;
  }


  // InterpolationOptionEnumStringType
  // 

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (Value v)
  : ::xml_schema::String (_xsd_InterpolationOptionEnumStringType_literals_[v])
  {
  }

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const InterpolationOptionEnumStringType& v,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  InterpolationOptionEnumStringType& InterpolationOptionEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_InterpolationOptionEnumStringType_literals_[v]);

    return *this;
  }


  // LimiterOptionEnumStringType
  // 

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (Value v)
  : ::xml_schema::String (_xsd_LimiterOptionEnumStringType_literals_[v])
  {
  }

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const LimiterOptionEnumStringType& v,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  LimiterOptionEnumStringType& LimiterOptionEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_LimiterOptionEnumStringType_literals_[v]);

    return *this;
  }


  // TimeRelativeEnumStringType
  // 

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (Value v)
  : ::xml_schema::String (_xsd_TimeRelativeEnumStringType_literals_[v])
  {
  }

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const TimeRelativeEnumStringType& v,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  TimeRelativeEnumStringType& TimeRelativeEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_TimeRelativeEnumStringType_literals_[v]);

    return *this;
  }


  // CaseLangetenEnumStringType
  // 

  CaseLangetenEnumStringType::
  CaseLangetenEnumStringType (::xml_schema::Int v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (v)
  {
  }

  CaseLangetenEnumStringType::
  CaseLangetenEnumStringType (const CaseLangetenEnumStringType& v,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (v, f, c)
  {
  }


  // FlowDirectionEnumStringType
  //

  FlowDirectionEnumStringType::
  FlowDirectionEnumStringType (const char* s)
  : ::xml_schema::String (s)
  {
  }

  FlowDirectionEnumStringType::
  FlowDirectionEnumStringType (const ::std::string& s)
  : ::xml_schema::String (s)
  {
  }

  FlowDirectionEnumStringType::
  FlowDirectionEnumStringType (const FlowDirectionEnumStringType& o,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (o, f, c)
  {
  }

  // LogicalOperatorEnumStringType
  // 

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (Value v)
  : ::xml_schema::String (_xsd_LogicalOperatorEnumStringType_literals_[v])
  {
  }

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const LogicalOperatorEnumStringType& v,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  LogicalOperatorEnumStringType& LogicalOperatorEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_LogicalOperatorEnumStringType_literals_[v]);

    return *this;
  }


  // RelationalOperatorEnumStringType
  // 

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (Value v)
  : ::xml_schema::String (_xsd_RelationalOperatorEnumStringType_literals_[v])
  {
  }

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const RelationalOperatorEnumStringType& v,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  RelationalOperatorEnumStringType& RelationalOperatorEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_RelationalOperatorEnumStringType_literals_[v]);

    return *this;
  }


  // MathematicalOperatorEnumStringType
  // 

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (Value v)
  : ::xml_schema::String (_xsd_MathematicalOperatorEnumStringType_literals_[v])
  {
  }

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const MathematicalOperatorEnumStringType& v,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MathematicalOperatorEnumStringType& MathematicalOperatorEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MathematicalOperatorEnumStringType_literals_[v]);

    return *this;
  }


  // SpatialEnumStringType
  // 

  SpatialEnumStringType::
  SpatialEnumStringType (Value v)
  : ::xml_schema::String (_xsd_SpatialEnumStringType_literals_[v])
  {
  }

  SpatialEnumStringType::
  SpatialEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  SpatialEnumStringType::
  SpatialEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  SpatialEnumStringType::
  SpatialEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  SpatialEnumStringType::
  SpatialEnumStringType (const SpatialEnumStringType& v,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  SpatialEnumStringType& SpatialEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_SpatialEnumStringType_literals_[v]);

    return *this;
  }


  // CapacityReferenceEnumStringType
  // 

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (Value v)
  : ::xml_schema::String (_xsd_CapacityReferenceEnumStringType_literals_[v])
  {
  }

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const CapacityReferenceEnumStringType& v,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  CapacityReferenceEnumStringType& CapacityReferenceEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_CapacityReferenceEnumStringType_literals_[v]);

    return *this;
  }


  // InputReferenceEnumStringType
  // 

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (Value v)
  : ::xml_schema::String (_xsd_InputReferenceEnumStringType_literals_[v])
  {
  }

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const InputReferenceEnumStringType& v,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  InputReferenceEnumStringType& InputReferenceEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_InputReferenceEnumStringType_literals_[v]);

    return *this;
  }


  // BranchTypeEnumStringType
  // 

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (Value v)
  : ::xml_schema::String (_xsd_BranchTypeEnumStringType_literals_[v])
  {
  }

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const BranchTypeEnumStringType& v,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  BranchTypeEnumStringType& BranchTypeEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_BranchTypeEnumStringType_literals_[v]);

    return *this;
  }


  // EquationEnumStringType
  // 

  EquationEnumStringType::
  EquationEnumStringType (Value v)
  : ::xml_schema::String (_xsd_EquationEnumStringType_literals_[v])
  {
  }

  EquationEnumStringType::
  EquationEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  EquationEnumStringType::
  EquationEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  EquationEnumStringType::
  EquationEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  EquationEnumStringType::
  EquationEnumStringType (const EquationEnumStringType& v,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  EquationEnumStringType& EquationEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_EquationEnumStringType_literals_[v]);

    return *this;
  }


  // MergerSplitterEnumStringType
  // 

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (Value v)
  : ::xml_schema::String (_xsd_MergerSplitterEnumStringType_literals_[v])
  {
  }

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const MergerSplitterEnumStringType& v,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MergerSplitterEnumStringType& MergerSplitterEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MergerSplitterEnumStringType_literals_[v]);

    return *this;
  }


  // HydraulicModelModeEnumStringType
  // 

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (Value v)
  : ::xml_schema::String (_xsd_HydraulicModelModeEnumStringType_literals_[v])
  {
  }

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const HydraulicModelModeEnumStringType& v,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  HydraulicModelModeEnumStringType& HydraulicModelModeEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_HydraulicModelModeEnumStringType_literals_[v]);

    return *this;
  }


  // TransferFunctionEnumStringType
  // 

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (Value v)
  : ::xml_schema::String (_xsd_TransferFunctionEnumStringType_literals_[v])
  {
  }

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const TransferFunctionEnumStringType& v,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  TransferFunctionEnumStringType& TransferFunctionEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_TransferFunctionEnumStringType_literals_[v]);

    return *this;
  }


  // PidComplexType
  // 

  const PidComplexType::ModeOptional& PidComplexType::
  getMode () const
  {
    return this->mode_;
  }

  PidComplexType::ModeOptional& PidComplexType::
  getMode ()
  {
    return this->mode_;
  }

  void PidComplexType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void PidComplexType::
  setMode (const ModeOptional& x)
  {
    this->mode_ = x;
  }

  void PidComplexType::
  setMode (::std::auto_ptr< ModeType > x)
  {
    this->mode_.set (x);
  }

  const PidComplexType::ModeType& PidComplexType::
  getModeDefaultValue ()
  {
    return mode_default_value_;
  }

  const PidComplexType::SettingMinType& PidComplexType::
  getSettingMin () const
  {
    return this->settingMin_.get ();
  }

  PidComplexType::SettingMinType& PidComplexType::
  getSettingMin ()
  {
    return this->settingMin_.get ();
  }

  void PidComplexType::
  setSettingMin (const SettingMinType& x)
  {
    this->settingMin_.set (x);
  }

  const PidComplexType::SettingMaxType& PidComplexType::
  getSettingMax () const
  {
    return this->settingMax_.get ();
  }

  PidComplexType::SettingMaxType& PidComplexType::
  getSettingMax ()
  {
    return this->settingMax_.get ();
  }

  void PidComplexType::
  setSettingMax (const SettingMaxType& x)
  {
    this->settingMax_.set (x);
  }

  const PidComplexType::SettingMaxSpeedType& PidComplexType::
  getSettingMaxSpeed () const
  {
    return this->settingMaxSpeed_.get ();
  }

  PidComplexType::SettingMaxSpeedType& PidComplexType::
  getSettingMaxSpeed ()
  {
    return this->settingMaxSpeed_.get ();
  }

  void PidComplexType::
  setSettingMaxSpeed (const SettingMaxSpeedType& x)
  {
    this->settingMaxSpeed_.set (x);
  }

  const PidComplexType::KpType& PidComplexType::
  getKp () const
  {
    return this->kp_.get ();
  }

  PidComplexType::KpType& PidComplexType::
  getKp ()
  {
    return this->kp_.get ();
  }

  void PidComplexType::
  setKp (const KpType& x)
  {
    this->kp_.set (x);
  }

  const PidComplexType::KiType& PidComplexType::
  getKi () const
  {
    return this->ki_.get ();
  }

  PidComplexType::KiType& PidComplexType::
  getKi ()
  {
    return this->ki_.get ();
  }

  void PidComplexType::
  setKi (const KiType& x)
  {
    this->ki_.set (x);
  }

  const PidComplexType::KdType& PidComplexType::
  getKd () const
  {
    return this->kd_.get ();
  }

  PidComplexType::KdType& PidComplexType::
  getKd ()
  {
    return this->kd_.get ();
  }

  void PidComplexType::
  setKd (const KdType& x)
  {
    this->kd_.set (x);
  }

  const PidComplexType::InputType& PidComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  PidComplexType::InputType& PidComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void PidComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void PidComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const PidComplexType::OutputType& PidComplexType::
  getOutput () const
  {
    return this->output_.get ();
  }

  PidComplexType::OutputType& PidComplexType::
  getOutput ()
  {
    return this->output_.get ();
  }

  void PidComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void PidComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }

  const PidComplexType::IdType& PidComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  PidComplexType::IdType& PidComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void PidComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void PidComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const PidComplexType::NameOptional& PidComplexType::
  getName () const
  {
    return this->name_;
  }

  PidComplexType::NameOptional& PidComplexType::
  getName ()
  {
    return this->name_;
  }

  void PidComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void PidComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void PidComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // InputPidComplexType
  // 

  const InputPidComplexType::XType& InputPidComplexType::
  getX () const
  {
    return this->x_.get ();
  }

  InputPidComplexType::XType& InputPidComplexType::
  getX ()
  {
    return this->x_.get ();
  }

  void InputPidComplexType::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  void InputPidComplexType::
  setX (::std::auto_ptr< XType > x)
  {
    this->x_.set (x);
  }

  const InputPidComplexType::SetpointSeriesOptional& InputPidComplexType::
  getSetpointSeries () const
  {
    return this->setpointSeries_;
  }

  InputPidComplexType::SetpointSeriesOptional& InputPidComplexType::
  getSetpointSeries ()
  {
    return this->setpointSeries_;
  }

  void InputPidComplexType::
  setSetpointSeries (const SetpointSeriesType& x)
  {
    this->setpointSeries_.set (x);
  }

  void InputPidComplexType::
  setSetpointSeries (const SetpointSeriesOptional& x)
  {
    this->setpointSeries_ = x;
  }

  void InputPidComplexType::
  setSetpointSeries (::std::auto_ptr< SetpointSeriesType > x)
  {
    this->setpointSeries_.set (x);
  }

  const InputPidComplexType::SetpointValueOptional& InputPidComplexType::
  getSetpointValue () const
  {
    return this->setpointValue_;
  }

  InputPidComplexType::SetpointValueOptional& InputPidComplexType::
  getSetpointValue ()
  {
    return this->setpointValue_;
  }

  void InputPidComplexType::
  setSetpointValue (const SetpointValueType& x)
  {
    this->setpointValue_.set (x);
  }

  void InputPidComplexType::
  setSetpointValue (const SetpointValueOptional& x)
  {
    this->setpointValue_ = x;
  }

  const InputPidComplexType::DisturbanceOptional& InputPidComplexType::
  getDisturbance () const
  {
    return this->disturbance_;
  }

  InputPidComplexType::DisturbanceOptional& InputPidComplexType::
  getDisturbance ()
  {
    return this->disturbance_;
  }

  void InputPidComplexType::
  setDisturbance (const DisturbanceType& x)
  {
    this->disturbance_.set (x);
  }

  void InputPidComplexType::
  setDisturbance (const DisturbanceOptional& x)
  {
    this->disturbance_ = x;
  }

  void InputPidComplexType::
  setDisturbance (::std::auto_ptr< DisturbanceType > x)
  {
    this->disturbance_.set (x);
  }


  // OutputPidComplexType
  // 

  const OutputPidComplexType::YType& OutputPidComplexType::
  getY () const
  {
    return this->y_.get ();
  }

  OutputPidComplexType::YType& OutputPidComplexType::
  getY ()
  {
    return this->y_.get ();
  }

  void OutputPidComplexType::
  setY (const YType& x)
  {
    this->y_.set (x);
  }

  void OutputPidComplexType::
  setY (::std::auto_ptr< YType > x)
  {
    this->y_.set (x);
  }

  const OutputPidComplexType::IntegralPartType& OutputPidComplexType::
  getIntegralPart () const
  {
    return this->integralPart_.get ();
  }

  OutputPidComplexType::IntegralPartType& OutputPidComplexType::
  getIntegralPart ()
  {
    return this->integralPart_.get ();
  }

  void OutputPidComplexType::
  setIntegralPart (const IntegralPartType& x)
  {
    this->integralPart_.set (x);
  }

  void OutputPidComplexType::
  setIntegralPart (::std::auto_ptr< IntegralPartType > x)
  {
    this->integralPart_.set (x);
  }

  const OutputPidComplexType::DifferentialPartType& OutputPidComplexType::
  getDifferentialPart () const
  {
    return this->differentialPart_.get ();
  }

  OutputPidComplexType::DifferentialPartType& OutputPidComplexType::
  getDifferentialPart ()
  {
    return this->differentialPart_.get ();
  }

  void OutputPidComplexType::
  setDifferentialPart (const DifferentialPartType& x)
  {
    this->differentialPart_.set (x);
  }

  void OutputPidComplexType::
  setDifferentialPart (::std::auto_ptr< DifferentialPartType > x)
  {
    this->differentialPart_.set (x);
  }


  // TriggerControllerComplexType
  // 

  const TriggerControllerComplexType::InputType& TriggerControllerComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TriggerControllerComplexType::InputType& TriggerControllerComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TriggerControllerComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TriggerControllerComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TriggerControllerComplexType::ValueType& TriggerControllerComplexType::
  getValue () const
  {
    return this->value_.get ();
  }

  TriggerControllerComplexType::ValueType& TriggerControllerComplexType::
  getValue ()
  {
    return this->value_.get ();
  }

  void TriggerControllerComplexType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // LayerIDSimpleType
  // 


  // NeuronIDSimpleType
  // 


  // UnitTypeEnumStringType
  // 

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (Value v)
  : ::xml_schema::String (_xsd_UnitTypeEnumStringType_literals_[v])
  {
  }

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const UnitTypeEnumStringType& v,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  UnitTypeEnumStringType& UnitTypeEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_UnitTypeEnumStringType_literals_[v]);

    return *this;
  }


  // Row
  // 

  const Row::IdType& Row::
  getId () const
  {
    return this->id_.get ();
  }

  Row::IdType& Row::
  getId ()
  {
    return this->id_.get ();
  }

  void Row::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void Row::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const Row::ValueType& Row::
  getValue () const
  {
    return this->value_.get ();
  }

  Row::ValueType& Row::
  getValue ()
  {
    return this->value_.get ();
  }

  void Row::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // Y
  // 

  const Y::IdType& Y::
  getId () const
  {
    return this->id_.get ();
  }

  Y::IdType& Y::
  getId ()
  {
    return this->id_.get ();
  }

  void Y::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void Y::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const Y::SelectingColumnIdOptional& Y::
  getSelectingColumnId () const
  {
    return this->selectingColumnId_;
  }

  Y::SelectingColumnIdOptional& Y::
  getSelectingColumnId ()
  {
    return this->selectingColumnId_;
  }

  void Y::
  setSelectingColumnId (const SelectingColumnIdType& x)
  {
    this->selectingColumnId_.set (x);
  }

  void Y::
  setSelectingColumnId (const SelectingColumnIdOptional& x)
  {
    this->selectingColumnId_ = x;
  }

  void Y::
  setSelectingColumnId (::std::auto_ptr< SelectingColumnIdType > x)
  {
    this->selectingColumnId_.set (x);
  }


  // MonthOfYear
  // 

  MonthOfYear::
  MonthOfYear (Value v)
  : ::xml_schema::String (_xsd_MonthOfYear_literals_[v])
  {
  }

  MonthOfYear::
  MonthOfYear (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MonthOfYear::
  MonthOfYear (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MonthOfYear::
  MonthOfYear (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MonthOfYear::
  MonthOfYear (const MonthOfYear& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MonthOfYear& MonthOfYear::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MonthOfYear_literals_[v]);

    return *this;
  }


  // QSPercentage
  // 

  const QSPercentage::UseAbsoluteAsSpillCapOptional& QSPercentage::
  getUseAbsoluteAsSpillCap () const
  {
    return this->useAbsoluteAsSpillCap_;
  }

  QSPercentage::UseAbsoluteAsSpillCapOptional& QSPercentage::
  getUseAbsoluteAsSpillCap ()
  {
    return this->useAbsoluteAsSpillCap_;
  }

  void QSPercentage::
  setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapType& x)
  {
    this->useAbsoluteAsSpillCap_.set (x);
  }

  void QSPercentage::
  setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapOptional& x)
  {
    this->useAbsoluteAsSpillCap_ = x;
  }


  // QSPercentageValue
  // 

  const QSPercentageValue::UseAbsoluteAsSpillCapOptional& QSPercentageValue::
  getUseAbsoluteAsSpillCap () const
  {
    return this->useAbsoluteAsSpillCap_;
  }

  QSPercentageValue::UseAbsoluteAsSpillCapOptional& QSPercentageValue::
  getUseAbsoluteAsSpillCap ()
  {
    return this->useAbsoluteAsSpillCap_;
  }

  void QSPercentageValue::
  setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapType& x)
  {
    this->useAbsoluteAsSpillCap_.set (x);
  }

  void QSPercentageValue::
  setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapOptional& x)
  {
    this->useAbsoluteAsSpillCap_ = x;
  }


  // External
  // 

  const External::WeightType& External::
  getWeight () const
  {
    return this->weight_.get ();
  }

  External::WeightType& External::
  getWeight ()
  {
    return this->weight_.get ();
  }

  void External::
  setWeight (const WeightType& x)
  {
    this->weight_.set (x);
  }

  void External::
  setWeight (::std::auto_ptr< WeightType > x)
  {
    this->weight_.set (x);
  }


  // Internal
  // 

  const Internal::WeightType& Internal::
  getWeight () const
  {
    return this->weight_.get ();
  }

  Internal::WeightType& Internal::
  getWeight ()
  {
    return this->weight_.get ();
  }

  void Internal::
  setWeight (const WeightType& x)
  {
    this->weight_.set (x);
  }

  void Internal::
  setWeight (::std::auto_ptr< WeightType > x)
  {
    this->weight_.set (x);
  }


  // Multiplier
  // 


  // Property
  // 

  Property::
  Property (Value v)
  : ::xml_schema::String (_xsd_Property_literals_[v])
  {
  }

  Property::
  Property (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Property::
  Property (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Property::
  Property (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Property::
  Property (const Property& v,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Property& Property::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Property_literals_[v]);

    return *this;
  }


  // X
  // 

  const X::RefType& X::
  getRef () const
  {
    return this->ref_.get ();
  }

  X::RefType& X::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X::RefType& X::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X1
  // 

  const X1::RefType& X1::
  getRef () const
  {
    return this->ref_.get ();
  }

  X1::RefType& X1::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X1::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X1::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X1::RefType& X1::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X11
  // 

  const X11::RefType& X11::
  getRef () const
  {
    return this->ref_.get ();
  }

  X11::RefType& X11::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X11::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X11::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X11::RefType& X11::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X2
  // 

  const X2::RefType& X2::
  getRef () const
  {
    return this->ref_.get ();
  }

  X2::RefType& X2::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X2::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X2::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X2::RefType& X2::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X12
  // 

  const X12::RefType& X12::
  getRef () const
  {
    return this->ref_.get ();
  }

  X12::RefType& X12::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X12::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X12::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X12::RefType& X12::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X21
  // 

  const X21::RefType& X21::
  getRef () const
  {
    return this->ref_.get ();
  }

  X21::RefType& X21::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X21::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X21::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X21::RefType& X21::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X3
  // 

  const X3::RefType& X3::
  getRef () const
  {
    return this->ref_.get ();
  }

  X3::RefType& X3::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X3::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X3::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X3::RefType& X3::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X4
  // 

  const X4::RefType& X4::
  getRef () const
  {
    return this->ref_.get ();
  }

  X4::RefType& X4::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X4::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X4::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X4::RefType& X4::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X5
  // 

  const X5::FactorType& X5::
  getFactor () const
  {
    return this->factor_.get ();
  }

  X5::FactorType& X5::
  getFactor ()
  {
    return this->factor_.get ();
  }

  void X5::
  setFactor (const FactorType& x)
  {
    this->factor_.set (x);
  }

  X5::FactorType X5::
  getFactorDefaultValue ()
  {
    return FactorType (1.0);
  }

  const X5::RefType& X5::
  getRef () const
  {
    return this->ref_.get ();
  }

  X5::RefType& X5::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X5::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X5::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X5::RefType& X5::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // XVector
  // 

  const XVector::RefType& XVector::
  getRef () const
  {
    return this->ref_.get ();
  }

  XVector::RefType& XVector::
  getRef ()
  {
    return this->ref_.get ();
  }

  void XVector::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void XVector::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const XVector::RefType& XVector::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }

  const XVector::NStepSeriesStartOptional& XVector::
  getNStepSeriesStart () const
  {
    return this->nStepSeriesStart_;
  }

  XVector::NStepSeriesStartOptional& XVector::
  getNStepSeriesStart ()
  {
    return this->nStepSeriesStart_;
  }

  void XVector::
  setNStepSeriesStart (const NStepSeriesStartType& x)
  {
    this->nStepSeriesStart_.set (x);
  }

  void XVector::
  setNStepSeriesStart (const NStepSeriesStartOptional& x)
  {
    this->nStepSeriesStart_ = x;
  }

  void XVector::
  setNStepSeriesStart (::std::auto_ptr< NStepSeriesStartType > x)
  {
    this->nStepSeriesStart_.set (x);
  }

  const XVector::NStepSeriesOptional& XVector::
  getNStepSeries () const
  {
    return this->nStepSeries_;
  }

  XVector::NStepSeriesOptional& XVector::
  getNStepSeries ()
  {
    return this->nStepSeries_;
  }

  void XVector::
  setNStepSeries (const NStepSeriesType& x)
  {
    this->nStepSeries_.set (x);
  }

  void XVector::
  setNStepSeries (const NStepSeriesOptional& x)
  {
    this->nStepSeries_ = x;
  }

  void XVector::
  setNStepSeries (::std::auto_ptr< NStepSeriesType > x)
  {
    this->nStepSeries_.set (x);
  }


  // Y1
  // 

  const Y1::FactorType& Y1::
  getFactor () const
  {
    return this->factor_.get ();
  }

  Y1::FactorType& Y1::
  getFactor ()
  {
    return this->factor_.get ();
  }

  void Y1::
  setFactor (const FactorType& x)
  {
    this->factor_.set (x);
  }

  Y1::FactorType Y1::
  getFactorDefaultValue ()
  {
    return FactorType (1.0);
  }


  // Mode
  // 

  Mode::
  Mode (Value v)
  : ::xml_schema::String (_xsd_Mode_literals_[v])
  {
  }

  Mode::
  Mode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Mode::
  Mode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Mode::
  Mode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Mode::
  Mode (const Mode& v,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Mode& Mode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Mode_literals_[v]);

    return *this;
  }


  // X1Series
  // 

  const X1Series::RefType& X1Series::
  getRef () const
  {
    return this->ref_.get ();
  }

  X1Series::RefType& X1Series::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X1Series::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X1Series::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X1Series::RefType& X1Series::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X1SeriesVector
  // 

  const X1SeriesVector::RefType& X1SeriesVector::
  getRef () const
  {
    return this->ref_.get ();
  }

  X1SeriesVector::RefType& X1SeriesVector::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X1SeriesVector::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X1SeriesVector::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X1SeriesVector::RefType& X1SeriesVector::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X2Series
  // 

  const X2Series::RefType& X2Series::
  getRef () const
  {
    return this->ref_.get ();
  }

  X2Series::RefType& X2Series::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X2Series::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X2Series::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X2Series::RefType& X2Series::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X2SeriesVector
  // 

  const X2SeriesVector::RefType& X2SeriesVector::
  getRef () const
  {
    return this->ref_.get ();
  }

  X2SeriesVector::RefType& X2SeriesVector::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X2SeriesVector::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X2SeriesVector::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X2SeriesVector::RefType& X2SeriesVector::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X6
  // 

  const X6::RefType& X6::
  getRef () const
  {
    return this->ref_.get ();
  }

  X6::RefType& X6::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X6::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X6::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X6::RefType& X6::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // ThresholdSeries
  // 

  const ThresholdSeries::RefType& ThresholdSeries::
  getRef () const
  {
    return this->ref_.get ();
  }

  ThresholdSeries::RefType& ThresholdSeries::
  getRef ()
  {
    return this->ref_.get ();
  }

  void ThresholdSeries::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void ThresholdSeries::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const ThresholdSeries::RefType& ThresholdSeries::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X1Series1
  // 

  const X1Series1::RefType& X1Series1::
  getRef () const
  {
    return this->ref_.get ();
  }

  X1Series1::RefType& X1Series1::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X1Series1::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X1Series1::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X1Series1::RefType& X1Series1::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X2Series1
  // 

  const X2Series1::RefType& X2Series1::
  getRef () const
  {
    return this->ref_.get ();
  }

  X2Series1::RefType& X2Series1::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X2Series1::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X2Series1::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X2Series1::RefType& X2Series1::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X1Series2
  // 

  const X1Series2::RefType& X1Series2::
  getRef () const
  {
    return this->ref_.get ();
  }

  X1Series2::RefType& X1Series2::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X1Series2::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X1Series2::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X1Series2::RefType& X1Series2::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // X2Series2
  // 

  const X2Series2::RefType& X2Series2::
  getRef () const
  {
    return this->ref_.get ();
  }

  X2Series2::RefType& X2Series2::
  getRef ()
  {
    return this->ref_.get ();
  }

  void X2Series2::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void X2Series2::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }

  const X2Series2::RefType& X2Series2::
  getRefDefaultValue ()
  {
    return ref_default_value_;
  }


  // QBC
  // 

  const QBC::FactorType& QBC::
  getFactor () const
  {
    return this->factor_.get ();
  }

  QBC::FactorType& QBC::
  getFactor ()
  {
    return this->factor_.get ();
  }

  void QBC::
  setFactor (const FactorType& x)
  {
    this->factor_.set (x);
  }

  QBC::FactorType QBC::
  getFactorDefaultValue ()
  {
    return FactorType (1.0);
  }


  // FlowDirectionEnumStringType_member
  // 

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (Value v)
  : ::xml_schema::String (_xsd_FlowDirectionEnumStringType_member_literals_[v])
  {
  }

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const char* v)
  : ::xml_schema::String (v)
  {
  }

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const FlowDirectionEnumStringType_member& v,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  FlowDirectionEnumStringType_member& FlowDirectionEnumStringType_member::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_FlowDirectionEnumStringType_member_literals_[v]);

    return *this;
  }


  // FlowDirectionEnumStringType_member1
  // 


  // Mode1
  // 

  Mode1::
  Mode1 (Value v)
  : ::xml_schema::String (_xsd_Mode1_literals_[v])
  {
  }

  Mode1::
  Mode1 (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Mode1::
  Mode1 (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Mode1::
  Mode1 (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Mode1::
  Mode1 (const Mode1& v,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Mode1& Mode1::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Mode1_literals_[v]);

    return *this;
  }


  // Disturbance
  // 

  const Disturbance::FactorType& Disturbance::
  getFactor () const
  {
    return this->factor_.get ();
  }

  Disturbance::FactorType& Disturbance::
  getFactor ()
  {
    return this->factor_.get ();
  }

  void Disturbance::
  setFactor (const FactorType& x)
  {
    this->factor_.set (x);
  }

  Disturbance::FactorType Disturbance::
  getFactorDefaultValue ()
  {
    return FactorType (1.0);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace fews
{
  // RtcToolsConfigComplexType
  //

  RtcToolsConfigComplexType::
  RtcToolsConfigComplexType ()
  : ::xml_schema::Type (),
    general_ (::xml_schema::Flags (), this),
    components_ (::xml_schema::Flags (), this),
    rules_ (::xml_schema::Flags (), this),
    triggers_ (::xml_schema::Flags (), this)
  {
  }

  RtcToolsConfigComplexType::
  RtcToolsConfigComplexType (const RtcToolsConfigComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    general_ (x.general_, f, this),
    components_ (x.components_, f, this),
    rules_ (x.rules_, f, this),
    triggers_ (x.triggers_, f, this)
  {
  }

  RtcToolsConfigComplexType::
  RtcToolsConfigComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    general_ (f, this),
    components_ (f, this),
    rules_ (f, this),
    triggers_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RtcToolsConfigComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // general
      //
      if (n.name () == "general" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< GeneralType > r (
          GeneralTraits::create (i, f, this));

        if (!this->general_)
        {
          this->general_.set (r);
          continue;
        }
      }

      // components
      //
      if (n.name () == "components" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ComponentsType > r (
          ComponentsTraits::create (i, f, this));

        if (!this->components_)
        {
          this->components_.set (r);
          continue;
        }
      }

      // rules
      //
      if (n.name () == "rules" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RulesType > r (
          RulesTraits::create (i, f, this));

        if (!this->rules_)
        {
          this->rules_.set (r);
          continue;
        }
      }

      // triggers
      //
      if (n.name () == "triggers" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TriggersType > r (
          TriggersTraits::create (i, f, this));

        if (!this->triggers_)
        {
          this->triggers_.set (r);
          continue;
        }
      }

      break;
    }
  }

  RtcToolsConfigComplexType* RtcToolsConfigComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RtcToolsConfigComplexType (*this, f, c);
  }

  RtcToolsConfigComplexType::
  ~RtcToolsConfigComplexType ()
  {
  }

  // GeneralModuleConfigComplexType
  //

  GeneralModuleConfigComplexType::
  GeneralModuleConfigComplexType (const PoolRoutingSchemeType& poolRoutingScheme,
                                  const ThetaType& theta)
  : ::xml_schema::Type (),
    description_ (::xml_schema::Flags (), this),
    poolRoutingScheme_ (poolRoutingScheme, ::xml_schema::Flags (), this),
    theta_ (theta, ::xml_schema::Flags (), this)
  {
  }

  GeneralModuleConfigComplexType::
  GeneralModuleConfigComplexType (const GeneralModuleConfigComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    description_ (x.description_, f, this),
    poolRoutingScheme_ (x.poolRoutingScheme_, f, this),
    theta_ (x.theta_, f, this)
  {
  }

  GeneralModuleConfigComplexType::
  GeneralModuleConfigComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    description_ (f, this),
    poolRoutingScheme_ (f, this),
    theta_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GeneralModuleConfigComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DescriptionType > r (
          DescriptionTraits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (r);
          continue;
        }
      }

      // poolRoutingScheme
      //
      if (n.name () == "poolRoutingScheme" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PoolRoutingSchemeType > r (
          PoolRoutingSchemeTraits::create (i, f, this));

        if (!poolRoutingScheme_.present ())
        {
          this->poolRoutingScheme_.set (r);
          continue;
        }
      }

      // theta
      //
      if (n.name () == "theta" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!theta_.present ())
        {
          this->theta_.set (ThetaTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!poolRoutingScheme_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "poolRoutingScheme",
        "http://www.wldelft.nl/fews");
    }

    if (!theta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "theta",
        "http://www.wldelft.nl/fews");
    }
  }

  GeneralModuleConfigComplexType* GeneralModuleConfigComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GeneralModuleConfigComplexType (*this, f, c);
  }

  GeneralModuleConfigComplexType::
  ~GeneralModuleConfigComplexType ()
  {
  }

  // ComponentsComplexType
  //

  ComponentsComplexType::
  ComponentsComplexType ()
  : ::xml_schema::Type (),
    component_ (::xml_schema::Flags (), this)
  {
  }

  ComponentsComplexType::
  ComponentsComplexType (const ComponentsComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this)
  {
  }

  ComponentsComplexType::
  ComponentsComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ComponentsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component
      //
      if (n.name () == "component" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (r);
        continue;
      }

      break;
    }
  }

  ComponentsComplexType* ComponentsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComponentsComplexType (*this, f, c);
  }

  ComponentsComplexType::
  ~ComponentsComplexType ()
  {
  }

  // ComponentComplexType
  //

  ComponentComplexType::
  ComponentComplexType ()
  : ::xml_schema::Type (),
    accumulation_ (::xml_schema::Flags (), this),
    allocationTable_ (::xml_schema::Flags (), this),
    arma_ (::xml_schema::Flags (), this),
    expression_ (::xml_schema::Flags (), this),
    gradient_ (::xml_schema::Flags (), this),
    hbv_ (::xml_schema::Flags (), this),
    hydraulicModel_ (::xml_schema::Flags (), this),
    hydrologicalModel_ (::xml_schema::Flags (), this),
    lookupTable_ (::xml_schema::Flags (), this),
    lookup2DTable_ (::xml_schema::Flags (), this),
    merger_ (::xml_schema::Flags (), this),
    mergerSplitter_ (::xml_schema::Flags (), this),
    neuralNetwork_ (::xml_schema::Flags (), this),
    reservoir_ (::xml_schema::Flags (), this),
    reservoirCompact_ (::xml_schema::Flags (), this),
    lorentGevers_ (::xml_schema::Flags (), this),
    routing_ (::xml_schema::Flags (), this),
    srm_ (::xml_schema::Flags (), this),
    unitDelay_ (::xml_schema::Flags (), this),
    unitHydrograph_ (::xml_schema::Flags (), this),
    template__ (::xml_schema::Flags (), this)
  {
  }

  ComponentComplexType::
  ComponentComplexType (const ComponentComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    accumulation_ (x.accumulation_, f, this),
    allocationTable_ (x.allocationTable_, f, this),
    arma_ (x.arma_, f, this),
    expression_ (x.expression_, f, this),
    gradient_ (x.gradient_, f, this),
    hbv_ (x.hbv_, f, this),
    hydraulicModel_ (x.hydraulicModel_, f, this),
    hydrologicalModel_ (x.hydrologicalModel_, f, this),
    lookupTable_ (x.lookupTable_, f, this),
    lookup2DTable_ (x.lookup2DTable_, f, this),
    merger_ (x.merger_, f, this),
    mergerSplitter_ (x.mergerSplitter_, f, this),
    neuralNetwork_ (x.neuralNetwork_, f, this),
    reservoir_ (x.reservoir_, f, this),
    reservoirCompact_ (x.reservoirCompact_, f, this),
    lorentGevers_ (x.lorentGevers_, f, this),
    routing_ (x.routing_, f, this),
    srm_ (x.srm_, f, this),
    unitDelay_ (x.unitDelay_, f, this),
    unitHydrograph_ (x.unitHydrograph_, f, this),
    template__ (x.template__, f, this)
  {
  }

  ComponentComplexType::
  ComponentComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    accumulation_ (f, this),
    allocationTable_ (f, this),
    arma_ (f, this),
    expression_ (f, this),
    gradient_ (f, this),
    hbv_ (f, this),
    hydraulicModel_ (f, this),
    hydrologicalModel_ (f, this),
    lookupTable_ (f, this),
    lookup2DTable_ (f, this),
    merger_ (f, this),
    mergerSplitter_ (f, this),
    neuralNetwork_ (f, this),
    reservoir_ (f, this),
    reservoirCompact_ (f, this),
    lorentGevers_ (f, this),
    routing_ (f, this),
    srm_ (f, this),
    unitDelay_ (f, this),
    unitHydrograph_ (f, this),
    template__ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ComponentComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accumulation
      //
      if (n.name () == "accumulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AccumulationType > r (
          AccumulationTraits::create (i, f, this));

        if (!this->accumulation_)
        {
          this->accumulation_.set (r);
          continue;
        }
      }

      // allocationTable
      //
      if (n.name () == "allocationTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AllocationTableType > r (
          AllocationTableTraits::create (i, f, this));

        if (!this->allocationTable_)
        {
          this->allocationTable_.set (r);
          continue;
        }
      }

      // arma
      //
      if (n.name () == "arma" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ArmaType > r (
          ArmaTraits::create (i, f, this));

        if (!this->arma_)
        {
          this->arma_.set (r);
          continue;
        }
      }

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExpressionType > r (
          ExpressionTraits::create (i, f, this));

        if (!this->expression_)
        {
          this->expression_.set (r);
          continue;
        }
      }

      // gradient
      //
      if (n.name () == "gradient" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< GradientType > r (
          GradientTraits::create (i, f, this));

        if (!this->gradient_)
        {
          this->gradient_.set (r);
          continue;
        }
      }

      // hbv
      //
      if (n.name () == "hbv" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HbvType > r (
          HbvTraits::create (i, f, this));

        if (!this->hbv_)
        {
          this->hbv_.set (r);
          continue;
        }
      }

      // hydraulicModel
      //
      if (n.name () == "hydraulicModel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HydraulicModelType > r (
          HydraulicModelTraits::create (i, f, this));

        if (!this->hydraulicModel_)
        {
          this->hydraulicModel_.set (r);
          continue;
        }
      }

      // hydrologicalModel
      //
      if (n.name () == "hydrologicalModel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HydrologicalModelType > r (
          HydrologicalModelTraits::create (i, f, this));

        if (!this->hydrologicalModel_)
        {
          this->hydrologicalModel_.set (r);
          continue;
        }
      }

      // lookupTable
      //
      if (n.name () == "lookupTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LookupTableType > r (
          LookupTableTraits::create (i, f, this));

        if (!this->lookupTable_)
        {
          this->lookupTable_.set (r);
          continue;
        }
      }

      // lookup2DTable
      //
      if (n.name () == "lookup2DTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Lookup2DTableType > r (
          Lookup2DTableTraits::create (i, f, this));

        if (!this->lookup2DTable_)
        {
          this->lookup2DTable_.set (r);
          continue;
        }
      }

      // merger
      //
      if (n.name () == "merger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MergerType > r (
          MergerTraits::create (i, f, this));

        if (!this->merger_)
        {
          this->merger_.set (r);
          continue;
        }
      }

      // mergerSplitter
      //
      if (n.name () == "mergerSplitter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MergerSplitterType > r (
          MergerSplitterTraits::create (i, f, this));

        if (!this->mergerSplitter_)
        {
          this->mergerSplitter_.set (r);
          continue;
        }
      }

      // neuralNetwork
      //
      if (n.name () == "neuralNetwork" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NeuralNetworkType > r (
          NeuralNetworkTraits::create (i, f, this));

        if (!this->neuralNetwork_)
        {
          this->neuralNetwork_.set (r);
          continue;
        }
      }

      // reservoir
      //
      if (n.name () == "reservoir" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReservoirType > r (
          ReservoirTraits::create (i, f, this));

        if (!this->reservoir_)
        {
          this->reservoir_.set (r);
          continue;
        }
      }

      // reservoirCompact
      //
      if (n.name () == "reservoirCompact" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReservoirCompactType > r (
          ReservoirCompactTraits::create (i, f, this));

        if (!this->reservoirCompact_)
        {
          this->reservoirCompact_.set (r);
          continue;
        }
      }

      // lorentGevers
      //
      if (n.name () == "lorentGevers" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LorentGeversType > r (
          LorentGeversTraits::create (i, f, this));

        if (!this->lorentGevers_)
        {
          this->lorentGevers_.set (r);
          continue;
        }
      }

      // routing
      //
      if (n.name () == "routing" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RoutingType > r (
          RoutingTraits::create (i, f, this));

        if (!this->routing_)
        {
          this->routing_.set (r);
          continue;
        }
      }

      // srm
      //
      if (n.name () == "srm" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SrmType > r (
          SrmTraits::create (i, f, this));

        if (!this->srm_)
        {
          this->srm_.set (r);
          continue;
        }
      }

      // unitDelay
      //
      if (n.name () == "unitDelay" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitDelayType > r (
          UnitDelayTraits::create (i, f, this));

        if (!this->unitDelay_)
        {
          this->unitDelay_.set (r);
          continue;
        }
      }

      // unitHydrograph
      //
      if (n.name () == "unitHydrograph" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitHydrographType > r (
          UnitHydrographTraits::create (i, f, this));

        if (!this->unitHydrograph_)
        {
          this->unitHydrograph_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "template" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TemplateType > r (
          TemplateTraits::create (i, f, this));

        this->template__.set (r);
        continue;
      }
    }
  }

  ComponentComplexType* ComponentComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComponentComplexType (*this, f, c);
  }

  ComponentComplexType::
  ~ComponentComplexType ()
  {
  }

  // AllocationTableComplexType
  //

  AllocationTableComplexType::
  AllocationTableComplexType (const InputType& input,
                              const OutputType& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    table_ (::xml_schema::Flags (), this),
    tableExternal_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AllocationTableComplexType::
  AllocationTableComplexType (::std::auto_ptr< InputType >& input,
                              ::std::auto_ptr< OutputType >& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    table_ (::xml_schema::Flags (), this),
    tableExternal_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AllocationTableComplexType::
  AllocationTableComplexType (const AllocationTableComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    table_ (x.table_, f, this),
    tableExternal_ (x.tableExternal_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  AllocationTableComplexType::
  AllocationTableComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    table_ (f, this),
    tableExternal_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AllocationTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // table
      //
      if (n.name () == "table" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TableType > r (
          TableTraits::create (i, f, this));

        if (!this->table_)
        {
          this->table_.set (r);
          continue;
        }
      }

      // tableExternal
      //
      if (n.name () == "tableExternal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TableExternalType > r (
          TableExternalTraits::create (i, f, this));

        if (!this->tableExternal_)
        {
          this->tableExternal_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  AllocationTableComplexType* AllocationTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AllocationTableComplexType (*this, f, c);
  }

  AllocationTableComplexType::
  ~AllocationTableComplexType ()
  {
  }

  // ATableComplexType
  //

  ATableComplexType::
  ATableComplexType ()
  : ::xml_schema::Type (),
    row_ (::xml_schema::Flags (), this)
  {
  }

  ATableComplexType::
  ATableComplexType (const ATableComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    row_ (x.row_, f, this)
  {
  }

  ATableComplexType::
  ATableComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    row_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ATableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // row
      //
      if (n.name () == "row" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RowType > r (
          RowTraits::create (i, f, this));

        this->row_.push_back (r);
        continue;
      }

      break;
    }
  }

  ATableComplexType* ATableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ATableComplexType (*this, f, c);
  }

  ATableComplexType::
  ~ATableComplexType ()
  {
  }

  // InputATableComplexType
  //

  InputATableComplexType::
  InputATableComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    valueSelection_ (::xml_schema::Flags (), this)
  {
  }

  InputATableComplexType::
  InputATableComplexType (const InputATableComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    valueSelection_ (x.valueSelection_, f, this)
  {
  }

  InputATableComplexType::
  InputATableComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    valueSelection_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputATableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // valueSelection
      //
      if (n.name () == "valueSelection" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ValueSelectionType > r (
          ValueSelectionTraits::create (i, f, this));

        if (!this->valueSelection_)
        {
          this->valueSelection_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  InputATableComplexType* InputATableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputATableComplexType (*this, f, c);
  }

  InputATableComplexType::
  ~InputATableComplexType ()
  {
  }

  // OutputATableComplexType
  //

  OutputATableComplexType::
  OutputATableComplexType ()
  : ::xml_schema::Type (),
    y_ (::xml_schema::Flags (), this)
  {
  }

  OutputATableComplexType::
  OutputATableComplexType (const OutputATableComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  OutputATableComplexType::
  OutputATableComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputATableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        this->y_.push_back (r);
        continue;
      }

      break;
    }
  }

  OutputATableComplexType* OutputATableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputATableComplexType (*this, f, c);
  }

  OutputATableComplexType::
  ~OutputATableComplexType ()
  {
  }

  // HydrologicalModelComplexType
  //

  HydrologicalModelComplexType::
  HydrologicalModelComplexType (const IdType& id)
  : ::xml_schema::Type (),
    submodel_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  HydrologicalModelComplexType::
  HydrologicalModelComplexType (const HydrologicalModelComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    submodel_ (x.submodel_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  HydrologicalModelComplexType::
  HydrologicalModelComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    submodel_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void HydrologicalModelComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // submodel
      //
      if (n.name () == "submodel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SubmodelType > r (
          SubmodelTraits::create (i, f, this));

        this->submodel_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  HydrologicalModelComplexType* HydrologicalModelComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydrologicalModelComplexType (*this, f, c);
  }

  HydrologicalModelComplexType::
  ~HydrologicalModelComplexType ()
  {
  }

  // SubmodelComplexType
  //

  SubmodelComplexType::
  SubmodelComplexType ()
  : ::xml_schema::Type (),
    typicalProfile_ (::xml_schema::Flags (), this),
    snowRainJunction_ (::xml_schema::Flags (), this),
    evaporationPotential_ (::xml_schema::Flags (), this),
    storageSystem_ (::xml_schema::Flags (), this)
  {
  }

  SubmodelComplexType::
  SubmodelComplexType (const SubmodelComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    typicalProfile_ (x.typicalProfile_, f, this),
    snowRainJunction_ (x.snowRainJunction_, f, this),
    evaporationPotential_ (x.evaporationPotential_, f, this),
    storageSystem_ (x.storageSystem_, f, this)
  {
  }

  SubmodelComplexType::
  SubmodelComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    typicalProfile_ (f, this),
    snowRainJunction_ (f, this),
    evaporationPotential_ (f, this),
    storageSystem_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SubmodelComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // typicalProfile
      //
      if (n.name () == "typicalProfile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TypicalProfileType > r (
          TypicalProfileTraits::create (i, f, this));

        if (!this->typicalProfile_)
        {
          this->typicalProfile_.set (r);
          continue;
        }
      }

      // snowRainJunction
      //
      if (n.name () == "snowRainJunction" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SnowRainJunctionType > r (
          SnowRainJunctionTraits::create (i, f, this));

        if (!this->snowRainJunction_)
        {
          this->snowRainJunction_.set (r);
          continue;
        }
      }

      // evaporationPotential
      //
      if (n.name () == "evaporationPotential" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EvaporationPotentialType > r (
          EvaporationPotentialTraits::create (i, f, this));

        if (!this->evaporationPotential_)
        {
          this->evaporationPotential_.set (r);
          continue;
        }
      }

      // storageSystem
      //
      if (n.name () == "storageSystem" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageSystemType > r (
          StorageSystemTraits::create (i, f, this));

        if (!this->storageSystem_)
        {
          this->storageSystem_.set (r);
          continue;
        }
      }

      break;
    }
  }

  SubmodelComplexType* SubmodelComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SubmodelComplexType (*this, f, c);
  }

  SubmodelComplexType::
  ~SubmodelComplexType ()
  {
  }

  // ReleaseTotalComplexType
  //

  ReleaseTotalComplexType::
  ReleaseTotalComplexType (const InputType& input,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReleaseTotalComplexType::
  ReleaseTotalComplexType (::std::auto_ptr< InputType >& input,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReleaseTotalComplexType::
  ReleaseTotalComplexType (const ReleaseTotalComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ReleaseTotalComplexType::
  ReleaseTotalComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ReleaseTotalComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ReleaseTotalComplexType* ReleaseTotalComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReleaseTotalComplexType (*this, f, c);
  }

  ReleaseTotalComplexType::
  ~ReleaseTotalComplexType ()
  {
  }

  // ParameterReleaseTotalComplexType
  //

  ParameterReleaseTotalComplexType::
  ParameterReleaseTotalComplexType (const AREAType& AREA)
  : ::xml_schema::Type (),
    AREA_ (AREA, ::xml_schema::Flags (), this)
  {
  }

  ParameterReleaseTotalComplexType::
  ParameterReleaseTotalComplexType (const ParameterReleaseTotalComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this)
  {
  }

  ParameterReleaseTotalComplexType::
  ParameterReleaseTotalComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterReleaseTotalComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!AREA_.present ())
        {
          this->AREA_.set (r);
          continue;
        }
      }

      break;
    }

    if (!AREA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AREA",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterReleaseTotalComplexType* ParameterReleaseTotalComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterReleaseTotalComplexType (*this, f, c);
  }

  ParameterReleaseTotalComplexType::
  ~ParameterReleaseTotalComplexType ()
  {
  }

  // InputReleaseTotalComplexType
  //

  const InputReleaseTotalComplexType::DischargeType InputReleaseTotalComplexType::discharge_default_value_ (
    "Q");

  InputReleaseTotalComplexType::
  InputReleaseTotalComplexType ()
  : ::xml_schema::Type (),
    discharge_ (::xml_schema::Flags (), this)
  {
  }

  InputReleaseTotalComplexType::
  InputReleaseTotalComplexType (const InputReleaseTotalComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    discharge_ (x.discharge_, f, this)
  {
  }

  InputReleaseTotalComplexType::
  InputReleaseTotalComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    discharge_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputReleaseTotalComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // discharge
      //
      if (n.name () == "discharge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeType > r (
          DischargeTraits::create (i, f, this));

        this->discharge_.push_back (r);
        continue;
      }

      break;
    }
  }

  InputReleaseTotalComplexType* InputReleaseTotalComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputReleaseTotalComplexType (*this, f, c);
  }

  InputReleaseTotalComplexType::
  ~InputReleaseTotalComplexType ()
  {
  }

  // EvaporationPotentialComplexType
  //

  EvaporationPotentialComplexType::
  EvaporationPotentialComplexType (const ParameterType& parameter,
                                   const InputType& input,
                                   const OutputType& output,
                                   const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EvaporationPotentialComplexType::
  EvaporationPotentialComplexType (::std::auto_ptr< ParameterType >& parameter,
                                   ::std::auto_ptr< InputType >& input,
                                   ::std::auto_ptr< OutputType >& output,
                                   const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EvaporationPotentialComplexType::
  EvaporationPotentialComplexType (const EvaporationPotentialComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  EvaporationPotentialComplexType::
  EvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EvaporationPotentialComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  EvaporationPotentialComplexType* EvaporationPotentialComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EvaporationPotentialComplexType (*this, f, c);
  }

  EvaporationPotentialComplexType::
  ~EvaporationPotentialComplexType ()
  {
  }

  // ParameterEvaporationPotentialComplexType
  //

  ParameterEvaporationPotentialComplexType::
  ParameterEvaporationPotentialComplexType (const ETFType& ETF)
  : ::xml_schema::Type (),
    ECORR_ (::xml_schema::Flags (), this),
    ETF_ (ETF, ::xml_schema::Flags (), this)
  {
  }

  ParameterEvaporationPotentialComplexType::
  ParameterEvaporationPotentialComplexType (const ParameterEvaporationPotentialComplexType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ECORR_ (x.ECORR_, f, this),
    ETF_ (x.ETF_, f, this)
  {
  }

  ParameterEvaporationPotentialComplexType::
  ParameterEvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ECORR_ (f, this),
    ETF_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterEvaporationPotentialComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ECORR
      //
      if (n.name () == "ECORR" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ECORRType > r (
          ECORRTraits::create (i, f, this));

        if (!this->ECORR_)
        {
          this->ECORR_.set (r);
          continue;
        }
      }

      // ETF
      //
      if (n.name () == "ETF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ETFType > r (
          ETFTraits::create (i, f, this));

        if (!ETF_.present ())
        {
          this->ETF_.set (r);
          continue;
        }
      }

      break;
    }

    if (!ETF_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ETF",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterEvaporationPotentialComplexType* ParameterEvaporationPotentialComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterEvaporationPotentialComplexType (*this, f, c);
  }

  ParameterEvaporationPotentialComplexType::
  ~ParameterEvaporationPotentialComplexType ()
  {
  }

  // InputEvaporationPotentialComplexType
  //

  const InputEvaporationPotentialComplexType::EPMType InputEvaporationPotentialComplexType::EPM_default_value_ (
    "EPM");

  const InputEvaporationPotentialComplexType::TMType InputEvaporationPotentialComplexType::TM_default_value_ (
    "TM");

  const InputEvaporationPotentialComplexType::TType InputEvaporationPotentialComplexType::T_default_value_ (
    "T");

  InputEvaporationPotentialComplexType::
  InputEvaporationPotentialComplexType (const EPMType& EPM,
                                        const TMType& TM,
                                        const TType& T)
  : ::xml_schema::Type (),
    EPM_ (EPM, ::xml_schema::Flags (), this),
    TM_ (TM, ::xml_schema::Flags (), this),
    T_ (T, ::xml_schema::Flags (), this)
  {
  }

  InputEvaporationPotentialComplexType::
  InputEvaporationPotentialComplexType (const InputEvaporationPotentialComplexType& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EPM_ (x.EPM_, f, this),
    TM_ (x.TM_, f, this),
    T_ (x.T_, f, this)
  {
  }

  InputEvaporationPotentialComplexType::
  InputEvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EPM_ (f, this),
    TM_ (f, this),
    T_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputEvaporationPotentialComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EPM
      //
      if (n.name () == "EPM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPMType > r (
          EPMTraits::create (i, f, this));

        if (!EPM_.present ())
        {
          this->EPM_.set (r);
          continue;
        }
      }

      // TM
      //
      if (n.name () == "TM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TMType > r (
          TMTraits::create (i, f, this));

        if (!TM_.present ())
        {
          this->TM_.set (r);
          continue;
        }
      }

      // T
      //
      if (n.name () == "T" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TType > r (
          TTraits::create (i, f, this));

        if (!T_.present ())
        {
          this->T_.set (r);
          continue;
        }
      }

      break;
    }

    if (!EPM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EPM",
        "http://www.wldelft.nl/fews");
    }

    if (!TM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TM",
        "http://www.wldelft.nl/fews");
    }

    if (!T_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "T",
        "http://www.wldelft.nl/fews");
    }
  }

  InputEvaporationPotentialComplexType* InputEvaporationPotentialComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputEvaporationPotentialComplexType (*this, f, c);
  }

  InputEvaporationPotentialComplexType::
  ~InputEvaporationPotentialComplexType ()
  {
  }

  // OutputEvaporationPotentialComplexType
  //

  const OutputEvaporationPotentialComplexType::EPType OutputEvaporationPotentialComplexType::EP_default_value_ (
    "EP");

  OutputEvaporationPotentialComplexType::
  OutputEvaporationPotentialComplexType (const EPType& EP)
  : ::xml_schema::Type (),
    EP_ (EP, ::xml_schema::Flags (), this)
  {
  }

  OutputEvaporationPotentialComplexType::
  OutputEvaporationPotentialComplexType (const OutputEvaporationPotentialComplexType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EP_ (x.EP_, f, this)
  {
  }

  OutputEvaporationPotentialComplexType::
  OutputEvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EP_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputEvaporationPotentialComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EP
      //
      if (n.name () == "EP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPType > r (
          EPTraits::create (i, f, this));

        if (!EP_.present ())
        {
          this->EP_.set (r);
          continue;
        }
      }

      break;
    }

    if (!EP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EP",
        "http://www.wldelft.nl/fews");
    }
  }

  OutputEvaporationPotentialComplexType* OutputEvaporationPotentialComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputEvaporationPotentialComplexType (*this, f, c);
  }

  OutputEvaporationPotentialComplexType::
  ~OutputEvaporationPotentialComplexType ()
  {
  }

  // TypicalProfileComplexType
  //

  TypicalProfileComplexType::
  TypicalProfileComplexType (const OutputType& output,
                             const IdType& id)
  : ::xml_schema::Type (),
    data_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  TypicalProfileComplexType::
  TypicalProfileComplexType (const TypicalProfileComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    data_ (x.data_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  TypicalProfileComplexType::
  TypicalProfileComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    data_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TypicalProfileComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // data
      //
      if (n.name () == "data" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DataType > r (
          DataTraits::create (i, f, this));

        this->data_.push_back (r);
        continue;
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TypicalProfileComplexType* TypicalProfileComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TypicalProfileComplexType (*this, f, c);
  }

  TypicalProfileComplexType::
  ~TypicalProfileComplexType ()
  {
  }

  // DataTypicalProfileComplexType
  //

  DataTypicalProfileComplexType::
  DataTypicalProfileComplexType (const MonthOfYearType& monthOfYear,
                                 const ValueType& value)
  : ::xml_schema::Type (),
    monthOfYear_ (monthOfYear, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  DataTypicalProfileComplexType::
  DataTypicalProfileComplexType (const DataTypicalProfileComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    monthOfYear_ (x.monthOfYear_, f, this),
    value_ (x.value_, f, this)
  {
  }

  DataTypicalProfileComplexType::
  DataTypicalProfileComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    monthOfYear_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void DataTypicalProfileComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "monthOfYear" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MonthOfYearType > r (
          MonthOfYearTraits::create (i, f, this));

        this->monthOfYear_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!monthOfYear_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "monthOfYear",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  DataTypicalProfileComplexType* DataTypicalProfileComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DataTypicalProfileComplexType (*this, f, c);
  }

  DataTypicalProfileComplexType::
  ~DataTypicalProfileComplexType ()
  {
  }

  // SnowRainJunctionComplexType
  //

  SnowRainJunctionComplexType::
  SnowRainJunctionComplexType (const ParameterType& parameter,
                               const InputType& input,
                               const OutputType& output,
                               const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SnowRainJunctionComplexType::
  SnowRainJunctionComplexType (::std::auto_ptr< ParameterType >& parameter,
                               ::std::auto_ptr< InputType >& input,
                               ::std::auto_ptr< OutputType >& output,
                               const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SnowRainJunctionComplexType::
  SnowRainJunctionComplexType (const SnowRainJunctionComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  SnowRainJunctionComplexType::
  SnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SnowRainJunctionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  SnowRainJunctionComplexType* SnowRainJunctionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SnowRainJunctionComplexType (*this, f, c);
  }

  SnowRainJunctionComplexType::
  ~SnowRainJunctionComplexType ()
  {
  }

  // ParameterSnowRainJunctionComplexType
  //

  ParameterSnowRainJunctionComplexType::
  ParameterSnowRainJunctionComplexType (const TTType& TT,
                                        const TTIType& TTI)
  : ::xml_schema::Type (),
    D_ (::xml_schema::Flags (), this),
    RFCF_ (::xml_schema::Flags (), this),
    SFCF_ (::xml_schema::Flags (), this),
    TT_ (TT, ::xml_schema::Flags (), this),
    TTI_ (TTI, ::xml_schema::Flags (), this)
  {
  }

  ParameterSnowRainJunctionComplexType::
  ParameterSnowRainJunctionComplexType (const ParameterSnowRainJunctionComplexType& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    D_ (x.D_, f, this),
    RFCF_ (x.RFCF_, f, this),
    SFCF_ (x.SFCF_, f, this),
    TT_ (x.TT_, f, this),
    TTI_ (x.TTI_, f, this)
  {
  }

  ParameterSnowRainJunctionComplexType::
  ParameterSnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    D_ (f, this),
    RFCF_ (f, this),
    SFCF_ (f, this),
    TT_ (f, this),
    TTI_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterSnowRainJunctionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!this->D_)
        {
          this->D_.set (r);
          continue;
        }
      }

      // RFCF
      //
      if (n.name () == "RFCF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RFCFType > r (
          RFCFTraits::create (i, f, this));

        if (!this->RFCF_)
        {
          this->RFCF_.set (r);
          continue;
        }
      }

      // SFCF
      //
      if (n.name () == "SFCF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SFCFType > r (
          SFCFTraits::create (i, f, this));

        if (!this->SFCF_)
        {
          this->SFCF_.set (r);
          continue;
        }
      }

      // TT
      //
      if (n.name () == "TT" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TTType > r (
          TTTraits::create (i, f, this));

        if (!TT_.present ())
        {
          this->TT_.set (r);
          continue;
        }
      }

      // TTI
      //
      if (n.name () == "TTI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TTIType > r (
          TTITraits::create (i, f, this));

        if (!TTI_.present ())
        {
          this->TTI_.set (r);
          continue;
        }
      }

      break;
    }

    if (!TT_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TT",
        "http://www.wldelft.nl/fews");
    }

    if (!TTI_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TTI",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterSnowRainJunctionComplexType* ParameterSnowRainJunctionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterSnowRainJunctionComplexType (*this, f, c);
  }

  ParameterSnowRainJunctionComplexType::
  ~ParameterSnowRainJunctionComplexType ()
  {
  }

  // InputSnowRainJunctionComplexType
  //

  const InputSnowRainJunctionComplexType::PType InputSnowRainJunctionComplexType::P_default_value_ (
    "P");

  const InputSnowRainJunctionComplexType::TType InputSnowRainJunctionComplexType::T_default_value_ (
    "T");

  InputSnowRainJunctionComplexType::
  InputSnowRainJunctionComplexType (const PType& P,
                                    const TType& T)
  : ::xml_schema::Type (),
    P_ (P, ::xml_schema::Flags (), this),
    T_ (T, ::xml_schema::Flags (), this)
  {
  }

  InputSnowRainJunctionComplexType::
  InputSnowRainJunctionComplexType (const InputSnowRainJunctionComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    P_ (x.P_, f, this),
    T_ (x.T_, f, this)
  {
  }

  InputSnowRainJunctionComplexType::
  InputSnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    P_ (f, this),
    T_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputSnowRainJunctionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PType > r (
          PTraits::create (i, f, this));

        if (!P_.present ())
        {
          this->P_.set (r);
          continue;
        }
      }

      // T
      //
      if (n.name () == "T" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TType > r (
          TTraits::create (i, f, this));

        if (!T_.present ())
        {
          this->T_.set (r);
          continue;
        }
      }

      break;
    }

    if (!P_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "P",
        "http://www.wldelft.nl/fews");
    }

    if (!T_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "T",
        "http://www.wldelft.nl/fews");
    }
  }

  InputSnowRainJunctionComplexType* InputSnowRainJunctionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputSnowRainJunctionComplexType (*this, f, c);
  }

  InputSnowRainJunctionComplexType::
  ~InputSnowRainJunctionComplexType ()
  {
  }

  // OutputSnowRainJunctionComplexType
  //

  const OutputSnowRainJunctionComplexType::RFType OutputSnowRainJunctionComplexType::RF_default_value_ (
    "RF");

  const OutputSnowRainJunctionComplexType::SFType OutputSnowRainJunctionComplexType::SF_default_value_ (
    "SF");

  OutputSnowRainJunctionComplexType::
  OutputSnowRainJunctionComplexType (const RFType& RF,
                                     const SFType& SF)
  : ::xml_schema::Type (),
    RF_ (RF, ::xml_schema::Flags (), this),
    SF_ (SF, ::xml_schema::Flags (), this)
  {
  }

  OutputSnowRainJunctionComplexType::
  OutputSnowRainJunctionComplexType (const OutputSnowRainJunctionComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    RF_ (x.RF_, f, this),
    SF_ (x.SF_, f, this)
  {
  }

  OutputSnowRainJunctionComplexType::
  OutputSnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    RF_ (f, this),
    SF_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputSnowRainJunctionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RF
      //
      if (n.name () == "RF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RFType > r (
          RFTraits::create (i, f, this));

        if (!RF_.present ())
        {
          this->RF_.set (r);
          continue;
        }
      }

      // SF
      //
      if (n.name () == "SF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SFType > r (
          SFTraits::create (i, f, this));

        if (!SF_.present ())
        {
          this->SF_.set (r);
          continue;
        }
      }

      break;
    }

    if (!RF_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RF",
        "http://www.wldelft.nl/fews");
    }

    if (!SF_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SF",
        "http://www.wldelft.nl/fews");
    }
  }

  OutputSnowRainJunctionComplexType* OutputSnowRainJunctionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputSnowRainJunctionComplexType (*this, f, c);
  }

  OutputSnowRainJunctionComplexType::
  ~OutputSnowRainJunctionComplexType ()
  {
  }

  // StorageSystemComplexType
  //

  StorageSystemComplexType::
  StorageSystemComplexType (const IdType& id)
  : ::xml_schema::Type (),
    settings_ (::xml_schema::Flags (), this),
    storageNode_ (::xml_schema::Flags (), this),
    link_ (::xml_schema::Flags (), this),
    output_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  StorageSystemComplexType::
  StorageSystemComplexType (const StorageSystemComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    settings_ (x.settings_, f, this),
    storageNode_ (x.storageNode_, f, this),
    link_ (x.link_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  StorageSystemComplexType::
  StorageSystemComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    settings_ (f, this),
    storageNode_ (f, this),
    link_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void StorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // settings
      //
      if (n.name () == "settings" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SettingsType > r (
          SettingsTraits::create (i, f, this));

        if (!this->settings_)
        {
          this->settings_.set (r);
          continue;
        }
      }

      // storageNode
      //
      if (n.name () == "storageNode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageNodeType > r (
          StorageNodeTraits::create (i, f, this));

        this->storageNode_.push_back (r);
        continue;
      }

      // link
      //
      if (n.name () == "link" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LinkType > r (
          LinkTraits::create (i, f, this));

        this->link_.push_back (r);
        continue;
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!this->output_)
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  StorageSystemComplexType* StorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StorageSystemComplexType (*this, f, c);
  }

  StorageSystemComplexType::
  ~StorageSystemComplexType ()
  {
  }

  // StorageSystemSettingsComplexType
  //

  StorageSystemSettingsComplexType::
  StorageSystemSettingsComplexType (const ConvergenceThresholdType& convergenceThreshold,
                                    const TreatNonConvergenceAsErrorType& treatNonConvergenceAsError)
  : ::xml_schema::Type (),
    convergenceThreshold_ (convergenceThreshold, ::xml_schema::Flags (), this),
    acceptableConvergenceThreshold_ (::xml_schema::Flags (), this),
    treatNonConvergenceAsError_ (treatNonConvergenceAsError, ::xml_schema::Flags (), this)
  {
  }

  StorageSystemSettingsComplexType::
  StorageSystemSettingsComplexType (const StorageSystemSettingsComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    convergenceThreshold_ (x.convergenceThreshold_, f, this),
    acceptableConvergenceThreshold_ (x.acceptableConvergenceThreshold_, f, this),
    treatNonConvergenceAsError_ (x.treatNonConvergenceAsError_, f, this)
  {
  }

  StorageSystemSettingsComplexType::
  StorageSystemSettingsComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    convergenceThreshold_ (f, this),
    acceptableConvergenceThreshold_ (f, this),
    treatNonConvergenceAsError_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void StorageSystemSettingsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // convergenceThreshold
      //
      if (n.name () == "convergenceThreshold" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!convergenceThreshold_.present ())
        {
          this->convergenceThreshold_.set (ConvergenceThresholdTraits::create (i, f, this));
          continue;
        }
      }

      // acceptableConvergenceThreshold
      //
      if (n.name () == "acceptableConvergenceThreshold" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->acceptableConvergenceThreshold_)
        {
          this->acceptableConvergenceThreshold_.set (AcceptableConvergenceThresholdTraits::create (i, f, this));
          continue;
        }
      }

      // treatNonConvergenceAsError
      //
      if (n.name () == "treatNonConvergenceAsError" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!treatNonConvergenceAsError_.present ())
        {
          this->treatNonConvergenceAsError_.set (TreatNonConvergenceAsErrorTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!convergenceThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "convergenceThreshold",
        "http://www.wldelft.nl/fews");
    }

    if (!treatNonConvergenceAsError_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treatNonConvergenceAsError",
        "http://www.wldelft.nl/fews");
    }
  }

  StorageSystemSettingsComplexType* StorageSystemSettingsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StorageSystemSettingsComplexType (*this, f, c);
  }

  StorageSystemSettingsComplexType::
  ~StorageSystemSettingsComplexType ()
  {
  }

  // OutputStorageSystemComplexType
  //

  OutputStorageSystemComplexType::
  OutputStorageSystemComplexType (const NJacType& nJac,
                                  const NFunType& nFun,
                                  const ResType& res)
  : ::xml_schema::Type (),
    nJac_ (nJac, ::xml_schema::Flags (), this),
    nFun_ (nFun, ::xml_schema::Flags (), this),
    res_ (res, ::xml_schema::Flags (), this)
  {
  }

  OutputStorageSystemComplexType::
  OutputStorageSystemComplexType (const OutputStorageSystemComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nJac_ (x.nJac_, f, this),
    nFun_ (x.nFun_, f, this),
    res_ (x.res_, f, this)
  {
  }

  OutputStorageSystemComplexType::
  OutputStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nJac_ (f, this),
    nFun_ (f, this),
    res_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nJac
      //
      if (n.name () == "nJac" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NJacType > r (
          NJacTraits::create (i, f, this));

        if (!nJac_.present ())
        {
          this->nJac_.set (r);
          continue;
        }
      }

      // nFun
      //
      if (n.name () == "nFun" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NFunType > r (
          NFunTraits::create (i, f, this));

        if (!nFun_.present ())
        {
          this->nFun_.set (r);
          continue;
        }
      }

      // res
      //
      if (n.name () == "res" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ResType > r (
          ResTraits::create (i, f, this));

        if (!res_.present ())
        {
          this->res_.set (r);
          continue;
        }
      }

      break;
    }

    if (!nJac_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nJac",
        "http://www.wldelft.nl/fews");
    }

    if (!nFun_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nFun",
        "http://www.wldelft.nl/fews");
    }

    if (!res_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "res",
        "http://www.wldelft.nl/fews");
    }
  }

  OutputStorageSystemComplexType* OutputStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputStorageSystemComplexType (*this, f, c);
  }

  OutputStorageSystemComplexType::
  ~OutputStorageSystemComplexType ()
  {
  }

  // NodeStorageSystemComplexType
  //

  NodeStorageSystemComplexType::
  NodeStorageSystemComplexType (const StateType& state,
                                const ResiduumType& residuum,
                                const IdType& id)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    stateMin_ (::xml_schema::Flags (), this),
    stateMax_ (::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    residuum_ (residuum, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  NodeStorageSystemComplexType::
  NodeStorageSystemComplexType (const NodeStorageSystemComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    stateMin_ (x.stateMin_, f, this),
    stateMax_ (x.stateMax_, f, this),
    input_ (x.input_, f, this),
    state_ (x.state_, f, this),
    residuum_ (x.residuum_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  NodeStorageSystemComplexType::
  NodeStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    stateMin_ (f, this),
    stateMax_ (f, this),
    input_ (f, this),
    state_ (f, this),
    residuum_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void NodeStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // stateMin
      //
      if (n.name () == "stateMin" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateMinType > r (
          StateMinTraits::create (i, f, this));

        if (!this->stateMin_)
        {
          this->stateMin_.set (r);
          continue;
        }
      }

      // stateMax
      //
      if (n.name () == "stateMax" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateMaxType > r (
          StateMaxTraits::create (i, f, this));

        if (!this->stateMax_)
        {
          this->stateMax_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!this->input_)
        {
          this->input_.set (r);
          continue;
        }
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!state_.present ())
        {
          this->state_.set (r);
          continue;
        }
      }

      // residuum
      //
      if (n.name () == "residuum" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ResiduumType > r (
          ResiduumTraits::create (i, f, this));

        if (!residuum_.present ())
        {
          this->residuum_.set (r);
          continue;
        }
      }

      break;
    }

    if (!state_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "state",
        "http://www.wldelft.nl/fews");
    }

    if (!residuum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "residuum",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  NodeStorageSystemComplexType* NodeStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NodeStorageSystemComplexType (*this, f, c);
  }

  NodeStorageSystemComplexType::
  ~NodeStorageSystemComplexType ()
  {
  }

  // InputNodeStorageSystemComplexType
  //

  InputNodeStorageSystemComplexType::
  InputNodeStorageSystemComplexType ()
  : ::xml_schema::Type (),
    discharge_ (::xml_schema::Flags (), this),
    unitVolume_ (::xml_schema::Flags (), this),
    state_ (::xml_schema::Flags (), this)
  {
  }

  InputNodeStorageSystemComplexType::
  InputNodeStorageSystemComplexType (const InputNodeStorageSystemComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    discharge_ (x.discharge_, f, this),
    unitVolume_ (x.unitVolume_, f, this),
    state_ (x.state_, f, this)
  {
  }

  InputNodeStorageSystemComplexType::
  InputNodeStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    discharge_ (f, this),
    unitVolume_ (f, this),
    state_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputNodeStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // discharge
      //
      if (n.name () == "discharge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeType > r (
          DischargeTraits::create (i, f, this));

        this->discharge_.push_back (r);
        continue;
      }

      // unitVolume
      //
      if (n.name () == "unitVolume" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitVolumeType > r (
          UnitVolumeTraits::create (i, f, this));

        this->unitVolume_.push_back (r);
        continue;
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!this->state_)
        {
          this->state_.set (r);
          continue;
        }
      }

      break;
    }
  }

  InputNodeStorageSystemComplexType* InputNodeStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputNodeStorageSystemComplexType (*this, f, c);
  }

  InputNodeStorageSystemComplexType::
  ~InputNodeStorageSystemComplexType ()
  {
  }

  // LinkStorageSystemComplexType
  //

  LinkStorageSystemComplexType::
  LinkStorageSystemComplexType ()
  : ::xml_schema::Type (),
    capillaryFlow_ (::xml_schema::Flags (), this),
    evaporationActual_ (::xml_schema::Flags (), this),
    evaporationInterception_ (::xml_schema::Flags (), this),
    groundwaterFlow_ (::xml_schema::Flags (), this),
    percolation_ (::xml_schema::Flags (), this),
    releaseInterception_ (::xml_schema::Flags (), this),
    response_ (::xml_schema::Flags (), this),
    sewerOverflow_ (::xml_schema::Flags (), this),
    soilRunoff_ (::xml_schema::Flags (), this),
    wasteWaterTreatmentPlant_ (::xml_schema::Flags (), this),
    waterDistributionConstant_ (::xml_schema::Flags (), this),
    waterDistributionVariable_ (::xml_schema::Flags (), this),
    meltRefreezing_ (::xml_schema::Flags (), this),
    releaseWaterContent_ (::xml_schema::Flags (), this),
    irrigation_ (::xml_schema::Flags (), this)
  {
  }

  LinkStorageSystemComplexType::
  LinkStorageSystemComplexType (const LinkStorageSystemComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    capillaryFlow_ (x.capillaryFlow_, f, this),
    evaporationActual_ (x.evaporationActual_, f, this),
    evaporationInterception_ (x.evaporationInterception_, f, this),
    groundwaterFlow_ (x.groundwaterFlow_, f, this),
    percolation_ (x.percolation_, f, this),
    releaseInterception_ (x.releaseInterception_, f, this),
    response_ (x.response_, f, this),
    sewerOverflow_ (x.sewerOverflow_, f, this),
    soilRunoff_ (x.soilRunoff_, f, this),
    wasteWaterTreatmentPlant_ (x.wasteWaterTreatmentPlant_, f, this),
    waterDistributionConstant_ (x.waterDistributionConstant_, f, this),
    waterDistributionVariable_ (x.waterDistributionVariable_, f, this),
    meltRefreezing_ (x.meltRefreezing_, f, this),
    releaseWaterContent_ (x.releaseWaterContent_, f, this),
    irrigation_ (x.irrigation_, f, this)
  {
  }

  LinkStorageSystemComplexType::
  LinkStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    capillaryFlow_ (f, this),
    evaporationActual_ (f, this),
    evaporationInterception_ (f, this),
    groundwaterFlow_ (f, this),
    percolation_ (f, this),
    releaseInterception_ (f, this),
    response_ (f, this),
    sewerOverflow_ (f, this),
    soilRunoff_ (f, this),
    wasteWaterTreatmentPlant_ (f, this),
    waterDistributionConstant_ (f, this),
    waterDistributionVariable_ (f, this),
    meltRefreezing_ (f, this),
    releaseWaterContent_ (f, this),
    irrigation_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LinkStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // capillaryFlow
      //
      if (n.name () == "capillaryFlow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapillaryFlowType > r (
          CapillaryFlowTraits::create (i, f, this));

        if (!this->capillaryFlow_)
        {
          this->capillaryFlow_.set (r);
          continue;
        }
      }

      // evaporationActual
      //
      if (n.name () == "evaporationActual" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EvaporationActualType > r (
          EvaporationActualTraits::create (i, f, this));

        if (!this->evaporationActual_)
        {
          this->evaporationActual_.set (r);
          continue;
        }
      }

      // evaporationInterception
      //
      if (n.name () == "evaporationInterception" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EvaporationInterceptionType > r (
          EvaporationInterceptionTraits::create (i, f, this));

        if (!this->evaporationInterception_)
        {
          this->evaporationInterception_.set (r);
          continue;
        }
      }

      // groundwaterFlow
      //
      if (n.name () == "groundwaterFlow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< GroundwaterFlowType > r (
          GroundwaterFlowTraits::create (i, f, this));

        if (!this->groundwaterFlow_)
        {
          this->groundwaterFlow_.set (r);
          continue;
        }
      }

      // percolation
      //
      if (n.name () == "percolation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PercolationType > r (
          PercolationTraits::create (i, f, this));

        if (!this->percolation_)
        {
          this->percolation_.set (r);
          continue;
        }
      }

      // releaseInterception
      //
      if (n.name () == "releaseInterception" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseInterceptionType > r (
          ReleaseInterceptionTraits::create (i, f, this));

        if (!this->releaseInterception_)
        {
          this->releaseInterception_.set (r);
          continue;
        }
      }

      // response
      //
      if (n.name () == "response" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ResponseType > r (
          ResponseTraits::create (i, f, this));

        if (!this->response_)
        {
          this->response_.set (r);
          continue;
        }
      }

      // sewerOverflow
      //
      if (n.name () == "sewerOverflow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SewerOverflowType > r (
          SewerOverflowTraits::create (i, f, this));

        if (!this->sewerOverflow_)
        {
          this->sewerOverflow_.set (r);
          continue;
        }
      }

      // soilRunoff
      //
      if (n.name () == "soilRunoff" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SoilRunoffType > r (
          SoilRunoffTraits::create (i, f, this));

        if (!this->soilRunoff_)
        {
          this->soilRunoff_.set (r);
          continue;
        }
      }

      // wasteWaterTreatmentPlant
      //
      if (n.name () == "wasteWaterTreatmentPlant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WasteWaterTreatmentPlantType > r (
          WasteWaterTreatmentPlantTraits::create (i, f, this));

        if (!this->wasteWaterTreatmentPlant_)
        {
          this->wasteWaterTreatmentPlant_.set (r);
          continue;
        }
      }

      // waterDistributionConstant
      //
      if (n.name () == "waterDistributionConstant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WaterDistributionConstantType > r (
          WaterDistributionConstantTraits::create (i, f, this));

        if (!this->waterDistributionConstant_)
        {
          this->waterDistributionConstant_.set (r);
          continue;
        }
      }

      // waterDistributionVariable
      //
      if (n.name () == "waterDistributionVariable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WaterDistributionVariableType > r (
          WaterDistributionVariableTraits::create (i, f, this));

        if (!this->waterDistributionVariable_)
        {
          this->waterDistributionVariable_.set (r);
          continue;
        }
      }

      // meltRefreezing
      //
      if (n.name () == "meltRefreezing" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MeltRefreezingType > r (
          MeltRefreezingTraits::create (i, f, this));

        if (!this->meltRefreezing_)
        {
          this->meltRefreezing_.set (r);
          continue;
        }
      }

      // releaseWaterContent
      //
      if (n.name () == "releaseWaterContent" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseWaterContentType > r (
          ReleaseWaterContentTraits::create (i, f, this));

        if (!this->releaseWaterContent_)
        {
          this->releaseWaterContent_.set (r);
          continue;
        }
      }

      // irrigation
      //
      if (n.name () == "irrigation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< IrrigationType > r (
          IrrigationTraits::create (i, f, this));

        if (!this->irrigation_)
        {
          this->irrigation_.set (r);
          continue;
        }
      }

      break;
    }
  }

  LinkStorageSystemComplexType* LinkStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LinkStorageSystemComplexType (*this, f, c);
  }

  LinkStorageSystemComplexType::
  ~LinkStorageSystemComplexType ()
  {
  }

  // OutputLinkStorageSystemComplexType
  //

  OutputLinkStorageSystemComplexType::
  OutputLinkStorageSystemComplexType (const HType& H,
                                      const QType& Q)
  : ::xml_schema::Type (),
    H_ (H, ::xml_schema::Flags (), this),
    Q_ (Q, ::xml_schema::Flags (), this)
  {
  }

  OutputLinkStorageSystemComplexType::
  OutputLinkStorageSystemComplexType (const OutputLinkStorageSystemComplexType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    H_ (x.H_, f, this),
    Q_ (x.Q_, f, this)
  {
  }

  OutputLinkStorageSystemComplexType::
  OutputLinkStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    H_ (f, this),
    Q_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputLinkStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // H
      //
      if (n.name () == "H" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HType > r (
          HTraits::create (i, f, this));

        if (!H_.present ())
        {
          this->H_.set (r);
          continue;
        }
      }

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      break;
    }

    if (!H_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "H",
        "http://www.wldelft.nl/fews");
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  OutputLinkStorageSystemComplexType* OutputLinkStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputLinkStorageSystemComplexType (*this, f, c);
  }

  OutputLinkStorageSystemComplexType::
  ~OutputLinkStorageSystemComplexType ()
  {
  }

  // MeltRefreezingStorageSystemComplexType
  //

  MeltRefreezingStorageSystemComplexType::
  MeltRefreezingStorageSystemComplexType (const ParameterType& parameter,
                                          const NodeUType& nodeU,
                                          const NodeDType& nodeD,
                                          const InputType& input,
                                          const OutputType& output,
                                          const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    nodeU_ (nodeU, ::xml_schema::Flags (), this),
    nodeD_ (nodeD, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MeltRefreezingStorageSystemComplexType::
  MeltRefreezingStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                          const NodeUType& nodeU,
                                          const NodeDType& nodeD,
                                          const InputType& input,
                                          ::std::auto_ptr< OutputType >& output,
                                          const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    nodeU_ (nodeU, ::xml_schema::Flags (), this),
    nodeD_ (nodeD, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MeltRefreezingStorageSystemComplexType::
  MeltRefreezingStorageSystemComplexType (const MeltRefreezingStorageSystemComplexType& x,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    nodeU_ (x.nodeU_, f, this),
    nodeD_ (x.nodeD_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  MeltRefreezingStorageSystemComplexType::
  MeltRefreezingStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    nodeU_ (f, this),
    nodeD_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void MeltRefreezingStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // nodeU
      //
      if (n.name () == "nodeU" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeUType > r (
          NodeUTraits::create (i, f, this));

        if (!nodeU_.present ())
        {
          this->nodeU_.set (r);
          continue;
        }
      }

      // nodeD
      //
      if (n.name () == "nodeD" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeDType > r (
          NodeDTraits::create (i, f, this));

        if (!nodeD_.present ())
        {
          this->nodeD_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeU_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeU",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeD_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeD",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  MeltRefreezingStorageSystemComplexType* MeltRefreezingStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MeltRefreezingStorageSystemComplexType (*this, f, c);
  }

  MeltRefreezingStorageSystemComplexType::
  ~MeltRefreezingStorageSystemComplexType ()
  {
  }

  // ParameterMeltRefreezingStorageSystemComplexType
  //

  ParameterMeltRefreezingStorageSystemComplexType::
  ParameterMeltRefreezingStorageSystemComplexType (const CFMAXType& CFMAX,
                                                   const CFRType& CFR,
                                                   const TTMType& TTM)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    CFMAX_ (CFMAX, ::xml_schema::Flags (), this),
    CFR_ (CFR, ::xml_schema::Flags (), this),
    M_ (::xml_schema::Flags (), this),
    TTM_ (TTM, ::xml_schema::Flags (), this)
  {
  }

  ParameterMeltRefreezingStorageSystemComplexType::
  ParameterMeltRefreezingStorageSystemComplexType (const ParameterMeltRefreezingStorageSystemComplexType& x,
                                                   ::xml_schema::Flags f,
                                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    CFMAX_ (x.CFMAX_, f, this),
    CFR_ (x.CFR_, f, this),
    M_ (x.M_, f, this),
    TTM_ (x.TTM_, f, this)
  {
  }

  ParameterMeltRefreezingStorageSystemComplexType::
  ParameterMeltRefreezingStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::Flags f,
                                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    CFMAX_ (f, this),
    CFR_ (f, this),
    M_ (f, this),
    TTM_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterMeltRefreezingStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // CFMAX
      //
      if (n.name () == "CFMAX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFMAXType > r (
          CFMAXTraits::create (i, f, this));

        if (!CFMAX_.present ())
        {
          this->CFMAX_.set (r);
          continue;
        }
      }

      // CFR
      //
      if (n.name () == "CFR" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFRType > r (
          CFRTraits::create (i, f, this));

        if (!CFR_.present ())
        {
          this->CFR_.set (r);
          continue;
        }
      }

      // M
      //
      if (n.name () == "M" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MType > r (
          MTraits::create (i, f, this));

        if (!this->M_)
        {
          this->M_.set (r);
          continue;
        }
      }

      // TTM
      //
      if (n.name () == "TTM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TTMType > r (
          TTMTraits::create (i, f, this));

        if (!TTM_.present ())
        {
          this->TTM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!CFMAX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFMAX",
        "http://www.wldelft.nl/fews");
    }

    if (!CFR_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFR",
        "http://www.wldelft.nl/fews");
    }

    if (!TTM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TTM",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterMeltRefreezingStorageSystemComplexType* ParameterMeltRefreezingStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterMeltRefreezingStorageSystemComplexType (*this, f, c);
  }

  ParameterMeltRefreezingStorageSystemComplexType::
  ~ParameterMeltRefreezingStorageSystemComplexType ()
  {
  }

  // ReleaseWaterContentStorageSystemComplexType
  //

  ReleaseWaterContentStorageSystemComplexType::
  ReleaseWaterContentStorageSystemComplexType (const ParameterType& parameter,
                                               const NodeUType& nodeU,
                                               const NodeAType& nodeA,
                                               const OutputType& output,
                                               const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    nodeU_ (nodeU, ::xml_schema::Flags (), this),
    nodeA_ (nodeA, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReleaseWaterContentStorageSystemComplexType::
  ReleaseWaterContentStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                               const NodeUType& nodeU,
                                               const NodeAType& nodeA,
                                               ::std::auto_ptr< OutputType >& output,
                                               const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    nodeU_ (nodeU, ::xml_schema::Flags (), this),
    nodeA_ (nodeA, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReleaseWaterContentStorageSystemComplexType::
  ReleaseWaterContentStorageSystemComplexType (const ReleaseWaterContentStorageSystemComplexType& x,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    nodeU_ (x.nodeU_, f, this),
    nodeA_ (x.nodeA_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ReleaseWaterContentStorageSystemComplexType::
  ReleaseWaterContentStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    nodeU_ (f, this),
    nodeA_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ReleaseWaterContentStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // nodeU
      //
      if (n.name () == "nodeU" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeUType > r (
          NodeUTraits::create (i, f, this));

        if (!nodeU_.present ())
        {
          this->nodeU_.set (r);
          continue;
        }
      }

      // nodeA
      //
      if (n.name () == "nodeA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeAType > r (
          NodeATraits::create (i, f, this));

        if (!nodeA_.present ())
        {
          this->nodeA_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeU_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeU",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeA",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ReleaseWaterContentStorageSystemComplexType* ReleaseWaterContentStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReleaseWaterContentStorageSystemComplexType (*this, f, c);
  }

  ReleaseWaterContentStorageSystemComplexType::
  ~ReleaseWaterContentStorageSystemComplexType ()
  {
  }

  // ParameterReleaseWaterContentStorageSystemComplexType
  //

  ParameterReleaseWaterContentStorageSystemComplexType::
  ParameterReleaseWaterContentStorageSystemComplexType (const WHCType& WHC)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    WHC_ (WHC, ::xml_schema::Flags (), this),
    M_ (::xml_schema::Flags (), this)
  {
  }

  ParameterReleaseWaterContentStorageSystemComplexType::
  ParameterReleaseWaterContentStorageSystemComplexType (const ParameterReleaseWaterContentStorageSystemComplexType& x,
                                                        ::xml_schema::Flags f,
                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    WHC_ (x.WHC_, f, this),
    M_ (x.M_, f, this)
  {
  }

  ParameterReleaseWaterContentStorageSystemComplexType::
  ParameterReleaseWaterContentStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::Flags f,
                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    WHC_ (f, this),
    M_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterReleaseWaterContentStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // WHC
      //
      if (n.name () == "WHC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WHCType > r (
          WHCTraits::create (i, f, this));

        if (!WHC_.present ())
        {
          this->WHC_.set (r);
          continue;
        }
      }

      // M
      //
      if (n.name () == "M" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MType > r (
          MTraits::create (i, f, this));

        if (!this->M_)
        {
          this->M_.set (r);
          continue;
        }
      }

      break;
    }

    if (!WHC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "WHC",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterReleaseWaterContentStorageSystemComplexType* ParameterReleaseWaterContentStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterReleaseWaterContentStorageSystemComplexType (*this, f, c);
  }

  ParameterReleaseWaterContentStorageSystemComplexType::
  ~ParameterReleaseWaterContentStorageSystemComplexType ()
  {
  }

  // EvaporationInterceptionStorageSystemComplexType
  //

  EvaporationInterceptionStorageSystemComplexType::
  EvaporationInterceptionStorageSystemComplexType (const ParameterType& parameter,
                                                   const InputType& input,
                                                   const OutputType& output,
                                                   const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EvaporationInterceptionStorageSystemComplexType::
  EvaporationInterceptionStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                                   ::std::auto_ptr< InputType >& input,
                                                   ::std::auto_ptr< OutputType >& output,
                                                   const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EvaporationInterceptionStorageSystemComplexType::
  EvaporationInterceptionStorageSystemComplexType (const EvaporationInterceptionStorageSystemComplexType& x,
                                                   ::xml_schema::Flags f,
                                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  EvaporationInterceptionStorageSystemComplexType::
  EvaporationInterceptionStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::Flags f,
                                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EvaporationInterceptionStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  EvaporationInterceptionStorageSystemComplexType* EvaporationInterceptionStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EvaporationInterceptionStorageSystemComplexType (*this, f, c);
  }

  EvaporationInterceptionStorageSystemComplexType::
  ~EvaporationInterceptionStorageSystemComplexType ()
  {
  }

  // InputEvaporationInterceptionStorageSystemComplexType
  //

  InputEvaporationInterceptionStorageSystemComplexType::
  InputEvaporationInterceptionStorageSystemComplexType (const HUpType& HUp,
                                                        const EPType& EP)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    EP_ (EP, ::xml_schema::Flags (), this)
  {
  }

  InputEvaporationInterceptionStorageSystemComplexType::
  InputEvaporationInterceptionStorageSystemComplexType (const InputEvaporationInterceptionStorageSystemComplexType& x,
                                                        ::xml_schema::Flags f,
                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    EP_ (x.EP_, f, this)
  {
  }

  InputEvaporationInterceptionStorageSystemComplexType::
  InputEvaporationInterceptionStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::Flags f,
                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    EP_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputEvaporationInterceptionStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // EP
      //
      if (n.name () == "EP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPType > r (
          EPTraits::create (i, f, this));

        if (!EP_.present ())
        {
          this->EP_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!EP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EP",
        "http://www.wldelft.nl/fews");
    }
  }

  InputEvaporationInterceptionStorageSystemComplexType* InputEvaporationInterceptionStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputEvaporationInterceptionStorageSystemComplexType (*this, f, c);
  }

  InputEvaporationInterceptionStorageSystemComplexType::
  ~InputEvaporationInterceptionStorageSystemComplexType ()
  {
  }

  // ParameterEvaporationInterceptionStorageSystemComplexType
  //

  ParameterEvaporationInterceptionStorageSystemComplexType::
  ParameterEvaporationInterceptionStorageSystemComplexType ()
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this)
  {
  }

  ParameterEvaporationInterceptionStorageSystemComplexType::
  ParameterEvaporationInterceptionStorageSystemComplexType (const ParameterEvaporationInterceptionStorageSystemComplexType& x,
                                                            ::xml_schema::Flags f,
                                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this)
  {
  }

  ParameterEvaporationInterceptionStorageSystemComplexType::
  ParameterEvaporationInterceptionStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::Flags f,
                                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterEvaporationInterceptionStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      break;
    }
  }

  ParameterEvaporationInterceptionStorageSystemComplexType* ParameterEvaporationInterceptionStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterEvaporationInterceptionStorageSystemComplexType (*this, f, c);
  }

  ParameterEvaporationInterceptionStorageSystemComplexType::
  ~ParameterEvaporationInterceptionStorageSystemComplexType ()
  {
  }

  // ReleaseAboveThresholdStorageSystemComplexType
  //

  ReleaseAboveThresholdStorageSystemComplexType::
  ReleaseAboveThresholdStorageSystemComplexType (const ParameterType& parameter,
                                                 const InputType& input,
                                                 const OutputType& output,
                                                 const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReleaseAboveThresholdStorageSystemComplexType::
  ReleaseAboveThresholdStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                                 ::std::auto_ptr< InputType >& input,
                                                 ::std::auto_ptr< OutputType >& output,
                                                 const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReleaseAboveThresholdStorageSystemComplexType::
  ReleaseAboveThresholdStorageSystemComplexType (const ReleaseAboveThresholdStorageSystemComplexType& x,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ReleaseAboveThresholdStorageSystemComplexType::
  ReleaseAboveThresholdStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ReleaseAboveThresholdStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ReleaseAboveThresholdStorageSystemComplexType* ReleaseAboveThresholdStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReleaseAboveThresholdStorageSystemComplexType (*this, f, c);
  }

  ReleaseAboveThresholdStorageSystemComplexType::
  ~ReleaseAboveThresholdStorageSystemComplexType ()
  {
  }

  // ParameterReleaseAboveThresholdStorageSystemComplexType
  //

  const ParameterReleaseAboveThresholdStorageSystemComplexType::FRACType ParameterReleaseAboveThresholdStorageSystemComplexType::FRAC_default_value_ (
    "100.0");

  ParameterReleaseAboveThresholdStorageSystemComplexType::
  ParameterReleaseAboveThresholdStorageSystemComplexType (const LICType& LIC)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    FRAC_ (::xml_schema::Flags (), this),
    LIC_ (LIC, ::xml_schema::Flags (), this),
    M_ (::xml_schema::Flags (), this)
  {
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::
  ParameterReleaseAboveThresholdStorageSystemComplexType (const ParameterReleaseAboveThresholdStorageSystemComplexType& x,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    FRAC_ (x.FRAC_, f, this),
    LIC_ (x.LIC_, f, this),
    M_ (x.M_, f, this)
  {
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::
  ParameterReleaseAboveThresholdStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    FRAC_ (f, this),
    LIC_ (f, this),
    M_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterReleaseAboveThresholdStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // FRAC
      //
      if (n.name () == "FRAC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FRACType > r (
          FRACTraits::create (i, f, this));

        if (!this->FRAC_)
        {
          this->FRAC_.set (r);
          continue;
        }
      }

      // LIC
      //
      if (n.name () == "LIC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LICType > r (
          LICTraits::create (i, f, this));

        if (!LIC_.present ())
        {
          this->LIC_.set (r);
          continue;
        }
      }

      // M
      //
      if (n.name () == "M" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MType > r (
          MTraits::create (i, f, this));

        if (!this->M_)
        {
          this->M_.set (r);
          continue;
        }
      }

      break;
    }

    if (!LIC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LIC",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType* ParameterReleaseAboveThresholdStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterReleaseAboveThresholdStorageSystemComplexType (*this, f, c);
  }

  ParameterReleaseAboveThresholdStorageSystemComplexType::
  ~ParameterReleaseAboveThresholdStorageSystemComplexType ()
  {
  }

  // InputReleaseAboveThresholdStorageSystemComplexType
  //

  InputReleaseAboveThresholdStorageSystemComplexType::
  InputReleaseAboveThresholdStorageSystemComplexType (const HUpType& HUp)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (::xml_schema::Flags (), this)
  {
  }

  InputReleaseAboveThresholdStorageSystemComplexType::
  InputReleaseAboveThresholdStorageSystemComplexType (const InputReleaseAboveThresholdStorageSystemComplexType& x,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this)
  {
  }

  InputReleaseAboveThresholdStorageSystemComplexType::
  InputReleaseAboveThresholdStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputReleaseAboveThresholdStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!this->HDown_)
        {
          this->HDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }
  }

  InputReleaseAboveThresholdStorageSystemComplexType* InputReleaseAboveThresholdStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputReleaseAboveThresholdStorageSystemComplexType (*this, f, c);
  }

  InputReleaseAboveThresholdStorageSystemComplexType::
  ~InputReleaseAboveThresholdStorageSystemComplexType ()
  {
  }

  // IrrigationStorageSystemComplexType
  //

  IrrigationStorageSystemComplexType::
  IrrigationStorageSystemComplexType (const ParameterType& parameter,
                                      const NodeUType& nodeU,
                                      const NodeDType& nodeD,
                                      const OutputType& output,
                                      const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    nodeU_ (nodeU, ::xml_schema::Flags (), this),
    nodeD_ (nodeD, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  IrrigationStorageSystemComplexType::
  IrrigationStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                      const NodeUType& nodeU,
                                      const NodeDType& nodeD,
                                      ::std::auto_ptr< OutputType >& output,
                                      const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    nodeU_ (nodeU, ::xml_schema::Flags (), this),
    nodeD_ (nodeD, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  IrrigationStorageSystemComplexType::
  IrrigationStorageSystemComplexType (const IrrigationStorageSystemComplexType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    nodeU_ (x.nodeU_, f, this),
    nodeD_ (x.nodeD_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  IrrigationStorageSystemComplexType::
  IrrigationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    nodeU_ (f, this),
    nodeD_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void IrrigationStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // nodeU
      //
      if (n.name () == "nodeU" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeUType > r (
          NodeUTraits::create (i, f, this));

        if (!nodeU_.present ())
        {
          this->nodeU_.set (r);
          continue;
        }
      }

      // nodeD
      //
      if (n.name () == "nodeD" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeDType > r (
          NodeDTraits::create (i, f, this));

        if (!nodeD_.present ())
        {
          this->nodeD_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeU_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeU",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeD_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeD",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  IrrigationStorageSystemComplexType* IrrigationStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IrrigationStorageSystemComplexType (*this, f, c);
  }

  IrrigationStorageSystemComplexType::
  ~IrrigationStorageSystemComplexType ()
  {
  }

  // ParameterIrrigationStorageSystemComplexType
  //

  ParameterIrrigationStorageSystemComplexType::
  ParameterIrrigationStorageSystemComplexType (const IRR_THRType& IRR_THR)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    IRR_CONST_ (::xml_schema::Flags (), this),
    IRR_THR_ (IRR_THR, ::xml_schema::Flags (), this),
    M_ (::xml_schema::Flags (), this)
  {
  }

  ParameterIrrigationStorageSystemComplexType::
  ParameterIrrigationStorageSystemComplexType (const ParameterIrrigationStorageSystemComplexType& x,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    IRR_CONST_ (x.IRR_CONST_, f, this),
    IRR_THR_ (x.IRR_THR_, f, this),
    M_ (x.M_, f, this)
  {
  }

  ParameterIrrigationStorageSystemComplexType::
  ParameterIrrigationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    IRR_CONST_ (f, this),
    IRR_THR_ (f, this),
    M_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterIrrigationStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // IRR_CONST
      //
      if (n.name () == "IRR_CONST" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< IRR_CONSTType > r (
          IRR_CONSTTraits::create (i, f, this));

        if (!this->IRR_CONST_)
        {
          this->IRR_CONST_.set (r);
          continue;
        }
      }

      // IRR_THR
      //
      if (n.name () == "IRR_THR" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< IRR_THRType > r (
          IRR_THRTraits::create (i, f, this));

        if (!IRR_THR_.present ())
        {
          this->IRR_THR_.set (r);
          continue;
        }
      }

      // M
      //
      if (n.name () == "M" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MType > r (
          MTraits::create (i, f, this));

        if (!this->M_)
        {
          this->M_.set (r);
          continue;
        }
      }

      break;
    }

    if (!IRR_THR_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IRR_THR",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterIrrigationStorageSystemComplexType* ParameterIrrigationStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterIrrigationStorageSystemComplexType (*this, f, c);
  }

  ParameterIrrigationStorageSystemComplexType::
  ~ParameterIrrigationStorageSystemComplexType ()
  {
  }

  // WaterDistributionConstantStorageSystemComplexType
  //

  WaterDistributionConstantStorageSystemComplexType::
  WaterDistributionConstantStorageSystemComplexType (const ParameterType& parameter,
                                                     const InputType& input,
                                                     const OutputType& output,
                                                     const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  WaterDistributionConstantStorageSystemComplexType::
  WaterDistributionConstantStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                                     ::std::auto_ptr< InputType >& input,
                                                     ::std::auto_ptr< OutputType >& output,
                                                     const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  WaterDistributionConstantStorageSystemComplexType::
  WaterDistributionConstantStorageSystemComplexType (const WaterDistributionConstantStorageSystemComplexType& x,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  WaterDistributionConstantStorageSystemComplexType::
  WaterDistributionConstantStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void WaterDistributionConstantStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  WaterDistributionConstantStorageSystemComplexType* WaterDistributionConstantStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WaterDistributionConstantStorageSystemComplexType (*this, f, c);
  }

  WaterDistributionConstantStorageSystemComplexType::
  ~WaterDistributionConstantStorageSystemComplexType ()
  {
  }

  // ParameterWaterDistributionConstantStorageSystemComplexType
  //

  ParameterWaterDistributionConstantStorageSystemComplexType::
  ParameterWaterDistributionConstantStorageSystemComplexType (const DType& D)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    D_ (D, ::xml_schema::Flags (), this),
    MIN_UP_ (::xml_schema::Flags (), this),
    M_ (::xml_schema::Flags (), this)
  {
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::
  ParameterWaterDistributionConstantStorageSystemComplexType (const ParameterWaterDistributionConstantStorageSystemComplexType& x,
                                                              ::xml_schema::Flags f,
                                                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    D_ (x.D_, f, this),
    MIN_UP_ (x.MIN_UP_, f, this),
    M_ (x.M_, f, this)
  {
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::
  ParameterWaterDistributionConstantStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::Flags f,
                                                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    D_ (f, this),
    MIN_UP_ (f, this),
    M_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterWaterDistributionConstantStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!D_.present ())
        {
          this->D_.set (r);
          continue;
        }
      }

      // MIN_UP
      //
      if (n.name () == "MIN_UP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MIN_UPType > r (
          MIN_UPTraits::create (i, f, this));

        if (!this->MIN_UP_)
        {
          this->MIN_UP_.set (r);
          continue;
        }
      }

      // M
      //
      if (n.name () == "M" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MType > r (
          MTraits::create (i, f, this));

        if (!this->M_)
        {
          this->M_.set (r);
          continue;
        }
      }

      break;
    }

    if (!D_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "D",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterWaterDistributionConstantStorageSystemComplexType* ParameterWaterDistributionConstantStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterWaterDistributionConstantStorageSystemComplexType (*this, f, c);
  }

  ParameterWaterDistributionConstantStorageSystemComplexType::
  ~ParameterWaterDistributionConstantStorageSystemComplexType ()
  {
  }

  // InputWaterDistributionConstantStorageSystemComplexType
  //

  InputWaterDistributionConstantStorageSystemComplexType::
  InputWaterDistributionConstantStorageSystemComplexType (const HUpType& HUp)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (::xml_schema::Flags (), this)
  {
  }

  InputWaterDistributionConstantStorageSystemComplexType::
  InputWaterDistributionConstantStorageSystemComplexType (const InputWaterDistributionConstantStorageSystemComplexType& x,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this)
  {
  }

  InputWaterDistributionConstantStorageSystemComplexType::
  InputWaterDistributionConstantStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputWaterDistributionConstantStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!this->HDown_)
        {
          this->HDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }
  }

  InputWaterDistributionConstantStorageSystemComplexType* InputWaterDistributionConstantStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputWaterDistributionConstantStorageSystemComplexType (*this, f, c);
  }

  InputWaterDistributionConstantStorageSystemComplexType::
  ~InputWaterDistributionConstantStorageSystemComplexType ()
  {
  }

  // WaterDistributionVariableStorageSystemComplexType
  //

  WaterDistributionVariableStorageSystemComplexType::
  WaterDistributionVariableStorageSystemComplexType (const ParameterType& parameter,
                                                     const InputType& input,
                                                     const OutputType& output,
                                                     const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  WaterDistributionVariableStorageSystemComplexType::
  WaterDistributionVariableStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                                     ::std::auto_ptr< InputType >& input,
                                                     ::std::auto_ptr< OutputType >& output,
                                                     const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  WaterDistributionVariableStorageSystemComplexType::
  WaterDistributionVariableStorageSystemComplexType (const WaterDistributionVariableStorageSystemComplexType& x,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  WaterDistributionVariableStorageSystemComplexType::
  WaterDistributionVariableStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void WaterDistributionVariableStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  WaterDistributionVariableStorageSystemComplexType* WaterDistributionVariableStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WaterDistributionVariableStorageSystemComplexType (*this, f, c);
  }

  WaterDistributionVariableStorageSystemComplexType::
  ~WaterDistributionVariableStorageSystemComplexType ()
  {
  }

  // ParameterWaterDistributionVariableStorageSystemComplexType
  //

  ParameterWaterDistributionVariableStorageSystemComplexType::
  ParameterWaterDistributionVariableStorageSystemComplexType ()
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    MIN_UP_ (::xml_schema::Flags (), this),
    M_ (::xml_schema::Flags (), this)
  {
  }

  ParameterWaterDistributionVariableStorageSystemComplexType::
  ParameterWaterDistributionVariableStorageSystemComplexType (const ParameterWaterDistributionVariableStorageSystemComplexType& x,
                                                              ::xml_schema::Flags f,
                                                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    MIN_UP_ (x.MIN_UP_, f, this),
    M_ (x.M_, f, this)
  {
  }

  ParameterWaterDistributionVariableStorageSystemComplexType::
  ParameterWaterDistributionVariableStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::Flags f,
                                                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    MIN_UP_ (f, this),
    M_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterWaterDistributionVariableStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // MIN_UP
      //
      if (n.name () == "MIN_UP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MIN_UPType > r (
          MIN_UPTraits::create (i, f, this));

        if (!this->MIN_UP_)
        {
          this->MIN_UP_.set (r);
          continue;
        }
      }

      // M
      //
      if (n.name () == "M" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MType > r (
          MTraits::create (i, f, this));

        if (!this->M_)
        {
          this->M_.set (r);
          continue;
        }
      }

      break;
    }
  }

  ParameterWaterDistributionVariableStorageSystemComplexType* ParameterWaterDistributionVariableStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterWaterDistributionVariableStorageSystemComplexType (*this, f, c);
  }

  ParameterWaterDistributionVariableStorageSystemComplexType::
  ~ParameterWaterDistributionVariableStorageSystemComplexType ()
  {
  }

  // InputWaterDistributionVariableStorageSystemComplexType
  //

  InputWaterDistributionVariableStorageSystemComplexType::
  InputWaterDistributionVariableStorageSystemComplexType (const HUpType& HUp,
                                                          const DType& D)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (::xml_schema::Flags (), this),
    D_ (D, ::xml_schema::Flags (), this)
  {
  }

  InputWaterDistributionVariableStorageSystemComplexType::
  InputWaterDistributionVariableStorageSystemComplexType (const InputWaterDistributionVariableStorageSystemComplexType& x,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this),
    D_ (x.D_, f, this)
  {
  }

  InputWaterDistributionVariableStorageSystemComplexType::
  InputWaterDistributionVariableStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this),
    D_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputWaterDistributionVariableStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!this->HDown_)
        {
          this->HDown_.set (r);
          continue;
        }
      }

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!D_.present ())
        {
          this->D_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!D_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "D",
        "http://www.wldelft.nl/fews");
    }
  }

  InputWaterDistributionVariableStorageSystemComplexType* InputWaterDistributionVariableStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputWaterDistributionVariableStorageSystemComplexType (*this, f, c);
  }

  InputWaterDistributionVariableStorageSystemComplexType::
  ~InputWaterDistributionVariableStorageSystemComplexType ()
  {
  }

  // GroundwaterFlowStorageSystemComplexType
  //

  GroundwaterFlowStorageSystemComplexType::
  GroundwaterFlowStorageSystemComplexType (const ParameterType& parameter,
                                           const InputType& input,
                                           const OutputType& output,
                                           const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  GroundwaterFlowStorageSystemComplexType::
  GroundwaterFlowStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                           ::std::auto_ptr< InputType >& input,
                                           ::std::auto_ptr< OutputType >& output,
                                           const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  GroundwaterFlowStorageSystemComplexType::
  GroundwaterFlowStorageSystemComplexType (const GroundwaterFlowStorageSystemComplexType& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  GroundwaterFlowStorageSystemComplexType::
  GroundwaterFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void GroundwaterFlowStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  GroundwaterFlowStorageSystemComplexType* GroundwaterFlowStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GroundwaterFlowStorageSystemComplexType (*this, f, c);
  }

  GroundwaterFlowStorageSystemComplexType::
  ~GroundwaterFlowStorageSystemComplexType ()
  {
  }

  // InputGroundwaterFlowStorageSystemComplexType
  //

  InputGroundwaterFlowStorageSystemComplexType::
  InputGroundwaterFlowStorageSystemComplexType (const HUpType& HUp,
                                                const HDownType& HDown)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (HDown, ::xml_schema::Flags (), this)
  {
  }

  InputGroundwaterFlowStorageSystemComplexType::
  InputGroundwaterFlowStorageSystemComplexType (const InputGroundwaterFlowStorageSystemComplexType& x,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this)
  {
  }

  InputGroundwaterFlowStorageSystemComplexType::
  InputGroundwaterFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputGroundwaterFlowStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!HDown_.present ())
        {
          this->HDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!HDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HDown",
        "http://www.wldelft.nl/fews");
    }
  }

  InputGroundwaterFlowStorageSystemComplexType* InputGroundwaterFlowStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputGroundwaterFlowStorageSystemComplexType (*this, f, c);
  }

  InputGroundwaterFlowStorageSystemComplexType::
  ~InputGroundwaterFlowStorageSystemComplexType ()
  {
  }

  // ParametergroundwaterFlowStorageSystemComplexType
  //

  ParametergroundwaterFlowStorageSystemComplexType::
  ParametergroundwaterFlowStorageSystemComplexType (const ALPHAType& ALPHA,
                                                    const KType& K,
                                                    const MAX_GFLOWType& MAX_GFLOW)
  : ::xml_schema::Type (),
    ALPHA_ (ALPHA, ::xml_schema::Flags (), this),
    AREA_ (::xml_schema::Flags (), this),
    K_ (K, ::xml_schema::Flags (), this),
    MAX_GFLOW_ (MAX_GFLOW, ::xml_schema::Flags (), this)
  {
  }

  ParametergroundwaterFlowStorageSystemComplexType::
  ParametergroundwaterFlowStorageSystemComplexType (const ParametergroundwaterFlowStorageSystemComplexType& x,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ALPHA_ (x.ALPHA_, f, this),
    AREA_ (x.AREA_, f, this),
    K_ (x.K_, f, this),
    MAX_GFLOW_ (x.MAX_GFLOW_, f, this)
  {
  }

  ParametergroundwaterFlowStorageSystemComplexType::
  ParametergroundwaterFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ALPHA_ (f, this),
    AREA_ (f, this),
    K_ (f, this),
    MAX_GFLOW_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParametergroundwaterFlowStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ALPHA
      //
      if (n.name () == "ALPHA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ALPHAType > r (
          ALPHATraits::create (i, f, this));

        if (!ALPHA_.present ())
        {
          this->ALPHA_.set (r);
          continue;
        }
      }

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // K
      //
      if (n.name () == "K" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< KType > r (
          KTraits::create (i, f, this));

        if (!K_.present ())
        {
          this->K_.set (r);
          continue;
        }
      }

      // MAX_GFLOW
      //
      if (n.name () == "MAX_GFLOW" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MAX_GFLOWType > r (
          MAX_GFLOWTraits::create (i, f, this));

        if (!MAX_GFLOW_.present ())
        {
          this->MAX_GFLOW_.set (r);
          continue;
        }
      }

      break;
    }

    if (!ALPHA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ALPHA",
        "http://www.wldelft.nl/fews");
    }

    if (!K_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "K",
        "http://www.wldelft.nl/fews");
    }

    if (!MAX_GFLOW_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MAX_GFLOW",
        "http://www.wldelft.nl/fews");
    }
  }

  ParametergroundwaterFlowStorageSystemComplexType* ParametergroundwaterFlowStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParametergroundwaterFlowStorageSystemComplexType (*this, f, c);
  }

  ParametergroundwaterFlowStorageSystemComplexType::
  ~ParametergroundwaterFlowStorageSystemComplexType ()
  {
  }

  // EvaporationActualStorageSystemComplexType
  //

  EvaporationActualStorageSystemComplexType::
  EvaporationActualStorageSystemComplexType (const ParameterType& parameter,
                                             const InputType& input,
                                             const OutputType& output,
                                             const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EvaporationActualStorageSystemComplexType::
  EvaporationActualStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                             ::std::auto_ptr< InputType >& input,
                                             ::std::auto_ptr< OutputType >& output,
                                             const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EvaporationActualStorageSystemComplexType::
  EvaporationActualStorageSystemComplexType (const EvaporationActualStorageSystemComplexType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  EvaporationActualStorageSystemComplexType::
  EvaporationActualStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EvaporationActualStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  EvaporationActualStorageSystemComplexType* EvaporationActualStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EvaporationActualStorageSystemComplexType (*this, f, c);
  }

  EvaporationActualStorageSystemComplexType::
  ~EvaporationActualStorageSystemComplexType ()
  {
  }

  // InputEvaporationActualStorageSystemComplexType
  //

  InputEvaporationActualStorageSystemComplexType::
  InputEvaporationActualStorageSystemComplexType (const HUpType& HUp,
                                                  const EPType& EP)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    EP_ (EP, ::xml_schema::Flags (), this),
    EI_ (::xml_schema::Flags (), this)
  {
  }

  InputEvaporationActualStorageSystemComplexType::
  InputEvaporationActualStorageSystemComplexType (const InputEvaporationActualStorageSystemComplexType& x,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    EP_ (x.EP_, f, this),
    EI_ (x.EI_, f, this)
  {
  }

  InputEvaporationActualStorageSystemComplexType::
  InputEvaporationActualStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    EP_ (f, this),
    EI_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputEvaporationActualStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // EP
      //
      if (n.name () == "EP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPType > r (
          EPTraits::create (i, f, this));

        if (!EP_.present ())
        {
          this->EP_.set (r);
          continue;
        }
      }

      // EI
      //
      if (n.name () == "EI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EIType > r (
          EITraits::create (i, f, this));

        if (!this->EI_)
        {
          this->EI_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!EP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EP",
        "http://www.wldelft.nl/fews");
    }
  }

  InputEvaporationActualStorageSystemComplexType* InputEvaporationActualStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputEvaporationActualStorageSystemComplexType (*this, f, c);
  }

  InputEvaporationActualStorageSystemComplexType::
  ~InputEvaporationActualStorageSystemComplexType ()
  {
  }

  // ParameterEvaporationActualStorageSystemComplexType
  //

  ParameterEvaporationActualStorageSystemComplexType::
  ParameterEvaporationActualStorageSystemComplexType (const FCType& FC,
                                                      const LPType& LP)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    D_ (::xml_schema::Flags (), this),
    FC_ (FC, ::xml_schema::Flags (), this),
    LP_ (LP, ::xml_schema::Flags (), this)
  {
  }

  ParameterEvaporationActualStorageSystemComplexType::
  ParameterEvaporationActualStorageSystemComplexType (const ParameterEvaporationActualStorageSystemComplexType& x,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    D_ (x.D_, f, this),
    FC_ (x.FC_, f, this),
    LP_ (x.LP_, f, this)
  {
  }

  ParameterEvaporationActualStorageSystemComplexType::
  ParameterEvaporationActualStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    D_ (f, this),
    FC_ (f, this),
    LP_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterEvaporationActualStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!this->D_)
        {
          this->D_.set (r);
          continue;
        }
      }

      // FC
      //
      if (n.name () == "FC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FCType > r (
          FCTraits::create (i, f, this));

        if (!FC_.present ())
        {
          this->FC_.set (r);
          continue;
        }
      }

      // LP
      //
      if (n.name () == "LP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LPType > r (
          LPTraits::create (i, f, this));

        if (!LP_.present ())
        {
          this->LP_.set (r);
          continue;
        }
      }

      break;
    }

    if (!FC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FC",
        "http://www.wldelft.nl/fews");
    }

    if (!LP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LP",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterEvaporationActualStorageSystemComplexType* ParameterEvaporationActualStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterEvaporationActualStorageSystemComplexType (*this, f, c);
  }

  ParameterEvaporationActualStorageSystemComplexType::
  ~ParameterEvaporationActualStorageSystemComplexType ()
  {
  }

  // SoilRunoffStorageSystemComplexType
  //

  SoilRunoffStorageSystemComplexType::
  SoilRunoffStorageSystemComplexType (const ParameterType& parameter,
                                      const InputType& input,
                                      const OutputType& output,
                                      const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SoilRunoffStorageSystemComplexType::
  SoilRunoffStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                      ::std::auto_ptr< InputType >& input,
                                      ::std::auto_ptr< OutputType >& output,
                                      const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SoilRunoffStorageSystemComplexType::
  SoilRunoffStorageSystemComplexType (const SoilRunoffStorageSystemComplexType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  SoilRunoffStorageSystemComplexType::
  SoilRunoffStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SoilRunoffStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  SoilRunoffStorageSystemComplexType* SoilRunoffStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SoilRunoffStorageSystemComplexType (*this, f, c);
  }

  SoilRunoffStorageSystemComplexType::
  ~SoilRunoffStorageSystemComplexType ()
  {
  }

  // InputSoilRunoffStorageSystemComplexType
  //

  InputSoilRunoffStorageSystemComplexType::
  InputSoilRunoffStorageSystemComplexType (const HUpType& HUp)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (::xml_schema::Flags (), this),
    INF_ (::xml_schema::Flags (), this)
  {
  }

  InputSoilRunoffStorageSystemComplexType::
  InputSoilRunoffStorageSystemComplexType (const InputSoilRunoffStorageSystemComplexType& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this),
    INF_ (x.INF_, f, this)
  {
  }

  InputSoilRunoffStorageSystemComplexType::
  InputSoilRunoffStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this),
    INF_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputSoilRunoffStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!this->HDown_)
        {
          this->HDown_.set (r);
          continue;
        }
      }

      // INF
      //
      if (n.name () == "INF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< INFType > r (
          INFTraits::create (i, f, this));

        this->INF_.push_back (r);
        continue;
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }
  }

  InputSoilRunoffStorageSystemComplexType* InputSoilRunoffStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputSoilRunoffStorageSystemComplexType (*this, f, c);
  }

  InputSoilRunoffStorageSystemComplexType::
  ~InputSoilRunoffStorageSystemComplexType ()
  {
  }

  // ParameterSoilRunoffStorageSystemComplexType
  //

  ParameterSoilRunoffStorageSystemComplexType::
  ParameterSoilRunoffStorageSystemComplexType (const BETAType& BETA,
                                               const FCType& FC)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    BETA_ (BETA, ::xml_schema::Flags (), this),
    FC_ (FC, ::xml_schema::Flags (), this)
  {
  }

  ParameterSoilRunoffStorageSystemComplexType::
  ParameterSoilRunoffStorageSystemComplexType (const ParameterSoilRunoffStorageSystemComplexType& x,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    BETA_ (x.BETA_, f, this),
    FC_ (x.FC_, f, this)
  {
  }

  ParameterSoilRunoffStorageSystemComplexType::
  ParameterSoilRunoffStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    BETA_ (f, this),
    FC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterSoilRunoffStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // BETA
      //
      if (n.name () == "BETA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BETAType > r (
          BETATraits::create (i, f, this));

        if (!BETA_.present ())
        {
          this->BETA_.set (r);
          continue;
        }
      }

      // FC
      //
      if (n.name () == "FC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FCType > r (
          FCTraits::create (i, f, this));

        if (!FC_.present ())
        {
          this->FC_.set (r);
          continue;
        }
      }

      break;
    }

    if (!BETA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "BETA",
        "http://www.wldelft.nl/fews");
    }

    if (!FC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FC",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterSoilRunoffStorageSystemComplexType* ParameterSoilRunoffStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterSoilRunoffStorageSystemComplexType (*this, f, c);
  }

  ParameterSoilRunoffStorageSystemComplexType::
  ~ParameterSoilRunoffStorageSystemComplexType ()
  {
  }

  // CapillaryFlowStorageSystemComplexType
  //

  CapillaryFlowStorageSystemComplexType::
  CapillaryFlowStorageSystemComplexType (const ParameterType& parameter,
                                         const InputType& input,
                                         const OutputType& output,
                                         const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  CapillaryFlowStorageSystemComplexType::
  CapillaryFlowStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                         ::std::auto_ptr< InputType >& input,
                                         ::std::auto_ptr< OutputType >& output,
                                         const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  CapillaryFlowStorageSystemComplexType::
  CapillaryFlowStorageSystemComplexType (const CapillaryFlowStorageSystemComplexType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  CapillaryFlowStorageSystemComplexType::
  CapillaryFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void CapillaryFlowStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  CapillaryFlowStorageSystemComplexType* CapillaryFlowStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CapillaryFlowStorageSystemComplexType (*this, f, c);
  }

  CapillaryFlowStorageSystemComplexType::
  ~CapillaryFlowStorageSystemComplexType ()
  {
  }

  // InputCapillaryFlowStorageSystemComplexType
  //

  InputCapillaryFlowStorageSystemComplexType::
  InputCapillaryFlowStorageSystemComplexType (const HUpType& HUp,
                                              const HDownType& HDown)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (HDown, ::xml_schema::Flags (), this)
  {
  }

  InputCapillaryFlowStorageSystemComplexType::
  InputCapillaryFlowStorageSystemComplexType (const InputCapillaryFlowStorageSystemComplexType& x,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this)
  {
  }

  InputCapillaryFlowStorageSystemComplexType::
  InputCapillaryFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputCapillaryFlowStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!HDown_.present ())
        {
          this->HDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!HDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HDown",
        "http://www.wldelft.nl/fews");
    }
  }

  InputCapillaryFlowStorageSystemComplexType* InputCapillaryFlowStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputCapillaryFlowStorageSystemComplexType (*this, f, c);
  }

  InputCapillaryFlowStorageSystemComplexType::
  ~InputCapillaryFlowStorageSystemComplexType ()
  {
  }

  // ParameterCapillaryFlowStorageSystemComplexType
  //

  ParameterCapillaryFlowStorageSystemComplexType::
  ParameterCapillaryFlowStorageSystemComplexType (const CFLUXType& CFLUX,
                                                  const FCType& FC)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    CFLUX_ (CFLUX, ::xml_schema::Flags (), this),
    FC_ (FC, ::xml_schema::Flags (), this)
  {
  }

  ParameterCapillaryFlowStorageSystemComplexType::
  ParameterCapillaryFlowStorageSystemComplexType (const ParameterCapillaryFlowStorageSystemComplexType& x,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    CFLUX_ (x.CFLUX_, f, this),
    FC_ (x.FC_, f, this)
  {
  }

  ParameterCapillaryFlowStorageSystemComplexType::
  ParameterCapillaryFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    CFLUX_ (f, this),
    FC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterCapillaryFlowStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // CFLUX
      //
      if (n.name () == "CFLUX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFLUXType > r (
          CFLUXTraits::create (i, f, this));

        if (!CFLUX_.present ())
        {
          this->CFLUX_.set (r);
          continue;
        }
      }

      // FC
      //
      if (n.name () == "FC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FCType > r (
          FCTraits::create (i, f, this));

        if (!FC_.present ())
        {
          this->FC_.set (r);
          continue;
        }
      }

      break;
    }

    if (!CFLUX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFLUX",
        "http://www.wldelft.nl/fews");
    }

    if (!FC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FC",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterCapillaryFlowStorageSystemComplexType* ParameterCapillaryFlowStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterCapillaryFlowStorageSystemComplexType (*this, f, c);
  }

  ParameterCapillaryFlowStorageSystemComplexType::
  ~ParameterCapillaryFlowStorageSystemComplexType ()
  {
  }

  // ResponseStorageSystemComplexType
  //

  ResponseStorageSystemComplexType::
  ResponseStorageSystemComplexType (const ParameterType& parameter,
                                    const InputType& input,
                                    const OutputType& output,
                                    const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ResponseStorageSystemComplexType::
  ResponseStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                    ::std::auto_ptr< InputType >& input,
                                    ::std::auto_ptr< OutputType >& output,
                                    const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ResponseStorageSystemComplexType::
  ResponseStorageSystemComplexType (const ResponseStorageSystemComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ResponseStorageSystemComplexType::
  ResponseStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ResponseStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ResponseStorageSystemComplexType* ResponseStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ResponseStorageSystemComplexType (*this, f, c);
  }

  ResponseStorageSystemComplexType::
  ~ResponseStorageSystemComplexType ()
  {
  }

  // ParameterResponseStorageSystemComplexType
  //

  ParameterResponseStorageSystemComplexType::
  ParameterResponseStorageSystemComplexType (const KType& K)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    K_ (K, ::xml_schema::Flags (), this),
    ALPHA_ (::xml_schema::Flags (), this)
  {
  }

  ParameterResponseStorageSystemComplexType::
  ParameterResponseStorageSystemComplexType (const ParameterResponseStorageSystemComplexType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    K_ (x.K_, f, this),
    ALPHA_ (x.ALPHA_, f, this)
  {
  }

  ParameterResponseStorageSystemComplexType::
  ParameterResponseStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    K_ (f, this),
    ALPHA_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterResponseStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // K
      //
      if (n.name () == "K" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< KType > r (
          KTraits::create (i, f, this));

        if (!K_.present ())
        {
          this->K_.set (r);
          continue;
        }
      }

      // ALPHA
      //
      if (n.name () == "ALPHA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ALPHAType > r (
          ALPHATraits::create (i, f, this));

        if (!this->ALPHA_)
        {
          this->ALPHA_.set (r);
          continue;
        }
      }

      break;
    }

    if (!K_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "K",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterResponseStorageSystemComplexType* ParameterResponseStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterResponseStorageSystemComplexType (*this, f, c);
  }

  ParameterResponseStorageSystemComplexType::
  ~ParameterResponseStorageSystemComplexType ()
  {
  }

  // InputResponseStorageSystemComplexType
  //

  InputResponseStorageSystemComplexType::
  InputResponseStorageSystemComplexType (const HUpType& HUp)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this)
  {
  }

  InputResponseStorageSystemComplexType::
  InputResponseStorageSystemComplexType (const InputResponseStorageSystemComplexType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this)
  {
  }

  InputResponseStorageSystemComplexType::
  InputResponseStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputResponseStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }
  }

  InputResponseStorageSystemComplexType* InputResponseStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputResponseStorageSystemComplexType (*this, f, c);
  }

  InputResponseStorageSystemComplexType::
  ~InputResponseStorageSystemComplexType ()
  {
  }

  // PercolationStorageSystemComplexType
  //

  PercolationStorageSystemComplexType::
  PercolationStorageSystemComplexType (const ParameterType& parameter,
                                       const InputType& input,
                                       const OutputType& output,
                                       const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  PercolationStorageSystemComplexType::
  PercolationStorageSystemComplexType (::std::auto_ptr< ParameterType >& parameter,
                                       ::std::auto_ptr< InputType >& input,
                                       ::std::auto_ptr< OutputType >& output,
                                       const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  PercolationStorageSystemComplexType::
  PercolationStorageSystemComplexType (const PercolationStorageSystemComplexType& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  PercolationStorageSystemComplexType::
  PercolationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PercolationStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  PercolationStorageSystemComplexType* PercolationStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PercolationStorageSystemComplexType (*this, f, c);
  }

  PercolationStorageSystemComplexType::
  ~PercolationStorageSystemComplexType ()
  {
  }

  // ParameterPercolationStorageSystemComplexType
  //

  ParameterPercolationStorageSystemComplexType::
  ParameterPercolationStorageSystemComplexType (const PERCType& PERC)
  : ::xml_schema::Type (),
    AREA_ (::xml_schema::Flags (), this),
    PERC_ (PERC, ::xml_schema::Flags (), this)
  {
  }

  ParameterPercolationStorageSystemComplexType::
  ParameterPercolationStorageSystemComplexType (const ParameterPercolationStorageSystemComplexType& x,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    PERC_ (x.PERC_, f, this)
  {
  }

  ParameterPercolationStorageSystemComplexType::
  ParameterPercolationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    PERC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterPercolationStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!this->AREA_)
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // PERC
      //
      if (n.name () == "PERC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PERCType > r (
          PERCTraits::create (i, f, this));

        if (!PERC_.present ())
        {
          this->PERC_.set (r);
          continue;
        }
      }

      break;
    }

    if (!PERC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PERC",
        "http://www.wldelft.nl/fews");
    }
  }

  ParameterPercolationStorageSystemComplexType* ParameterPercolationStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterPercolationStorageSystemComplexType (*this, f, c);
  }

  ParameterPercolationStorageSystemComplexType::
  ~ParameterPercolationStorageSystemComplexType ()
  {
  }

  // InputPercolationStorageSystemComplexType
  //

  InputPercolationStorageSystemComplexType::
  InputPercolationStorageSystemComplexType (const HUpType& HUp)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (::xml_schema::Flags (), this)
  {
  }

  InputPercolationStorageSystemComplexType::
  InputPercolationStorageSystemComplexType (const InputPercolationStorageSystemComplexType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this)
  {
  }

  InputPercolationStorageSystemComplexType::
  InputPercolationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputPercolationStorageSystemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!this->HDown_)
        {
          this->HDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }
  }

  InputPercolationStorageSystemComplexType* InputPercolationStorageSystemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputPercolationStorageSystemComplexType (*this, f, c);
  }

  InputPercolationStorageSystemComplexType::
  ~InputPercolationStorageSystemComplexType ()
  {
  }

  // ArmaComplexType
  //

  ArmaComplexType::
  ArmaComplexType (const ArCoefType& arCoef,
                   const InputType& input,
                   const OutputType& output,
                   const IdType& id)
  : ::xml_schema::Type (),
    arCoef_ (arCoef, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ArmaComplexType::
  ArmaComplexType (const ArCoefType& arCoef,
                   ::std::auto_ptr< InputType >& input,
                   ::std::auto_ptr< OutputType >& output,
                   const IdType& id)
  : ::xml_schema::Type (),
    arCoef_ (arCoef, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ArmaComplexType::
  ArmaComplexType (const ArmaComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    arCoef_ (x.arCoef_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ArmaComplexType::
  ArmaComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    arCoef_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ArmaComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // arCoef
      //
      if (n.name () == "arCoef" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!arCoef_.present ())
        {
          this->arCoef_.set (ArCoefTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!arCoef_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "arCoef",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ArmaComplexType* ArmaComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ArmaComplexType (*this, f, c);
  }

  ArmaComplexType::
  ~ArmaComplexType ()
  {
  }

  // ArmaInputComplexType
  //

  ArmaInputComplexType::
  ArmaInputComplexType (const ObsType& obs,
                        const SimType& sim)
  : ::xml_schema::Type (),
    obs_ (obs, ::xml_schema::Flags (), this),
    sim_ (sim, ::xml_schema::Flags (), this)
  {
  }

  ArmaInputComplexType::
  ArmaInputComplexType (const ArmaInputComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    obs_ (x.obs_, f, this),
    sim_ (x.sim_, f, this)
  {
  }

  ArmaInputComplexType::
  ArmaInputComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    obs_ (f, this),
    sim_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ArmaInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // obs
      //
      if (n.name () == "obs" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ObsType > r (
          ObsTraits::create (i, f, this));

        if (!obs_.present ())
        {
          this->obs_.set (r);
          continue;
        }
      }

      // sim
      //
      if (n.name () == "sim" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimType > r (
          SimTraits::create (i, f, this));

        if (!sim_.present ())
        {
          this->sim_.set (r);
          continue;
        }
      }

      break;
    }

    if (!obs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "obs",
        "http://www.wldelft.nl/fews");
    }

    if (!sim_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sim",
        "http://www.wldelft.nl/fews");
    }
  }

  ArmaInputComplexType* ArmaInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ArmaInputComplexType (*this, f, c);
  }

  ArmaInputComplexType::
  ~ArmaInputComplexType ()
  {
  }

  // ArmaOutputComplexType
  //

  ArmaOutputComplexType::
  ArmaOutputComplexType (const ArmaType& arma)
  : ::xml_schema::Type (),
    arma_ (arma, ::xml_schema::Flags (), this)
  {
  }

  ArmaOutputComplexType::
  ArmaOutputComplexType (const ArmaOutputComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    arma_ (x.arma_, f, this)
  {
  }

  ArmaOutputComplexType::
  ArmaOutputComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    arma_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ArmaOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // arma
      //
      if (n.name () == "arma" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ArmaType > r (
          ArmaTraits::create (i, f, this));

        if (!arma_.present ())
        {
          this->arma_.set (r);
          continue;
        }
      }

      break;
    }

    if (!arma_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "arma",
        "http://www.wldelft.nl/fews");
    }
  }

  ArmaOutputComplexType* ArmaOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ArmaOutputComplexType (*this, f, c);
  }

  ArmaOutputComplexType::
  ~ArmaOutputComplexType ()
  {
  }

  // AccumulationComplexType
  //

  AccumulationComplexType::
  AccumulationComplexType (const InputType& input,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    multiplier_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AccumulationComplexType::
  AccumulationComplexType (::std::auto_ptr< InputType >& input,
                           ::std::auto_ptr< OutputType >& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    multiplier_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AccumulationComplexType::
  AccumulationComplexType (const AccumulationComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    multiplier_ (x.multiplier_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  AccumulationComplexType::
  AccumulationComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    multiplier_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AccumulationComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // multiplier
      //
      if (n.name () == "multiplier" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->multiplier_)
        {
          this->multiplier_.set (MultiplierTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  AccumulationComplexType* AccumulationComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AccumulationComplexType (*this, f, c);
  }

  AccumulationComplexType::
  ~AccumulationComplexType ()
  {
  }

  // AccumulationInputComplexType
  //

  AccumulationInputComplexType::
  AccumulationInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  AccumulationInputComplexType::
  AccumulationInputComplexType (const AccumulationInputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  AccumulationInputComplexType::
  AccumulationInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AccumulationInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  AccumulationInputComplexType* AccumulationInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AccumulationInputComplexType (*this, f, c);
  }

  AccumulationInputComplexType::
  ~AccumulationInputComplexType ()
  {
  }

  // AccumulationOutputComplexType
  //

  AccumulationOutputComplexType::
  AccumulationOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  AccumulationOutputComplexType::
  AccumulationOutputComplexType (const AccumulationOutputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  AccumulationOutputComplexType::
  AccumulationOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AccumulationOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  AccumulationOutputComplexType* AccumulationOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AccumulationOutputComplexType (*this, f, c);
  }

  AccumulationOutputComplexType::
  ~AccumulationOutputComplexType ()
  {
  }

  // GradientComplexType
  //

  GradientComplexType::
  GradientComplexType (const InputType& input,
                       const OutputType& output,
                       const IdType& id)
  : ::xml_schema::Type (),
    multiplier_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  GradientComplexType::
  GradientComplexType (::std::auto_ptr< InputType >& input,
                       ::std::auto_ptr< OutputType >& output,
                       const IdType& id)
  : ::xml_schema::Type (),
    multiplier_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  GradientComplexType::
  GradientComplexType (const GradientComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    multiplier_ (x.multiplier_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  GradientComplexType::
  GradientComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    multiplier_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void GradientComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // multiplier
      //
      if (n.name () == "multiplier" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->multiplier_)
        {
          this->multiplier_.set (MultiplierTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  GradientComplexType* GradientComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GradientComplexType (*this, f, c);
  }

  GradientComplexType::
  ~GradientComplexType ()
  {
  }

  // GradientInputComplexType
  //

  GradientInputComplexType::
  GradientInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  GradientInputComplexType::
  GradientInputComplexType (const GradientInputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  GradientInputComplexType::
  GradientInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GradientInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  GradientInputComplexType* GradientInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GradientInputComplexType (*this, f, c);
  }

  GradientInputComplexType::
  ~GradientInputComplexType ()
  {
  }

  // GradientOutputComplexType
  //

  GradientOutputComplexType::
  GradientOutputComplexType (const DxType& dx)
  : ::xml_schema::Type (),
    dx_ (dx, ::xml_schema::Flags (), this)
  {
  }

  GradientOutputComplexType::
  GradientOutputComplexType (const GradientOutputComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dx_ (x.dx_, f, this)
  {
  }

  GradientOutputComplexType::
  GradientOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dx_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GradientOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dx
      //
      if (n.name () == "dx" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DxType > r (
          DxTraits::create (i, f, this));

        if (!dx_.present ())
        {
          this->dx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!dx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dx",
        "http://www.wldelft.nl/fews");
    }
  }

  GradientOutputComplexType* GradientOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GradientOutputComplexType (*this, f, c);
  }

  GradientOutputComplexType::
  ~GradientOutputComplexType ()
  {
  }

  // LorentGeversComplexType
  //

  LorentGeversComplexType::
  LorentGeversComplexType (const ParameterSoilType& parameterSoil,
                           const ParameterResponseType& parameterResponse,
                           const InputType& input,
                           const StateType& state,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    parameterSoil_ (parameterSoil, ::xml_schema::Flags (), this),
    parameterResponse_ (parameterResponse, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    stateUpdate_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LorentGeversComplexType::
  LorentGeversComplexType (::std::auto_ptr< ParameterSoilType >& parameterSoil,
                           ::std::auto_ptr< ParameterResponseType >& parameterResponse,
                           ::std::auto_ptr< InputType >& input,
                           ::std::auto_ptr< StateType >& state,
                           ::std::auto_ptr< OutputType >& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    parameterSoil_ (parameterSoil, ::xml_schema::Flags (), this),
    parameterResponse_ (parameterResponse, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    stateUpdate_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LorentGeversComplexType::
  LorentGeversComplexType (const LorentGeversComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameterSoil_ (x.parameterSoil_, f, this),
    parameterResponse_ (x.parameterResponse_, f, this),
    input_ (x.input_, f, this),
    state_ (x.state_, f, this),
    stateUpdate_ (x.stateUpdate_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  LorentGeversComplexType::
  LorentGeversComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameterSoil_ (f, this),
    parameterResponse_ (f, this),
    input_ (f, this),
    state_ (f, this),
    stateUpdate_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void LorentGeversComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameterSoil
      //
      if (n.name () == "parameterSoil" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterSoilType > r (
          ParameterSoilTraits::create (i, f, this));

        if (!parameterSoil_.present ())
        {
          this->parameterSoil_.set (r);
          continue;
        }
      }

      // parameterResponse
      //
      if (n.name () == "parameterResponse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterResponseType > r (
          ParameterResponseTraits::create (i, f, this));

        if (!parameterResponse_.present ())
        {
          this->parameterResponse_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!state_.present ())
        {
          this->state_.set (r);
          continue;
        }
      }

      // stateUpdate
      //
      if (n.name () == "stateUpdate" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateUpdateType > r (
          StateUpdateTraits::create (i, f, this));

        if (!this->stateUpdate_)
        {
          this->stateUpdate_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameterSoil_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterSoil",
        "http://www.wldelft.nl/fews");
    }

    if (!parameterResponse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterResponse",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!state_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "state",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  LorentGeversComplexType* LorentGeversComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversComplexType (*this, f, c);
  }

  LorentGeversComplexType::
  ~LorentGeversComplexType ()
  {
  }

  // LorentGeversParameterSoilComplexType
  //

  LorentGeversParameterSoilComplexType::
  LorentGeversParameterSoilComplexType (const BETAType& BETA,
                                        const PMAXType& PMAX,
                                        const SMAXType& SMAX)
  : ::xml_schema::Type (),
    BETA_ (BETA, ::xml_schema::Flags (), this),
    PMAX_ (PMAX, ::xml_schema::Flags (), this),
    SMAX_ (SMAX, ::xml_schema::Flags (), this)
  {
  }

  LorentGeversParameterSoilComplexType::
  LorentGeversParameterSoilComplexType (const LorentGeversParameterSoilComplexType& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    BETA_ (x.BETA_, f, this),
    PMAX_ (x.PMAX_, f, this),
    SMAX_ (x.SMAX_, f, this)
  {
  }

  LorentGeversParameterSoilComplexType::
  LorentGeversParameterSoilComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    BETA_ (f, this),
    PMAX_ (f, this),
    SMAX_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LorentGeversParameterSoilComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BETA
      //
      if (n.name () == "BETA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BETAType > r (
          BETATraits::create (i, f, this));

        if (!BETA_.present ())
        {
          this->BETA_.set (r);
          continue;
        }
      }

      // PMAX
      //
      if (n.name () == "PMAX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PMAXType > r (
          PMAXTraits::create (i, f, this));

        if (!PMAX_.present ())
        {
          this->PMAX_.set (r);
          continue;
        }
      }

      // SMAX
      //
      if (n.name () == "SMAX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SMAXType > r (
          SMAXTraits::create (i, f, this));

        if (!SMAX_.present ())
        {
          this->SMAX_.set (r);
          continue;
        }
      }

      break;
    }

    if (!BETA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "BETA",
        "http://www.wldelft.nl/fews");
    }

    if (!PMAX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PMAX",
        "http://www.wldelft.nl/fews");
    }

    if (!SMAX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SMAX",
        "http://www.wldelft.nl/fews");
    }
  }

  LorentGeversParameterSoilComplexType* LorentGeversParameterSoilComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversParameterSoilComplexType (*this, f, c);
  }

  LorentGeversParameterSoilComplexType::
  ~LorentGeversParameterSoilComplexType ()
  {
  }

  // LorentGeversParameterResponseComplexType
  //

  LorentGeversParameterResponseComplexType::
  LorentGeversParameterResponseComplexType (const AREAType& AREA,
                                            const KSType& KS,
                                            const TS1Type& TS1,
                                            const TS2Type& TS2,
                                            const KBType& KB,
                                            const TB1Type& TB1,
                                            const TB2Type& TB2)
  : ::xml_schema::Type (),
    AREA_ (AREA, ::xml_schema::Flags (), this),
    KS_ (KS, ::xml_schema::Flags (), this),
    TS1_ (TS1, ::xml_schema::Flags (), this),
    TS2_ (TS2, ::xml_schema::Flags (), this),
    KB_ (KB, ::xml_schema::Flags (), this),
    TB1_ (TB1, ::xml_schema::Flags (), this),
    TB2_ (TB2, ::xml_schema::Flags (), this)
  {
  }

  LorentGeversParameterResponseComplexType::
  LorentGeversParameterResponseComplexType (const LorentGeversParameterResponseComplexType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AREA_ (x.AREA_, f, this),
    KS_ (x.KS_, f, this),
    TS1_ (x.TS1_, f, this),
    TS2_ (x.TS2_, f, this),
    KB_ (x.KB_, f, this),
    TB1_ (x.TB1_, f, this),
    TB2_ (x.TB2_, f, this)
  {
  }

  LorentGeversParameterResponseComplexType::
  LorentGeversParameterResponseComplexType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AREA_ (f, this),
    KS_ (f, this),
    TS1_ (f, this),
    TS2_ (f, this),
    KB_ (f, this),
    TB1_ (f, this),
    TB2_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LorentGeversParameterResponseComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!AREA_.present ())
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // KS
      //
      if (n.name () == "KS" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< KSType > r (
          KSTraits::create (i, f, this));

        if (!KS_.present ())
        {
          this->KS_.set (r);
          continue;
        }
      }

      // TS1
      //
      if (n.name () == "TS1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TS1Type > r (
          TS1Traits::create (i, f, this));

        if (!TS1_.present ())
        {
          this->TS1_.set (r);
          continue;
        }
      }

      // TS2
      //
      if (n.name () == "TS2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TS2Type > r (
          TS2Traits::create (i, f, this));

        if (!TS2_.present ())
        {
          this->TS2_.set (r);
          continue;
        }
      }

      // KB
      //
      if (n.name () == "KB" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< KBType > r (
          KBTraits::create (i, f, this));

        if (!KB_.present ())
        {
          this->KB_.set (r);
          continue;
        }
      }

      // TB1
      //
      if (n.name () == "TB1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TB1Type > r (
          TB1Traits::create (i, f, this));

        if (!TB1_.present ())
        {
          this->TB1_.set (r);
          continue;
        }
      }

      // TB2
      //
      if (n.name () == "TB2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TB2Type > r (
          TB2Traits::create (i, f, this));

        if (!TB2_.present ())
        {
          this->TB2_.set (r);
          continue;
        }
      }

      break;
    }

    if (!AREA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AREA",
        "http://www.wldelft.nl/fews");
    }

    if (!KS_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "KS",
        "http://www.wldelft.nl/fews");
    }

    if (!TS1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TS1",
        "http://www.wldelft.nl/fews");
    }

    if (!TS2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TS2",
        "http://www.wldelft.nl/fews");
    }

    if (!KB_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "KB",
        "http://www.wldelft.nl/fews");
    }

    if (!TB1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TB1",
        "http://www.wldelft.nl/fews");
    }

    if (!TB2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TB2",
        "http://www.wldelft.nl/fews");
    }
  }

  LorentGeversParameterResponseComplexType* LorentGeversParameterResponseComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversParameterResponseComplexType (*this, f, c);
  }

  LorentGeversParameterResponseComplexType::
  ~LorentGeversParameterResponseComplexType ()
  {
  }

  // LorentGeversInputComplexType
  //

  LorentGeversInputComplexType::
  LorentGeversInputComplexType (const EPType& EP,
                                const PType& P)
  : ::xml_schema::Type (),
    EP_ (EP, ::xml_schema::Flags (), this),
    P_ (P, ::xml_schema::Flags (), this)
  {
  }

  LorentGeversInputComplexType::
  LorentGeversInputComplexType (const LorentGeversInputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EP_ (x.EP_, f, this),
    P_ (x.P_, f, this)
  {
  }

  LorentGeversInputComplexType::
  LorentGeversInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EP_ (f, this),
    P_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LorentGeversInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EP
      //
      if (n.name () == "EP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPType > r (
          EPTraits::create (i, f, this));

        if (!EP_.present ())
        {
          this->EP_.set (r);
          continue;
        }
      }

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PType > r (
          PTraits::create (i, f, this));

        if (!P_.present ())
        {
          this->P_.set (r);
          continue;
        }
      }

      break;
    }

    if (!EP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EP",
        "http://www.wldelft.nl/fews");
    }

    if (!P_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "P",
        "http://www.wldelft.nl/fews");
    }
  }

  LorentGeversInputComplexType* LorentGeversInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversInputComplexType (*this, f, c);
  }

  LorentGeversInputComplexType::
  ~LorentGeversInputComplexType ()
  {
  }

  // LorentGeversStateComplexType
  //

  LorentGeversStateComplexType::
  LorentGeversStateComplexType (const SType& S,
                                const QS1Type& QS1,
                                const QS2Type& QS2,
                                const QB1Type& QB1,
                                const QB2Type& QB2)
  : ::xml_schema::Type (),
    S_ (S, ::xml_schema::Flags (), this),
    QS1_ (QS1, ::xml_schema::Flags (), this),
    QS2_ (QS2, ::xml_schema::Flags (), this),
    QB1_ (QB1, ::xml_schema::Flags (), this),
    QB2_ (QB2, ::xml_schema::Flags (), this)
  {
  }

  LorentGeversStateComplexType::
  LorentGeversStateComplexType (const LorentGeversStateComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    S_ (x.S_, f, this),
    QS1_ (x.QS1_, f, this),
    QS2_ (x.QS2_, f, this),
    QB1_ (x.QB1_, f, this),
    QB2_ (x.QB2_, f, this)
  {
  }

  LorentGeversStateComplexType::
  LorentGeversStateComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    S_ (f, this),
    QS1_ (f, this),
    QS2_ (f, this),
    QB1_ (f, this),
    QB2_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LorentGeversStateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // S
      //
      if (n.name () == "S" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SType > r (
          STraits::create (i, f, this));

        if (!S_.present ())
        {
          this->S_.set (r);
          continue;
        }
      }

      // QS1
      //
      if (n.name () == "QS1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QS1Type > r (
          QS1Traits::create (i, f, this));

        if (!QS1_.present ())
        {
          this->QS1_.set (r);
          continue;
        }
      }

      // QS2
      //
      if (n.name () == "QS2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QS2Type > r (
          QS2Traits::create (i, f, this));

        if (!QS2_.present ())
        {
          this->QS2_.set (r);
          continue;
        }
      }

      // QB1
      //
      if (n.name () == "QB1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QB1Type > r (
          QB1Traits::create (i, f, this));

        if (!QB1_.present ())
        {
          this->QB1_.set (r);
          continue;
        }
      }

      // QB2
      //
      if (n.name () == "QB2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QB2Type > r (
          QB2Traits::create (i, f, this));

        if (!QB2_.present ())
        {
          this->QB2_.set (r);
          continue;
        }
      }

      break;
    }

    if (!S_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "S",
        "http://www.wldelft.nl/fews");
    }

    if (!QS1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QS1",
        "http://www.wldelft.nl/fews");
    }

    if (!QS2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QS2",
        "http://www.wldelft.nl/fews");
    }

    if (!QB1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QB1",
        "http://www.wldelft.nl/fews");
    }

    if (!QB2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QB2",
        "http://www.wldelft.nl/fews");
    }
  }

  LorentGeversStateComplexType* LorentGeversStateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversStateComplexType (*this, f, c);
  }

  LorentGeversStateComplexType::
  ~LorentGeversStateComplexType ()
  {
  }

  // LorentGeversStateUpdateComplexType
  //

  LorentGeversStateUpdateComplexType::
  LorentGeversStateUpdateComplexType (const SType& S)
  : ::xml_schema::Type (),
    S_ (S, ::xml_schema::Flags (), this)
  {
  }

  LorentGeversStateUpdateComplexType::
  LorentGeversStateUpdateComplexType (const LorentGeversStateUpdateComplexType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    S_ (x.S_, f, this)
  {
  }

  LorentGeversStateUpdateComplexType::
  LorentGeversStateUpdateComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    S_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LorentGeversStateUpdateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // S
      //
      if (n.name () == "S" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SType > r (
          STraits::create (i, f, this));

        if (!S_.present ())
        {
          this->S_.set (r);
          continue;
        }
      }

      break;
    }

    if (!S_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "S",
        "http://www.wldelft.nl/fews");
    }
  }

  LorentGeversStateUpdateComplexType* LorentGeversStateUpdateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversStateUpdateComplexType (*this, f, c);
  }

  LorentGeversStateUpdateComplexType::
  ~LorentGeversStateUpdateComplexType ()
  {
  }

  // LorentGeversOutputComplexType
  //

  LorentGeversOutputComplexType::
  LorentGeversOutputComplexType (const QType& Q)
  : ::xml_schema::Type (),
    Q_ (Q, ::xml_schema::Flags (), this)
  {
  }

  LorentGeversOutputComplexType::
  LorentGeversOutputComplexType (const LorentGeversOutputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Q_ (x.Q_, f, this)
  {
  }

  LorentGeversOutputComplexType::
  LorentGeversOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Q_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LorentGeversOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  LorentGeversOutputComplexType* LorentGeversOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LorentGeversOutputComplexType (*this, f, c);
  }

  LorentGeversOutputComplexType::
  ~LorentGeversOutputComplexType ()
  {
  }

  // HBVComplexType
  //

  HBVComplexType::
  HBVComplexType (const ParameterInputType& parameterInput,
                  const ParameterSnowType& parameterSnow,
                  const ParameterInterceptionType& parameterInterception,
                  const ParameterSoilType& parameterSoil,
                  const ParameterResponseType& parameterResponse,
                  const InputType& input,
                  const StateType& state,
                  const OutputType& output,
                  const IdType& id)
  : ::xml_schema::Type (),
    parameterInput_ (parameterInput, ::xml_schema::Flags (), this),
    parameterSnow_ (parameterSnow, ::xml_schema::Flags (), this),
    parameterInterception_ (parameterInterception, ::xml_schema::Flags (), this),
    parameterSoil_ (parameterSoil, ::xml_schema::Flags (), this),
    parameterResponse_ (parameterResponse, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    link_ (::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    stateUpdate_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  HBVComplexType::
  HBVComplexType (::std::auto_ptr< ParameterInputType >& parameterInput,
                  ::std::auto_ptr< ParameterSnowType >& parameterSnow,
                  ::std::auto_ptr< ParameterInterceptionType >& parameterInterception,
                  ::std::auto_ptr< ParameterSoilType >& parameterSoil,
                  ::std::auto_ptr< ParameterResponseType >& parameterResponse,
                  ::std::auto_ptr< InputType >& input,
                  ::std::auto_ptr< StateType >& state,
                  ::std::auto_ptr< OutputType >& output,
                  const IdType& id)
  : ::xml_schema::Type (),
    parameterInput_ (parameterInput, ::xml_schema::Flags (), this),
    parameterSnow_ (parameterSnow, ::xml_schema::Flags (), this),
    parameterInterception_ (parameterInterception, ::xml_schema::Flags (), this),
    parameterSoil_ (parameterSoil, ::xml_schema::Flags (), this),
    parameterResponse_ (parameterResponse, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    link_ (::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    stateUpdate_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  HBVComplexType::
  HBVComplexType (const HBVComplexType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameterInput_ (x.parameterInput_, f, this),
    parameterSnow_ (x.parameterSnow_, f, this),
    parameterInterception_ (x.parameterInterception_, f, this),
    parameterSoil_ (x.parameterSoil_, f, this),
    parameterResponse_ (x.parameterResponse_, f, this),
    input_ (x.input_, f, this),
    link_ (x.link_, f, this),
    state_ (x.state_, f, this),
    stateUpdate_ (x.stateUpdate_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  HBVComplexType::
  HBVComplexType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameterInput_ (f, this),
    parameterSnow_ (f, this),
    parameterInterception_ (f, this),
    parameterSoil_ (f, this),
    parameterResponse_ (f, this),
    input_ (f, this),
    link_ (f, this),
    state_ (f, this),
    stateUpdate_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void HBVComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameterInput
      //
      if (n.name () == "parameterInput" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterInputType > r (
          ParameterInputTraits::create (i, f, this));

        if (!parameterInput_.present ())
        {
          this->parameterInput_.set (r);
          continue;
        }
      }

      // parameterSnow
      //
      if (n.name () == "parameterSnow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterSnowType > r (
          ParameterSnowTraits::create (i, f, this));

        if (!parameterSnow_.present ())
        {
          this->parameterSnow_.set (r);
          continue;
        }
      }

      // parameterInterception
      //
      if (n.name () == "parameterInterception" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterInterceptionType > r (
          ParameterInterceptionTraits::create (i, f, this));

        if (!parameterInterception_.present ())
        {
          this->parameterInterception_.set (r);
          continue;
        }
      }

      // parameterSoil
      //
      if (n.name () == "parameterSoil" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterSoilType > r (
          ParameterSoilTraits::create (i, f, this));

        if (!parameterSoil_.present ())
        {
          this->parameterSoil_.set (r);
          continue;
        }
      }

      // parameterResponse
      //
      if (n.name () == "parameterResponse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterResponseType > r (
          ParameterResponseTraits::create (i, f, this));

        if (!parameterResponse_.present ())
        {
          this->parameterResponse_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // link
      //
      if (n.name () == "link" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LinkType > r (
          LinkTraits::create (i, f, this));

        if (!this->link_)
        {
          this->link_.set (r);
          continue;
        }
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!state_.present ())
        {
          this->state_.set (r);
          continue;
        }
      }

      // stateUpdate
      //
      if (n.name () == "stateUpdate" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateUpdateType > r (
          StateUpdateTraits::create (i, f, this));

        if (!this->stateUpdate_)
        {
          this->stateUpdate_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameterInput_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterInput",
        "http://www.wldelft.nl/fews");
    }

    if (!parameterSnow_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterSnow",
        "http://www.wldelft.nl/fews");
    }

    if (!parameterInterception_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterInterception",
        "http://www.wldelft.nl/fews");
    }

    if (!parameterSoil_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterSoil",
        "http://www.wldelft.nl/fews");
    }

    if (!parameterResponse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterResponse",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!state_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "state",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  HBVComplexType* HBVComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVComplexType (*this, f, c);
  }

  HBVComplexType::
  ~HBVComplexType ()
  {
  }

  // HBVParameterInputComplexType
  //

  HBVParameterInputComplexType::
  HBVParameterInputComplexType (const TTType& TT,
                                const TTIType& TTI)
  : ::xml_schema::Type (),
    ECORR_ (::xml_schema::Flags (), this),
    RFCF_ (::xml_schema::Flags (), this),
    SFCF_ (::xml_schema::Flags (), this),
    TT_ (TT, ::xml_schema::Flags (), this),
    TTI_ (TTI, ::xml_schema::Flags (), this)
  {
  }

  HBVParameterInputComplexType::
  HBVParameterInputComplexType (const HBVParameterInputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ECORR_ (x.ECORR_, f, this),
    RFCF_ (x.RFCF_, f, this),
    SFCF_ (x.SFCF_, f, this),
    TT_ (x.TT_, f, this),
    TTI_ (x.TTI_, f, this)
  {
  }

  HBVParameterInputComplexType::
  HBVParameterInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ECORR_ (f, this),
    RFCF_ (f, this),
    SFCF_ (f, this),
    TT_ (f, this),
    TTI_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVParameterInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ECORR
      //
      if (n.name () == "ECORR" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ECORRType > r (
          ECORRTraits::create (i, f, this));

        if (!this->ECORR_)
        {
          this->ECORR_.set (r);
          continue;
        }
      }

      // RFCF
      //
      if (n.name () == "RFCF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RFCFType > r (
          RFCFTraits::create (i, f, this));

        if (!this->RFCF_)
        {
          this->RFCF_.set (r);
          continue;
        }
      }

      // SFCF
      //
      if (n.name () == "SFCF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SFCFType > r (
          SFCFTraits::create (i, f, this));

        if (!this->SFCF_)
        {
          this->SFCF_.set (r);
          continue;
        }
      }

      // TT
      //
      if (n.name () == "TT" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TTType > r (
          TTTraits::create (i, f, this));

        if (!TT_.present ())
        {
          this->TT_.set (r);
          continue;
        }
      }

      // TTI
      //
      if (n.name () == "TTI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TTIType > r (
          TTITraits::create (i, f, this));

        if (!TTI_.present ())
        {
          this->TTI_.set (r);
          continue;
        }
      }

      break;
    }

    if (!TT_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TT",
        "http://www.wldelft.nl/fews");
    }

    if (!TTI_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TTI",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVParameterInputComplexType* HBVParameterInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVParameterInputComplexType (*this, f, c);
  }

  HBVParameterInputComplexType::
  ~HBVParameterInputComplexType ()
  {
  }

  // HBVParameterSnowComplexType
  //

  HBVParameterSnowComplexType::
  HBVParameterSnowComplexType (const CFMAXType& CFMAX,
                               const CFRType& CFR,
                               const CWHType& CWH,
                               const TTMType& TTM)
  : ::xml_schema::Type (),
    CFMAX_ (CFMAX, ::xml_schema::Flags (), this),
    CFR_ (CFR, ::xml_schema::Flags (), this),
    CWH_ (CWH, ::xml_schema::Flags (), this),
    TTM_ (TTM, ::xml_schema::Flags (), this)
  {
  }

  HBVParameterSnowComplexType::
  HBVParameterSnowComplexType (const HBVParameterSnowComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CFMAX_ (x.CFMAX_, f, this),
    CFR_ (x.CFR_, f, this),
    CWH_ (x.CWH_, f, this),
    TTM_ (x.TTM_, f, this)
  {
  }

  HBVParameterSnowComplexType::
  HBVParameterSnowComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CFMAX_ (f, this),
    CFR_ (f, this),
    CWH_ (f, this),
    TTM_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVParameterSnowComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CFMAX
      //
      if (n.name () == "CFMAX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFMAXType > r (
          CFMAXTraits::create (i, f, this));

        if (!CFMAX_.present ())
        {
          this->CFMAX_.set (r);
          continue;
        }
      }

      // CFR
      //
      if (n.name () == "CFR" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFRType > r (
          CFRTraits::create (i, f, this));

        if (!CFR_.present ())
        {
          this->CFR_.set (r);
          continue;
        }
      }

      // CWH
      //
      if (n.name () == "CWH" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CWHType > r (
          CWHTraits::create (i, f, this));

        if (!CWH_.present ())
        {
          this->CWH_.set (r);
          continue;
        }
      }

      // TTM
      //
      if (n.name () == "TTM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TTMType > r (
          TTMTraits::create (i, f, this));

        if (!TTM_.present ())
        {
          this->TTM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!CFMAX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFMAX",
        "http://www.wldelft.nl/fews");
    }

    if (!CFR_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFR",
        "http://www.wldelft.nl/fews");
    }

    if (!CWH_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CWH",
        "http://www.wldelft.nl/fews");
    }

    if (!TTM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TTM",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVParameterSnowComplexType* HBVParameterSnowComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVParameterSnowComplexType (*this, f, c);
  }

  HBVParameterSnowComplexType::
  ~HBVParameterSnowComplexType ()
  {
  }

  // HBVParameterInterceptionComplexType
  //

  HBVParameterInterceptionComplexType::
  HBVParameterInterceptionComplexType (const LICType& LIC)
  : ::xml_schema::Type (),
    LIC_ (LIC, ::xml_schema::Flags (), this)
  {
  }

  HBVParameterInterceptionComplexType::
  HBVParameterInterceptionComplexType (const HBVParameterInterceptionComplexType& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    LIC_ (x.LIC_, f, this)
  {
  }

  HBVParameterInterceptionComplexType::
  HBVParameterInterceptionComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    LIC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVParameterInterceptionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LIC
      //
      if (n.name () == "LIC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LICType > r (
          LICTraits::create (i, f, this));

        if (!LIC_.present ())
        {
          this->LIC_.set (r);
          continue;
        }
      }

      break;
    }

    if (!LIC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LIC",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVParameterInterceptionComplexType* HBVParameterInterceptionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVParameterInterceptionComplexType (*this, f, c);
  }

  HBVParameterInterceptionComplexType::
  ~HBVParameterInterceptionComplexType ()
  {
  }

  // HBVParameterSoilComplexType
  //

  HBVParameterSoilComplexType::
  HBVParameterSoilComplexType (const BETAType& BETA,
                               const CFLUXType& CFLUX,
                               const ETFType& ETF,
                               const FCType& FC,
                               const LPType& LP)
  : ::xml_schema::Type (),
    BETA_ (BETA, ::xml_schema::Flags (), this),
    CFLUX_ (CFLUX, ::xml_schema::Flags (), this),
    ETF_ (ETF, ::xml_schema::Flags (), this),
    FC_ (FC, ::xml_schema::Flags (), this),
    LP_ (LP, ::xml_schema::Flags (), this)
  {
  }

  HBVParameterSoilComplexType::
  HBVParameterSoilComplexType (const HBVParameterSoilComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    BETA_ (x.BETA_, f, this),
    CFLUX_ (x.CFLUX_, f, this),
    ETF_ (x.ETF_, f, this),
    FC_ (x.FC_, f, this),
    LP_ (x.LP_, f, this)
  {
  }

  HBVParameterSoilComplexType::
  HBVParameterSoilComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    BETA_ (f, this),
    CFLUX_ (f, this),
    ETF_ (f, this),
    FC_ (f, this),
    LP_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVParameterSoilComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BETA
      //
      if (n.name () == "BETA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BETAType > r (
          BETATraits::create (i, f, this));

        if (!BETA_.present ())
        {
          this->BETA_.set (r);
          continue;
        }
      }

      // CFLUX
      //
      if (n.name () == "CFLUX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFLUXType > r (
          CFLUXTraits::create (i, f, this));

        if (!CFLUX_.present ())
        {
          this->CFLUX_.set (r);
          continue;
        }
      }

      // ETF
      //
      if (n.name () == "ETF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ETFType > r (
          ETFTraits::create (i, f, this));

        if (!ETF_.present ())
        {
          this->ETF_.set (r);
          continue;
        }
      }

      // FC
      //
      if (n.name () == "FC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FCType > r (
          FCTraits::create (i, f, this));

        if (!FC_.present ())
        {
          this->FC_.set (r);
          continue;
        }
      }

      // LP
      //
      if (n.name () == "LP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LPType > r (
          LPTraits::create (i, f, this));

        if (!LP_.present ())
        {
          this->LP_.set (r);
          continue;
        }
      }

      break;
    }

    if (!BETA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "BETA",
        "http://www.wldelft.nl/fews");
    }

    if (!CFLUX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFLUX",
        "http://www.wldelft.nl/fews");
    }

    if (!ETF_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ETF",
        "http://www.wldelft.nl/fews");
    }

    if (!FC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FC",
        "http://www.wldelft.nl/fews");
    }

    if (!LP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LP",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVParameterSoilComplexType* HBVParameterSoilComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVParameterSoilComplexType (*this, f, c);
  }

  HBVParameterSoilComplexType::
  ~HBVParameterSoilComplexType ()
  {
  }

  // HBVParameterResponseComplexType
  //

  HBVParameterResponseComplexType::
  HBVParameterResponseComplexType (const ALPHAType& ALPHA,
                                   const AREAType& AREA,
                                   const KType& K,
                                   const K1Type& K1,
                                   const PERCType& PERC)
  : ::xml_schema::Type (),
    ALPHA_ (ALPHA, ::xml_schema::Flags (), this),
    AREA_ (AREA, ::xml_schema::Flags (), this),
    K_ (K, ::xml_schema::Flags (), this),
    K1_ (K1, ::xml_schema::Flags (), this),
    PERC_ (PERC, ::xml_schema::Flags (), this)
  {
  }

  HBVParameterResponseComplexType::
  HBVParameterResponseComplexType (const HBVParameterResponseComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ALPHA_ (x.ALPHA_, f, this),
    AREA_ (x.AREA_, f, this),
    K_ (x.K_, f, this),
    K1_ (x.K1_, f, this),
    PERC_ (x.PERC_, f, this)
  {
  }

  HBVParameterResponseComplexType::
  HBVParameterResponseComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ALPHA_ (f, this),
    AREA_ (f, this),
    K_ (f, this),
    K1_ (f, this),
    PERC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVParameterResponseComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ALPHA
      //
      if (n.name () == "ALPHA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ALPHAType > r (
          ALPHATraits::create (i, f, this));

        if (!ALPHA_.present ())
        {
          this->ALPHA_.set (r);
          continue;
        }
      }

      // AREA
      //
      if (n.name () == "AREA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AREAType > r (
          AREATraits::create (i, f, this));

        if (!AREA_.present ())
        {
          this->AREA_.set (r);
          continue;
        }
      }

      // K
      //
      if (n.name () == "K" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< KType > r (
          KTraits::create (i, f, this));

        if (!K_.present ())
        {
          this->K_.set (r);
          continue;
        }
      }

      // K1
      //
      if (n.name () == "K1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< K1Type > r (
          K1Traits::create (i, f, this));

        if (!K1_.present ())
        {
          this->K1_.set (r);
          continue;
        }
      }

      // PERC
      //
      if (n.name () == "PERC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PERCType > r (
          PERCTraits::create (i, f, this));

        if (!PERC_.present ())
        {
          this->PERC_.set (r);
          continue;
        }
      }

      break;
    }

    if (!ALPHA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ALPHA",
        "http://www.wldelft.nl/fews");
    }

    if (!AREA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AREA",
        "http://www.wldelft.nl/fews");
    }

    if (!K_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "K",
        "http://www.wldelft.nl/fews");
    }

    if (!K1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "K1",
        "http://www.wldelft.nl/fews");
    }

    if (!PERC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PERC",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVParameterResponseComplexType* HBVParameterResponseComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVParameterResponseComplexType (*this, f, c);
  }

  HBVParameterResponseComplexType::
  ~HBVParameterResponseComplexType ()
  {
  }

  // HBVInputComplexType
  //

  HBVInputComplexType::
  HBVInputComplexType (const EPType& EP,
                       const PType& P,
                       const TType& T,
                       const TMType& TM)
  : ::xml_schema::Type (),
    EP_ (EP, ::xml_schema::Flags (), this),
    P_ (P, ::xml_schema::Flags (), this),
    T_ (T, ::xml_schema::Flags (), this),
    TM_ (TM, ::xml_schema::Flags (), this)
  {
  }

  HBVInputComplexType::
  HBVInputComplexType (const HBVInputComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EP_ (x.EP_, f, this),
    P_ (x.P_, f, this),
    T_ (x.T_, f, this),
    TM_ (x.TM_, f, this)
  {
  }

  HBVInputComplexType::
  HBVInputComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EP_ (f, this),
    P_ (f, this),
    T_ (f, this),
    TM_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EP
      //
      if (n.name () == "EP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPType > r (
          EPTraits::create (i, f, this));

        if (!EP_.present ())
        {
          this->EP_.set (r);
          continue;
        }
      }

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PType > r (
          PTraits::create (i, f, this));

        if (!P_.present ())
        {
          this->P_.set (r);
          continue;
        }
      }

      // T
      //
      if (n.name () == "T" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TType > r (
          TTraits::create (i, f, this));

        if (!T_.present ())
        {
          this->T_.set (r);
          continue;
        }
      }

      // TM
      //
      if (n.name () == "TM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TMType > r (
          TMTraits::create (i, f, this));

        if (!TM_.present ())
        {
          this->TM_.set (r);
          continue;
        }
      }

      break;
    }

    if (!EP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EP",
        "http://www.wldelft.nl/fews");
    }

    if (!P_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "P",
        "http://www.wldelft.nl/fews");
    }

    if (!T_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "T",
        "http://www.wldelft.nl/fews");
    }

    if (!TM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TM",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVInputComplexType* HBVInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVInputComplexType (*this, f, c);
  }

  HBVInputComplexType::
  ~HBVInputComplexType ()
  {
  }

  // HBVLinkComplexType
  //

  HBVLinkComplexType::
  HBVLinkComplexType (const CFType& CF,
                      const EAType& EA,
                      const EIType& EI,
                      const EPType& EP,
                      const INType& IN,
                      const INIType& INI,
                      const PERCType& PERC,
                      const RType& R)
  : ::xml_schema::Type (),
    CF_ (CF, ::xml_schema::Flags (), this),
    EA_ (EA, ::xml_schema::Flags (), this),
    EI_ (EI, ::xml_schema::Flags (), this),
    EP_ (EP, ::xml_schema::Flags (), this),
    IN_ (IN, ::xml_schema::Flags (), this),
    INI_ (INI, ::xml_schema::Flags (), this),
    PERC_ (PERC, ::xml_schema::Flags (), this),
    R_ (R, ::xml_schema::Flags (), this)
  {
  }

  HBVLinkComplexType::
  HBVLinkComplexType (const HBVLinkComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CF_ (x.CF_, f, this),
    EA_ (x.EA_, f, this),
    EI_ (x.EI_, f, this),
    EP_ (x.EP_, f, this),
    IN_ (x.IN_, f, this),
    INI_ (x.INI_, f, this),
    PERC_ (x.PERC_, f, this),
    R_ (x.R_, f, this)
  {
  }

  HBVLinkComplexType::
  HBVLinkComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CF_ (f, this),
    EA_ (f, this),
    EI_ (f, this),
    EP_ (f, this),
    IN_ (f, this),
    INI_ (f, this),
    PERC_ (f, this),
    R_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVLinkComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CF
      //
      if (n.name () == "CF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CFType > r (
          CFTraits::create (i, f, this));

        if (!CF_.present ())
        {
          this->CF_.set (r);
          continue;
        }
      }

      // EA
      //
      if (n.name () == "EA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EAType > r (
          EATraits::create (i, f, this));

        if (!EA_.present ())
        {
          this->EA_.set (r);
          continue;
        }
      }

      // EI
      //
      if (n.name () == "EI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EIType > r (
          EITraits::create (i, f, this));

        if (!EI_.present ())
        {
          this->EI_.set (r);
          continue;
        }
      }

      // EP
      //
      if (n.name () == "EP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EPType > r (
          EPTraits::create (i, f, this));

        if (!EP_.present ())
        {
          this->EP_.set (r);
          continue;
        }
      }

      // IN
      //
      if (n.name () == "IN" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< INType > r (
          INTraits::create (i, f, this));

        if (!IN_.present ())
        {
          this->IN_.set (r);
          continue;
        }
      }

      // INI
      //
      if (n.name () == "INI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< INIType > r (
          INITraits::create (i, f, this));

        if (!INI_.present ())
        {
          this->INI_.set (r);
          continue;
        }
      }

      // PERC
      //
      if (n.name () == "PERC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PERCType > r (
          PERCTraits::create (i, f, this));

        if (!PERC_.present ())
        {
          this->PERC_.set (r);
          continue;
        }
      }

      // R
      //
      if (n.name () == "R" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RType > r (
          RTraits::create (i, f, this));

        if (!R_.present ())
        {
          this->R_.set (r);
          continue;
        }
      }

      break;
    }

    if (!CF_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CF",
        "http://www.wldelft.nl/fews");
    }

    if (!EA_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EA",
        "http://www.wldelft.nl/fews");
    }

    if (!EI_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EI",
        "http://www.wldelft.nl/fews");
    }

    if (!EP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EP",
        "http://www.wldelft.nl/fews");
    }

    if (!IN_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IN",
        "http://www.wldelft.nl/fews");
    }

    if (!INI_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "INI",
        "http://www.wldelft.nl/fews");
    }

    if (!PERC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PERC",
        "http://www.wldelft.nl/fews");
    }

    if (!R_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "R",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVLinkComplexType* HBVLinkComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVLinkComplexType (*this, f, c);
  }

  HBVLinkComplexType::
  ~HBVLinkComplexType ()
  {
  }

  // HBVStateComplexType
  //

  HBVStateComplexType::
  HBVStateComplexType (const ICType& IC,
                       const LZType& LZ,
                       const SMType& SM,
                       const SPType& SP,
                       const UZType& UZ,
                       const WCType& WC)
  : ::xml_schema::Type (),
    IC_ (IC, ::xml_schema::Flags (), this),
    LZ_ (LZ, ::xml_schema::Flags (), this),
    SM_ (SM, ::xml_schema::Flags (), this),
    SP_ (SP, ::xml_schema::Flags (), this),
    UZ_ (UZ, ::xml_schema::Flags (), this),
    WC_ (WC, ::xml_schema::Flags (), this)
  {
  }

  HBVStateComplexType::
  HBVStateComplexType (const HBVStateComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    IC_ (x.IC_, f, this),
    LZ_ (x.LZ_, f, this),
    SM_ (x.SM_, f, this),
    SP_ (x.SP_, f, this),
    UZ_ (x.UZ_, f, this),
    WC_ (x.WC_, f, this)
  {
  }

  HBVStateComplexType::
  HBVStateComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    IC_ (f, this),
    LZ_ (f, this),
    SM_ (f, this),
    SP_ (f, this),
    UZ_ (f, this),
    WC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVStateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IC
      //
      if (n.name () == "IC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ICType > r (
          ICTraits::create (i, f, this));

        if (!IC_.present ())
        {
          this->IC_.set (r);
          continue;
        }
      }

      // LZ
      //
      if (n.name () == "LZ" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LZType > r (
          LZTraits::create (i, f, this));

        if (!LZ_.present ())
        {
          this->LZ_.set (r);
          continue;
        }
      }

      // SM
      //
      if (n.name () == "SM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SMType > r (
          SMTraits::create (i, f, this));

        if (!SM_.present ())
        {
          this->SM_.set (r);
          continue;
        }
      }

      // SP
      //
      if (n.name () == "SP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SPType > r (
          SPTraits::create (i, f, this));

        if (!SP_.present ())
        {
          this->SP_.set (r);
          continue;
        }
      }

      // UZ
      //
      if (n.name () == "UZ" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UZType > r (
          UZTraits::create (i, f, this));

        if (!UZ_.present ())
        {
          this->UZ_.set (r);
          continue;
        }
      }

      // WC
      //
      if (n.name () == "WC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WCType > r (
          WCTraits::create (i, f, this));

        if (!WC_.present ())
        {
          this->WC_.set (r);
          continue;
        }
      }

      break;
    }

    if (!IC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IC",
        "http://www.wldelft.nl/fews");
    }

    if (!LZ_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LZ",
        "http://www.wldelft.nl/fews");
    }

    if (!SM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SM",
        "http://www.wldelft.nl/fews");
    }

    if (!SP_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SP",
        "http://www.wldelft.nl/fews");
    }

    if (!UZ_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "UZ",
        "http://www.wldelft.nl/fews");
    }

    if (!WC_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "WC",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVStateComplexType* HBVStateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVStateComplexType (*this, f, c);
  }

  HBVStateComplexType::
  ~HBVStateComplexType ()
  {
  }

  // HBVStateUpdateComplexType
  //

  HBVStateUpdateComplexType::
  HBVStateUpdateComplexType ()
  : ::xml_schema::Type (),
    IC_ (::xml_schema::Flags (), this),
    LZ_ (::xml_schema::Flags (), this),
    SM_ (::xml_schema::Flags (), this),
    SP_ (::xml_schema::Flags (), this),
    UZ_ (::xml_schema::Flags (), this),
    WC_ (::xml_schema::Flags (), this)
  {
  }

  HBVStateUpdateComplexType::
  HBVStateUpdateComplexType (const HBVStateUpdateComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    IC_ (x.IC_, f, this),
    LZ_ (x.LZ_, f, this),
    SM_ (x.SM_, f, this),
    SP_ (x.SP_, f, this),
    UZ_ (x.UZ_, f, this),
    WC_ (x.WC_, f, this)
  {
  }

  HBVStateUpdateComplexType::
  HBVStateUpdateComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    IC_ (f, this),
    LZ_ (f, this),
    SM_ (f, this),
    SP_ (f, this),
    UZ_ (f, this),
    WC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVStateUpdateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IC
      //
      if (n.name () == "IC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ICType > r (
          ICTraits::create (i, f, this));

        if (!this->IC_)
        {
          this->IC_.set (r);
          continue;
        }
      }

      // LZ
      //
      if (n.name () == "LZ" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LZType > r (
          LZTraits::create (i, f, this));

        if (!this->LZ_)
        {
          this->LZ_.set (r);
          continue;
        }
      }

      // SM
      //
      if (n.name () == "SM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SMType > r (
          SMTraits::create (i, f, this));

        if (!this->SM_)
        {
          this->SM_.set (r);
          continue;
        }
      }

      // SP
      //
      if (n.name () == "SP" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SPType > r (
          SPTraits::create (i, f, this));

        if (!this->SP_)
        {
          this->SP_.set (r);
          continue;
        }
      }

      // UZ
      //
      if (n.name () == "UZ" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UZType > r (
          UZTraits::create (i, f, this));

        if (!this->UZ_)
        {
          this->UZ_.set (r);
          continue;
        }
      }

      // WC
      //
      if (n.name () == "WC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WCType > r (
          WCTraits::create (i, f, this));

        if (!this->WC_)
        {
          this->WC_.set (r);
          continue;
        }
      }

      break;
    }
  }

  HBVStateUpdateComplexType* HBVStateUpdateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVStateUpdateComplexType (*this, f, c);
  }

  HBVStateUpdateComplexType::
  ~HBVStateUpdateComplexType ()
  {
  }

  // HBVOutputComplexType
  //

  HBVOutputComplexType::
  HBVOutputComplexType (const QType& Q)
  : ::xml_schema::Type (),
    Q_ (Q, ::xml_schema::Flags (), this),
    SMPercentage_ (::xml_schema::Flags (), this),
    SWE_ (::xml_schema::Flags (), this)
  {
  }

  HBVOutputComplexType::
  HBVOutputComplexType (const HBVOutputComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Q_ (x.Q_, f, this),
    SMPercentage_ (x.SMPercentage_, f, this),
    SWE_ (x.SWE_, f, this)
  {
  }

  HBVOutputComplexType::
  HBVOutputComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Q_ (f, this),
    SMPercentage_ (f, this),
    SWE_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HBVOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      // SMPercentage
      //
      if (n.name () == "SMPercentage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SMPercentageType > r (
          SMPercentageTraits::create (i, f, this));

        if (!this->SMPercentage_)
        {
          this->SMPercentage_.set (r);
          continue;
        }
      }

      // SWE
      //
      if (n.name () == "SWE" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SWEType > r (
          SWETraits::create (i, f, this));

        if (!this->SWE_)
        {
          this->SWE_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  HBVOutputComplexType* HBVOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HBVOutputComplexType (*this, f, c);
  }

  HBVOutputComplexType::
  ~HBVOutputComplexType ()
  {
  }

  // SRMComplexType
  //

  SRMComplexType::
  SRMComplexType (const ParameterType& parameter,
                  const InputType& input,
                  const StateType& state,
                  const OutputType& output,
                  const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    parameterZone_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SRMComplexType::
  SRMComplexType (::std::auto_ptr< ParameterType >& parameter,
                  ::std::auto_ptr< InputType >& input,
                  ::std::auto_ptr< StateType >& state,
                  ::std::auto_ptr< OutputType >& output,
                  const IdType& id)
  : ::xml_schema::Type (),
    parameter_ (parameter, ::xml_schema::Flags (), this),
    parameterZone_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SRMComplexType::
  SRMComplexType (const SRMComplexType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    parameterZone_ (x.parameterZone_, f, this),
    input_ (x.input_, f, this),
    state_ (x.state_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  SRMComplexType::
  SRMComplexType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (f, this),
    parameterZone_ (f, this),
    input_ (f, this),
    state_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SRMComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        if (!parameter_.present ())
        {
          this->parameter_.set (r);
          continue;
        }
      }

      // parameterZone
      //
      if (n.name () == "parameterZone" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterZoneType > r (
          ParameterZoneTraits::create (i, f, this));

        this->parameterZone_.push_back (r);
        continue;
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!state_.present ())
        {
          this->state_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!parameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!state_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "state",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  SRMComplexType* SRMComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SRMComplexType (*this, f, c);
  }

  SRMComplexType::
  ~SRMComplexType ()
  {
  }

  // SRMParameterComplexType
  //

  SRMParameterComplexType::
  SRMParameterComplexType (const PtType& Pt,
                           const TLagType& TLag,
                           const XType& x,
                           const YType& y)
  : ::xml_schema::Type (),
    Pt_ (Pt, ::xml_schema::Flags (), this),
    TLag_ (TLag, ::xml_schema::Flags (), this),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  SRMParameterComplexType::
  SRMParameterComplexType (const SRMParameterComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Pt_ (x.Pt_, f, this),
    TLag_ (x.TLag_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  SRMParameterComplexType::
  SRMParameterComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Pt_ (f, this),
    TLag_ (f, this),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SRMParameterComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Pt
      //
      if (n.name () == "Pt" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PtType > r (
          PtTraits::create (i, f, this));

        if (!Pt_.present ())
        {
          this->Pt_.set (r);
          continue;
        }
      }

      // TLag
      //
      if (n.name () == "TLag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TLagType > r (
          TLagTraits::create (i, f, this));

        if (!TLag_.present ())
        {
          this->TLag_.set (r);
          continue;
        }
      }

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Pt_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Pt",
        "http://www.wldelft.nl/fews");
    }

    if (!TLag_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TLag",
        "http://www.wldelft.nl/fews");
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  SRMParameterComplexType* SRMParameterComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SRMParameterComplexType (*this, f, c);
  }

  SRMParameterComplexType::
  ~SRMParameterComplexType ()
  {
  }

  // SRMParameterZoneComplexType
  //

  SRMParameterZoneComplexType::
  SRMParameterZoneComplexType (const AType& a,
                               const AreaType& area,
                               const Tcr1Type& Tcr1,
                               const Tcr2Type& Tcr2)
  : ::xml_schema::Type (),
    a_ (a, ::xml_schema::Flags (), this),
    area_ (area, ::xml_schema::Flags (), this),
    Tcr1_ (Tcr1, ::xml_schema::Flags (), this),
    Tcr2_ (Tcr2, ::xml_schema::Flags (), this),
    id_ (::xml_schema::Flags (), this)
  {
  }

  SRMParameterZoneComplexType::
  SRMParameterZoneComplexType (const SRMParameterZoneComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a_ (x.a_, f, this),
    area_ (x.area_, f, this),
    Tcr1_ (x.Tcr1_, f, this),
    Tcr2_ (x.Tcr2_, f, this),
    id_ (x.id_, f, this)
  {
  }

  SRMParameterZoneComplexType::
  SRMParameterZoneComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a_ (f, this),
    area_ (f, this),
    Tcr1_ (f, this),
    Tcr2_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SRMParameterZoneComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // a
      //
      if (n.name () == "a" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AType > r (
          ATraits::create (i, f, this));

        if (!a_.present ())
        {
          this->a_.set (r);
          continue;
        }
      }

      // area
      //
      if (n.name () == "area" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AreaType > r (
          AreaTraits::create (i, f, this));

        if (!area_.present ())
        {
          this->area_.set (r);
          continue;
        }
      }

      // Tcr1
      //
      if (n.name () == "Tcr1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Tcr1Type > r (
          Tcr1Traits::create (i, f, this));

        if (!Tcr1_.present ())
        {
          this->Tcr1_.set (r);
          continue;
        }
      }

      // Tcr2
      //
      if (n.name () == "Tcr2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Tcr2Type > r (
          Tcr2Traits::create (i, f, this));

        if (!Tcr2_.present ())
        {
          this->Tcr2_.set (r);
          continue;
        }
      }

      break;
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a",
        "http://www.wldelft.nl/fews");
    }

    if (!area_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "area",
        "http://www.wldelft.nl/fews");
    }

    if (!Tcr1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Tcr1",
        "http://www.wldelft.nl/fews");
    }

    if (!Tcr2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Tcr2",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }
  }

  SRMParameterZoneComplexType* SRMParameterZoneComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SRMParameterZoneComplexType (*this, f, c);
  }

  SRMParameterZoneComplexType::
  ~SRMParameterZoneComplexType ()
  {
  }

  // SRMInputComplexType
  //

  SRMInputComplexType::
  SRMInputComplexType ()
  : ::xml_schema::Type (),
    P_ (::xml_schema::Flags (), this),
    P_Vector_ (::xml_schema::Flags (), this),
    T_ (::xml_schema::Flags (), this),
    T_Vector_ (::xml_schema::Flags (), this),
    SCA_ (::xml_schema::Flags (), this),
    SCA_Vector_ (::xml_schema::Flags (), this),
    RCA_ (::xml_schema::Flags (), this),
    RCA_Vector_ (::xml_schema::Flags (), this),
    cr_ (::xml_schema::Flags (), this),
    cr_Vector_ (::xml_schema::Flags (), this),
    cs_ (::xml_schema::Flags (), this),
    cs_Vector_ (::xml_schema::Flags (), this)
  {
  }

  SRMInputComplexType::
  SRMInputComplexType (const SRMInputComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    P_ (x.P_, f, this),
    P_Vector_ (x.P_Vector_, f, this),
    T_ (x.T_, f, this),
    T_Vector_ (x.T_Vector_, f, this),
    SCA_ (x.SCA_, f, this),
    SCA_Vector_ (x.SCA_Vector_, f, this),
    RCA_ (x.RCA_, f, this),
    RCA_Vector_ (x.RCA_Vector_, f, this),
    cr_ (x.cr_, f, this),
    cr_Vector_ (x.cr_Vector_, f, this),
    cs_ (x.cs_, f, this),
    cs_Vector_ (x.cs_Vector_, f, this)
  {
  }

  SRMInputComplexType::
  SRMInputComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    P_ (f, this),
    P_Vector_ (f, this),
    T_ (f, this),
    T_Vector_ (f, this),
    SCA_ (f, this),
    SCA_Vector_ (f, this),
    RCA_ (f, this),
    RCA_Vector_ (f, this),
    cr_ (f, this),
    cr_Vector_ (f, this),
    cs_ (f, this),
    cs_Vector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SRMInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PType > r (
          PTraits::create (i, f, this));

        if (!this->P_)
        {
          this->P_.set (r);
          continue;
        }
      }

      // P-Vector
      //
      if (n.name () == "P-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< P_VectorType > r (
          P_VectorTraits::create (i, f, this));

        if (!this->P_Vector_)
        {
          this->P_Vector_.set (r);
          continue;
        }
      }

      // T
      //
      if (n.name () == "T" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TType > r (
          TTraits::create (i, f, this));

        if (!this->T_)
        {
          this->T_.set (r);
          continue;
        }
      }

      // T-Vector
      //
      if (n.name () == "T-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< T_VectorType > r (
          T_VectorTraits::create (i, f, this));

        if (!this->T_Vector_)
        {
          this->T_Vector_.set (r);
          continue;
        }
      }

      // SCA
      //
      if (n.name () == "SCA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SCAType > r (
          SCATraits::create (i, f, this));

        if (!this->SCA_)
        {
          this->SCA_.set (r);
          continue;
        }
      }

      // SCA-Vector
      //
      if (n.name () == "SCA-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SCA_VectorType > r (
          SCA_VectorTraits::create (i, f, this));

        if (!this->SCA_Vector_)
        {
          this->SCA_Vector_.set (r);
          continue;
        }
      }

      // RCA
      //
      if (n.name () == "RCA" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RCAType > r (
          RCATraits::create (i, f, this));

        if (!this->RCA_)
        {
          this->RCA_.set (r);
          continue;
        }
      }

      // RCA-Vector
      //
      if (n.name () == "RCA-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RCA_VectorType > r (
          RCA_VectorTraits::create (i, f, this));

        if (!this->RCA_Vector_)
        {
          this->RCA_Vector_.set (r);
          continue;
        }
      }

      // cr
      //
      if (n.name () == "cr" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CrType > r (
          CrTraits::create (i, f, this));

        if (!this->cr_)
        {
          this->cr_.set (r);
          continue;
        }
      }

      // cr-Vector
      //
      if (n.name () == "cr-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Cr_VectorType > r (
          Cr_VectorTraits::create (i, f, this));

        if (!this->cr_Vector_)
        {
          this->cr_Vector_.set (r);
          continue;
        }
      }

      // cs
      //
      if (n.name () == "cs" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CsType > r (
          CsTraits::create (i, f, this));

        if (!this->cs_)
        {
          this->cs_.set (r);
          continue;
        }
      }

      // cs-Vector
      //
      if (n.name () == "cs-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Cs_VectorType > r (
          Cs_VectorTraits::create (i, f, this));

        if (!this->cs_Vector_)
        {
          this->cs_Vector_.set (r);
          continue;
        }
      }

      break;
    }
  }

  SRMInputComplexType* SRMInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SRMInputComplexType (*this, f, c);
  }

  SRMInputComplexType::
  ~SRMInputComplexType ()
  {
  }

  // SRMStateComplexType
  //

  SRMStateComplexType::
  SRMStateComplexType (const PStorage_VectorType& PStorage_Vector,
                       const QType& Q)
  : ::xml_schema::Type (),
    PStorage_Vector_ (PStorage_Vector, ::xml_schema::Flags (), this),
    Q_ (Q, ::xml_schema::Flags (), this)
  {
  }

  SRMStateComplexType::
  SRMStateComplexType (const SRMStateComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PStorage_Vector_ (x.PStorage_Vector_, f, this),
    Q_ (x.Q_, f, this)
  {
  }

  SRMStateComplexType::
  SRMStateComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PStorage_Vector_ (f, this),
    Q_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SRMStateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PStorage-Vector
      //
      if (n.name () == "PStorage-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PStorage_VectorType > r (
          PStorage_VectorTraits::create (i, f, this));

        if (!PStorage_Vector_.present ())
        {
          this->PStorage_Vector_.set (r);
          continue;
        }
      }

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      break;
    }

    if (!PStorage_Vector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PStorage-Vector",
        "http://www.wldelft.nl/fews");
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  SRMStateComplexType* SRMStateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SRMStateComplexType (*this, f, c);
  }

  SRMStateComplexType::
  ~SRMStateComplexType ()
  {
  }

  // SRMOutputComplexType
  //

  SRMOutputComplexType::
  SRMOutputComplexType (const QRain_VectorType& QRain_Vector,
                        const QSnow_VectorType& QSnow_Vector,
                        const QStorage_VectorType& QStorage_Vector)
  : ::xml_schema::Type (),
    QRain_Vector_ (QRain_Vector, ::xml_schema::Flags (), this),
    QSnow_Vector_ (QSnow_Vector, ::xml_schema::Flags (), this),
    QStorage_Vector_ (QStorage_Vector, ::xml_schema::Flags (), this)
  {
  }

  SRMOutputComplexType::
  SRMOutputComplexType (const SRMOutputComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    QRain_Vector_ (x.QRain_Vector_, f, this),
    QSnow_Vector_ (x.QSnow_Vector_, f, this),
    QStorage_Vector_ (x.QStorage_Vector_, f, this)
  {
  }

  SRMOutputComplexType::
  SRMOutputComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    QRain_Vector_ (f, this),
    QSnow_Vector_ (f, this),
    QStorage_Vector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SRMOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // QRain-Vector
      //
      if (n.name () == "QRain-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QRain_VectorType > r (
          QRain_VectorTraits::create (i, f, this));

        if (!QRain_Vector_.present ())
        {
          this->QRain_Vector_.set (r);
          continue;
        }
      }

      // QSnow-Vector
      //
      if (n.name () == "QSnow-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSnow_VectorType > r (
          QSnow_VectorTraits::create (i, f, this));

        if (!QSnow_Vector_.present ())
        {
          this->QSnow_Vector_.set (r);
          continue;
        }
      }

      // QStorage-Vector
      //
      if (n.name () == "QStorage-Vector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QStorage_VectorType > r (
          QStorage_VectorTraits::create (i, f, this));

        if (!QStorage_Vector_.present ())
        {
          this->QStorage_Vector_.set (r);
          continue;
        }
      }

      break;
    }

    if (!QRain_Vector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QRain-Vector",
        "http://www.wldelft.nl/fews");
    }

    if (!QSnow_Vector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QSnow-Vector",
        "http://www.wldelft.nl/fews");
    }

    if (!QStorage_Vector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QStorage-Vector",
        "http://www.wldelft.nl/fews");
    }
  }

  SRMOutputComplexType* SRMOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SRMOutputComplexType (*this, f, c);
  }

  SRMOutputComplexType::
  ~SRMOutputComplexType ()
  {
  }

  // UnitDelayComplexType
  //

  UnitDelayComplexType::
  UnitDelayComplexType (const InputType& input,
                        const OutputType& output,
                        const IdType& id)
  : ::xml_schema::Type (),
    nStep_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  UnitDelayComplexType::
  UnitDelayComplexType (::std::auto_ptr< InputType >& input,
                        ::std::auto_ptr< OutputType >& output,
                        const IdType& id)
  : ::xml_schema::Type (),
    nStep_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  UnitDelayComplexType::
  UnitDelayComplexType (const UnitDelayComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nStep_ (x.nStep_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  UnitDelayComplexType::
  UnitDelayComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nStep_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void UnitDelayComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nStep
      //
      if (n.name () == "nStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepType > r (
          NStepTraits::create (i, f, this));

        if (!this->nStep_)
        {
          this->nStep_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  UnitDelayComplexType* UnitDelayComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitDelayComplexType (*this, f, c);
  }

  UnitDelayComplexType::
  ~UnitDelayComplexType ()
  {
  }

  // UnitDelayInputComplexType
  //

  UnitDelayInputComplexType::
  UnitDelayInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  UnitDelayInputComplexType::
  UnitDelayInputComplexType (const UnitDelayInputComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  UnitDelayInputComplexType::
  UnitDelayInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitDelayInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  UnitDelayInputComplexType* UnitDelayInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitDelayInputComplexType (*this, f, c);
  }

  UnitDelayInputComplexType::
  ~UnitDelayInputComplexType ()
  {
  }

  // UnitDelayOutputComplexType
  //

  UnitDelayOutputComplexType::
  UnitDelayOutputComplexType ()
  : ::xml_schema::Type (),
    y_ (::xml_schema::Flags (), this),
    yVector_ (::xml_schema::Flags (), this),
    yFinal_ (::xml_schema::Flags (), this),
    yMin_ (::xml_schema::Flags (), this),
    yMean_ (::xml_schema::Flags (), this),
    yMax_ (::xml_schema::Flags (), this),
    ySum_ (::xml_schema::Flags (), this)
  {
  }

  UnitDelayOutputComplexType::
  UnitDelayOutputComplexType (const UnitDelayOutputComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this),
    yVector_ (x.yVector_, f, this),
    yFinal_ (x.yFinal_, f, this),
    yMin_ (x.yMin_, f, this),
    yMean_ (x.yMean_, f, this),
    yMax_ (x.yMax_, f, this),
    ySum_ (x.ySum_, f, this)
  {
  }

  UnitDelayOutputComplexType::
  UnitDelayOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this),
    yVector_ (f, this),
    yFinal_ (f, this),
    yMin_ (f, this),
    yMean_ (f, this),
    yMax_ (f, this),
    ySum_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitDelayOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        this->y_.push_back (r);
        continue;
      }

      // yVector
      //
      if (n.name () == "yVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YVectorType > r (
          YVectorTraits::create (i, f, this));

        if (!this->yVector_)
        {
          this->yVector_.set (r);
          continue;
        }
      }

      // yFinal
      //
      if (n.name () == "yFinal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YFinalType > r (
          YFinalTraits::create (i, f, this));

        if (!this->yFinal_)
        {
          this->yFinal_.set (r);
          continue;
        }
      }

      // yMin
      //
      if (n.name () == "yMin" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YMinType > r (
          YMinTraits::create (i, f, this));

        if (!this->yMin_)
        {
          this->yMin_.set (r);
          continue;
        }
      }

      // yMean
      //
      if (n.name () == "yMean" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YMeanType > r (
          YMeanTraits::create (i, f, this));

        if (!this->yMean_)
        {
          this->yMean_.set (r);
          continue;
        }
      }

      // yMax
      //
      if (n.name () == "yMax" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YMaxType > r (
          YMaxTraits::create (i, f, this));

        if (!this->yMax_)
        {
          this->yMax_.set (r);
          continue;
        }
      }

      // ySum
      //
      if (n.name () == "ySum" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YSumType > r (
          YSumTraits::create (i, f, this));

        if (!this->ySum_)
        {
          this->ySum_.set (r);
          continue;
        }
      }

      break;
    }
  }

  UnitDelayOutputComplexType* UnitDelayOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitDelayOutputComplexType (*this, f, c);
  }

  UnitDelayOutputComplexType::
  ~UnitDelayOutputComplexType ()
  {
  }

  // UnitHydrographComplexType
  //

  UnitHydrographComplexType::
  UnitHydrographComplexType (const WeightsType& weights,
                             const InputType& input,
                             const OutputType& output,
                             const IdType& id)
  : ::xml_schema::Type (),
    weights_ (weights, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  UnitHydrographComplexType::
  UnitHydrographComplexType (::std::auto_ptr< WeightsType >& weights,
                             ::std::auto_ptr< InputType >& input,
                             ::std::auto_ptr< OutputType >& output,
                             const IdType& id)
  : ::xml_schema::Type (),
    weights_ (weights, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  UnitHydrographComplexType::
  UnitHydrographComplexType (const UnitHydrographComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weights_ (x.weights_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  UnitHydrographComplexType::
  UnitHydrographComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weights_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void UnitHydrographComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weights
      //
      if (n.name () == "weights" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightsType > r (
          WeightsTraits::create (i, f, this));

        if (!weights_.present ())
        {
          this->weights_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!weights_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weights",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  UnitHydrographComplexType* UnitHydrographComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitHydrographComplexType (*this, f, c);
  }

  UnitHydrographComplexType::
  ~UnitHydrographComplexType ()
  {
  }

  // UnitHydrographWeightComplexType
  //

  UnitHydrographWeightComplexType::
  UnitHydrographWeightComplexType ()
  : ::xml_schema::Type (),
    triangular_ (::xml_schema::Flags (), this),
    custom_ (::xml_schema::Flags (), this)
  {
  }

  UnitHydrographWeightComplexType::
  UnitHydrographWeightComplexType (const UnitHydrographWeightComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    triangular_ (x.triangular_, f, this),
    custom_ (x.custom_, f, this)
  {
  }

  UnitHydrographWeightComplexType::
  UnitHydrographWeightComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    triangular_ (f, this),
    custom_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitHydrographWeightComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // triangular
      //
      if (n.name () == "triangular" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TriangularType > r (
          TriangularTraits::create (i, f, this));

        if (!this->triangular_)
        {
          this->triangular_.set (r);
          continue;
        }
      }

      // custom
      //
      if (n.name () == "custom" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CustomType > r (
          CustomTraits::create (i, f, this));

        if (!this->custom_)
        {
          this->custom_.set (r);
          continue;
        }
      }

      break;
    }
  }

  UnitHydrographWeightComplexType* UnitHydrographWeightComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitHydrographWeightComplexType (*this, f, c);
  }

  UnitHydrographWeightComplexType::
  ~UnitHydrographWeightComplexType ()
  {
  }

  // UnitHydrographWeightTriangularComplexType
  //

  UnitHydrographWeightTriangularComplexType::
  UnitHydrographWeightTriangularComplexType (const NStepsType& nSteps)
  : ::xml_schema::Type (),
    nSteps_ (nSteps, ::xml_schema::Flags (), this),
    factor_ (::xml_schema::Flags (), this)
  {
  }

  UnitHydrographWeightTriangularComplexType::
  UnitHydrographWeightTriangularComplexType (const UnitHydrographWeightTriangularComplexType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nSteps_ (x.nSteps_, f, this),
    factor_ (x.factor_, f, this)
  {
  }

  UnitHydrographWeightTriangularComplexType::
  UnitHydrographWeightTriangularComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nSteps_ (f, this),
    factor_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitHydrographWeightTriangularComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nSteps
      //
      if (n.name () == "nSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepsType > r (
          NStepsTraits::create (i, f, this));

        if (!nSteps_.present ())
        {
          this->nSteps_.set (r);
          continue;
        }
      }

      // factor
      //
      if (n.name () == "factor" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->factor_)
        {
          this->factor_.set (FactorTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!nSteps_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nSteps",
        "http://www.wldelft.nl/fews");
    }
  }

  UnitHydrographWeightTriangularComplexType* UnitHydrographWeightTriangularComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitHydrographWeightTriangularComplexType (*this, f, c);
  }

  UnitHydrographWeightTriangularComplexType::
  ~UnitHydrographWeightTriangularComplexType ()
  {
  }

  // UnitHydrographWeightCustomComplexType
  //

  UnitHydrographWeightCustomComplexType::
  UnitHydrographWeightCustomComplexType ()
  : ::xml_schema::Type (),
    weight_ (::xml_schema::Flags (), this)
  {
  }

  UnitHydrographWeightCustomComplexType::
  UnitHydrographWeightCustomComplexType (const UnitHydrographWeightCustomComplexType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weight_ (x.weight_, f, this)
  {
  }

  UnitHydrographWeightCustomComplexType::
  UnitHydrographWeightCustomComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weight_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitHydrographWeightCustomComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weight
      //
      if (n.name () == "weight" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        this->weight_.push_back (WeightTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  UnitHydrographWeightCustomComplexType* UnitHydrographWeightCustomComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitHydrographWeightCustomComplexType (*this, f, c);
  }

  UnitHydrographWeightCustomComplexType::
  ~UnitHydrographWeightCustomComplexType ()
  {
  }

  // UnitHydrographInputComplexType
  //

  UnitHydrographInputComplexType::
  UnitHydrographInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  UnitHydrographInputComplexType::
  UnitHydrographInputComplexType (const UnitHydrographInputComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  UnitHydrographInputComplexType::
  UnitHydrographInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitHydrographInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  UnitHydrographInputComplexType* UnitHydrographInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitHydrographInputComplexType (*this, f, c);
  }

  UnitHydrographInputComplexType::
  ~UnitHydrographInputComplexType ()
  {
  }

  // UnitHydrographOutputComplexType
  //

  UnitHydrographOutputComplexType::
  UnitHydrographOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    xDelay_ (::xml_schema::Flags (), this),
    xDelayVector_ (::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  UnitHydrographOutputComplexType::
  UnitHydrographOutputComplexType (const UnitHydrographOutputComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    xDelay_ (x.xDelay_, f, this),
    xDelayVector_ (x.xDelayVector_, f, this),
    y_ (x.y_, f, this)
  {
  }

  UnitHydrographOutputComplexType::
  UnitHydrographOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    xDelay_ (f, this),
    xDelayVector_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UnitHydrographOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // xDelay
      //
      if (n.name () == "xDelay" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XDelayType > r (
          XDelayTraits::create (i, f, this));

        this->xDelay_.push_back (r);
        continue;
      }

      // xDelayVector
      //
      if (n.name () == "xDelayVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XDelayVectorType > r (
          XDelayVectorTraits::create (i, f, this));

        if (!this->xDelayVector_)
        {
          this->xDelayVector_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  UnitHydrographOutputComplexType* UnitHydrographOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitHydrographOutputComplexType (*this, f, c);
  }

  UnitHydrographOutputComplexType::
  ~UnitHydrographOutputComplexType ()
  {
  }

  // ReservoirCompactComplexType
  //

  const ReservoirCompactComplexType::UnitsType ReservoirCompactComplexType::units_default_value_ (
    "SI");

  const ReservoirCompactComplexType::TurbineEfficiencyConstantType ReservoirCompactComplexType::turbineEfficiencyConstant_default_value_ (
    "0.88");

  ReservoirCompactComplexType::
  ReservoirCompactComplexType (const InputType& input,
                               const OutputType& output,
                               const IdType& id)
  : ::xml_schema::Type (),
    units_ (::xml_schema::Flags (), this),
    levelStorageTable_ (::xml_schema::Flags (), this),
    levelStorageTableExternal_ (::xml_schema::Flags (), this),
    levelStorageEquation_ (::xml_schema::Flags (), this),
    tailwaterTable_ (::xml_schema::Flags (), this),
    tailwaterEquation_ (::xml_schema::Flags (), this),
    tailwaterTidalEquation_ (::xml_schema::Flags (), this),
    tailwaterExternalTable_ (::xml_schema::Flags (), this),
    tailwaterExternalTimeSeries_ (::xml_schema::Flags (), this),
    tailwaterConstant_ (::xml_schema::Flags (), this),
    turbineEfficiencyConstant_ (::xml_schema::Flags (), this),
    turbineEfficiencyTable_ (::xml_schema::Flags (), this),
    turbineEfficiencyTableExternal_ (::xml_schema::Flags (), this),
    turbineEfficiencyTable2D_ (::xml_schema::Flags (), this),
    turbineEfficiencyTable2DExternal_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirCompactComplexType::
  ReservoirCompactComplexType (::std::auto_ptr< InputType >& input,
                               ::std::auto_ptr< OutputType >& output,
                               const IdType& id)
  : ::xml_schema::Type (),
    units_ (::xml_schema::Flags (), this),
    levelStorageTable_ (::xml_schema::Flags (), this),
    levelStorageTableExternal_ (::xml_schema::Flags (), this),
    levelStorageEquation_ (::xml_schema::Flags (), this),
    tailwaterTable_ (::xml_schema::Flags (), this),
    tailwaterEquation_ (::xml_schema::Flags (), this),
    tailwaterTidalEquation_ (::xml_schema::Flags (), this),
    tailwaterExternalTable_ (::xml_schema::Flags (), this),
    tailwaterExternalTimeSeries_ (::xml_schema::Flags (), this),
    tailwaterConstant_ (::xml_schema::Flags (), this),
    turbineEfficiencyConstant_ (::xml_schema::Flags (), this),
    turbineEfficiencyTable_ (::xml_schema::Flags (), this),
    turbineEfficiencyTableExternal_ (::xml_schema::Flags (), this),
    turbineEfficiencyTable2D_ (::xml_schema::Flags (), this),
    turbineEfficiencyTable2DExternal_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirCompactComplexType::
  ReservoirCompactComplexType (const ReservoirCompactComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    units_ (x.units_, f, this),
    levelStorageTable_ (x.levelStorageTable_, f, this),
    levelStorageTableExternal_ (x.levelStorageTableExternal_, f, this),
    levelStorageEquation_ (x.levelStorageEquation_, f, this),
    tailwaterTable_ (x.tailwaterTable_, f, this),
    tailwaterEquation_ (x.tailwaterEquation_, f, this),
    tailwaterTidalEquation_ (x.tailwaterTidalEquation_, f, this),
    tailwaterExternalTable_ (x.tailwaterExternalTable_, f, this),
    tailwaterExternalTimeSeries_ (x.tailwaterExternalTimeSeries_, f, this),
    tailwaterConstant_ (x.tailwaterConstant_, f, this),
    turbineEfficiencyConstant_ (x.turbineEfficiencyConstant_, f, this),
    turbineEfficiencyTable_ (x.turbineEfficiencyTable_, f, this),
    turbineEfficiencyTableExternal_ (x.turbineEfficiencyTableExternal_, f, this),
    turbineEfficiencyTable2D_ (x.turbineEfficiencyTable2D_, f, this),
    turbineEfficiencyTable2DExternal_ (x.turbineEfficiencyTable2DExternal_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ReservoirCompactComplexType::
  ReservoirCompactComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    units_ (f, this),
    levelStorageTable_ (f, this),
    levelStorageTableExternal_ (f, this),
    levelStorageEquation_ (f, this),
    tailwaterTable_ (f, this),
    tailwaterEquation_ (f, this),
    tailwaterTidalEquation_ (f, this),
    tailwaterExternalTable_ (f, this),
    tailwaterExternalTimeSeries_ (f, this),
    tailwaterConstant_ (f, this),
    turbineEfficiencyConstant_ (f, this),
    turbineEfficiencyTable_ (f, this),
    turbineEfficiencyTableExternal_ (f, this),
    turbineEfficiencyTable2D_ (f, this),
    turbineEfficiencyTable2DExternal_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ReservoirCompactComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // units
      //
      if (n.name () == "units" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitsType > r (
          UnitsTraits::create (i, f, this));

        if (!this->units_)
        {
          this->units_.set (r);
          continue;
        }
      }

      // levelStorageTable
      //
      if (n.name () == "levelStorageTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelStorageTableType > r (
          LevelStorageTableTraits::create (i, f, this));

        if (!this->levelStorageTable_)
        {
          this->levelStorageTable_.set (r);
          continue;
        }
      }

      // levelStorageTableExternal
      //
      if (n.name () == "levelStorageTableExternal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelStorageTableExternalType > r (
          LevelStorageTableExternalTraits::create (i, f, this));

        if (!this->levelStorageTableExternal_)
        {
          this->levelStorageTableExternal_.set (r);
          continue;
        }
      }

      // levelStorageEquation
      //
      if (n.name () == "levelStorageEquation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelStorageEquationType > r (
          LevelStorageEquationTraits::create (i, f, this));

        if (!this->levelStorageEquation_)
        {
          this->levelStorageEquation_.set (r);
          continue;
        }
      }

      // tailwaterTable
      //
      if (n.name () == "tailwaterTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterTableType > r (
          TailwaterTableTraits::create (i, f, this));

        if (!this->tailwaterTable_)
        {
          this->tailwaterTable_.set (r);
          continue;
        }
      }

      // tailwaterEquation
      //
      if (n.name () == "tailwaterEquation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterEquationType > r (
          TailwaterEquationTraits::create (i, f, this));

        if (!this->tailwaterEquation_)
        {
          this->tailwaterEquation_.set (r);
          continue;
        }
      }

      // tailwaterTidalEquation
      //
      if (n.name () == "tailwaterTidalEquation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterTidalEquationType > r (
          TailwaterTidalEquationTraits::create (i, f, this));

        if (!this->tailwaterTidalEquation_)
        {
          this->tailwaterTidalEquation_.set (r);
          continue;
        }
      }

      // tailwaterExternalTable
      //
      if (n.name () == "tailwaterExternalTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterExternalTableType > r (
          TailwaterExternalTableTraits::create (i, f, this));

        if (!this->tailwaterExternalTable_)
        {
          this->tailwaterExternalTable_.set (r);
          continue;
        }
      }

      // tailwaterExternalTimeSeries
      //
      if (n.name () == "tailwaterExternalTimeSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterExternalTimeSeriesType > r (
          TailwaterExternalTimeSeriesTraits::create (i, f, this));

        if (!this->tailwaterExternalTimeSeries_)
        {
          this->tailwaterExternalTimeSeries_.set (r);
          continue;
        }
      }

      // tailwaterConstant
      //
      if (n.name () == "tailwaterConstant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterConstantType > r (
          TailwaterConstantTraits::create (i, f, this));

        if (!this->tailwaterConstant_)
        {
          this->tailwaterConstant_.set (r);
          continue;
        }
      }

      // turbineEfficiencyConstant
      //
      if (n.name () == "turbineEfficiencyConstant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TurbineEfficiencyConstantType > r (
          TurbineEfficiencyConstantTraits::create (i, f, this));

        if (!this->turbineEfficiencyConstant_)
        {
          this->turbineEfficiencyConstant_.set (r);
          continue;
        }
      }

      // turbineEfficiencyTable
      //
      if (n.name () == "turbineEfficiencyTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TurbineEfficiencyTableType > r (
          TurbineEfficiencyTableTraits::create (i, f, this));

        if (!this->turbineEfficiencyTable_)
        {
          this->turbineEfficiencyTable_.set (r);
          continue;
        }
      }

      // turbineEfficiencyTableExternal
      //
      if (n.name () == "turbineEfficiencyTableExternal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TurbineEfficiencyTableExternalType > r (
          TurbineEfficiencyTableExternalTraits::create (i, f, this));

        if (!this->turbineEfficiencyTableExternal_)
        {
          this->turbineEfficiencyTableExternal_.set (r);
          continue;
        }
      }

      // turbineEfficiencyTable2D
      //
      if (n.name () == "turbineEfficiencyTable2D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TurbineEfficiencyTable2DType > r (
          TurbineEfficiencyTable2DTraits::create (i, f, this));

        if (!this->turbineEfficiencyTable2D_)
        {
          this->turbineEfficiencyTable2D_.set (r);
          continue;
        }
      }

      // turbineEfficiencyTable2DExternal
      //
      if (n.name () == "turbineEfficiencyTable2DExternal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TurbineEfficiencyTable2DExternalType > r (
          TurbineEfficiencyTable2DExternalTraits::create (i, f, this));

        if (!this->turbineEfficiencyTable2DExternal_)
        {
          this->turbineEfficiencyTable2DExternal_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ReservoirCompactComplexType* ReservoirCompactComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirCompactComplexType (*this, f, c);
  }

  ReservoirCompactComplexType::
  ~ReservoirCompactComplexType ()
  {
  }

  // LevelStorageEquationComplexType
  //

  LevelStorageEquationComplexType::
  LevelStorageEquationComplexType (const A0Type& A0,
                                   const A1Type& A1)
  : ::xml_schema::Type (),
    A0_ (A0, ::xml_schema::Flags (), this),
    A1_ (A1, ::xml_schema::Flags (), this),
    A2_ (::xml_schema::Flags (), this),
    A3_ (::xml_schema::Flags (), this),
    A4_ (::xml_schema::Flags (), this)
  {
  }

  LevelStorageEquationComplexType::
  LevelStorageEquationComplexType (const LevelStorageEquationComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    A0_ (x.A0_, f, this),
    A1_ (x.A1_, f, this),
    A2_ (x.A2_, f, this),
    A3_ (x.A3_, f, this),
    A4_ (x.A4_, f, this)
  {
  }

  LevelStorageEquationComplexType::
  LevelStorageEquationComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    A0_ (f, this),
    A1_ (f, this),
    A2_ (f, this),
    A3_ (f, this),
    A4_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LevelStorageEquationComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // A0
      //
      if (n.name () == "A0" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!A0_.present ())
        {
          this->A0_.set (A0Traits::create (i, f, this));
          continue;
        }
      }

      // A1
      //
      if (n.name () == "A1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!A1_.present ())
        {
          this->A1_.set (A1Traits::create (i, f, this));
          continue;
        }
      }

      // A2
      //
      if (n.name () == "A2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->A2_)
        {
          this->A2_.set (A2Traits::create (i, f, this));
          continue;
        }
      }

      // A3
      //
      if (n.name () == "A3" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->A3_)
        {
          this->A3_.set (A3Traits::create (i, f, this));
          continue;
        }
      }

      // A4
      //
      if (n.name () == "A4" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->A4_)
        {
          this->A4_.set (A4Traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!A0_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "A0",
        "http://www.wldelft.nl/fews");
    }

    if (!A1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "A1",
        "http://www.wldelft.nl/fews");
    }
  }

  LevelStorageEquationComplexType* LevelStorageEquationComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LevelStorageEquationComplexType (*this, f, c);
  }

  LevelStorageEquationComplexType::
  ~LevelStorageEquationComplexType ()
  {
  }

  // TailwaterEquationComplexType
  //

  const TailwaterEquationComplexType::DType TailwaterEquationComplexType::D_default_value_ (
    "1.0");

  TailwaterEquationComplexType::
  TailwaterEquationComplexType (const AType& A,
                                const BType& B,
                                const CType& C)
  : ::xml_schema::Type (),
    A_ (A, ::xml_schema::Flags (), this),
    B_ (B, ::xml_schema::Flags (), this),
    C_ (C, ::xml_schema::Flags (), this),
    D_ (::xml_schema::Flags (), this),
    FBDown_ (::xml_schema::Flags (), this)
  {
  }

  TailwaterEquationComplexType::
  TailwaterEquationComplexType (const TailwaterEquationComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    A_ (x.A_, f, this),
    B_ (x.B_, f, this),
    C_ (x.C_, f, this),
    D_ (x.D_, f, this),
    FBDown_ (x.FBDown_, f, this)
  {
  }

  TailwaterEquationComplexType::
  TailwaterEquationComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    A_ (f, this),
    B_ (f, this),
    C_ (f, this),
    D_ (f, this),
    FBDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TailwaterEquationComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // A
      //
      if (n.name () == "A" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AType > r (
          ATraits::create (i, f, this));

        if (!A_.present ())
        {
          this->A_.set (r);
          continue;
        }
      }

      // B
      //
      if (n.name () == "B" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BType > r (
          BTraits::create (i, f, this));

        if (!B_.present ())
        {
          this->B_.set (r);
          continue;
        }
      }

      // C
      //
      if (n.name () == "C" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CType > r (
          CTraits::create (i, f, this));

        if (!C_.present ())
        {
          this->C_.set (r);
          continue;
        }
      }

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!this->D_)
        {
          this->D_.set (r);
          continue;
        }
      }

      // FBDown
      //
      if (n.name () == "FBDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FBDownType > r (
          FBDownTraits::create (i, f, this));

        if (!this->FBDown_)
        {
          this->FBDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!A_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "A",
        "http://www.wldelft.nl/fews");
    }

    if (!B_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "B",
        "http://www.wldelft.nl/fews");
    }

    if (!C_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "C",
        "http://www.wldelft.nl/fews");
    }
  }

  TailwaterEquationComplexType* TailwaterEquationComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TailwaterEquationComplexType (*this, f, c);
  }

  TailwaterEquationComplexType::
  ~TailwaterEquationComplexType ()
  {
  }

  // TailwaterTidalEquationComplexType
  //

  TailwaterTidalEquationComplexType::
  TailwaterTidalEquationComplexType (const AType& A,
                                     const TWObsType& TWObs,
                                     const QObsType& QObs)
  : ::xml_schema::Type (),
    A_ (A, ::xml_schema::Flags (), this),
    TWObs_ (TWObs, ::xml_schema::Flags (), this),
    QObs_ (QObs, ::xml_schema::Flags (), this)
  {
  }

  TailwaterTidalEquationComplexType::
  TailwaterTidalEquationComplexType (const TailwaterTidalEquationComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    A_ (x.A_, f, this),
    TWObs_ (x.TWObs_, f, this),
    QObs_ (x.QObs_, f, this)
  {
  }

  TailwaterTidalEquationComplexType::
  TailwaterTidalEquationComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    A_ (f, this),
    TWObs_ (f, this),
    QObs_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TailwaterTidalEquationComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // A
      //
      if (n.name () == "A" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AType > r (
          ATraits::create (i, f, this));

        if (!A_.present ())
        {
          this->A_.set (r);
          continue;
        }
      }

      // TWObs
      //
      if (n.name () == "TWObs" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TWObsType > r (
          TWObsTraits::create (i, f, this));

        if (!TWObs_.present ())
        {
          this->TWObs_.set (r);
          continue;
        }
      }

      // QObs
      //
      if (n.name () == "QObs" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QObsType > r (
          QObsTraits::create (i, f, this));

        if (!QObs_.present ())
        {
          this->QObs_.set (r);
          continue;
        }
      }

      break;
    }

    if (!A_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "A",
        "http://www.wldelft.nl/fews");
    }

    if (!TWObs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TWObs",
        "http://www.wldelft.nl/fews");
    }

    if (!QObs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QObs",
        "http://www.wldelft.nl/fews");
    }
  }

  TailwaterTidalEquationComplexType* TailwaterTidalEquationComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TailwaterTidalEquationComplexType (*this, f, c);
  }

  TailwaterTidalEquationComplexType::
  ~TailwaterTidalEquationComplexType ()
  {
  }

  // TurbineEfficiencyTableComplexType
  //

  TurbineEfficiencyTableComplexType::
  TurbineEfficiencyTableComplexType (const ColumnsType& columns,
                                     const MaxFlowsType& maxFlows)
  : ::xml_schema::Type (),
    columns_ (columns, ::xml_schema::Flags (), this),
    row_ (::xml_schema::Flags (), this),
    maxFlows_ (maxFlows, ::xml_schema::Flags (), this)
  {
  }

  TurbineEfficiencyTableComplexType::
  TurbineEfficiencyTableComplexType (::std::auto_ptr< ColumnsType >& columns,
                                     ::std::auto_ptr< MaxFlowsType >& maxFlows)
  : ::xml_schema::Type (),
    columns_ (columns, ::xml_schema::Flags (), this),
    row_ (::xml_schema::Flags (), this),
    maxFlows_ (maxFlows, ::xml_schema::Flags (), this)
  {
  }

  TurbineEfficiencyTableComplexType::
  TurbineEfficiencyTableComplexType (const TurbineEfficiencyTableComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    columns_ (x.columns_, f, this),
    row_ (x.row_, f, this),
    maxFlows_ (x.maxFlows_, f, this)
  {
  }

  TurbineEfficiencyTableComplexType::
  TurbineEfficiencyTableComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    columns_ (f, this),
    row_ (f, this),
    maxFlows_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineEfficiencyTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // columns
      //
      if (n.name () == "columns" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ColumnsType > r (
          ColumnsTraits::create (i, f, this));

        if (!columns_.present ())
        {
          this->columns_.set (r);
          continue;
        }
      }

      // row
      //
      if (n.name () == "row" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RowType > r (
          RowTraits::create (i, f, this));

        this->row_.push_back (r);
        continue;
      }

      // maxFlows
      //
      if (n.name () == "maxFlows" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MaxFlowsType > r (
          MaxFlowsTraits::create (i, f, this));

        if (!maxFlows_.present ())
        {
          this->maxFlows_.set (r);
          continue;
        }
      }

      break;
    }

    if (!columns_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "columns",
        "http://www.wldelft.nl/fews");
    }

    if (!maxFlows_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maxFlows",
        "http://www.wldelft.nl/fews");
    }
  }

  TurbineEfficiencyTableComplexType* TurbineEfficiencyTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineEfficiencyTableComplexType (*this, f, c);
  }

  TurbineEfficiencyTableComplexType::
  ~TurbineEfficiencyTableComplexType ()
  {
  }

  // ColumnsComplexType
  //

  ColumnsComplexType::
  ColumnsComplexType (const Head01Type& head01,
                      const Head02Type& head02)
  : ::xml_schema::Type (),
    head01_ (head01, ::xml_schema::Flags (), this),
    head02_ (head02, ::xml_schema::Flags (), this),
    head03_ (::xml_schema::Flags (), this),
    head04_ (::xml_schema::Flags (), this),
    head05_ (::xml_schema::Flags (), this),
    head06_ (::xml_schema::Flags (), this),
    head07_ (::xml_schema::Flags (), this),
    head08_ (::xml_schema::Flags (), this),
    head09_ (::xml_schema::Flags (), this),
    head10_ (::xml_schema::Flags (), this),
    head11_ (::xml_schema::Flags (), this),
    head12_ (::xml_schema::Flags (), this),
    head13_ (::xml_schema::Flags (), this),
    head14_ (::xml_schema::Flags (), this),
    head15_ (::xml_schema::Flags (), this),
    head16_ (::xml_schema::Flags (), this),
    head17_ (::xml_schema::Flags (), this),
    head18_ (::xml_schema::Flags (), this),
    head19_ (::xml_schema::Flags (), this),
    head20_ (::xml_schema::Flags (), this)
  {
  }

  ColumnsComplexType::
  ColumnsComplexType (const ColumnsComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    head01_ (x.head01_, f, this),
    head02_ (x.head02_, f, this),
    head03_ (x.head03_, f, this),
    head04_ (x.head04_, f, this),
    head05_ (x.head05_, f, this),
    head06_ (x.head06_, f, this),
    head07_ (x.head07_, f, this),
    head08_ (x.head08_, f, this),
    head09_ (x.head09_, f, this),
    head10_ (x.head10_, f, this),
    head11_ (x.head11_, f, this),
    head12_ (x.head12_, f, this),
    head13_ (x.head13_, f, this),
    head14_ (x.head14_, f, this),
    head15_ (x.head15_, f, this),
    head16_ (x.head16_, f, this),
    head17_ (x.head17_, f, this),
    head18_ (x.head18_, f, this),
    head19_ (x.head19_, f, this),
    head20_ (x.head20_, f, this)
  {
  }

  ColumnsComplexType::
  ColumnsComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    head01_ (f, this),
    head02_ (f, this),
    head03_ (f, this),
    head04_ (f, this),
    head05_ (f, this),
    head06_ (f, this),
    head07_ (f, this),
    head08_ (f, this),
    head09_ (f, this),
    head10_ (f, this),
    head11_ (f, this),
    head12_ (f, this),
    head13_ (f, this),
    head14_ (f, this),
    head15_ (f, this),
    head16_ (f, this),
    head17_ (f, this),
    head18_ (f, this),
    head19_ (f, this),
    head20_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ColumnsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "head01" && n.namespace_ ().empty ())
      {
        this->head01_.set (Head01Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head02" && n.namespace_ ().empty ())
      {
        this->head02_.set (Head02Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head03" && n.namespace_ ().empty ())
      {
        this->head03_.set (Head03Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head04" && n.namespace_ ().empty ())
      {
        this->head04_.set (Head04Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head05" && n.namespace_ ().empty ())
      {
        this->head05_.set (Head05Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head06" && n.namespace_ ().empty ())
      {
        this->head06_.set (Head06Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head07" && n.namespace_ ().empty ())
      {
        this->head07_.set (Head07Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head08" && n.namespace_ ().empty ())
      {
        this->head08_.set (Head08Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head09" && n.namespace_ ().empty ())
      {
        this->head09_.set (Head09Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head10" && n.namespace_ ().empty ())
      {
        this->head10_.set (Head10Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head11" && n.namespace_ ().empty ())
      {
        this->head11_.set (Head11Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head12" && n.namespace_ ().empty ())
      {
        this->head12_.set (Head12Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head13" && n.namespace_ ().empty ())
      {
        this->head13_.set (Head13Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head14" && n.namespace_ ().empty ())
      {
        this->head14_.set (Head14Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head15" && n.namespace_ ().empty ())
      {
        this->head15_.set (Head15Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head16" && n.namespace_ ().empty ())
      {
        this->head16_.set (Head16Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head17" && n.namespace_ ().empty ())
      {
        this->head17_.set (Head17Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head18" && n.namespace_ ().empty ())
      {
        this->head18_.set (Head18Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head19" && n.namespace_ ().empty ())
      {
        this->head19_.set (Head19Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "head20" && n.namespace_ ().empty ())
      {
        this->head20_.set (Head20Traits::create (i, f, this));
        continue;
      }
    }

    if (!head01_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "head01",
        "");
    }

    if (!head02_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "head02",
        "");
    }
  }

  ColumnsComplexType* ColumnsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ColumnsComplexType (*this, f, c);
  }

  ColumnsComplexType::
  ~ColumnsComplexType ()
  {
  }

  // RowComplexType
  //

  RowComplexType::
  RowComplexType (const FlowType& flow,
                  const Eta_head01Type& eta_head01,
                  const Eta_head02Type& eta_head02)
  : ::xml_schema::Type (),
    flow_ (flow, ::xml_schema::Flags (), this),
    eta_head01_ (eta_head01, ::xml_schema::Flags (), this),
    eta_head02_ (eta_head02, ::xml_schema::Flags (), this),
    eta_head03_ (::xml_schema::Flags (), this),
    eta_head04_ (::xml_schema::Flags (), this),
    eta_head05_ (::xml_schema::Flags (), this),
    eta_head06_ (::xml_schema::Flags (), this),
    eta_head07_ (::xml_schema::Flags (), this),
    eta_head08_ (::xml_schema::Flags (), this),
    eta_head09_ (::xml_schema::Flags (), this),
    eta_head10_ (::xml_schema::Flags (), this),
    eta_head11_ (::xml_schema::Flags (), this),
    eta_head12_ (::xml_schema::Flags (), this),
    eta_head13_ (::xml_schema::Flags (), this),
    eta_head14_ (::xml_schema::Flags (), this),
    eta_head15_ (::xml_schema::Flags (), this),
    eta_head16_ (::xml_schema::Flags (), this),
    eta_head17_ (::xml_schema::Flags (), this),
    eta_head18_ (::xml_schema::Flags (), this),
    eta_head19_ (::xml_schema::Flags (), this),
    eta_head20_ (::xml_schema::Flags (), this)
  {
  }

  RowComplexType::
  RowComplexType (const RowComplexType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flow_ (x.flow_, f, this),
    eta_head01_ (x.eta_head01_, f, this),
    eta_head02_ (x.eta_head02_, f, this),
    eta_head03_ (x.eta_head03_, f, this),
    eta_head04_ (x.eta_head04_, f, this),
    eta_head05_ (x.eta_head05_, f, this),
    eta_head06_ (x.eta_head06_, f, this),
    eta_head07_ (x.eta_head07_, f, this),
    eta_head08_ (x.eta_head08_, f, this),
    eta_head09_ (x.eta_head09_, f, this),
    eta_head10_ (x.eta_head10_, f, this),
    eta_head11_ (x.eta_head11_, f, this),
    eta_head12_ (x.eta_head12_, f, this),
    eta_head13_ (x.eta_head13_, f, this),
    eta_head14_ (x.eta_head14_, f, this),
    eta_head15_ (x.eta_head15_, f, this),
    eta_head16_ (x.eta_head16_, f, this),
    eta_head17_ (x.eta_head17_, f, this),
    eta_head18_ (x.eta_head18_, f, this),
    eta_head19_ (x.eta_head19_, f, this),
    eta_head20_ (x.eta_head20_, f, this)
  {
  }

  RowComplexType::
  RowComplexType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flow_ (f, this),
    eta_head01_ (f, this),
    eta_head02_ (f, this),
    eta_head03_ (f, this),
    eta_head04_ (f, this),
    eta_head05_ (f, this),
    eta_head06_ (f, this),
    eta_head07_ (f, this),
    eta_head08_ (f, this),
    eta_head09_ (f, this),
    eta_head10_ (f, this),
    eta_head11_ (f, this),
    eta_head12_ (f, this),
    eta_head13_ (f, this),
    eta_head14_ (f, this),
    eta_head15_ (f, this),
    eta_head16_ (f, this),
    eta_head17_ (f, this),
    eta_head18_ (f, this),
    eta_head19_ (f, this),
    eta_head20_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void RowComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "flow" && n.namespace_ ().empty ())
      {
        this->flow_.set (FlowTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head01" && n.namespace_ ().empty ())
      {
        this->eta_head01_.set (Eta_head01Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head02" && n.namespace_ ().empty ())
      {
        this->eta_head02_.set (Eta_head02Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head03" && n.namespace_ ().empty ())
      {
        this->eta_head03_.set (Eta_head03Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head04" && n.namespace_ ().empty ())
      {
        this->eta_head04_.set (Eta_head04Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head05" && n.namespace_ ().empty ())
      {
        this->eta_head05_.set (Eta_head05Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head06" && n.namespace_ ().empty ())
      {
        this->eta_head06_.set (Eta_head06Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head07" && n.namespace_ ().empty ())
      {
        this->eta_head07_.set (Eta_head07Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head08" && n.namespace_ ().empty ())
      {
        this->eta_head08_.set (Eta_head08Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head09" && n.namespace_ ().empty ())
      {
        this->eta_head09_.set (Eta_head09Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head10" && n.namespace_ ().empty ())
      {
        this->eta_head10_.set (Eta_head10Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head11" && n.namespace_ ().empty ())
      {
        this->eta_head11_.set (Eta_head11Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head12" && n.namespace_ ().empty ())
      {
        this->eta_head12_.set (Eta_head12Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head13" && n.namespace_ ().empty ())
      {
        this->eta_head13_.set (Eta_head13Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head14" && n.namespace_ ().empty ())
      {
        this->eta_head14_.set (Eta_head14Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head15" && n.namespace_ ().empty ())
      {
        this->eta_head15_.set (Eta_head15Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head16" && n.namespace_ ().empty ())
      {
        this->eta_head16_.set (Eta_head16Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head17" && n.namespace_ ().empty ())
      {
        this->eta_head17_.set (Eta_head17Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head18" && n.namespace_ ().empty ())
      {
        this->eta_head18_.set (Eta_head18Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head19" && n.namespace_ ().empty ())
      {
        this->eta_head19_.set (Eta_head19Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "eta_head20" && n.namespace_ ().empty ())
      {
        this->eta_head20_.set (Eta_head20Traits::create (i, f, this));
        continue;
      }
    }

    if (!flow_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "flow",
        "");
    }

    if (!eta_head01_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eta_head01",
        "");
    }

    if (!eta_head02_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eta_head02",
        "");
    }
  }

  RowComplexType* RowComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RowComplexType (*this, f, c);
  }

  RowComplexType::
  ~RowComplexType ()
  {
  }

  // MaxFlowsComplexType
  //

  MaxFlowsComplexType::
  MaxFlowsComplexType (const MaxFlow_head01Type& maxFlow_head01,
                       const MaxFlow_head02Type& maxFlow_head02)
  : ::xml_schema::Type (),
    maxFlow_head01_ (maxFlow_head01, ::xml_schema::Flags (), this),
    maxFlow_head02_ (maxFlow_head02, ::xml_schema::Flags (), this),
    maxFlow_head03_ (::xml_schema::Flags (), this),
    maxFlow_head04_ (::xml_schema::Flags (), this),
    maxFlow_head05_ (::xml_schema::Flags (), this),
    maxFlow_head06_ (::xml_schema::Flags (), this),
    maxFlow_head07_ (::xml_schema::Flags (), this),
    maxFlow_head08_ (::xml_schema::Flags (), this),
    maxFlow_head09_ (::xml_schema::Flags (), this),
    maxFlow_head10_ (::xml_schema::Flags (), this),
    maxFlow_head11_ (::xml_schema::Flags (), this),
    maxFlow_head12_ (::xml_schema::Flags (), this),
    maxFlow_head13_ (::xml_schema::Flags (), this),
    maxFlow_head14_ (::xml_schema::Flags (), this),
    maxFlow_head15_ (::xml_schema::Flags (), this),
    maxFlow_head16_ (::xml_schema::Flags (), this),
    maxFlow_head17_ (::xml_schema::Flags (), this),
    maxFlow_head18_ (::xml_schema::Flags (), this),
    maxFlow_head19_ (::xml_schema::Flags (), this),
    maxFlow_head20_ (::xml_schema::Flags (), this)
  {
  }

  MaxFlowsComplexType::
  MaxFlowsComplexType (const MaxFlowsComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    maxFlow_head01_ (x.maxFlow_head01_, f, this),
    maxFlow_head02_ (x.maxFlow_head02_, f, this),
    maxFlow_head03_ (x.maxFlow_head03_, f, this),
    maxFlow_head04_ (x.maxFlow_head04_, f, this),
    maxFlow_head05_ (x.maxFlow_head05_, f, this),
    maxFlow_head06_ (x.maxFlow_head06_, f, this),
    maxFlow_head07_ (x.maxFlow_head07_, f, this),
    maxFlow_head08_ (x.maxFlow_head08_, f, this),
    maxFlow_head09_ (x.maxFlow_head09_, f, this),
    maxFlow_head10_ (x.maxFlow_head10_, f, this),
    maxFlow_head11_ (x.maxFlow_head11_, f, this),
    maxFlow_head12_ (x.maxFlow_head12_, f, this),
    maxFlow_head13_ (x.maxFlow_head13_, f, this),
    maxFlow_head14_ (x.maxFlow_head14_, f, this),
    maxFlow_head15_ (x.maxFlow_head15_, f, this),
    maxFlow_head16_ (x.maxFlow_head16_, f, this),
    maxFlow_head17_ (x.maxFlow_head17_, f, this),
    maxFlow_head18_ (x.maxFlow_head18_, f, this),
    maxFlow_head19_ (x.maxFlow_head19_, f, this),
    maxFlow_head20_ (x.maxFlow_head20_, f, this)
  {
  }

  MaxFlowsComplexType::
  MaxFlowsComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    maxFlow_head01_ (f, this),
    maxFlow_head02_ (f, this),
    maxFlow_head03_ (f, this),
    maxFlow_head04_ (f, this),
    maxFlow_head05_ (f, this),
    maxFlow_head06_ (f, this),
    maxFlow_head07_ (f, this),
    maxFlow_head08_ (f, this),
    maxFlow_head09_ (f, this),
    maxFlow_head10_ (f, this),
    maxFlow_head11_ (f, this),
    maxFlow_head12_ (f, this),
    maxFlow_head13_ (f, this),
    maxFlow_head14_ (f, this),
    maxFlow_head15_ (f, this),
    maxFlow_head16_ (f, this),
    maxFlow_head17_ (f, this),
    maxFlow_head18_ (f, this),
    maxFlow_head19_ (f, this),
    maxFlow_head20_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MaxFlowsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "maxFlow_head01" && n.namespace_ ().empty ())
      {
        this->maxFlow_head01_.set (MaxFlow_head01Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head02" && n.namespace_ ().empty ())
      {
        this->maxFlow_head02_.set (MaxFlow_head02Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head03" && n.namespace_ ().empty ())
      {
        this->maxFlow_head03_.set (MaxFlow_head03Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head04" && n.namespace_ ().empty ())
      {
        this->maxFlow_head04_.set (MaxFlow_head04Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head05" && n.namespace_ ().empty ())
      {
        this->maxFlow_head05_.set (MaxFlow_head05Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head06" && n.namespace_ ().empty ())
      {
        this->maxFlow_head06_.set (MaxFlow_head06Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head07" && n.namespace_ ().empty ())
      {
        this->maxFlow_head07_.set (MaxFlow_head07Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head08" && n.namespace_ ().empty ())
      {
        this->maxFlow_head08_.set (MaxFlow_head08Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head09" && n.namespace_ ().empty ())
      {
        this->maxFlow_head09_.set (MaxFlow_head09Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head10" && n.namespace_ ().empty ())
      {
        this->maxFlow_head10_.set (MaxFlow_head10Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head11" && n.namespace_ ().empty ())
      {
        this->maxFlow_head11_.set (MaxFlow_head11Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head12" && n.namespace_ ().empty ())
      {
        this->maxFlow_head12_.set (MaxFlow_head12Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head13" && n.namespace_ ().empty ())
      {
        this->maxFlow_head13_.set (MaxFlow_head13Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head14" && n.namespace_ ().empty ())
      {
        this->maxFlow_head14_.set (MaxFlow_head14Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head15" && n.namespace_ ().empty ())
      {
        this->maxFlow_head15_.set (MaxFlow_head15Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head16" && n.namespace_ ().empty ())
      {
        this->maxFlow_head16_.set (MaxFlow_head16Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head17" && n.namespace_ ().empty ())
      {
        this->maxFlow_head17_.set (MaxFlow_head17Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head18" && n.namespace_ ().empty ())
      {
        this->maxFlow_head18_.set (MaxFlow_head18Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head19" && n.namespace_ ().empty ())
      {
        this->maxFlow_head19_.set (MaxFlow_head19Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxFlow_head20" && n.namespace_ ().empty ())
      {
        this->maxFlow_head20_.set (MaxFlow_head20Traits::create (i, f, this));
        continue;
      }
    }

    if (!maxFlow_head01_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maxFlow_head01",
        "");
    }

    if (!maxFlow_head02_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maxFlow_head02",
        "");
    }
  }

  MaxFlowsComplexType* MaxFlowsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MaxFlowsComplexType (*this, f, c);
  }

  MaxFlowsComplexType::
  ~MaxFlowsComplexType ()
  {
  }

  // ReservoirCompactInputComplexType
  //

  ReservoirCompactInputComplexType::
  ReservoirCompactInputComplexType (const FBType& FB,
                                    const QType& Q)
  : ::xml_schema::Type (),
    FB_ (FB, ::xml_schema::Flags (), this),
    QI_ (::xml_schema::Flags (), this),
    Q_ (Q, ::xml_schema::Flags (), this),
    QSPercentage_ (::xml_schema::Flags (), this),
    QSPercentageValue_ (::xml_schema::Flags (), this),
    QS_ (::xml_schema::Flags (), this),
    QSValue_ (::xml_schema::Flags (), this),
    QMISC_ (::xml_schema::Flags (), this),
    PM_ (::xml_schema::Flags (), this),
    PMValue_ (::xml_schema::Flags (), this),
    PX_ (::xml_schema::Flags (), this),
    PXValue_ (::xml_schema::Flags (), this),
    QTX_ (::xml_schema::Flags (), this),
    QTXValue_ (::xml_schema::Flags (), this),
    OF_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirCompactInputComplexType::
  ReservoirCompactInputComplexType (const ReservoirCompactInputComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    FB_ (x.FB_, f, this),
    QI_ (x.QI_, f, this),
    Q_ (x.Q_, f, this),
    QSPercentage_ (x.QSPercentage_, f, this),
    QSPercentageValue_ (x.QSPercentageValue_, f, this),
    QS_ (x.QS_, f, this),
    QSValue_ (x.QSValue_, f, this),
    QMISC_ (x.QMISC_, f, this),
    PM_ (x.PM_, f, this),
    PMValue_ (x.PMValue_, f, this),
    PX_ (x.PX_, f, this),
    PXValue_ (x.PXValue_, f, this),
    QTX_ (x.QTX_, f, this),
    QTXValue_ (x.QTXValue_, f, this),
    OF_ (x.OF_, f, this)
  {
  }

  ReservoirCompactInputComplexType::
  ReservoirCompactInputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    FB_ (f, this),
    QI_ (f, this),
    Q_ (f, this),
    QSPercentage_ (f, this),
    QSPercentageValue_ (f, this),
    QS_ (f, this),
    QSValue_ (f, this),
    QMISC_ (f, this),
    PM_ (f, this),
    PMValue_ (f, this),
    PX_ (f, this),
    PXValue_ (f, this),
    QTX_ (f, this),
    QTXValue_ (f, this),
    OF_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirCompactInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FB
      //
      if (n.name () == "FB" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FBType > r (
          FBTraits::create (i, f, this));

        if (!FB_.present ())
        {
          this->FB_.set (r);
          continue;
        }
      }

      // QI
      //
      if (n.name () == "QI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QIType > r (
          QITraits::create (i, f, this));

        this->QI_.push_back (r);
        continue;
      }

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      // QSPercentage
      //
      if (n.name () == "QSPercentage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSPercentageType > r (
          QSPercentageTraits::create (i, f, this));

        if (!this->QSPercentage_)
        {
          this->QSPercentage_.set (r);
          continue;
        }
      }

      // QSPercentageValue
      //
      if (n.name () == "QSPercentageValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSPercentageValueType > r (
          QSPercentageValueTraits::create (i, f, this));

        if (!this->QSPercentageValue_)
        {
          this->QSPercentageValue_.set (r);
          continue;
        }
      }

      // QS
      //
      if (n.name () == "QS" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSType > r (
          QSTraits::create (i, f, this));

        if (!this->QS_)
        {
          this->QS_.set (r);
          continue;
        }
      }

      // QSValue
      //
      if (n.name () == "QSValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSValueType > r (
          QSValueTraits::create (i, f, this));

        if (!this->QSValue_)
        {
          this->QSValue_.set (r);
          continue;
        }
      }

      // QMISC
      //
      if (n.name () == "QMISC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QMISCType > r (
          QMISCTraits::create (i, f, this));

        if (!this->QMISC_)
        {
          this->QMISC_.set (r);
          continue;
        }
      }

      // PM
      //
      if (n.name () == "PM" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PMType > r (
          PMTraits::create (i, f, this));

        if (!this->PM_)
        {
          this->PM_.set (r);
          continue;
        }
      }

      // PMValue
      //
      if (n.name () == "PMValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PMValueType > r (
          PMValueTraits::create (i, f, this));

        if (!this->PMValue_)
        {
          this->PMValue_.set (r);
          continue;
        }
      }

      // PX
      //
      if (n.name () == "PX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PXType > r (
          PXTraits::create (i, f, this));

        if (!this->PX_)
        {
          this->PX_.set (r);
          continue;
        }
      }

      // PXValue
      //
      if (n.name () == "PXValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PXValueType > r (
          PXValueTraits::create (i, f, this));

        if (!this->PXValue_)
        {
          this->PXValue_.set (r);
          continue;
        }
      }

      // QTX
      //
      if (n.name () == "QTX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QTXType > r (
          QTXTraits::create (i, f, this));

        if (!this->QTX_)
        {
          this->QTX_.set (r);
          continue;
        }
      }

      // QTXValue
      //
      if (n.name () == "QTXValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QTXValueType > r (
          QTXValueTraits::create (i, f, this));

        if (!this->QTXValue_)
        {
          this->QTXValue_.set (r);
          continue;
        }
      }

      // OF
      //
      if (n.name () == "OF" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OFType > r (
          OFTraits::create (i, f, this));

        if (!this->OF_)
        {
          this->OF_.set (r);
          continue;
        }
      }

      break;
    }

    if (!FB_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FB",
        "http://www.wldelft.nl/fews");
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  ReservoirCompactInputComplexType* ReservoirCompactInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirCompactInputComplexType (*this, f, c);
  }

  ReservoirCompactInputComplexType::
  ~ReservoirCompactInputComplexType ()
  {
  }

  // ReservoirCompactOutputComplexType
  //

  ReservoirCompactOutputComplexType::
  ReservoirCompactOutputComplexType (const SType& S,
                                     const FBType& FB,
                                     const QType& Q,
                                     const QIType& QI,
                                     const QTType& QT,
                                     const QSType& QS,
                                     const DQType& DQ,
                                     const TWType& TW,
                                     const HType& H,
                                     const PType& P,
                                     const RType& R)
  : ::xml_schema::Type (),
    S_ (S, ::xml_schema::Flags (), this),
    FB_ (FB, ::xml_schema::Flags (), this),
    Q_ (Q, ::xml_schema::Flags (), this),
    QI_ (QI, ::xml_schema::Flags (), this),
    QT_ (QT, ::xml_schema::Flags (), this),
    QTX_ (::xml_schema::Flags (), this),
    QS_ (QS, ::xml_schema::Flags (), this),
    QSPercentage_ (::xml_schema::Flags (), this),
    QMISC_ (::xml_schema::Flags (), this),
    DQ_ (DQ, ::xml_schema::Flags (), this),
    TW_ (TW, ::xml_schema::Flags (), this),
    H_ (H, ::xml_schema::Flags (), this),
    P_ (P, ::xml_schema::Flags (), this),
    PX_ (::xml_schema::Flags (), this),
    R_ (R, ::xml_schema::Flags (), this)
  {
  }

  ReservoirCompactOutputComplexType::
  ReservoirCompactOutputComplexType (const ReservoirCompactOutputComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    S_ (x.S_, f, this),
    FB_ (x.FB_, f, this),
    Q_ (x.Q_, f, this),
    QI_ (x.QI_, f, this),
    QT_ (x.QT_, f, this),
    QTX_ (x.QTX_, f, this),
    QS_ (x.QS_, f, this),
    QSPercentage_ (x.QSPercentage_, f, this),
    QMISC_ (x.QMISC_, f, this),
    DQ_ (x.DQ_, f, this),
    TW_ (x.TW_, f, this),
    H_ (x.H_, f, this),
    P_ (x.P_, f, this),
    PX_ (x.PX_, f, this),
    R_ (x.R_, f, this)
  {
  }

  ReservoirCompactOutputComplexType::
  ReservoirCompactOutputComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    S_ (f, this),
    FB_ (f, this),
    Q_ (f, this),
    QI_ (f, this),
    QT_ (f, this),
    QTX_ (f, this),
    QS_ (f, this),
    QSPercentage_ (f, this),
    QMISC_ (f, this),
    DQ_ (f, this),
    TW_ (f, this),
    H_ (f, this),
    P_ (f, this),
    PX_ (f, this),
    R_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirCompactOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // S
      //
      if (n.name () == "S" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SType > r (
          STraits::create (i, f, this));

        if (!S_.present ())
        {
          this->S_.set (r);
          continue;
        }
      }

      // FB
      //
      if (n.name () == "FB" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FBType > r (
          FBTraits::create (i, f, this));

        if (!FB_.present ())
        {
          this->FB_.set (r);
          continue;
        }
      }

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      // QI
      //
      if (n.name () == "QI" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QIType > r (
          QITraits::create (i, f, this));

        if (!QI_.present ())
        {
          this->QI_.set (r);
          continue;
        }
      }

      // QT
      //
      if (n.name () == "QT" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QTType > r (
          QTTraits::create (i, f, this));

        if (!QT_.present ())
        {
          this->QT_.set (r);
          continue;
        }
      }

      // QTX
      //
      if (n.name () == "QTX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QTXType > r (
          QTXTraits::create (i, f, this));

        if (!this->QTX_)
        {
          this->QTX_.set (r);
          continue;
        }
      }

      // QS
      //
      if (n.name () == "QS" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSType > r (
          QSTraits::create (i, f, this));

        if (!QS_.present ())
        {
          this->QS_.set (r);
          continue;
        }
      }

      // QSPercentage
      //
      if (n.name () == "QSPercentage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QSPercentageType > r (
          QSPercentageTraits::create (i, f, this));

        if (!this->QSPercentage_)
        {
          this->QSPercentage_.set (r);
          continue;
        }
      }

      // QMISC
      //
      if (n.name () == "QMISC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QMISCType > r (
          QMISCTraits::create (i, f, this));

        if (!this->QMISC_)
        {
          this->QMISC_.set (r);
          continue;
        }
      }

      // DQ
      //
      if (n.name () == "DQ" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DQType > r (
          DQTraits::create (i, f, this));

        if (!DQ_.present ())
        {
          this->DQ_.set (r);
          continue;
        }
      }

      // TW
      //
      if (n.name () == "TW" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TWType > r (
          TWTraits::create (i, f, this));

        if (!TW_.present ())
        {
          this->TW_.set (r);
          continue;
        }
      }

      // H
      //
      if (n.name () == "H" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HType > r (
          HTraits::create (i, f, this));

        if (!H_.present ())
        {
          this->H_.set (r);
          continue;
        }
      }

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PType > r (
          PTraits::create (i, f, this));

        if (!P_.present ())
        {
          this->P_.set (r);
          continue;
        }
      }

      // PX
      //
      if (n.name () == "PX" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PXType > r (
          PXTraits::create (i, f, this));

        if (!this->PX_)
        {
          this->PX_.set (r);
          continue;
        }
      }

      // R
      //
      if (n.name () == "R" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RType > r (
          RTraits::create (i, f, this));

        if (!R_.present ())
        {
          this->R_.set (r);
          continue;
        }
      }

      break;
    }

    if (!S_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "S",
        "http://www.wldelft.nl/fews");
    }

    if (!FB_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FB",
        "http://www.wldelft.nl/fews");
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }

    if (!QI_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QI",
        "http://www.wldelft.nl/fews");
    }

    if (!QT_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QT",
        "http://www.wldelft.nl/fews");
    }

    if (!QS_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QS",
        "http://www.wldelft.nl/fews");
    }

    if (!DQ_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DQ",
        "http://www.wldelft.nl/fews");
    }

    if (!TW_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TW",
        "http://www.wldelft.nl/fews");
    }

    if (!H_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "H",
        "http://www.wldelft.nl/fews");
    }

    if (!P_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "P",
        "http://www.wldelft.nl/fews");
    }

    if (!R_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "R",
        "http://www.wldelft.nl/fews");
    }
  }

  ReservoirCompactOutputComplexType* ReservoirCompactOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirCompactOutputComplexType (*this, f, c);
  }

  ReservoirCompactOutputComplexType::
  ~ReservoirCompactOutputComplexType ()
  {
  }

  // ReservoirComplexType
  //

  ReservoirComplexType::
  ReservoirComplexType (const ModeType& mode,
                        const ThetaType& theta,
                        const StorageCharacteristicsType& storageCharacteristics,
                        const InputType& input,
                        const OutputType& output,
                        const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    theta_ (theta, ::xml_schema::Flags (), this),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this),
    controlledOutlet_ (::xml_schema::Flags (), this),
    uncontrolledOutlet_ (::xml_schema::Flags (), this),
    tailwater_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirComplexType::
  ReservoirComplexType (const ModeType& mode,
                        const ThetaType& theta,
                        ::std::auto_ptr< StorageCharacteristicsType >& storageCharacteristics,
                        ::std::auto_ptr< InputType >& input,
                        ::std::auto_ptr< OutputType >& output,
                        const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    theta_ (theta, ::xml_schema::Flags (), this),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this),
    controlledOutlet_ (::xml_schema::Flags (), this),
    uncontrolledOutlet_ (::xml_schema::Flags (), this),
    tailwater_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirComplexType::
  ReservoirComplexType (const ReservoirComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mode_ (x.mode_, f, this),
    theta_ (x.theta_, f, this),
    storageCharacteristics_ (x.storageCharacteristics_, f, this),
    controlledOutlet_ (x.controlledOutlet_, f, this),
    uncontrolledOutlet_ (x.uncontrolledOutlet_, f, this),
    tailwater_ (x.tailwater_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ReservoirComplexType::
  ReservoirComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mode_ (f, this),
    theta_ (f, this),
    storageCharacteristics_ (f, this),
    controlledOutlet_ (f, this),
    uncontrolledOutlet_ (f, this),
    tailwater_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ReservoirComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mode
      //
      if (n.name () == "mode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ModeType > r (
          ModeTraits::create (i, f, this));

        if (!mode_.present ())
        {
          this->mode_.set (r);
          continue;
        }
      }

      // theta
      //
      if (n.name () == "theta" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!theta_.present ())
        {
          this->theta_.set (ThetaTraits::create (i, f, this));
          continue;
        }
      }

      // storageCharacteristics
      //
      if (n.name () == "storageCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageCharacteristicsType > r (
          StorageCharacteristicsTraits::create (i, f, this));

        if (!storageCharacteristics_.present ())
        {
          this->storageCharacteristics_.set (r);
          continue;
        }
      }

      // controlledOutlet
      //
      if (n.name () == "controlledOutlet" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ControlledOutletType > r (
          ControlledOutletTraits::create (i, f, this));

        this->controlledOutlet_.push_back (r);
        continue;
      }

      // uncontrolledOutlet
      //
      if (n.name () == "uncontrolledOutlet" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UncontrolledOutletType > r (
          UncontrolledOutletTraits::create (i, f, this));

        this->uncontrolledOutlet_.push_back (r);
        continue;
      }

      // tailwater
      //
      if (n.name () == "tailwater" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TailwaterType > r (
          TailwaterTraits::create (i, f, this));

        if (!this->tailwater_)
        {
          this->tailwater_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mode",
        "http://www.wldelft.nl/fews");
    }

    if (!theta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "theta",
        "http://www.wldelft.nl/fews");
    }

    if (!storageCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ReservoirComplexType* ReservoirComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirComplexType (*this, f, c);
  }

  ReservoirComplexType::
  ~ReservoirComplexType ()
  {
  }

  // RoutingComplexType
  //

  RoutingComplexType::
  RoutingComplexType (const OutputReferencesType& outputReferences,
                      const IdType& id)
  : ::xml_schema::Type (),
    inflow_ (::xml_schema::Flags (), this),
    reservoirRouting_ (::xml_schema::Flags (), this),
    dischargeRef_ (::xml_schema::Flags (), this),
    outputReferences_ (outputReferences, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  RoutingComplexType::
  RoutingComplexType (::std::auto_ptr< OutputReferencesType >& outputReferences,
                      const IdType& id)
  : ::xml_schema::Type (),
    inflow_ (::xml_schema::Flags (), this),
    reservoirRouting_ (::xml_schema::Flags (), this),
    dischargeRef_ (::xml_schema::Flags (), this),
    outputReferences_ (outputReferences, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  RoutingComplexType::
  RoutingComplexType (const RoutingComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    inflow_ (x.inflow_, f, this),
    reservoirRouting_ (x.reservoirRouting_, f, this),
    dischargeRef_ (x.dischargeRef_, f, this),
    outputReferences_ (x.outputReferences_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  RoutingComplexType::
  RoutingComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    inflow_ (f, this),
    reservoirRouting_ (f, this),
    dischargeRef_ (f, this),
    outputReferences_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RoutingComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inflow
      //
      if (n.name () == "inflow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InflowType > r (
          InflowTraits::create (i, f, this));

        this->inflow_.push_back (r);
        continue;
      }

      // reservoirRouting
      //
      if (n.name () == "reservoirRouting" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReservoirRoutingType > r (
          ReservoirRoutingTraits::create (i, f, this));

        if (!this->reservoirRouting_)
        {
          this->reservoirRouting_.set (r);
          continue;
        }
      }

      // dischargeRef
      //
      if (n.name () == "dischargeRef" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeRefType > r (
          DischargeRefTraits::create (i, f, this));

        if (!this->dischargeRef_)
        {
          this->dischargeRef_.set (r);
          continue;
        }
      }

      // outputReferences
      //
      if (n.name () == "outputReferences" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputReferencesType > r (
          OutputReferencesTraits::create (i, f, this));

        if (!outputReferences_.present ())
        {
          this->outputReferences_.set (r);
          continue;
        }
      }

      break;
    }

    if (!outputReferences_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "outputReferences",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  RoutingComplexType* RoutingComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RoutingComplexType (*this, f, c);
  }

  RoutingComplexType::
  ~RoutingComplexType ()
  {
  }

  // NeuralNetworkComplexType
  //

  NeuralNetworkComplexType::
  NeuralNetworkComplexType (const IdType& id)
  : ::xml_schema::Type (),
    layer_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  NeuralNetworkComplexType::
  NeuralNetworkComplexType (const NeuralNetworkComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    layer_ (x.layer_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  NeuralNetworkComplexType::
  NeuralNetworkComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    layer_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void NeuralNetworkComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // layer
      //
      if (n.name () == "layer" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LayerType > r (
          LayerTraits::create (i, f, this));

        this->layer_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  NeuralNetworkComplexType* NeuralNetworkComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeuralNetworkComplexType (*this, f, c);
  }

  NeuralNetworkComplexType::
  ~NeuralNetworkComplexType ()
  {
  }

  // LayerComplexType
  //

  LayerComplexType::
  LayerComplexType (const IdType& id)
  : ::xml_schema::Type (),
    neuron_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LayerComplexType::
  LayerComplexType (const LayerComplexType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    neuron_ (x.neuron_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  LayerComplexType::
  LayerComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    neuron_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void LayerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // neuron
      //
      if (n.name () == "neuron" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NeuronType > r (
          NeuronTraits::create (i, f, this));

        this->neuron_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  LayerComplexType* LayerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LayerComplexType (*this, f, c);
  }

  LayerComplexType::
  ~LayerComplexType ()
  {
  }

  // NeuronComplexType
  //

  NeuronComplexType::
  NeuronComplexType (const BiasType& bias,
                     const TransferFunctionType& transferFunction,
                     const InputType& input,
                     const OutputType& output,
                     const IdType& id)
  : ::xml_schema::Type (),
    bias_ (bias, ::xml_schema::Flags (), this),
    transferFunction_ (transferFunction, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  NeuronComplexType::
  NeuronComplexType (const BiasType& bias,
                     const TransferFunctionType& transferFunction,
                     ::std::auto_ptr< InputType >& input,
                     ::std::auto_ptr< OutputType >& output,
                     const IdType& id)
  : ::xml_schema::Type (),
    bias_ (bias, ::xml_schema::Flags (), this),
    transferFunction_ (transferFunction, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  NeuronComplexType::
  NeuronComplexType (const NeuronComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    bias_ (x.bias_, f, this),
    transferFunction_ (x.transferFunction_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  NeuronComplexType::
  NeuronComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    bias_ (f, this),
    transferFunction_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void NeuronComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bias
      //
      if (n.name () == "bias" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BiasType > r (
          BiasTraits::create (i, f, this));

        if (!bias_.present ())
        {
          this->bias_.set (r);
          continue;
        }
      }

      // transferFunction
      //
      if (n.name () == "transferFunction" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TransferFunctionType > r (
          TransferFunctionTraits::create (i, f, this));

        if (!transferFunction_.present ())
        {
          this->transferFunction_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!bias_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bias",
        "http://www.wldelft.nl/fews");
    }

    if (!transferFunction_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "transferFunction",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  NeuronComplexType* NeuronComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeuronComplexType (*this, f, c);
  }

  NeuronComplexType::
  ~NeuronComplexType ()
  {
  }

  // NeuronInputComplexType
  //

  NeuronInputComplexType::
  NeuronInputComplexType ()
  : ::xml_schema::Type (),
    external_ (::xml_schema::Flags (), this),
    internal_ (::xml_schema::Flags (), this)
  {
  }

  NeuronInputComplexType::
  NeuronInputComplexType (const NeuronInputComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    external_ (x.external_, f, this),
    internal_ (x.internal_, f, this)
  {
  }

  NeuronInputComplexType::
  NeuronInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    external_ (f, this),
    internal_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NeuronInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // external
      //
      if (n.name () == "external" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExternalType > r (
          ExternalTraits::create (i, f, this));

        this->external_.push_back (r);
        continue;
      }

      // internal
      //
      if (n.name () == "internal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InternalType > r (
          InternalTraits::create (i, f, this));

        this->internal_.push_back (r);
        continue;
      }

      break;
    }
  }

  NeuronInputComplexType* NeuronInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeuronInputComplexType (*this, f, c);
  }

  NeuronInputComplexType::
  ~NeuronInputComplexType ()
  {
  }

  // NeuronOutputComplexType
  //

  NeuronOutputComplexType::
  NeuronOutputComplexType (const XType& x,
                           const YType& y)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  NeuronOutputComplexType::
  NeuronOutputComplexType (const NeuronOutputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  NeuronOutputComplexType::
  NeuronOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NeuronOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  NeuronOutputComplexType* NeuronOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeuronOutputComplexType (*this, f, c);
  }

  NeuronOutputComplexType::
  ~NeuronOutputComplexType ()
  {
  }

  // HydraulicModelComplexType
  //

  HydraulicModelComplexType::
  HydraulicModelComplexType (const ModeType& mode,
                             const NumericalToleranceType& numericalTolerance,
                             const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    sequentialImplicitSettings_ (::xml_schema::Flags (), this),
    simultaneousSettings_ (::xml_schema::Flags (), this),
    numericalTolerance_ (numericalTolerance, ::xml_schema::Flags (), this),
    node_ (::xml_schema::Flags (), this),
    branch_ (::xml_schema::Flags (), this),
    hydraulicStructure_ (::xml_schema::Flags (), this),
    output_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  HydraulicModelComplexType::
  HydraulicModelComplexType (const HydraulicModelComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mode_ (x.mode_, f, this),
    sequentialImplicitSettings_ (x.sequentialImplicitSettings_, f, this),
    simultaneousSettings_ (x.simultaneousSettings_, f, this),
    numericalTolerance_ (x.numericalTolerance_, f, this),
    node_ (x.node_, f, this),
    branch_ (x.branch_, f, this),
    hydraulicStructure_ (x.hydraulicStructure_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  HydraulicModelComplexType::
  HydraulicModelComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mode_ (f, this),
    sequentialImplicitSettings_ (f, this),
    simultaneousSettings_ (f, this),
    numericalTolerance_ (f, this),
    node_ (f, this),
    branch_ (f, this),
    hydraulicStructure_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void HydraulicModelComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mode
      //
      if (n.name () == "mode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ModeType > r (
          ModeTraits::create (i, f, this));

        if (!mode_.present ())
        {
          this->mode_.set (r);
          continue;
        }
      }

      // sequentialImplicitSettings
      //
      if (n.name () == "sequentialImplicitSettings" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SequentialImplicitSettingsType > r (
          SequentialImplicitSettingsTraits::create (i, f, this));

        if (!this->sequentialImplicitSettings_)
        {
          this->sequentialImplicitSettings_.set (r);
          continue;
        }
      }

      // simultaneousSettings
      //
      if (n.name () == "simultaneousSettings" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimultaneousSettingsType > r (
          SimultaneousSettingsTraits::create (i, f, this));

        if (!this->simultaneousSettings_)
        {
          this->simultaneousSettings_.set (r);
          continue;
        }
      }

      // numericalTolerance
      //
      if (n.name () == "numericalTolerance" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!numericalTolerance_.present ())
        {
          this->numericalTolerance_.set (NumericalToleranceTraits::create (i, f, this));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeType > r (
          NodeTraits::create (i, f, this));

        this->node_.push_back (r);
        continue;
      }

      // branch
      //
      if (n.name () == "branch" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BranchType > r (
          BranchTraits::create (i, f, this));

        this->branch_.push_back (r);
        continue;
      }

      // hydraulicStructure
      //
      if (n.name () == "hydraulicStructure" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HydraulicStructureType > r (
          HydraulicStructureTraits::create (i, f, this));

        this->hydraulicStructure_.push_back (r);
        continue;
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!this->output_)
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mode",
        "http://www.wldelft.nl/fews");
    }

    if (!numericalTolerance_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numericalTolerance",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  HydraulicModelComplexType* HydraulicModelComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraulicModelComplexType (*this, f, c);
  }

  HydraulicModelComplexType::
  ~HydraulicModelComplexType ()
  {
  }

  // HydraulicModelSequentialImplicitComplexType
  //

  HydraulicModelSequentialImplicitComplexType::
  HydraulicModelSequentialImplicitComplexType (const ThetaType& theta,
                                               const ConvergenceThresholdType& convergenceThreshold,
                                               const TreatNonConvergenceAsErrorType& treatNonConvergenceAsError)
  : ::xml_schema::Type (),
    theta_ (theta, ::xml_schema::Flags (), this),
    convergenceThreshold_ (convergenceThreshold, ::xml_schema::Flags (), this),
    treatNonConvergenceAsError_ (treatNonConvergenceAsError, ::xml_schema::Flags (), this)
  {
  }

  HydraulicModelSequentialImplicitComplexType::
  HydraulicModelSequentialImplicitComplexType (const HydraulicModelSequentialImplicitComplexType& x,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    theta_ (x.theta_, f, this),
    convergenceThreshold_ (x.convergenceThreshold_, f, this),
    treatNonConvergenceAsError_ (x.treatNonConvergenceAsError_, f, this)
  {
  }

  HydraulicModelSequentialImplicitComplexType::
  HydraulicModelSequentialImplicitComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    theta_ (f, this),
    convergenceThreshold_ (f, this),
    treatNonConvergenceAsError_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HydraulicModelSequentialImplicitComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // theta
      //
      if (n.name () == "theta" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!theta_.present ())
        {
          this->theta_.set (ThetaTraits::create (i, f, this));
          continue;
        }
      }

      // convergenceThreshold
      //
      if (n.name () == "convergenceThreshold" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!convergenceThreshold_.present ())
        {
          this->convergenceThreshold_.set (ConvergenceThresholdTraits::create (i, f, this));
          continue;
        }
      }

      // treatNonConvergenceAsError
      //
      if (n.name () == "treatNonConvergenceAsError" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!treatNonConvergenceAsError_.present ())
        {
          this->treatNonConvergenceAsError_.set (TreatNonConvergenceAsErrorTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!theta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "theta",
        "http://www.wldelft.nl/fews");
    }

    if (!convergenceThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "convergenceThreshold",
        "http://www.wldelft.nl/fews");
    }

    if (!treatNonConvergenceAsError_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treatNonConvergenceAsError",
        "http://www.wldelft.nl/fews");
    }
  }

  HydraulicModelSequentialImplicitComplexType* HydraulicModelSequentialImplicitComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraulicModelSequentialImplicitComplexType (*this, f, c);
  }

  HydraulicModelSequentialImplicitComplexType::
  ~HydraulicModelSequentialImplicitComplexType ()
  {
  }

  // HydraulicModelSimultaneousComplexType
  //

  HydraulicModelSimultaneousComplexType::
  HydraulicModelSimultaneousComplexType (const ThetaType& theta)
  : ::xml_schema::Type (),
    theta_ (theta, ::xml_schema::Flags (), this)
  {
  }

  HydraulicModelSimultaneousComplexType::
  HydraulicModelSimultaneousComplexType (const HydraulicModelSimultaneousComplexType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    theta_ (x.theta_, f, this)
  {
  }

  HydraulicModelSimultaneousComplexType::
  HydraulicModelSimultaneousComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    theta_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HydraulicModelSimultaneousComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // theta
      //
      if (n.name () == "theta" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!theta_.present ())
        {
          this->theta_.set (ThetaTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!theta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "theta",
        "http://www.wldelft.nl/fews");
    }
  }

  HydraulicModelSimultaneousComplexType* HydraulicModelSimultaneousComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraulicModelSimultaneousComplexType (*this, f, c);
  }

  HydraulicModelSimultaneousComplexType::
  ~HydraulicModelSimultaneousComplexType ()
  {
  }

  // HydraulicModelOutputComplexType
  //

  HydraulicModelOutputComplexType::
  HydraulicModelOutputComplexType (const NJacType& nJac,
                                   const NFunType& nFun,
                                   const ResType& res)
  : ::xml_schema::Type (),
    nJac_ (nJac, ::xml_schema::Flags (), this),
    nFun_ (nFun, ::xml_schema::Flags (), this),
    res_ (res, ::xml_schema::Flags (), this)
  {
  }

  HydraulicModelOutputComplexType::
  HydraulicModelOutputComplexType (const HydraulicModelOutputComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nJac_ (x.nJac_, f, this),
    nFun_ (x.nFun_, f, this),
    res_ (x.res_, f, this)
  {
  }

  HydraulicModelOutputComplexType::
  HydraulicModelOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nJac_ (f, this),
    nFun_ (f, this),
    res_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HydraulicModelOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nJac
      //
      if (n.name () == "nJac" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NJacType > r (
          NJacTraits::create (i, f, this));

        if (!nJac_.present ())
        {
          this->nJac_.set (r);
          continue;
        }
      }

      // nFun
      //
      if (n.name () == "nFun" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NFunType > r (
          NFunTraits::create (i, f, this));

        if (!nFun_.present ())
        {
          this->nFun_.set (r);
          continue;
        }
      }

      // res
      //
      if (n.name () == "res" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ResType > r (
          ResTraits::create (i, f, this));

        if (!res_.present ())
        {
          this->res_.set (r);
          continue;
        }
      }

      break;
    }

    if (!nJac_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nJac",
        "http://www.wldelft.nl/fews");
    }

    if (!nFun_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nFun",
        "http://www.wldelft.nl/fews");
    }

    if (!res_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "res",
        "http://www.wldelft.nl/fews");
    }
  }

  HydraulicModelOutputComplexType* HydraulicModelOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraulicModelOutputComplexType (*this, f, c);
  }

  HydraulicModelOutputComplexType::
  ~HydraulicModelOutputComplexType ()
  {
  }

  // ConnectionInputComplexType
  //

  ConnectionInputComplexType::
  ConnectionInputComplexType (const UpstreamLevelType& upstreamLevel,
                              const DownstreamLevelType& downstreamLevel,
                              const DischargeType& discharge)
  : ::xml_schema::Type (),
    upstreamLevel_ (upstreamLevel, ::xml_schema::Flags (), this),
    downstreamLevel_ (downstreamLevel, ::xml_schema::Flags (), this),
    discharge_ (discharge, ::xml_schema::Flags (), this)
  {
  }

  ConnectionInputComplexType::
  ConnectionInputComplexType (const ConnectionInputComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    upstreamLevel_ (x.upstreamLevel_, f, this),
    downstreamLevel_ (x.downstreamLevel_, f, this),
    discharge_ (x.discharge_, f, this)
  {
  }

  ConnectionInputComplexType::
  ConnectionInputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    upstreamLevel_ (f, this),
    downstreamLevel_ (f, this),
    discharge_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConnectionInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // upstreamLevel
      //
      if (n.name () == "upstreamLevel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpstreamLevelType > r (
          UpstreamLevelTraits::create (i, f, this));

        if (!upstreamLevel_.present ())
        {
          this->upstreamLevel_.set (r);
          continue;
        }
      }

      // downstreamLevel
      //
      if (n.name () == "downstreamLevel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DownstreamLevelType > r (
          DownstreamLevelTraits::create (i, f, this));

        if (!downstreamLevel_.present ())
        {
          this->downstreamLevel_.set (r);
          continue;
        }
      }

      // discharge
      //
      if (n.name () == "discharge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeType > r (
          DischargeTraits::create (i, f, this));

        if (!discharge_.present ())
        {
          this->discharge_.set (r);
          continue;
        }
      }

      break;
    }

    if (!upstreamLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "upstreamLevel",
        "http://www.wldelft.nl/fews");
    }

    if (!downstreamLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "downstreamLevel",
        "http://www.wldelft.nl/fews");
    }

    if (!discharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "discharge",
        "http://www.wldelft.nl/fews");
    }
  }

  ConnectionInputComplexType* ConnectionInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConnectionInputComplexType (*this, f, c);
  }

  ConnectionInputComplexType::
  ~ConnectionInputComplexType ()
  {
  }

  // ConnectionOutputComplexType
  //

  ConnectionOutputComplexType::
  ConnectionOutputComplexType (const DischargeType& discharge)
  : ::xml_schema::Type (),
    discharge_ (discharge, ::xml_schema::Flags (), this)
  {
  }

  ConnectionOutputComplexType::
  ConnectionOutputComplexType (const ConnectionOutputComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    discharge_ (x.discharge_, f, this)
  {
  }

  ConnectionOutputComplexType::
  ConnectionOutputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    discharge_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConnectionOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // discharge
      //
      if (n.name () == "discharge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeType > r (
          DischargeTraits::create (i, f, this));

        if (!discharge_.present ())
        {
          this->discharge_.set (r);
          continue;
        }
      }

      break;
    }

    if (!discharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "discharge",
        "http://www.wldelft.nl/fews");
    }
  }

  ConnectionOutputComplexType* ConnectionOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConnectionOutputComplexType (*this, f, c);
  }

  ConnectionOutputComplexType::
  ~ConnectionOutputComplexType ()
  {
  }

  // RoutingOutputComplexType
  //

  RoutingOutputComplexType::
  RoutingOutputComplexType ()
  : ::xml_schema::Type (),
    discharge_ (::xml_schema::Flags (), this),
    error_ (::xml_schema::Flags (), this)
  {
  }

  RoutingOutputComplexType::
  RoutingOutputComplexType (const RoutingOutputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    discharge_ (x.discharge_, f, this),
    error_ (x.error_, f, this)
  {
  }

  RoutingOutputComplexType::
  RoutingOutputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    discharge_ (f, this),
    error_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RoutingOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // discharge
      //
      if (n.name () == "discharge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeType > r (
          DischargeTraits::create (i, f, this));

        if (!this->discharge_)
        {
          this->discharge_.set (r);
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!this->error_)
        {
          this->error_.set (r);
          continue;
        }
      }

      break;
    }
  }

  RoutingOutputComplexType* RoutingOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RoutingOutputComplexType (*this, f, c);
  }

  RoutingOutputComplexType::
  ~RoutingOutputComplexType ()
  {
  }

  // ReservoirRoutingComplexType
  //

  ReservoirRoutingComplexType::
  ReservoirRoutingComplexType ()
  : ::xml_schema::Type (),
    simpleReservoir_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirRoutingComplexType::
  ReservoirRoutingComplexType (const ReservoirRoutingComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    simpleReservoir_ (x.simpleReservoir_, f, this)
  {
  }

  ReservoirRoutingComplexType::
  ReservoirRoutingComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    simpleReservoir_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirRoutingComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // simpleReservoir
      //
      if (n.name () == "simpleReservoir" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimpleReservoirType > r (
          SimpleReservoirTraits::create (i, f, this));

        this->simpleReservoir_.push_back (r);
        continue;
      }

      break;
    }
  }

  ReservoirRoutingComplexType* ReservoirRoutingComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirRoutingComplexType (*this, f, c);
  }

  ReservoirRoutingComplexType::
  ~ReservoirRoutingComplexType ()
  {
  }

  // SimpleReservoirComplexType
  //

  SimpleReservoirComplexType::
  SimpleReservoirComplexType (const StorageCharacteristicsType& storageCharacteristics,
                              const CapacityCharacteristicsType& capacityCharacteristics)
  : ::xml_schema::Type (),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    multiplier_ (getMultiplierDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  SimpleReservoirComplexType::
  SimpleReservoirComplexType (::std::auto_ptr< StorageCharacteristicsType >& storageCharacteristics,
                              ::std::auto_ptr< CapacityCharacteristicsType >& capacityCharacteristics)
  : ::xml_schema::Type (),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    multiplier_ (getMultiplierDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  SimpleReservoirComplexType::
  SimpleReservoirComplexType (const SimpleReservoirComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    storageCharacteristics_ (x.storageCharacteristics_, f, this),
    capacityCharacteristics_ (x.capacityCharacteristics_, f, this),
    multiplier_ (x.multiplier_, f, this)
  {
  }

  SimpleReservoirComplexType::
  SimpleReservoirComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    storageCharacteristics_ (f, this),
    capacityCharacteristics_ (f, this),
    multiplier_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SimpleReservoirComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // storageCharacteristics
      //
      if (n.name () == "storageCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageCharacteristicsType > r (
          StorageCharacteristicsTraits::create (i, f, this));

        if (!storageCharacteristics_.present ())
        {
          this->storageCharacteristics_.set (r);
          continue;
        }
      }

      // capacityCharacteristics
      //
      if (n.name () == "capacityCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityCharacteristicsType > r (
          CapacityCharacteristicsTraits::create (i, f, this));

        if (!capacityCharacteristics_.present ())
        {
          this->capacityCharacteristics_.set (r);
          continue;
        }
      }

      break;
    }

    if (!storageCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!capacityCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "capacityCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "multiplier" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MultiplierType > r (
          MultiplierTraits::create (i, f, this));

        this->multiplier_.set (r);
        continue;
      }
    }

    if (!multiplier_.present ())
    {
      this->multiplier_.set (getMultiplierDefaultValue ());
    }
  }

  SimpleReservoirComplexType* SimpleReservoirComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SimpleReservoirComplexType (*this, f, c);
  }

  SimpleReservoirComplexType::
  ~SimpleReservoirComplexType ()
  {
  }

  // ConnectionCoefficientsComplexType
  //

  ConnectionCoefficientsComplexType::
  ConnectionCoefficientsComplexType (const AType& a,
                                     const BType& b,
                                     const CType& c,
                                     const DType& d)
  : ::xml_schema::Type (),
    a_ (a, ::xml_schema::Flags (), this),
    b_ (b, ::xml_schema::Flags (), this),
    c_ (c, ::xml_schema::Flags (), this),
    d_ (d, ::xml_schema::Flags (), this)
  {
  }

  ConnectionCoefficientsComplexType::
  ConnectionCoefficientsComplexType (const ConnectionCoefficientsComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    c_ (x.c_, f, this),
    d_ (x.d_, f, this)
  {
  }

  ConnectionCoefficientsComplexType::
  ConnectionCoefficientsComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a_ (f, this),
    b_ (f, this),
    c_ (f, this),
    d_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConnectionCoefficientsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // a
      //
      if (n.name () == "a" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AType > r (
          ATraits::create (i, f, this));

        if (!a_.present ())
        {
          this->a_.set (r);
          continue;
        }
      }

      // b
      //
      if (n.name () == "b" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BType > r (
          BTraits::create (i, f, this));

        if (!b_.present ())
        {
          this->b_.set (r);
          continue;
        }
      }

      // c
      //
      if (n.name () == "c" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CType > r (
          CTraits::create (i, f, this));

        if (!c_.present ())
        {
          this->c_.set (r);
          continue;
        }
      }

      // d
      //
      if (n.name () == "d" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!d_.present ())
        {
          this->d_.set (r);
          continue;
        }
      }

      break;
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a",
        "http://www.wldelft.nl/fews");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "b",
        "http://www.wldelft.nl/fews");
    }

    if (!c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "c",
        "http://www.wldelft.nl/fews");
    }

    if (!d_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "d",
        "http://www.wldelft.nl/fews");
    }
  }

  ConnectionCoefficientsComplexType* ConnectionCoefficientsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConnectionCoefficientsComplexType (*this, f, c);
  }

  ConnectionCoefficientsComplexType::
  ~ConnectionCoefficientsComplexType ()
  {
  }

  // RulesComplexType
  //

  RulesComplexType::
  RulesComplexType ()
  : ::xml_schema::Type (),
    rule_ (::xml_schema::Flags (), this)
  {
  }

  RulesComplexType::
  RulesComplexType (const RulesComplexType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    rule_ (x.rule_, f, this)
  {
  }

  RulesComplexType::
  RulesComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    rule_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RulesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rule
      //
      if (n.name () == "rule" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RuleType > r (
          RuleTraits::create (i, f, this));

        this->rule_.push_back (r);
        continue;
      }

      break;
    }
  }

  RulesComplexType* RulesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RulesComplexType (*this, f, c);
  }

  RulesComplexType::
  ~RulesComplexType ()
  {
  }

  // RuleComplexType
  //

  RuleComplexType::
  RuleComplexType ()
  : ::xml_schema::Type (),
    constant_ (::xml_schema::Flags (), this),
    dateLookupTable_ (::xml_schema::Flags (), this),
    deadBandValue_ (::xml_schema::Flags (), this),
    deadBandTime_ (::xml_schema::Flags (), this),
    dedicated_Aebi_ (::xml_schema::Flags (), this),
    dedicated_Thunersee_ (::xml_schema::Flags (), this),
    expression_ (::xml_schema::Flags (), this),
    guideband_ (::xml_schema::Flags (), this),
    interval_ (::xml_schema::Flags (), this),
    limiter_ (::xml_schema::Flags (), this),
    lookupTable_ (::xml_schema::Flags (), this),
    lookup2DTable_ (::xml_schema::Flags (), this),
    merger_ (::xml_schema::Flags (), this),
    pid_ (::xml_schema::Flags (), this),
    timeAbsolute_ (::xml_schema::Flags (), this),
    timeRelative_ (::xml_schema::Flags (), this),
    unitDelay_ (::xml_schema::Flags (), this)
  {
  }

  RuleComplexType::
  RuleComplexType (const RuleComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    constant_ (x.constant_, f, this),
    dateLookupTable_ (x.dateLookupTable_, f, this),
    deadBandValue_ (x.deadBandValue_, f, this),
    deadBandTime_ (x.deadBandTime_, f, this),
    dedicated_Aebi_ (x.dedicated_Aebi_, f, this),
    dedicated_Thunersee_ (x.dedicated_Thunersee_, f, this),
    expression_ (x.expression_, f, this),
    guideband_ (x.guideband_, f, this),
    interval_ (x.interval_, f, this),
    limiter_ (x.limiter_, f, this),
    lookupTable_ (x.lookupTable_, f, this),
    lookup2DTable_ (x.lookup2DTable_, f, this),
    merger_ (x.merger_, f, this),
    pid_ (x.pid_, f, this),
    timeAbsolute_ (x.timeAbsolute_, f, this),
    timeRelative_ (x.timeRelative_, f, this),
    unitDelay_ (x.unitDelay_, f, this)
  {
  }

  RuleComplexType::
  RuleComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    constant_ (f, this),
    dateLookupTable_ (f, this),
    deadBandValue_ (f, this),
    deadBandTime_ (f, this),
    dedicated_Aebi_ (f, this),
    dedicated_Thunersee_ (f, this),
    expression_ (f, this),
    guideband_ (f, this),
    interval_ (f, this),
    limiter_ (f, this),
    lookupTable_ (f, this),
    lookup2DTable_ (f, this),
    merger_ (f, this),
    pid_ (f, this),
    timeAbsolute_ (f, this),
    timeRelative_ (f, this),
    unitDelay_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConstantType > r (
          ConstantTraits::create (i, f, this));

        if (!this->constant_)
        {
          this->constant_.set (r);
          continue;
        }
      }

      // dateLookupTable
      //
      if (n.name () == "dateLookupTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DateLookupTableType > r (
          DateLookupTableTraits::create (i, f, this));

        if (!this->dateLookupTable_)
        {
          this->dateLookupTable_.set (r);
          continue;
        }
      }

      // deadBandValue
      //
      if (n.name () == "deadBandValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeadBandValueType > r (
          DeadBandValueTraits::create (i, f, this));

        if (!this->deadBandValue_)
        {
          this->deadBandValue_.set (r);
          continue;
        }
      }

      // deadBandTime
      //
      if (n.name () == "deadBandTime" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeadBandTimeType > r (
          DeadBandTimeTraits::create (i, f, this));

        if (!this->deadBandTime_)
        {
          this->deadBandTime_.set (r);
          continue;
        }
      }

      // dedicated-Aebi
      //
      if (n.name () == "dedicated-Aebi" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Dedicated_AebiType > r (
          Dedicated_AebiTraits::create (i, f, this));

        if (!this->dedicated_Aebi_)
        {
          this->dedicated_Aebi_.set (r);
          continue;
        }
      }

      // dedicated-Thunersee
      //
      if (n.name () == "dedicated-Thunersee" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Dedicated_ThunerseeType > r (
          Dedicated_ThunerseeTraits::create (i, f, this));

        if (!this->dedicated_Thunersee_)
        {
          this->dedicated_Thunersee_.set (r);
          continue;
        }
      }

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExpressionType > r (
          ExpressionTraits::create (i, f, this));

        if (!this->expression_)
        {
          this->expression_.set (r);
          continue;
        }
      }

      // guideband
      //
      if (n.name () == "guideband" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< GuidebandType > r (
          GuidebandTraits::create (i, f, this));

        if (!this->guideband_)
        {
          this->guideband_.set (r);
          continue;
        }
      }

      // interval
      //
      if (n.name () == "interval" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< IntervalType > r (
          IntervalTraits::create (i, f, this));

        if (!this->interval_)
        {
          this->interval_.set (r);
          continue;
        }
      }

      // limiter
      //
      if (n.name () == "limiter" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LimiterType > r (
          LimiterTraits::create (i, f, this));

        if (!this->limiter_)
        {
          this->limiter_.set (r);
          continue;
        }
      }

      // lookupTable
      //
      if (n.name () == "lookupTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LookupTableType > r (
          LookupTableTraits::create (i, f, this));

        if (!this->lookupTable_)
        {
          this->lookupTable_.set (r);
          continue;
        }
      }

      // lookup2DTable
      //
      if (n.name () == "lookup2DTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Lookup2DTableType > r (
          Lookup2DTableTraits::create (i, f, this));

        if (!this->lookup2DTable_)
        {
          this->lookup2DTable_.set (r);
          continue;
        }
      }

      // merger
      //
      if (n.name () == "merger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MergerType > r (
          MergerTraits::create (i, f, this));

        if (!this->merger_)
        {
          this->merger_.set (r);
          continue;
        }
      }

      // pid
      //
      if (n.name () == "pid" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PidType > r (
          PidTraits::create (i, f, this));

        if (!this->pid_)
        {
          this->pid_.set (r);
          continue;
        }
      }

      // timeAbsolute
      //
      if (n.name () == "timeAbsolute" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeAbsoluteType > r (
          TimeAbsoluteTraits::create (i, f, this));

        if (!this->timeAbsolute_)
        {
          this->timeAbsolute_.set (r);
          continue;
        }
      }

      // timeRelative
      //
      if (n.name () == "timeRelative" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeRelativeType > r (
          TimeRelativeTraits::create (i, f, this));

        if (!this->timeRelative_)
        {
          this->timeRelative_.set (r);
          continue;
        }
      }

      // unitDelay
      //
      if (n.name () == "unitDelay" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitDelayType > r (
          UnitDelayTraits::create (i, f, this));

        if (!this->unitDelay_)
        {
          this->unitDelay_.set (r);
          continue;
        }
      }

      break;
    }
  }

  RuleComplexType* RuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RuleComplexType (*this, f, c);
  }

  RuleComplexType::
  ~RuleComplexType ()
  {
  }

  // ThunerseeRuleComplexType
  //

  ThunerseeRuleComplexType::
  ThunerseeRuleComplexType (const LevelSetpointType& levelSetpoint,
                            const ReleaseLimiterPercentageType& releaseLimiterPercentage,
                            const ReservoirType& reservoir,
                            const WeirType& weir,
                            const TunnelType& tunnel,
                            const InputType& input,
                            const OutputType& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    levelSetpoint_ (levelSetpoint, ::xml_schema::Flags (), this),
    releaseLimiterPercentage_ (releaseLimiterPercentage, ::xml_schema::Flags (), this),
    reservoir_ (reservoir, ::xml_schema::Flags (), this),
    weir_ (weir, ::xml_schema::Flags (), this),
    tunnel_ (tunnel, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ThunerseeRuleComplexType::
  ThunerseeRuleComplexType (const LevelSetpointType& levelSetpoint,
                            const ReleaseLimiterPercentageType& releaseLimiterPercentage,
                            ::std::auto_ptr< ReservoirType >& reservoir,
                            ::std::auto_ptr< WeirType >& weir,
                            ::std::auto_ptr< TunnelType >& tunnel,
                            ::std::auto_ptr< InputType >& input,
                            ::std::auto_ptr< OutputType >& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    levelSetpoint_ (levelSetpoint, ::xml_schema::Flags (), this),
    releaseLimiterPercentage_ (releaseLimiterPercentage, ::xml_schema::Flags (), this),
    reservoir_ (reservoir, ::xml_schema::Flags (), this),
    weir_ (weir, ::xml_schema::Flags (), this),
    tunnel_ (tunnel, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ThunerseeRuleComplexType::
  ThunerseeRuleComplexType (const ThunerseeRuleComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    levelSetpoint_ (x.levelSetpoint_, f, this),
    releaseLimiterPercentage_ (x.releaseLimiterPercentage_, f, this),
    reservoir_ (x.reservoir_, f, this),
    weir_ (x.weir_, f, this),
    tunnel_ (x.tunnel_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ThunerseeRuleComplexType::
  ThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    levelSetpoint_ (f, this),
    releaseLimiterPercentage_ (f, this),
    reservoir_ (f, this),
    weir_ (f, this),
    tunnel_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ThunerseeRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // levelSetpoint
      //
      if (n.name () == "levelSetpoint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!levelSetpoint_.present ())
        {
          this->levelSetpoint_.set (LevelSetpointTraits::create (i, f, this));
          continue;
        }
      }

      // releaseLimiterPercentage
      //
      if (n.name () == "releaseLimiterPercentage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!releaseLimiterPercentage_.present ())
        {
          this->releaseLimiterPercentage_.set (ReleaseLimiterPercentageTraits::create (i, f, this));
          continue;
        }
      }

      // reservoir
      //
      if (n.name () == "reservoir" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReservoirType > r (
          ReservoirTraits::create (i, f, this));

        if (!reservoir_.present ())
        {
          this->reservoir_.set (r);
          continue;
        }
      }

      // weir
      //
      if (n.name () == "weir" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeirType > r (
          WeirTraits::create (i, f, this));

        if (!weir_.present ())
        {
          this->weir_.set (r);
          continue;
        }
      }

      // tunnel
      //
      if (n.name () == "tunnel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TunnelType > r (
          TunnelTraits::create (i, f, this));

        if (!tunnel_.present ())
        {
          this->tunnel_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!levelSetpoint_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "levelSetpoint",
        "http://www.wldelft.nl/fews");
    }

    if (!releaseLimiterPercentage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "releaseLimiterPercentage",
        "http://www.wldelft.nl/fews");
    }

    if (!reservoir_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reservoir",
        "http://www.wldelft.nl/fews");
    }

    if (!weir_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "weir",
        "http://www.wldelft.nl/fews");
    }

    if (!tunnel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tunnel",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ThunerseeRuleComplexType* ThunerseeRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ThunerseeRuleComplexType (*this, f, c);
  }

  ThunerseeRuleComplexType::
  ~ThunerseeRuleComplexType ()
  {
  }

  // ReservoirThunerseeRuleComplexType
  //

  ReservoirThunerseeRuleComplexType::
  ReservoirThunerseeRuleComplexType (const StorageCharacteristicsType& storageCharacteristics)
  : ::xml_schema::Type (),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this)
  {
  }

  ReservoirThunerseeRuleComplexType::
  ReservoirThunerseeRuleComplexType (::std::auto_ptr< StorageCharacteristicsType >& storageCharacteristics)
  : ::xml_schema::Type (),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this)
  {
  }

  ReservoirThunerseeRuleComplexType::
  ReservoirThunerseeRuleComplexType (const ReservoirThunerseeRuleComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    storageCharacteristics_ (x.storageCharacteristics_, f, this)
  {
  }

  ReservoirThunerseeRuleComplexType::
  ReservoirThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    storageCharacteristics_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirThunerseeRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // storageCharacteristics
      //
      if (n.name () == "storageCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageCharacteristicsType > r (
          StorageCharacteristicsTraits::create (i, f, this));

        if (!storageCharacteristics_.present ())
        {
          this->storageCharacteristics_.set (r);
          continue;
        }
      }

      break;
    }

    if (!storageCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageCharacteristics",
        "http://www.wldelft.nl/fews");
    }
  }

  ReservoirThunerseeRuleComplexType* ReservoirThunerseeRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirThunerseeRuleComplexType (*this, f, c);
  }

  ReservoirThunerseeRuleComplexType::
  ~ReservoirThunerseeRuleComplexType ()
  {
  }

  // WeirThunerseeRuleComplexType
  //

  WeirThunerseeRuleComplexType::
  WeirThunerseeRuleComplexType (const CapacityCharacteristicsType& capacityCharacteristics)
  : ::xml_schema::Type (),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this)
  {
  }

  WeirThunerseeRuleComplexType::
  WeirThunerseeRuleComplexType (::std::auto_ptr< CapacityCharacteristicsType >& capacityCharacteristics)
  : ::xml_schema::Type (),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this)
  {
  }

  WeirThunerseeRuleComplexType::
  WeirThunerseeRuleComplexType (const WeirThunerseeRuleComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    capacityCharacteristics_ (x.capacityCharacteristics_, f, this)
  {
  }

  WeirThunerseeRuleComplexType::
  WeirThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    capacityCharacteristics_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void WeirThunerseeRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // capacityCharacteristics
      //
      if (n.name () == "capacityCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityCharacteristicsType > r (
          CapacityCharacteristicsTraits::create (i, f, this));

        if (!capacityCharacteristics_.present ())
        {
          this->capacityCharacteristics_.set (r);
          continue;
        }
      }

      break;
    }

    if (!capacityCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "capacityCharacteristics",
        "http://www.wldelft.nl/fews");
    }
  }

  WeirThunerseeRuleComplexType* WeirThunerseeRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WeirThunerseeRuleComplexType (*this, f, c);
  }

  WeirThunerseeRuleComplexType::
  ~WeirThunerseeRuleComplexType ()
  {
  }

  // TunnelThunerseeRuleComplexType
  //

  TunnelThunerseeRuleComplexType::
  TunnelThunerseeRuleComplexType (const LevelThresholdType& levelThreshold,
                                  const CapacityCharacteristicsType& capacityCharacteristics)
  : ::xml_schema::Type (),
    levelThreshold_ (levelThreshold, ::xml_schema::Flags (), this),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this)
  {
  }

  TunnelThunerseeRuleComplexType::
  TunnelThunerseeRuleComplexType (const LevelThresholdType& levelThreshold,
                                  ::std::auto_ptr< CapacityCharacteristicsType >& capacityCharacteristics)
  : ::xml_schema::Type (),
    levelThreshold_ (levelThreshold, ::xml_schema::Flags (), this),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this)
  {
  }

  TunnelThunerseeRuleComplexType::
  TunnelThunerseeRuleComplexType (const TunnelThunerseeRuleComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    levelThreshold_ (x.levelThreshold_, f, this),
    capacityCharacteristics_ (x.capacityCharacteristics_, f, this)
  {
  }

  TunnelThunerseeRuleComplexType::
  TunnelThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    levelThreshold_ (f, this),
    capacityCharacteristics_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TunnelThunerseeRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // levelThreshold
      //
      if (n.name () == "levelThreshold" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!levelThreshold_.present ())
        {
          this->levelThreshold_.set (LevelThresholdTraits::create (i, f, this));
          continue;
        }
      }

      // capacityCharacteristics
      //
      if (n.name () == "capacityCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityCharacteristicsType > r (
          CapacityCharacteristicsTraits::create (i, f, this));

        if (!capacityCharacteristics_.present ())
        {
          this->capacityCharacteristics_.set (r);
          continue;
        }
      }

      break;
    }

    if (!levelThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "levelThreshold",
        "http://www.wldelft.nl/fews");
    }

    if (!capacityCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "capacityCharacteristics",
        "http://www.wldelft.nl/fews");
    }
  }

  TunnelThunerseeRuleComplexType* TunnelThunerseeRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TunnelThunerseeRuleComplexType (*this, f, c);
  }

  TunnelThunerseeRuleComplexType::
  ~TunnelThunerseeRuleComplexType ()
  {
  }

  // ThunerseeRuleInputComplexType
  //

  ThunerseeRuleInputComplexType::
  ThunerseeRuleInputComplexType (const InflowType& inflow,
                                 const LevelType& level,
                                 const CatchmentType& catchment)
  : ::xml_schema::Type (),
    inflow_ (inflow, ::xml_schema::Flags (), this),
    level_ (level, ::xml_schema::Flags (), this),
    catchment_ (catchment, ::xml_schema::Flags (), this)
  {
  }

  ThunerseeRuleInputComplexType::
  ThunerseeRuleInputComplexType (const ThunerseeRuleInputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    inflow_ (x.inflow_, f, this),
    level_ (x.level_, f, this),
    catchment_ (x.catchment_, f, this)
  {
  }

  ThunerseeRuleInputComplexType::
  ThunerseeRuleInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    inflow_ (f, this),
    level_ (f, this),
    catchment_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ThunerseeRuleInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inflow
      //
      if (n.name () == "inflow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InflowType > r (
          InflowTraits::create (i, f, this));

        if (!inflow_.present ())
        {
          this->inflow_.set (r);
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelType > r (
          LevelTraits::create (i, f, this));

        if (!level_.present ())
        {
          this->level_.set (r);
          continue;
        }
      }

      // catchment
      //
      if (n.name () == "catchment" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CatchmentType > r (
          CatchmentTraits::create (i, f, this));

        if (!catchment_.present ())
        {
          this->catchment_.set (r);
          continue;
        }
      }

      break;
    }

    if (!inflow_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "inflow",
        "http://www.wldelft.nl/fews");
    }

    if (!level_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "level",
        "http://www.wldelft.nl/fews");
    }

    if (!catchment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "catchment",
        "http://www.wldelft.nl/fews");
    }
  }

  ThunerseeRuleInputComplexType* ThunerseeRuleInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ThunerseeRuleInputComplexType (*this, f, c);
  }

  ThunerseeRuleInputComplexType::
  ~ThunerseeRuleInputComplexType ()
  {
  }

  // ThunerseeRuleOutputComplexType
  //

  ThunerseeRuleOutputComplexType::
  ThunerseeRuleOutputComplexType (const ReleaseWeirType& releaseWeir,
                                  const ReleaseTunnelType& releaseTunnel,
                                  const ReleaseTotalType& releaseTotal)
  : ::xml_schema::Type (),
    releaseWeir_ (releaseWeir, ::xml_schema::Flags (), this),
    releaseTunnel_ (releaseTunnel, ::xml_schema::Flags (), this),
    releaseTotal_ (releaseTotal, ::xml_schema::Flags (), this),
    active_ (::xml_schema::Flags (), this)
  {
  }

  ThunerseeRuleOutputComplexType::
  ThunerseeRuleOutputComplexType (const ThunerseeRuleOutputComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    releaseWeir_ (x.releaseWeir_, f, this),
    releaseTunnel_ (x.releaseTunnel_, f, this),
    releaseTotal_ (x.releaseTotal_, f, this),
    active_ (x.active_, f, this)
  {
  }

  ThunerseeRuleOutputComplexType::
  ThunerseeRuleOutputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    releaseWeir_ (f, this),
    releaseTunnel_ (f, this),
    releaseTotal_ (f, this),
    active_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ThunerseeRuleOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // releaseWeir
      //
      if (n.name () == "releaseWeir" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseWeirType > r (
          ReleaseWeirTraits::create (i, f, this));

        if (!releaseWeir_.present ())
        {
          this->releaseWeir_.set (r);
          continue;
        }
      }

      // releaseTunnel
      //
      if (n.name () == "releaseTunnel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseTunnelType > r (
          ReleaseTunnelTraits::create (i, f, this));

        if (!releaseTunnel_.present ())
        {
          this->releaseTunnel_.set (r);
          continue;
        }
      }

      // releaseTotal
      //
      if (n.name () == "releaseTotal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseTotalType > r (
          ReleaseTotalTraits::create (i, f, this));

        if (!releaseTotal_.present ())
        {
          this->releaseTotal_.set (r);
          continue;
        }
      }

      // active
      //
      if (n.name () == "active" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        if (!this->active_)
        {
          this->active_.set (r);
          continue;
        }
      }

      break;
    }

    if (!releaseWeir_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "releaseWeir",
        "http://www.wldelft.nl/fews");
    }

    if (!releaseTunnel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "releaseTunnel",
        "http://www.wldelft.nl/fews");
    }

    if (!releaseTotal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "releaseTotal",
        "http://www.wldelft.nl/fews");
    }
  }

  ThunerseeRuleOutputComplexType* ThunerseeRuleOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ThunerseeRuleOutputComplexType (*this, f, c);
  }

  ThunerseeRuleOutputComplexType::
  ~ThunerseeRuleOutputComplexType ()
  {
  }

  // AebiRuleComplexType
  //

  AebiRuleComplexType::
  AebiRuleComplexType (const FactorRTGType& FactorRTG,
                       const LangeteFallType& LangeteFall,
                       const InputType& input,
                       const OutputType& output,
                       const IdType& id)
  : ::xml_schema::Type (),
    FactorRTG_ (FactorRTG, ::xml_schema::Flags (), this),
    LangeteFall_ (LangeteFall, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AebiRuleComplexType::
  AebiRuleComplexType (const FactorRTGType& FactorRTG,
                       const LangeteFallType& LangeteFall,
                       ::std::auto_ptr< InputType >& input,
                       ::std::auto_ptr< OutputType >& output,
                       const IdType& id)
  : ::xml_schema::Type (),
    FactorRTG_ (FactorRTG, ::xml_schema::Flags (), this),
    LangeteFall_ (LangeteFall, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AebiRuleComplexType::
  AebiRuleComplexType (const AebiRuleComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    FactorRTG_ (x.FactorRTG_, f, this),
    LangeteFall_ (x.LangeteFall_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  AebiRuleComplexType::
  AebiRuleComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    FactorRTG_ (f, this),
    LangeteFall_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AebiRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FactorRTG
      //
      if (n.name () == "FactorRTG" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!FactorRTG_.present ())
        {
          this->FactorRTG_.set (FactorRTGTraits::create (i, f, this));
          continue;
        }
      }

      // LangeteFall
      //
      if (n.name () == "LangeteFall" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LangeteFallType > r (
          LangeteFallTraits::create (i, f, this));

        if (!LangeteFall_.present ())
        {
          this->LangeteFall_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!FactorRTG_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FactorRTG",
        "http://www.wldelft.nl/fews");
    }

    if (!LangeteFall_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LangeteFall",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  AebiRuleComplexType* AebiRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AebiRuleComplexType (*this, f, c);
  }

  AebiRuleComplexType::
  ~AebiRuleComplexType ()
  {
  }

  // AebiRuleInputComplexType
  //

  AebiRuleInputComplexType::
  AebiRuleInputComplexType (const AareBrueggType& AareBruegg,
                            const AareBrueggMin2Type& AareBrueggMin2,
                            const EmenmattType& Emenmatt,
                            const EmenmattMin4Type& EmenmattMin4,
                            const LangetenType& Langeten,
                            const LangetenMin4Type& LangetenMin4,
                            const AareMurgType& AareMurg,
                            const PegelBielerseeType& PegelBielersee,
                            const AbflussReglementPortType& AbflussReglementPort)
  : ::xml_schema::Type (),
    AareBruegg_ (AareBruegg, ::xml_schema::Flags (), this),
    AareBrueggMin2_ (AareBrueggMin2, ::xml_schema::Flags (), this),
    Emenmatt_ (Emenmatt, ::xml_schema::Flags (), this),
    EmenmattMin4_ (EmenmattMin4, ::xml_schema::Flags (), this),
    Langeten_ (Langeten, ::xml_schema::Flags (), this),
    LangetenMin4_ (LangetenMin4, ::xml_schema::Flags (), this),
    AareMurg_ (AareMurg, ::xml_schema::Flags (), this),
    PegelBielersee_ (PegelBielersee, ::xml_schema::Flags (), this),
    AbflussReglementPort_ (AbflussReglementPort, ::xml_schema::Flags (), this)
  {
  }

  AebiRuleInputComplexType::
  AebiRuleInputComplexType (const AebiRuleInputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AareBruegg_ (x.AareBruegg_, f, this),
    AareBrueggMin2_ (x.AareBrueggMin2_, f, this),
    Emenmatt_ (x.Emenmatt_, f, this),
    EmenmattMin4_ (x.EmenmattMin4_, f, this),
    Langeten_ (x.Langeten_, f, this),
    LangetenMin4_ (x.LangetenMin4_, f, this),
    AareMurg_ (x.AareMurg_, f, this),
    PegelBielersee_ (x.PegelBielersee_, f, this),
    AbflussReglementPort_ (x.AbflussReglementPort_, f, this)
  {
  }

  AebiRuleInputComplexType::
  AebiRuleInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AareBruegg_ (f, this),
    AareBrueggMin2_ (f, this),
    Emenmatt_ (f, this),
    EmenmattMin4_ (f, this),
    Langeten_ (f, this),
    LangetenMin4_ (f, this),
    AareMurg_ (f, this),
    PegelBielersee_ (f, this),
    AbflussReglementPort_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AebiRuleInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AareBruegg
      //
      if (n.name () == "AareBruegg" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AareBrueggType > r (
          AareBrueggTraits::create (i, f, this));

        if (!AareBruegg_.present ())
        {
          this->AareBruegg_.set (r);
          continue;
        }
      }

      // AareBrueggMin2
      //
      if (n.name () == "AareBrueggMin2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AareBrueggMin2Type > r (
          AareBrueggMin2Traits::create (i, f, this));

        if (!AareBrueggMin2_.present ())
        {
          this->AareBrueggMin2_.set (r);
          continue;
        }
      }

      // Emenmatt
      //
      if (n.name () == "Emenmatt" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EmenmattType > r (
          EmenmattTraits::create (i, f, this));

        if (!Emenmatt_.present ())
        {
          this->Emenmatt_.set (r);
          continue;
        }
      }

      // EmenmattMin4
      //
      if (n.name () == "EmenmattMin4" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EmenmattMin4Type > r (
          EmenmattMin4Traits::create (i, f, this));

        if (!EmenmattMin4_.present ())
        {
          this->EmenmattMin4_.set (r);
          continue;
        }
      }

      // Langeten
      //
      if (n.name () == "Langeten" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LangetenType > r (
          LangetenTraits::create (i, f, this));

        if (!Langeten_.present ())
        {
          this->Langeten_.set (r);
          continue;
        }
      }

      // LangetenMin4
      //
      if (n.name () == "LangetenMin4" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LangetenMin4Type > r (
          LangetenMin4Traits::create (i, f, this));

        if (!LangetenMin4_.present ())
        {
          this->LangetenMin4_.set (r);
          continue;
        }
      }

      // AareMurg
      //
      if (n.name () == "AareMurg" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AareMurgType > r (
          AareMurgTraits::create (i, f, this));

        if (!AareMurg_.present ())
        {
          this->AareMurg_.set (r);
          continue;
        }
      }

      // PegelBielersee
      //
      if (n.name () == "PegelBielersee" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PegelBielerseeType > r (
          PegelBielerseeTraits::create (i, f, this));

        if (!PegelBielersee_.present ())
        {
          this->PegelBielersee_.set (r);
          continue;
        }
      }

      // AbflussReglementPort
      //
      if (n.name () == "AbflussReglementPort" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AbflussReglementPortType > r (
          AbflussReglementPortTraits::create (i, f, this));

        if (!AbflussReglementPort_.present ())
        {
          this->AbflussReglementPort_.set (r);
          continue;
        }
      }

      break;
    }

    if (!AareBruegg_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AareBruegg",
        "http://www.wldelft.nl/fews");
    }

    if (!AareBrueggMin2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AareBrueggMin2",
        "http://www.wldelft.nl/fews");
    }

    if (!Emenmatt_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Emenmatt",
        "http://www.wldelft.nl/fews");
    }

    if (!EmenmattMin4_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EmenmattMin4",
        "http://www.wldelft.nl/fews");
    }

    if (!Langeten_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Langeten",
        "http://www.wldelft.nl/fews");
    }

    if (!LangetenMin4_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LangetenMin4",
        "http://www.wldelft.nl/fews");
    }

    if (!AareMurg_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AareMurg",
        "http://www.wldelft.nl/fews");
    }

    if (!PegelBielersee_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PegelBielersee",
        "http://www.wldelft.nl/fews");
    }

    if (!AbflussReglementPort_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AbflussReglementPort",
        "http://www.wldelft.nl/fews");
    }
  }

  AebiRuleInputComplexType* AebiRuleInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AebiRuleInputComplexType (*this, f, c);
  }

  AebiRuleInputComplexType::
  ~AebiRuleInputComplexType ()
  {
  }

  // AebiRuleOutputComplexType
  //

  AebiRuleOutputComplexType::
  AebiRuleOutputComplexType (const RTGType& RTG,
                             const AareMurg_oKWMin1Type& AareMurg_oKWMin1,
                             const ProvMaxAbflussPortType& ProvMaxAbflussPort,
                             const MaxAbflussPortType& MaxAbflussPort,
                             const AbflussaenderungPortType& AbflussaenderungPort)
  : ::xml_schema::Type (),
    RTG_ (RTG, ::xml_schema::Flags (), this),
    AareMurg_oKWMin1_ (AareMurg_oKWMin1, ::xml_schema::Flags (), this),
    ProvMaxAbflussPort_ (ProvMaxAbflussPort, ::xml_schema::Flags (), this),
    MaxAbflussPort_ (MaxAbflussPort, ::xml_schema::Flags (), this),
    AbflussaenderungPort_ (AbflussaenderungPort, ::xml_schema::Flags (), this)
  {
  }

  AebiRuleOutputComplexType::
  AebiRuleOutputComplexType (const AebiRuleOutputComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    RTG_ (x.RTG_, f, this),
    AareMurg_oKWMin1_ (x.AareMurg_oKWMin1_, f, this),
    ProvMaxAbflussPort_ (x.ProvMaxAbflussPort_, f, this),
    MaxAbflussPort_ (x.MaxAbflussPort_, f, this),
    AbflussaenderungPort_ (x.AbflussaenderungPort_, f, this)
  {
  }

  AebiRuleOutputComplexType::
  AebiRuleOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    RTG_ (f, this),
    AareMurg_oKWMin1_ (f, this),
    ProvMaxAbflussPort_ (f, this),
    MaxAbflussPort_ (f, this),
    AbflussaenderungPort_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AebiRuleOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RTG
      //
      if (n.name () == "RTG" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RTGType > r (
          RTGTraits::create (i, f, this));

        if (!RTG_.present ())
        {
          this->RTG_.set (r);
          continue;
        }
      }

      // AareMurg_oKWMin1
      //
      if (n.name () == "AareMurg_oKWMin1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AareMurg_oKWMin1Type > r (
          AareMurg_oKWMin1Traits::create (i, f, this));

        if (!AareMurg_oKWMin1_.present ())
        {
          this->AareMurg_oKWMin1_.set (r);
          continue;
        }
      }

      // ProvMaxAbflussPort
      //
      if (n.name () == "ProvMaxAbflussPort" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ProvMaxAbflussPortType > r (
          ProvMaxAbflussPortTraits::create (i, f, this));

        if (!ProvMaxAbflussPort_.present ())
        {
          this->ProvMaxAbflussPort_.set (r);
          continue;
        }
      }

      // MaxAbflussPort
      //
      if (n.name () == "MaxAbflussPort" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MaxAbflussPortType > r (
          MaxAbflussPortTraits::create (i, f, this));

        if (!MaxAbflussPort_.present ())
        {
          this->MaxAbflussPort_.set (r);
          continue;
        }
      }

      // AbflussaenderungPort
      //
      if (n.name () == "AbflussaenderungPort" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AbflussaenderungPortType > r (
          AbflussaenderungPortTraits::create (i, f, this));

        if (!AbflussaenderungPort_.present ())
        {
          this->AbflussaenderungPort_.set (r);
          continue;
        }
      }

      break;
    }

    if (!RTG_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RTG",
        "http://www.wldelft.nl/fews");
    }

    if (!AareMurg_oKWMin1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AareMurg_oKWMin1",
        "http://www.wldelft.nl/fews");
    }

    if (!ProvMaxAbflussPort_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ProvMaxAbflussPort",
        "http://www.wldelft.nl/fews");
    }

    if (!MaxAbflussPort_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MaxAbflussPort",
        "http://www.wldelft.nl/fews");
    }

    if (!AbflussaenderungPort_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AbflussaenderungPort",
        "http://www.wldelft.nl/fews");
    }
  }

  AebiRuleOutputComplexType* AebiRuleOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AebiRuleOutputComplexType (*this, f, c);
  }

  AebiRuleOutputComplexType::
  ~AebiRuleOutputComplexType ()
  {
  }

  // LookupTableComplexType
  //

  LookupTableComplexType::
  LookupTableComplexType (const InputType& input,
                          const OutputType& output,
                          const IdType& id)
  : ::xml_schema::Type (),
    property_ (::xml_schema::Flags (), this),
    table_ (::xml_schema::Flags (), this),
    tableExternal_ (::xml_schema::Flags (), this),
    interpolationOption_ (::xml_schema::Flags (), this),
    extrapolationOption_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LookupTableComplexType::
  LookupTableComplexType (::std::auto_ptr< InputType >& input,
                          ::std::auto_ptr< OutputType >& output,
                          const IdType& id)
  : ::xml_schema::Type (),
    property_ (::xml_schema::Flags (), this),
    table_ (::xml_schema::Flags (), this),
    tableExternal_ (::xml_schema::Flags (), this),
    interpolationOption_ (::xml_schema::Flags (), this),
    extrapolationOption_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LookupTableComplexType::
  LookupTableComplexType (const LookupTableComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    property_ (x.property_, f, this),
    table_ (x.table_, f, this),
    tableExternal_ (x.tableExternal_, f, this),
    interpolationOption_ (x.interpolationOption_, f, this),
    extrapolationOption_ (x.extrapolationOption_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  LookupTableComplexType::
  LookupTableComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    property_ (f, this),
    table_ (f, this),
    tableExternal_ (f, this),
    interpolationOption_ (f, this),
    extrapolationOption_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void LookupTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // property
      //
      if (n.name () == "property" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PropertyType > r (
          PropertyTraits::create (i, f, this));

        this->property_.push_back (r);
        continue;
      }

      // table
      //
      if (n.name () == "table" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TableType > r (
          TableTraits::create (i, f, this));

        if (!this->table_)
        {
          this->table_.set (r);
          continue;
        }
      }

      // tableExternal
      //
      if (n.name () == "tableExternal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TableExternalType > r (
          TableExternalTraits::create (i, f, this));

        if (!this->tableExternal_)
        {
          this->tableExternal_.set (r);
          continue;
        }
      }

      // interpolationOption
      //
      if (n.name () == "interpolationOption" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InterpolationOptionType > r (
          InterpolationOptionTraits::create (i, f, this));

        if (!this->interpolationOption_)
        {
          this->interpolationOption_.set (r);
          continue;
        }
      }

      // extrapolationOption
      //
      if (n.name () == "extrapolationOption" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExtrapolationOptionType > r (
          ExtrapolationOptionTraits::create (i, f, this));

        if (!this->extrapolationOption_)
        {
          this->extrapolationOption_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  LookupTableComplexType* LookupTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LookupTableComplexType (*this, f, c);
  }

  LookupTableComplexType::
  ~LookupTableComplexType ()
  {
  }

  // TableLookupTableComplexType
  //

  TableLookupTableComplexType::
  TableLookupTableComplexType ()
  : ::xml_schema::Type (),
    record_ (::xml_schema::Flags (), this)
  {
  }

  TableLookupTableComplexType::
  TableLookupTableComplexType (const TableLookupTableComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    record_ (x.record_, f, this)
  {
  }

  TableLookupTableComplexType::
  TableLookupTableComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    record_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TableLookupTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // record
      //
      if (n.name () == "record" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RecordType > r (
          RecordTraits::create (i, f, this));

        this->record_.push_back (r);
        continue;
      }

      break;
    }
  }

  TableLookupTableComplexType* TableLookupTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TableLookupTableComplexType (*this, f, c);
  }

  TableLookupTableComplexType::
  ~TableLookupTableComplexType ()
  {
  }

  // Lookup2DTableComplexType
  //

  Lookup2DTableComplexType::
  Lookup2DTableComplexType (const TableType& table,
                            const InputType& input,
                            const OutputType& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    table_ (table, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  Lookup2DTableComplexType::
  Lookup2DTableComplexType (::std::auto_ptr< TableType >& table,
                            ::std::auto_ptr< InputType >& input,
                            ::std::auto_ptr< OutputType >& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    table_ (table, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  Lookup2DTableComplexType::
  Lookup2DTableComplexType (const Lookup2DTableComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    table_ (x.table_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Lookup2DTableComplexType::
  Lookup2DTableComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    table_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Lookup2DTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // table
      //
      if (n.name () == "table" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TableType > r (
          TableTraits::create (i, f, this));

        if (!table_.present ())
        {
          this->table_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!table_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "table",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  Lookup2DTableComplexType* Lookup2DTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Lookup2DTableComplexType (*this, f, c);
  }

  Lookup2DTableComplexType::
  ~Lookup2DTableComplexType ()
  {
  }

  // Table2DLookupTableComplexType
  //

  Table2DLookupTableComplexType::
  Table2DLookupTableComplexType (const XType& x,
                                 const YType& y,
                                 const MatrixType& matrix)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this),
    matrix_ (matrix, ::xml_schema::Flags (), this)
  {
  }

  Table2DLookupTableComplexType::
  Table2DLookupTableComplexType (::std::auto_ptr< XType >& x,
                                 ::std::auto_ptr< YType >& y,
                                 ::std::auto_ptr< MatrixType >& matrix)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this),
    matrix_ (matrix, ::xml_schema::Flags (), this)
  {
  }

  Table2DLookupTableComplexType::
  Table2DLookupTableComplexType (const Table2DLookupTableComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    matrix_ (x.matrix_, f, this)
  {
  }

  Table2DLookupTableComplexType::
  Table2DLookupTableComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this),
    matrix_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Table2DLookupTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // matrix
      //
      if (n.name () == "matrix" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MatrixType > r (
          MatrixTraits::create (i, f, this));

        if (!matrix_.present ())
        {
          this->matrix_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }

    if (!matrix_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "matrix",
        "http://www.wldelft.nl/fews");
    }
  }

  Table2DLookupTableComplexType* Table2DLookupTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Table2DLookupTableComplexType (*this, f, c);
  }

  Table2DLookupTableComplexType::
  ~Table2DLookupTableComplexType ()
  {
  }

  // XDimComplexType
  //

  XDimComplexType::
  XDimComplexType ()
  : ::xml_schema::Type (),
    xDim_ (::xml_schema::Flags (), this)
  {
  }

  XDimComplexType::
  XDimComplexType (const XDimComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    xDim_ (x.xDim_, f, this)
  {
  }

  XDimComplexType::
  XDimComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    xDim_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void XDimComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // xDim
      //
      if (n.name () == "xDim" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XDimType > r (
          XDimTraits::create (i, f, this));

        this->xDim_.push_back (r);
        continue;
      }

      break;
    }
  }

  XDimComplexType* XDimComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class XDimComplexType (*this, f, c);
  }

  XDimComplexType::
  ~XDimComplexType ()
  {
  }

  // YDimComplexType
  //

  YDimComplexType::
  YDimComplexType ()
  : ::xml_schema::Type (),
    yDim_ (::xml_schema::Flags (), this)
  {
  }

  YDimComplexType::
  YDimComplexType (const YDimComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    yDim_ (x.yDim_, f, this)
  {
  }

  YDimComplexType::
  YDimComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    yDim_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void YDimComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // yDim
      //
      if (n.name () == "yDim" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        this->yDim_.push_back (YDimTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  YDimComplexType* YDimComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class YDimComplexType (*this, f, c);
  }

  YDimComplexType::
  ~YDimComplexType ()
  {
  }

  // ValueArrayComplexType
  //

  ValueArrayComplexType::
  ValueArrayComplexType ()
  : ::xml_schema::Type (),
    value_ (::xml_schema::Flags (), this)
  {
  }

  ValueArrayComplexType::
  ValueArrayComplexType (const ValueArrayComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  ValueArrayComplexType::
  ValueArrayComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ValueArrayComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        this->value_.push_back (ValueTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  ValueArrayComplexType* ValueArrayComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ValueArrayComplexType (*this, f, c);
  }

  ValueArrayComplexType::
  ~ValueArrayComplexType ()
  {
  }

  // IntervalComplexType
  //

  IntervalComplexType::
  IntervalComplexType (const SettingBelowType& settingBelow,
                       const SettingAboveType& settingAbove,
                       const InputType& input,
                       const OutputType& output,
                       const IdType& id)
  : ::xml_schema::Type (),
    settingBelow_ (settingBelow, ::xml_schema::Flags (), this),
    settingAbove_ (settingAbove, ::xml_schema::Flags (), this),
    settingMaxSpeed_ (::xml_schema::Flags (), this),
    settingMaxStep_ (::xml_schema::Flags (), this),
    deadbandSetpointAbsolute_ (::xml_schema::Flags (), this),
    deadbandSetpointRelative_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  IntervalComplexType::
  IntervalComplexType (const SettingBelowType& settingBelow,
                       const SettingAboveType& settingAbove,
                       ::std::auto_ptr< InputType >& input,
                       ::std::auto_ptr< OutputType >& output,
                       const IdType& id)
  : ::xml_schema::Type (),
    settingBelow_ (settingBelow, ::xml_schema::Flags (), this),
    settingAbove_ (settingAbove, ::xml_schema::Flags (), this),
    settingMaxSpeed_ (::xml_schema::Flags (), this),
    settingMaxStep_ (::xml_schema::Flags (), this),
    deadbandSetpointAbsolute_ (::xml_schema::Flags (), this),
    deadbandSetpointRelative_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  IntervalComplexType::
  IntervalComplexType (const IntervalComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    settingBelow_ (x.settingBelow_, f, this),
    settingAbove_ (x.settingAbove_, f, this),
    settingMaxSpeed_ (x.settingMaxSpeed_, f, this),
    settingMaxStep_ (x.settingMaxStep_, f, this),
    deadbandSetpointAbsolute_ (x.deadbandSetpointAbsolute_, f, this),
    deadbandSetpointRelative_ (x.deadbandSetpointRelative_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  IntervalComplexType::
  IntervalComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    settingBelow_ (f, this),
    settingAbove_ (f, this),
    settingMaxSpeed_ (f, this),
    settingMaxStep_ (f, this),
    deadbandSetpointAbsolute_ (f, this),
    deadbandSetpointRelative_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void IntervalComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // settingBelow
      //
      if (n.name () == "settingBelow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!settingBelow_.present ())
        {
          this->settingBelow_.set (SettingBelowTraits::create (i, f, this));
          continue;
        }
      }

      // settingAbove
      //
      if (n.name () == "settingAbove" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!settingAbove_.present ())
        {
          this->settingAbove_.set (SettingAboveTraits::create (i, f, this));
          continue;
        }
      }

      // settingMaxSpeed
      //
      if (n.name () == "settingMaxSpeed" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->settingMaxSpeed_)
        {
          this->settingMaxSpeed_.set (SettingMaxSpeedTraits::create (i, f, this));
          continue;
        }
      }

      // settingMaxStep
      //
      if (n.name () == "settingMaxStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->settingMaxStep_)
        {
          this->settingMaxStep_.set (SettingMaxStepTraits::create (i, f, this));
          continue;
        }
      }

      // deadbandSetpointAbsolute
      //
      if (n.name () == "deadbandSetpointAbsolute" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->deadbandSetpointAbsolute_)
        {
          this->deadbandSetpointAbsolute_.set (DeadbandSetpointAbsoluteTraits::create (i, f, this));
          continue;
        }
      }

      // deadbandSetpointRelative
      //
      if (n.name () == "deadbandSetpointRelative" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->deadbandSetpointRelative_)
        {
          this->deadbandSetpointRelative_.set (DeadbandSetpointRelativeTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!settingBelow_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "settingBelow",
        "http://www.wldelft.nl/fews");
    }

    if (!settingAbove_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "settingAbove",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  IntervalComplexType* IntervalComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntervalComplexType (*this, f, c);
  }

  IntervalComplexType::
  ~IntervalComplexType ()
  {
  }

  // IntervalInputComplexType
  //

  IntervalInputComplexType::
  IntervalInputComplexType (const XType& x,
                            const SetpointType& setpoint)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    setpoint_ (setpoint, ::xml_schema::Flags (), this)
  {
  }

  IntervalInputComplexType::
  IntervalInputComplexType (::std::auto_ptr< XType >& x,
                            const SetpointType& setpoint)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    setpoint_ (setpoint, ::xml_schema::Flags (), this)
  {
  }

  IntervalInputComplexType::
  IntervalInputComplexType (const IntervalInputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    setpoint_ (x.setpoint_, f, this)
  {
  }

  IntervalInputComplexType::
  IntervalInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    setpoint_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void IntervalInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // setpoint
      //
      if (n.name () == "setpoint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetpointType > r (
          SetpointTraits::create (i, f, this));

        if (!setpoint_.present ())
        {
          this->setpoint_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }

    if (!setpoint_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "setpoint",
        "http://www.wldelft.nl/fews");
    }
  }

  IntervalInputComplexType* IntervalInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntervalInputComplexType (*this, f, c);
  }

  IntervalInputComplexType::
  ~IntervalInputComplexType ()
  {
  }

  // IntervalOutputComplexType
  //

  IntervalOutputComplexType::
  IntervalOutputComplexType (const YType& y,
                             const StatusType& status)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this),
    status_ (status, ::xml_schema::Flags (), this)
  {
  }

  IntervalOutputComplexType::
  IntervalOutputComplexType (const IntervalOutputComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this),
    status_ (x.status_, f, this)
  {
  }

  IntervalOutputComplexType::
  IntervalOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this),
    status_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void IntervalOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // status
      //
      if (n.name () == "status" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StatusType > r (
          StatusTraits::create (i, f, this));

        if (!status_.present ())
        {
          this->status_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "status",
        "http://www.wldelft.nl/fews");
    }
  }

  IntervalOutputComplexType* IntervalOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntervalOutputComplexType (*this, f, c);
  }

  IntervalOutputComplexType::
  ~IntervalOutputComplexType ()
  {
  }

  // DateLookupTableComplexType
  //

  DateLookupTableComplexType::
  DateLookupTableComplexType (const InterpolationOptionsType& interpolationOptions,
                              const InputType& input,
                              const OutputType& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    interpolationOptions_ (interpolationOptions, ::xml_schema::Flags (), this),
    dateRecord_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DateLookupTableComplexType::
  DateLookupTableComplexType (::std::auto_ptr< InterpolationOptionsType >& interpolationOptions,
                              ::std::auto_ptr< InputType >& input,
                              ::std::auto_ptr< OutputType >& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    interpolationOptions_ (interpolationOptions, ::xml_schema::Flags (), this),
    dateRecord_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DateLookupTableComplexType::
  DateLookupTableComplexType (const DateLookupTableComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    interpolationOptions_ (x.interpolationOptions_, f, this),
    dateRecord_ (x.dateRecord_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DateLookupTableComplexType::
  DateLookupTableComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    interpolationOptions_ (f, this),
    dateRecord_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void DateLookupTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // interpolationOptions
      //
      if (n.name () == "interpolationOptions" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InterpolationOptionsType > r (
          InterpolationOptionsTraits::create (i, f, this));

        if (!interpolationOptions_.present ())
        {
          this->interpolationOptions_.set (r);
          continue;
        }
      }

      // dateRecord
      //
      if (n.name () == "dateRecord" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DateRecordType > r (
          DateRecordTraits::create (i, f, this));

        this->dateRecord_.push_back (r);
        continue;
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!interpolationOptions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interpolationOptions",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  DateLookupTableComplexType* DateLookupTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateLookupTableComplexType (*this, f, c);
  }

  DateLookupTableComplexType::
  ~DateLookupTableComplexType ()
  {
  }

  // InterpolationOptionsComplexType
  //

  InterpolationOptionsComplexType::
  InterpolationOptionsComplexType (const DateType& date,
                                   const ValueType& value)
  : ::xml_schema::Type (),
    date_ (date, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  InterpolationOptionsComplexType::
  InterpolationOptionsComplexType (const InterpolationOptionsComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    date_ (x.date_, f, this),
    value_ (x.value_, f, this)
  {
  }

  InterpolationOptionsComplexType::
  InterpolationOptionsComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    date_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InterpolationOptionsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DateType > r (
          DateTraits::create (i, f, this));

        if (!date_.present ())
        {
          this->date_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (r);
          continue;
        }
      }

      break;
    }

    if (!date_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "date",
        "http://www.wldelft.nl/fews");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.wldelft.nl/fews");
    }
  }

  InterpolationOptionsComplexType* InterpolationOptionsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InterpolationOptionsComplexType (*this, f, c);
  }

  InterpolationOptionsComplexType::
  ~InterpolationOptionsComplexType ()
  {
  }

  // DateRecord2ComplexType
  //

  DateRecord2ComplexType::
  DateRecord2ComplexType (const MonthDayType& monthDay)
  : ::xml_schema::Type (),
    record_ (::xml_schema::Flags (), this),
    monthDay_ (monthDay, ::xml_schema::Flags (), this)
  {
  }

  DateRecord2ComplexType::
  DateRecord2ComplexType (const DateRecord2ComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    record_ (x.record_, f, this),
    monthDay_ (x.monthDay_, f, this)
  {
  }

  DateRecord2ComplexType::
  DateRecord2ComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    record_ (f, this),
    monthDay_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void DateRecord2ComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // record
      //
      if (n.name () == "record" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RecordType > r (
          RecordTraits::create (i, f, this));

        this->record_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "monthDay" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MonthDayType > r (
          MonthDayTraits::create (i, f, this));

        this->monthDay_.set (r);
        continue;
      }
    }

    if (!monthDay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "monthDay",
        "");
    }
  }

  DateRecord2ComplexType* DateRecord2ComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateRecord2ComplexType (*this, f, c);
  }

  DateRecord2ComplexType::
  ~DateRecord2ComplexType ()
  {
  }

  // DateRecord2DataComplexType
  //

  DateRecord2DataComplexType::
  DateRecord2DataComplexType (const XType& x,
                              const YType& y)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  DateRecord2DataComplexType::
  DateRecord2DataComplexType (const DateRecord2DataComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  DateRecord2DataComplexType::
  DateRecord2DataComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void DateRecord2DataComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (XTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }
  }

  DateRecord2DataComplexType* DateRecord2DataComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateRecord2DataComplexType (*this, f, c);
  }

  DateRecord2DataComplexType::
  ~DateRecord2DataComplexType ()
  {
  }

  // DateLookupTableInputComplexType
  //

  DateLookupTableInputComplexType::
  DateLookupTableInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  DateLookupTableInputComplexType::
  DateLookupTableInputComplexType (const DateLookupTableInputComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  DateLookupTableInputComplexType::
  DateLookupTableInputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DateLookupTableInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!this->y_)
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  DateLookupTableInputComplexType* DateLookupTableInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateLookupTableInputComplexType (*this, f, c);
  }

  DateLookupTableInputComplexType::
  ~DateLookupTableInputComplexType ()
  {
  }

  // DateLookupTableOutputComplexType
  //

  DateLookupTableOutputComplexType::
  DateLookupTableOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this),
    active_ (::xml_schema::Flags (), this)
  {
  }

  DateLookupTableOutputComplexType::
  DateLookupTableOutputComplexType (const DateLookupTableOutputComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this),
    active_ (x.active_, f, this)
  {
  }

  DateLookupTableOutputComplexType::
  DateLookupTableOutputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this),
    active_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DateLookupTableOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // active
      //
      if (n.name () == "active" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        if (!this->active_)
        {
          this->active_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  DateLookupTableOutputComplexType* DateLookupTableOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateLookupTableOutputComplexType (*this, f, c);
  }

  DateLookupTableOutputComplexType::
  ~DateLookupTableOutputComplexType ()
  {
  }

  // LookupTableInputComplexType
  //

  LookupTableInputComplexType::
  LookupTableInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  LookupTableInputComplexType::
  LookupTableInputComplexType (::std::auto_ptr< XType >& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  LookupTableInputComplexType::
  LookupTableInputComplexType (const LookupTableInputComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  LookupTableInputComplexType::
  LookupTableInputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LookupTableInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!this->y_)
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  LookupTableInputComplexType* LookupTableInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LookupTableInputComplexType (*this, f, c);
  }

  LookupTableInputComplexType::
  ~LookupTableInputComplexType ()
  {
  }

  // LookupTableOutputComplexType
  //

  LookupTableOutputComplexType::
  LookupTableOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  LookupTableOutputComplexType::
  LookupTableOutputComplexType (const LookupTableOutputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  LookupTableOutputComplexType::
  LookupTableOutputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LookupTableOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  LookupTableOutputComplexType* LookupTableOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LookupTableOutputComplexType (*this, f, c);
  }

  LookupTableOutputComplexType::
  ~LookupTableOutputComplexType ()
  {
  }

  // Lookup2DTableInputComplexType
  //

  Lookup2DTableInputComplexType::
  Lookup2DTableInputComplexType (const XType& x,
                                 const YType& y)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this),
    z_ (::xml_schema::Flags (), this)
  {
  }

  Lookup2DTableInputComplexType::
  Lookup2DTableInputComplexType (const Lookup2DTableInputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  Lookup2DTableInputComplexType::
  Lookup2DTableInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Lookup2DTableInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ZType > r (
          ZTraits::create (i, f, this));

        if (!this->z_)
        {
          this->z_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  Lookup2DTableInputComplexType* Lookup2DTableInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Lookup2DTableInputComplexType (*this, f, c);
  }

  Lookup2DTableInputComplexType::
  ~Lookup2DTableInputComplexType ()
  {
  }

  // Lookup2DTableOutputComplexType
  //

  Lookup2DTableOutputComplexType::
  Lookup2DTableOutputComplexType (const ZType& z)
  : ::xml_schema::Type (),
    z_ (z, ::xml_schema::Flags (), this)
  {
  }

  Lookup2DTableOutputComplexType::
  Lookup2DTableOutputComplexType (const Lookup2DTableOutputComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    z_ (x.z_, f, this)
  {
  }

  Lookup2DTableOutputComplexType::
  Lookup2DTableOutputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    z_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Lookup2DTableOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ZType > r (
          ZTraits::create (i, f, this));

        if (!z_.present ())
        {
          this->z_.set (r);
          continue;
        }
      }

      break;
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www.wldelft.nl/fews");
    }
  }

  Lookup2DTableOutputComplexType* Lookup2DTableOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Lookup2DTableOutputComplexType (*this, f, c);
  }

  Lookup2DTableOutputComplexType::
  ~Lookup2DTableOutputComplexType ()
  {
  }

  // PolygonLookupComplexType
  //

  PolygonLookupComplexType::
  PolygonLookupComplexType (const PolygonsType& polygons,
                            const InputType& input,
                            const OutputType& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    polygons_ (polygons, ::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  PolygonLookupComplexType::
  PolygonLookupComplexType (::std::auto_ptr< PolygonsType >& polygons,
                            ::std::auto_ptr< InputType >& input,
                            ::std::auto_ptr< OutputType >& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    polygons_ (polygons, ::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  PolygonLookupComplexType::
  PolygonLookupComplexType (const PolygonLookupComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    polygons_ (x.polygons_, f, this),
    default__ (x.default__, f, this),
    true__ (x.true__, f, this),
    false__ (x.false__, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  PolygonLookupComplexType::
  PolygonLookupComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    polygons_ (f, this),
    default__ (f, this),
    true__ (f, this),
    false__ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PolygonLookupComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // polygons
      //
      if (n.name () == "polygons" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PolygonsType > r (
          PolygonsTraits::create (i, f, this));

        if (!polygons_.present ())
        {
          this->polygons_.set (r);
          continue;
        }
      }

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->default__)
        {
          this->default__.set (DefaultTraits::create (i, f, this));
          continue;
        }
      }

      // true
      //
      if (n.name () == "true" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TrueType > r (
          TrueTraits::create (i, f, this));

        if (!this->true__)
        {
          this->true__.set (r);
          continue;
        }
      }

      // false
      //
      if (n.name () == "false" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FalseType > r (
          FalseTraits::create (i, f, this));

        if (!this->false__)
        {
          this->false__.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!polygons_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "polygons",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  PolygonLookupComplexType* PolygonLookupComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PolygonLookupComplexType (*this, f, c);
  }

  PolygonLookupComplexType::
  ~PolygonLookupComplexType ()
  {
  }

  // PolygonsComplexType
  //

  PolygonsComplexType::
  PolygonsComplexType ()
  : ::xml_schema::Type (),
    polygon_ (::xml_schema::Flags (), this)
  {
  }

  PolygonsComplexType::
  PolygonsComplexType (const PolygonsComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    polygon_ (x.polygon_, f, this)
  {
  }

  PolygonsComplexType::
  PolygonsComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    polygon_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PolygonsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // polygon
      //
      if (n.name () == "polygon" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PolygonType > r (
          PolygonTraits::create (i, f, this));

        this->polygon_.push_back (r);
        continue;
      }

      break;
    }
  }

  PolygonsComplexType* PolygonsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PolygonsComplexType (*this, f, c);
  }

  PolygonsComplexType::
  ~PolygonsComplexType ()
  {
  }

  // PolygonComplexType
  //

  PolygonComplexType::
  PolygonComplexType (const EdgesType& edges)
  : ::xml_schema::Type (),
    value_ (::xml_schema::Flags (), this),
    edges_ (edges, ::xml_schema::Flags (), this),
    id_ (::xml_schema::Flags (), this)
  {
  }

  PolygonComplexType::
  PolygonComplexType (::std::auto_ptr< EdgesType >& edges)
  : ::xml_schema::Type (),
    value_ (::xml_schema::Flags (), this),
    edges_ (edges, ::xml_schema::Flags (), this),
    id_ (::xml_schema::Flags (), this)
  {
  }

  PolygonComplexType::
  PolygonComplexType (const PolygonComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this),
    edges_ (x.edges_, f, this),
    id_ (x.id_, f, this)
  {
  }

  PolygonComplexType::
  PolygonComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (f, this),
    edges_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PolygonComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->value_)
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      // edges
      //
      if (n.name () == "edges" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EdgesType > r (
          EdgesTraits::create (i, f, this));

        if (!edges_.present ())
        {
          this->edges_.set (r);
          continue;
        }
      }

      break;
    }

    if (!edges_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "edges",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }
  }

  PolygonComplexType* PolygonComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PolygonComplexType (*this, f, c);
  }

  PolygonComplexType::
  ~PolygonComplexType ()
  {
  }

  // EdgesComplexType
  //

  EdgesComplexType::
  EdgesComplexType ()
  : ::xml_schema::Type (),
    edge_ (::xml_schema::Flags (), this)
  {
  }

  EdgesComplexType::
  EdgesComplexType (const EdgesComplexType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    edge_ (x.edge_, f, this)
  {
  }

  EdgesComplexType::
  EdgesComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    edge_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void EdgesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // edge
      //
      if (n.name () == "edge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EdgeType > r (
          EdgeTraits::create (i, f, this));

        this->edge_.push_back (r);
        continue;
      }

      break;
    }
  }

  EdgesComplexType* EdgesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EdgesComplexType (*this, f, c);
  }

  EdgesComplexType::
  ~EdgesComplexType ()
  {
  }

  // EdgeComplexType
  //

  EdgeComplexType::
  EdgeComplexType (const X1Type& x1,
                   const X2Type& x2)
  : ::xml_schema::Type (),
    x1_ (x1, ::xml_schema::Flags (), this),
    x2_ (x2, ::xml_schema::Flags (), this)
  {
  }

  EdgeComplexType::
  EdgeComplexType (const EdgeComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1_ (x.x1_, f, this),
    x2_ (x.x2_, f, this)
  {
  }

  EdgeComplexType::
  EdgeComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1_ (f, this),
    x2_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void EdgeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x1" && n.namespace_ ().empty ())
      {
        this->x1_.set (X1Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "x2" && n.namespace_ ().empty ())
      {
        this->x2_.set (X2Traits::create (i, f, this));
        continue;
      }
    }

    if (!x1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x1",
        "");
    }

    if (!x2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x2",
        "");
    }
  }

  EdgeComplexType* EdgeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EdgeComplexType (*this, f, c);
  }

  EdgeComplexType::
  ~EdgeComplexType ()
  {
  }

  // PolygonLookupInputComplexType
  //

  PolygonLookupInputComplexType::
  PolygonLookupInputComplexType (const X1Type& x1,
                                 const X2Type& x2)
  : ::xml_schema::Type (),
    x1_ (x1, ::xml_schema::Flags (), this),
    x2_ (x2, ::xml_schema::Flags (), this)
  {
  }

  PolygonLookupInputComplexType::
  PolygonLookupInputComplexType (::std::auto_ptr< X1Type >& x1,
                                 ::std::auto_ptr< X2Type >& x2)
  : ::xml_schema::Type (),
    x1_ (x1, ::xml_schema::Flags (), this),
    x2_ (x2, ::xml_schema::Flags (), this)
  {
  }

  PolygonLookupInputComplexType::
  PolygonLookupInputComplexType (const PolygonLookupInputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1_ (x.x1_, f, this),
    x2_ (x.x2_, f, this)
  {
  }

  PolygonLookupInputComplexType::
  PolygonLookupInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1_ (f, this),
    x2_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PolygonLookupInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x1
      //
      if (n.name () == "x1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1Type > r (
          X1Traits::create (i, f, this));

        if (!x1_.present ())
        {
          this->x1_.set (r);
          continue;
        }
      }

      // x2
      //
      if (n.name () == "x2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2Type > r (
          X2Traits::create (i, f, this));

        if (!x2_.present ())
        {
          this->x2_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x1",
        "http://www.wldelft.nl/fews");
    }

    if (!x2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x2",
        "http://www.wldelft.nl/fews");
    }
  }

  PolygonLookupInputComplexType* PolygonLookupInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PolygonLookupInputComplexType (*this, f, c);
  }

  PolygonLookupInputComplexType::
  ~PolygonLookupInputComplexType ()
  {
  }

  // PolygonLookupOutputComplexType
  //

  PolygonLookupOutputComplexType::
  PolygonLookupOutputComplexType (const StatusType& status)
  : ::xml_schema::Type (),
    status_ (status, ::xml_schema::Flags (), this)
  {
  }

  PolygonLookupOutputComplexType::
  PolygonLookupOutputComplexType (const PolygonLookupOutputComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    status_ (x.status_, f, this)
  {
  }

  PolygonLookupOutputComplexType::
  PolygonLookupOutputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    status_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PolygonLookupOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // status
      //
      if (n.name () == "status" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StatusType > r (
          StatusTraits::create (i, f, this));

        if (!status_.present ())
        {
          this->status_.set (r);
          continue;
        }
      }

      break;
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "status",
        "http://www.wldelft.nl/fews");
    }
  }

  PolygonLookupOutputComplexType* PolygonLookupOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PolygonLookupOutputComplexType (*this, f, c);
  }

  PolygonLookupOutputComplexType::
  ~PolygonLookupOutputComplexType ()
  {
  }

  // SpreadsheetComplexType
  //

  SpreadsheetComplexType::
  SpreadsheetComplexType (const ToleranceType& tolerance,
                          const TablesType& tables,
                          const InputType& input,
                          const OutputType& output,
                          const IdType& id)
  : ::xml_schema::Type (),
    validPeriods_ (::xml_schema::Flags (), this),
    defaultInputValue_ (::xml_schema::Flags (), this),
    defaultOutputValue_ (::xml_schema::Flags (), this),
    tolerance_ (tolerance, ::xml_schema::Flags (), this),
    tables_ (tables, ::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SpreadsheetComplexType::
  SpreadsheetComplexType (const ToleranceType& tolerance,
                          ::std::auto_ptr< TablesType >& tables,
                          ::std::auto_ptr< InputType >& input,
                          ::std::auto_ptr< OutputType >& output,
                          const IdType& id)
  : ::xml_schema::Type (),
    validPeriods_ (::xml_schema::Flags (), this),
    defaultInputValue_ (::xml_schema::Flags (), this),
    defaultOutputValue_ (::xml_schema::Flags (), this),
    tolerance_ (tolerance, ::xml_schema::Flags (), this),
    tables_ (tables, ::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SpreadsheetComplexType::
  SpreadsheetComplexType (const SpreadsheetComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    validPeriods_ (x.validPeriods_, f, this),
    defaultInputValue_ (x.defaultInputValue_, f, this),
    defaultOutputValue_ (x.defaultOutputValue_, f, this),
    tolerance_ (x.tolerance_, f, this),
    tables_ (x.tables_, f, this),
    true__ (x.true__, f, this),
    false__ (x.false__, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  SpreadsheetComplexType::
  SpreadsheetComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    validPeriods_ (f, this),
    defaultInputValue_ (f, this),
    defaultOutputValue_ (f, this),
    tolerance_ (f, this),
    tables_ (f, this),
    true__ (f, this),
    false__ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SpreadsheetComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // validPeriods
      //
      if (n.name () == "validPeriods" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ValidPeriodsType > r (
          ValidPeriodsTraits::create (i, f, this));

        if (!this->validPeriods_)
        {
          this->validPeriods_.set (r);
          continue;
        }
      }

      // defaultInputValue
      //
      if (n.name () == "defaultInputValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->defaultInputValue_)
        {
          this->defaultInputValue_.set (DefaultInputValueTraits::create (i, f, this));
          continue;
        }
      }

      // defaultOutputValue
      //
      if (n.name () == "defaultOutputValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->defaultOutputValue_)
        {
          this->defaultOutputValue_.set (DefaultOutputValueTraits::create (i, f, this));
          continue;
        }
      }

      // tolerance
      //
      if (n.name () == "tolerance" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!tolerance_.present ())
        {
          this->tolerance_.set (ToleranceTraits::create (i, f, this));
          continue;
        }
      }

      // tables
      //
      if (n.name () == "tables" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TablesType > r (
          TablesTraits::create (i, f, this));

        if (!tables_.present ())
        {
          this->tables_.set (r);
          continue;
        }
      }

      // true
      //
      if (n.name () == "true" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TrueType > r (
          TrueTraits::create (i, f, this));

        if (!this->true__)
        {
          this->true__.set (r);
          continue;
        }
      }

      // false
      //
      if (n.name () == "false" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FalseType > r (
          FalseTraits::create (i, f, this));

        if (!this->false__)
        {
          this->false__.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!tolerance_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tolerance",
        "http://www.wldelft.nl/fews");
    }

    if (!tables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tables",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  SpreadsheetComplexType* SpreadsheetComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpreadsheetComplexType (*this, f, c);
  }

  SpreadsheetComplexType::
  ~SpreadsheetComplexType ()
  {
  }

  // ValidPeriodsComplexType
  //

  ValidPeriodsComplexType::
  ValidPeriodsComplexType ()
  : ::xml_schema::Type (),
    validPeriod_ (::xml_schema::Flags (), this)
  {
  }

  ValidPeriodsComplexType::
  ValidPeriodsComplexType (const ValidPeriodsComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    validPeriod_ (x.validPeriod_, f, this)
  {
  }

  ValidPeriodsComplexType::
  ValidPeriodsComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    validPeriod_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ValidPeriodsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // validPeriod
      //
      if (n.name () == "validPeriod" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ValidPeriodType > r (
          ValidPeriodTraits::create (i, f, this));

        this->validPeriod_.push_back (r);
        continue;
      }

      break;
    }
  }

  ValidPeriodsComplexType* ValidPeriodsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ValidPeriodsComplexType (*this, f, c);
  }

  ValidPeriodsComplexType::
  ~ValidPeriodsComplexType ()
  {
  }

  // ValidPeriodComplexType
  //

  ValidPeriodComplexType::
  ValidPeriodComplexType (const StartDateType& startDate,
                          const EndDateType& endDate)
  : ::xml_schema::Type (),
    startDate_ (startDate, ::xml_schema::Flags (), this),
    endDate_ (endDate, ::xml_schema::Flags (), this)
  {
  }

  ValidPeriodComplexType::
  ValidPeriodComplexType (::std::auto_ptr< StartDateType >& startDate,
                          ::std::auto_ptr< EndDateType >& endDate)
  : ::xml_schema::Type (),
    startDate_ (startDate, ::xml_schema::Flags (), this),
    endDate_ (endDate, ::xml_schema::Flags (), this)
  {
  }

  ValidPeriodComplexType::
  ValidPeriodComplexType (const ValidPeriodComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    startDate_ (x.startDate_, f, this),
    endDate_ (x.endDate_, f, this)
  {
  }

  ValidPeriodComplexType::
  ValidPeriodComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    startDate_ (f, this),
    endDate_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ValidPeriodComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // startDate
      //
      if (n.name () == "startDate" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StartDateType > r (
          StartDateTraits::create (i, f, this));

        if (!startDate_.present ())
        {
          this->startDate_.set (r);
          continue;
        }
      }

      // endDate
      //
      if (n.name () == "endDate" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EndDateType > r (
          EndDateTraits::create (i, f, this));

        if (!endDate_.present ())
        {
          this->endDate_.set (r);
          continue;
        }
      }

      break;
    }

    if (!startDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "startDate",
        "http://www.wldelft.nl/fews");
    }

    if (!endDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "endDate",
        "http://www.wldelft.nl/fews");
    }
  }

  ValidPeriodComplexType* ValidPeriodComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ValidPeriodComplexType (*this, f, c);
  }

  ValidPeriodComplexType::
  ~ValidPeriodComplexType ()
  {
  }

  // DateComplexType
  //

  DateComplexType::
  DateComplexType (const MonthDayType& monthDay)
  : ::xml_schema::Type (),
    monthDay_ (monthDay, ::xml_schema::Flags (), this)
  {
  }

  DateComplexType::
  DateComplexType (const DateComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    monthDay_ (x.monthDay_, f, this)
  {
  }

  DateComplexType::
  DateComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    monthDay_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void DateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "monthDay" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MonthDayType > r (
          MonthDayTraits::create (i, f, this));

        this->monthDay_.set (r);
        continue;
      }
    }

    if (!monthDay_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "monthDay",
        "");
    }
  }

  DateComplexType* DateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateComplexType (*this, f, c);
  }

  DateComplexType::
  ~DateComplexType ()
  {
  }

  // SpreadsheetTablesComplexType
  //

  SpreadsheetTablesComplexType::
  SpreadsheetTablesComplexType ()
  : ::xml_schema::Type (),
    table_ (::xml_schema::Flags (), this)
  {
  }

  SpreadsheetTablesComplexType::
  SpreadsheetTablesComplexType (const SpreadsheetTablesComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    table_ (x.table_, f, this)
  {
  }

  SpreadsheetTablesComplexType::
  SpreadsheetTablesComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    table_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SpreadsheetTablesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // table
      //
      if (n.name () == "table" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TableType > r (
          TableTraits::create (i, f, this));

        this->table_.push_back (r);
        continue;
      }

      break;
    }
  }

  SpreadsheetTablesComplexType* SpreadsheetTablesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpreadsheetTablesComplexType (*this, f, c);
  }

  SpreadsheetTablesComplexType::
  ~SpreadsheetTablesComplexType ()
  {
  }

  // SpreadsheetTableComplexType
  //

  SpreadsheetTableComplexType::
  SpreadsheetTableComplexType ()
  : ::xml_schema::Type (),
    record_ (::xml_schema::Flags (), this),
    initialState_ (::xml_schema::Flags (), this)
  {
  }

  SpreadsheetTableComplexType::
  SpreadsheetTableComplexType (const SpreadsheetTableComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    record_ (x.record_, f, this),
    initialState_ (x.initialState_, f, this)
  {
  }

  SpreadsheetTableComplexType::
  SpreadsheetTableComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    record_ (f, this),
    initialState_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SpreadsheetTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // record
      //
      if (n.name () == "record" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RecordType > r (
          RecordTraits::create (i, f, this));

        this->record_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "initialState" && n.namespace_ ().empty ())
      {
        this->initialState_.set (InitialStateTraits::create (i, f, this));
        continue;
      }
    }
  }

  SpreadsheetTableComplexType* SpreadsheetTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpreadsheetTableComplexType (*this, f, c);
  }

  SpreadsheetTableComplexType::
  ~SpreadsheetTableComplexType ()
  {
  }

  // SpreadsheetRecordComplexType
  //

  SpreadsheetRecordComplexType::
  SpreadsheetRecordComplexType (const X1Type& x1,
                                const X2Type& x2,
                                const YType& y)
  : ::xml_schema::Type (),
    x1_ (x1, ::xml_schema::Flags (), this),
    x2_ (x2, ::xml_schema::Flags (), this),
    x3_ (::xml_schema::Flags (), this),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  SpreadsheetRecordComplexType::
  SpreadsheetRecordComplexType (const SpreadsheetRecordComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1_ (x.x1_, f, this),
    x2_ (x.x2_, f, this),
    x3_ (x.x3_, f, this),
    y_ (x.y_, f, this)
  {
  }

  SpreadsheetRecordComplexType::
  SpreadsheetRecordComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1_ (f, this),
    x2_ (f, this),
    x3_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void SpreadsheetRecordComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x1" && n.namespace_ ().empty ())
      {
        this->x1_.set (X1Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "x2" && n.namespace_ ().empty ())
      {
        this->x2_.set (X2Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "x3" && n.namespace_ ().empty ())
      {
        this->x3_.set (X3Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }
    }

    if (!x1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x1",
        "");
    }

    if (!x2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x2",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }
  }

  SpreadsheetRecordComplexType* SpreadsheetRecordComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpreadsheetRecordComplexType (*this, f, c);
  }

  SpreadsheetRecordComplexType::
  ~SpreadsheetRecordComplexType ()
  {
  }

  // SpreadsheetInputComplexType
  //

  SpreadsheetInputComplexType::
  SpreadsheetInputComplexType (const X1Type& x1,
                               const X2Type& x2)
  : ::xml_schema::Type (),
    x1_ (x1, ::xml_schema::Flags (), this),
    x2_ (x2, ::xml_schema::Flags (), this),
    x3_ (::xml_schema::Flags (), this)
  {
  }

  SpreadsheetInputComplexType::
  SpreadsheetInputComplexType (::std::auto_ptr< X1Type >& x1,
                               ::std::auto_ptr< X2Type >& x2)
  : ::xml_schema::Type (),
    x1_ (x1, ::xml_schema::Flags (), this),
    x2_ (x2, ::xml_schema::Flags (), this),
    x3_ (::xml_schema::Flags (), this)
  {
  }

  SpreadsheetInputComplexType::
  SpreadsheetInputComplexType (const SpreadsheetInputComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1_ (x.x1_, f, this),
    x2_ (x.x2_, f, this),
    x3_ (x.x3_, f, this)
  {
  }

  SpreadsheetInputComplexType::
  SpreadsheetInputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1_ (f, this),
    x2_ (f, this),
    x3_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SpreadsheetInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x1
      //
      if (n.name () == "x1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1Type > r (
          X1Traits::create (i, f, this));

        if (!x1_.present ())
        {
          this->x1_.set (r);
          continue;
        }
      }

      // x2
      //
      if (n.name () == "x2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2Type > r (
          X2Traits::create (i, f, this));

        if (!x2_.present ())
        {
          this->x2_.set (r);
          continue;
        }
      }

      // x3
      //
      if (n.name () == "x3" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X3Type > r (
          X3Traits::create (i, f, this));

        if (!this->x3_)
        {
          this->x3_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x1",
        "http://www.wldelft.nl/fews");
    }

    if (!x2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x2",
        "http://www.wldelft.nl/fews");
    }
  }

  SpreadsheetInputComplexType* SpreadsheetInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpreadsheetInputComplexType (*this, f, c);
  }

  SpreadsheetInputComplexType::
  ~SpreadsheetInputComplexType ()
  {
  }

  // SpreadsheetOutputComplexType
  //

  SpreadsheetOutputComplexType::
  SpreadsheetOutputComplexType (const StatusType& status)
  : ::xml_schema::Type (),
    status_ (status, ::xml_schema::Flags (), this)
  {
  }

  SpreadsheetOutputComplexType::
  SpreadsheetOutputComplexType (const SpreadsheetOutputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    status_ (x.status_, f, this)
  {
  }

  SpreadsheetOutputComplexType::
  SpreadsheetOutputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    status_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SpreadsheetOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // status
      //
      if (n.name () == "status" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StatusType > r (
          StatusTraits::create (i, f, this));

        if (!status_.present ())
        {
          this->status_.set (r);
          continue;
        }
      }

      break;
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "status",
        "http://www.wldelft.nl/fews");
    }
  }

  SpreadsheetOutputComplexType* SpreadsheetOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpreadsheetOutputComplexType (*this, f, c);
  }

  SpreadsheetOutputComplexType::
  ~SpreadsheetOutputComplexType ()
  {
  }

  // MergerComplexType
  //

  MergerComplexType::
  MergerComplexType (const InputType& input,
                     const OutputType& output,
                     const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MergerComplexType::
  MergerComplexType (::std::auto_ptr< InputType >& input,
                     ::std::auto_ptr< OutputType >& output,
                     const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MergerComplexType::
  MergerComplexType (const MergerComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  MergerComplexType::
  MergerComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void MergerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  MergerComplexType* MergerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerComplexType (*this, f, c);
  }

  MergerComplexType::
  ~MergerComplexType ()
  {
  }

  // MergerInputComplexType
  //

  MergerInputComplexType::
  MergerInputComplexType ()
  : ::xml_schema::Type (),
    x_ (::xml_schema::Flags (), this)
  {
  }

  MergerInputComplexType::
  MergerInputComplexType (const MergerInputComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  MergerInputComplexType::
  MergerInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MergerInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        this->x_.push_back (r);
        continue;
      }

      break;
    }
  }

  MergerInputComplexType* MergerInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerInputComplexType (*this, f, c);
  }

  MergerInputComplexType::
  ~MergerInputComplexType ()
  {
  }

  // MergerOutputComplexType
  //

  MergerOutputComplexType::
  MergerOutputComplexType ()
  : ::xml_schema::Type (),
    y_ (::xml_schema::Flags (), this),
    ySum_ (::xml_schema::Flags (), this)
  {
  }

  MergerOutputComplexType::
  MergerOutputComplexType (const MergerOutputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this),
    ySum_ (x.ySum_, f, this)
  {
  }

  MergerOutputComplexType::
  MergerOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this),
    ySum_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MergerOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!this->y_)
        {
          this->y_.set (r);
          continue;
        }
      }

      // ySum
      //
      if (n.name () == "ySum" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YSumType > r (
          YSumTraits::create (i, f, this));

        if (!this->ySum_)
        {
          this->ySum_.set (r);
          continue;
        }
      }

      break;
    }
  }

  MergerOutputComplexType* MergerOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerOutputComplexType (*this, f, c);
  }

  MergerOutputComplexType::
  ~MergerOutputComplexType ()
  {
  }

  // MergerSplitterComplexType
  //

  MergerSplitterComplexType::
  MergerSplitterComplexType (const ModeType& mode,
                             const InputType& input,
                             const OutputType& output,
                             const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MergerSplitterComplexType::
  MergerSplitterComplexType (const ModeType& mode,
                             ::std::auto_ptr< InputType >& input,
                             ::std::auto_ptr< OutputType >& output,
                             const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MergerSplitterComplexType::
  MergerSplitterComplexType (const MergerSplitterComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mode_ (x.mode_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  MergerSplitterComplexType::
  MergerSplitterComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mode_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void MergerSplitterComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mode
      //
      if (n.name () == "mode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ModeType > r (
          ModeTraits::create (i, f, this));

        if (!mode_.present ())
        {
          this->mode_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mode",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  MergerSplitterComplexType* MergerSplitterComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerSplitterComplexType (*this, f, c);
  }

  MergerSplitterComplexType::
  ~MergerSplitterComplexType ()
  {
  }

  // MergerSplitterInputComplexType
  //

  MergerSplitterInputComplexType::
  MergerSplitterInputComplexType ()
  : ::xml_schema::Type (),
    x_ (::xml_schema::Flags (), this),
    xVector_ (::xml_schema::Flags (), this)
  {
  }

  MergerSplitterInputComplexType::
  MergerSplitterInputComplexType (const MergerSplitterInputComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    xVector_ (x.xVector_, f, this)
  {
  }

  MergerSplitterInputComplexType::
  MergerSplitterInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    xVector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MergerSplitterInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        this->x_.push_back (r);
        continue;
      }

      // xVector
      //
      if (n.name () == "xVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XVectorType > r (
          XVectorTraits::create (i, f, this));

        if (!this->xVector_)
        {
          this->xVector_.set (r);
          continue;
        }
      }

      break;
    }
  }

  MergerSplitterInputComplexType* MergerSplitterInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerSplitterInputComplexType (*this, f, c);
  }

  MergerSplitterInputComplexType::
  ~MergerSplitterInputComplexType ()
  {
  }

  // MergerSplitterOutputComplexType
  //

  MergerSplitterOutputComplexType::
  MergerSplitterOutputComplexType ()
  : ::xml_schema::Type (),
    y_ (::xml_schema::Flags (), this)
  {
  }

  MergerSplitterOutputComplexType::
  MergerSplitterOutputComplexType (const MergerSplitterOutputComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  MergerSplitterOutputComplexType::
  MergerSplitterOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MergerSplitterOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        this->y_.push_back (r);
        continue;
      }

      break;
    }
  }

  MergerSplitterOutputComplexType* MergerSplitterOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerSplitterOutputComplexType (*this, f, c);
  }

  MergerSplitterOutputComplexType::
  ~MergerSplitterOutputComplexType ()
  {
  }

  // TimeAbsoluteComplexType
  //

  TimeAbsoluteComplexType::
  TimeAbsoluteComplexType (const InputType& input,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  TimeAbsoluteComplexType::
  TimeAbsoluteComplexType (::std::auto_ptr< InputType >& input,
                           ::std::auto_ptr< OutputType >& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  TimeAbsoluteComplexType::
  TimeAbsoluteComplexType (const TimeAbsoluteComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  TimeAbsoluteComplexType::
  TimeAbsoluteComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TimeAbsoluteComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TimeAbsoluteComplexType* TimeAbsoluteComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeAbsoluteComplexType (*this, f, c);
  }

  TimeAbsoluteComplexType::
  ~TimeAbsoluteComplexType ()
  {
  }

  // TimeAbsoluteInputComplexType
  //

  TimeAbsoluteInputComplexType::
  TimeAbsoluteInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  TimeAbsoluteInputComplexType::
  TimeAbsoluteInputComplexType (const TimeAbsoluteInputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  TimeAbsoluteInputComplexType::
  TimeAbsoluteInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TimeAbsoluteInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  TimeAbsoluteInputComplexType* TimeAbsoluteInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeAbsoluteInputComplexType (*this, f, c);
  }

  TimeAbsoluteInputComplexType::
  ~TimeAbsoluteInputComplexType ()
  {
  }

  // TimeAbsoluteOutputComplexType
  //

  TimeAbsoluteOutputComplexType::
  TimeAbsoluteOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  TimeAbsoluteOutputComplexType::
  TimeAbsoluteOutputComplexType (const TimeAbsoluteOutputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  TimeAbsoluteOutputComplexType::
  TimeAbsoluteOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TimeAbsoluteOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  TimeAbsoluteOutputComplexType* TimeAbsoluteOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeAbsoluteOutputComplexType (*this, f, c);
  }

  TimeAbsoluteOutputComplexType::
  ~TimeAbsoluteOutputComplexType ()
  {
  }

  // TimeRelativeComplexType
  //

  const TimeRelativeComplexType::ModeType TimeRelativeComplexType::mode_default_value_ (
    "NATIVE");

  TimeRelativeComplexType::
  TimeRelativeComplexType (const ValueOptionType& valueOption,
                           const ControlTableType& controlTable,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    mode_ (::xml_schema::Flags (), this),
    valueOption_ (valueOption, ::xml_schema::Flags (), this),
    maximumPeriod_ (::xml_schema::Flags (), this),
    interpolationOption_ (::xml_schema::Flags (), this),
    controlTable_ (controlTable, ::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  TimeRelativeComplexType::
  TimeRelativeComplexType (const ValueOptionType& valueOption,
                           ::std::auto_ptr< ControlTableType >& controlTable,
                           ::std::auto_ptr< OutputType >& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    mode_ (::xml_schema::Flags (), this),
    valueOption_ (valueOption, ::xml_schema::Flags (), this),
    maximumPeriod_ (::xml_schema::Flags (), this),
    interpolationOption_ (::xml_schema::Flags (), this),
    controlTable_ (controlTable, ::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  TimeRelativeComplexType::
  TimeRelativeComplexType (const TimeRelativeComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mode_ (x.mode_, f, this),
    valueOption_ (x.valueOption_, f, this),
    maximumPeriod_ (x.maximumPeriod_, f, this),
    interpolationOption_ (x.interpolationOption_, f, this),
    controlTable_ (x.controlTable_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  TimeRelativeComplexType::
  TimeRelativeComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mode_ (f, this),
    valueOption_ (f, this),
    maximumPeriod_ (f, this),
    interpolationOption_ (f, this),
    controlTable_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TimeRelativeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mode
      //
      if (n.name () == "mode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ModeType > r (
          ModeTraits::create (i, f, this));

        if (!this->mode_)
        {
          this->mode_.set (r);
          continue;
        }
      }

      // valueOption
      //
      if (n.name () == "valueOption" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ValueOptionType > r (
          ValueOptionTraits::create (i, f, this));

        if (!valueOption_.present ())
        {
          this->valueOption_.set (r);
          continue;
        }
      }

      // maximumPeriod
      //
      if (n.name () == "maximumPeriod" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->maximumPeriod_)
        {
          this->maximumPeriod_.set (MaximumPeriodTraits::create (i, f, this));
          continue;
        }
      }

      // interpolationOption
      //
      if (n.name () == "interpolationOption" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InterpolationOptionType > r (
          InterpolationOptionTraits::create (i, f, this));

        if (!this->interpolationOption_)
        {
          this->interpolationOption_.set (r);
          continue;
        }
      }

      // controlTable
      //
      if (n.name () == "controlTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ControlTableType > r (
          ControlTableTraits::create (i, f, this));

        if (!controlTable_.present ())
        {
          this->controlTable_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!this->input_)
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!valueOption_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "valueOption",
        "http://www.wldelft.nl/fews");
    }

    if (!controlTable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "controlTable",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TimeRelativeComplexType* TimeRelativeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeRelativeComplexType (*this, f, c);
  }

  TimeRelativeComplexType::
  ~TimeRelativeComplexType ()
  {
  }

  // TimeRelativeControlTableComplexType
  //

  TimeRelativeControlTableComplexType::
  TimeRelativeControlTableComplexType ()
  : ::xml_schema::Type (),
    record_ (::xml_schema::Flags (), this)
  {
  }

  TimeRelativeControlTableComplexType::
  TimeRelativeControlTableComplexType (const TimeRelativeControlTableComplexType& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    record_ (x.record_, f, this)
  {
  }

  TimeRelativeControlTableComplexType::
  TimeRelativeControlTableComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    record_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TimeRelativeControlTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // record
      //
      if (n.name () == "record" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RecordType > r (
          RecordTraits::create (i, f, this));

        this->record_.push_back (r);
        continue;
      }

      break;
    }
  }

  TimeRelativeControlTableComplexType* TimeRelativeControlTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeRelativeControlTableComplexType (*this, f, c);
  }

  TimeRelativeControlTableComplexType::
  ~TimeRelativeControlTableComplexType ()
  {
  }

  // TimeRelativeControlTableRecordComplexType
  //

  TimeRelativeControlTableRecordComplexType::
  TimeRelativeControlTableRecordComplexType (const TimeType& time,
                                             const ValueType& value)
  : ::xml_schema::Type (),
    time_ (time, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  TimeRelativeControlTableRecordComplexType::
  TimeRelativeControlTableRecordComplexType (const TimeRelativeControlTableRecordComplexType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    time_ (x.time_, f, this),
    value_ (x.value_, f, this)
  {
  }

  TimeRelativeControlTableRecordComplexType::
  TimeRelativeControlTableRecordComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    time_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void TimeRelativeControlTableRecordComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  TimeRelativeControlTableRecordComplexType* TimeRelativeControlTableRecordComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeRelativeControlTableRecordComplexType (*this, f, c);
  }

  TimeRelativeControlTableRecordComplexType::
  ~TimeRelativeControlTableRecordComplexType ()
  {
  }

  // TimeRelativeInputComplexType
  //

  TimeRelativeInputComplexType::
  TimeRelativeInputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  TimeRelativeInputComplexType::
  TimeRelativeInputComplexType (const TimeRelativeInputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  TimeRelativeInputComplexType::
  TimeRelativeInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TimeRelativeInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  TimeRelativeInputComplexType* TimeRelativeInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeRelativeInputComplexType (*this, f, c);
  }

  TimeRelativeInputComplexType::
  ~TimeRelativeInputComplexType ()
  {
  }

  // TimeRelativeOutputComplexType
  //

  TimeRelativeOutputComplexType::
  TimeRelativeOutputComplexType (const YType& y,
                                 const TimeActiveType& timeActive)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this),
    timeActive_ (timeActive, ::xml_schema::Flags (), this)
  {
  }

  TimeRelativeOutputComplexType::
  TimeRelativeOutputComplexType (const TimeRelativeOutputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this),
    timeActive_ (x.timeActive_, f, this)
  {
  }

  TimeRelativeOutputComplexType::
  TimeRelativeOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this),
    timeActive_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TimeRelativeOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // timeActive
      //
      if (n.name () == "timeActive" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeActiveType > r (
          TimeActiveTraits::create (i, f, this));

        if (!timeActive_.present ())
        {
          this->timeActive_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }

    if (!timeActive_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeActive",
        "http://www.wldelft.nl/fews");
    }
  }

  TimeRelativeOutputComplexType* TimeRelativeOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeRelativeOutputComplexType (*this, f, c);
  }

  TimeRelativeOutputComplexType::
  ~TimeRelativeOutputComplexType ()
  {
  }

  // ExpressionComplexType
  //

  ExpressionComplexType::
  ExpressionComplexType (const MathematicalOperatorType& mathematicalOperator,
                         const IdType& id)
  : ::xml_schema::Type (),
    x1Value_ (::xml_schema::Flags (), this),
    x1Series_ (::xml_schema::Flags (), this),
    x1SeriesVector_ (::xml_schema::Flags (), this),
    mathematicalOperator_ (mathematicalOperator, ::xml_schema::Flags (), this),
    x2Value_ (::xml_schema::Flags (), this),
    x2Series_ (::xml_schema::Flags (), this),
    x2SeriesVector_ (::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this),
    yVector_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ExpressionComplexType::
  ExpressionComplexType (const ExpressionComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1Value_ (x.x1Value_, f, this),
    x1Series_ (x.x1Series_, f, this),
    x1SeriesVector_ (x.x1SeriesVector_, f, this),
    mathematicalOperator_ (x.mathematicalOperator_, f, this),
    x2Value_ (x.x2Value_, f, this),
    x2Series_ (x.x2Series_, f, this),
    x2SeriesVector_ (x.x2SeriesVector_, f, this),
    y_ (x.y_, f, this),
    yVector_ (x.yVector_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ExpressionComplexType::
  ExpressionComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1Value_ (f, this),
    x1Series_ (f, this),
    x1SeriesVector_ (f, this),
    mathematicalOperator_ (f, this),
    x2Value_ (f, this),
    x2Series_ (f, this),
    x2SeriesVector_ (f, this),
    y_ (f, this),
    yVector_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ExpressionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x1Value
      //
      if (n.name () == "x1Value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1ValueType > r (
          X1ValueTraits::create (i, f, this));

        if (!this->x1Value_)
        {
          this->x1Value_.set (r);
          continue;
        }
      }

      // x1Series
      //
      if (n.name () == "x1Series" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1SeriesType > r (
          X1SeriesTraits::create (i, f, this));

        if (!this->x1Series_)
        {
          this->x1Series_.set (r);
          continue;
        }
      }

      // x1SeriesVector
      //
      if (n.name () == "x1SeriesVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1SeriesVectorType > r (
          X1SeriesVectorTraits::create (i, f, this));

        if (!this->x1SeriesVector_)
        {
          this->x1SeriesVector_.set (r);
          continue;
        }
      }

      // mathematicalOperator
      //
      if (n.name () == "mathematicalOperator" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MathematicalOperatorType > r (
          MathematicalOperatorTraits::create (i, f, this));

        if (!mathematicalOperator_.present ())
        {
          this->mathematicalOperator_.set (r);
          continue;
        }
      }

      // x2Value
      //
      if (n.name () == "x2Value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2ValueType > r (
          X2ValueTraits::create (i, f, this));

        if (!this->x2Value_)
        {
          this->x2Value_.set (r);
          continue;
        }
      }

      // x2Series
      //
      if (n.name () == "x2Series" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2SeriesType > r (
          X2SeriesTraits::create (i, f, this));

        if (!this->x2Series_)
        {
          this->x2Series_.set (r);
          continue;
        }
      }

      // x2SeriesVector
      //
      if (n.name () == "x2SeriesVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2SeriesVectorType > r (
          X2SeriesVectorTraits::create (i, f, this));

        if (!this->x2SeriesVector_)
        {
          this->x2SeriesVector_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!this->y_)
        {
          this->y_.set (r);
          continue;
        }
      }

      // yVector
      //
      if (n.name () == "yVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YVectorType > r (
          YVectorTraits::create (i, f, this));

        if (!this->yVector_)
        {
          this->yVector_.set (r);
          continue;
        }
      }

      break;
    }

    if (!mathematicalOperator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mathematicalOperator",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ExpressionComplexType* ExpressionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ExpressionComplexType (*this, f, c);
  }

  ExpressionComplexType::
  ~ExpressionComplexType ()
  {
  }

  // DeadBandValueComplexType
  //

  DeadBandValueComplexType::
  DeadBandValueComplexType (const ThresholdType& threshold,
                            const InputType& input,
                            const IdType& id)
  : ::xml_schema::Type (),
    threshold_ (threshold, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandValueComplexType::
  DeadBandValueComplexType (const ThresholdType& threshold,
                            ::std::auto_ptr< InputType >& input,
                            const IdType& id)
  : ::xml_schema::Type (),
    threshold_ (threshold, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandValueComplexType::
  DeadBandValueComplexType (const DeadBandValueComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    threshold_ (x.threshold_, f, this),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DeadBandValueComplexType::
  DeadBandValueComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    threshold_ (f, this),
    input_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void DeadBandValueComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // threshold
      //
      if (n.name () == "threshold" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!threshold_.present ())
        {
          this->threshold_.set (ThresholdTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!threshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "threshold",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  DeadBandValueComplexType* DeadBandValueComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandValueComplexType (*this, f, c);
  }

  DeadBandValueComplexType::
  ~DeadBandValueComplexType ()
  {
  }

  // DeadBandValueInputComplexType
  //

  DeadBandValueInputComplexType::
  DeadBandValueInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  DeadBandValueInputComplexType::
  DeadBandValueInputComplexType (const DeadBandValueInputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  DeadBandValueInputComplexType::
  DeadBandValueInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeadBandValueInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  DeadBandValueInputComplexType* DeadBandValueInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandValueInputComplexType (*this, f, c);
  }

  DeadBandValueInputComplexType::
  ~DeadBandValueInputComplexType ()
  {
  }

  // DeadBandTimeComplexType
  //

  DeadBandTimeComplexType::
  DeadBandTimeComplexType (const DiscreteType& discrete,
                           const InputType& input,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    discrete_ (discrete, ::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandTimeComplexType::
  DeadBandTimeComplexType (::std::auto_ptr< DiscreteType >& discrete,
                           ::std::auto_ptr< InputType >& input,
                           ::std::auto_ptr< OutputType >& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    discrete_ (discrete, ::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandTimeComplexType::
  DeadBandTimeComplexType (const DeadBandTimeComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    discrete_ (x.discrete_, f, this),
    true__ (x.true__, f, this),
    false__ (x.false__, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DeadBandTimeComplexType::
  DeadBandTimeComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    discrete_ (f, this),
    true__ (f, this),
    false__ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void DeadBandTimeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // discrete
      //
      if (n.name () == "discrete" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DiscreteType > r (
          DiscreteTraits::create (i, f, this));

        if (!discrete_.present ())
        {
          this->discrete_.set (r);
          continue;
        }
      }

      // true
      //
      if (n.name () == "true" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TrueType > r (
          TrueTraits::create (i, f, this));

        if (!this->true__)
        {
          this->true__.set (r);
          continue;
        }
      }

      // false
      //
      if (n.name () == "false" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FalseType > r (
          FalseTraits::create (i, f, this));

        if (!this->false__)
        {
          this->false__.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!discrete_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "discrete",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  DeadBandTimeComplexType* DeadBandTimeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandTimeComplexType (*this, f, c);
  }

  DeadBandTimeComplexType::
  ~DeadBandTimeComplexType ()
  {
  }

  // DeadBandTimeDiscreteComplexType
  //

  DeadBandTimeDiscreteComplexType::
  DeadBandTimeDiscreteComplexType (const NumberOfStepsUpType& numberOfStepsUp,
                                   const NumberOfStepsDownType& numberOfStepsDown)
  : ::xml_schema::Type (),
    numberOfStepsUp_ (numberOfStepsUp, ::xml_schema::Flags (), this),
    numberOfStepsDown_ (numberOfStepsDown, ::xml_schema::Flags (), this)
  {
  }

  DeadBandTimeDiscreteComplexType::
  DeadBandTimeDiscreteComplexType (const DeadBandTimeDiscreteComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    numberOfStepsUp_ (x.numberOfStepsUp_, f, this),
    numberOfStepsDown_ (x.numberOfStepsDown_, f, this)
  {
  }

  DeadBandTimeDiscreteComplexType::
  DeadBandTimeDiscreteComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    numberOfStepsUp_ (f, this),
    numberOfStepsDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeadBandTimeDiscreteComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // numberOfStepsUp
      //
      if (n.name () == "numberOfStepsUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!numberOfStepsUp_.present ())
        {
          this->numberOfStepsUp_.set (NumberOfStepsUpTraits::create (i, f, this));
          continue;
        }
      }

      // numberOfStepsDown
      //
      if (n.name () == "numberOfStepsDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!numberOfStepsDown_.present ())
        {
          this->numberOfStepsDown_.set (NumberOfStepsDownTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!numberOfStepsUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numberOfStepsUp",
        "http://www.wldelft.nl/fews");
    }

    if (!numberOfStepsDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numberOfStepsDown",
        "http://www.wldelft.nl/fews");
    }
  }

  DeadBandTimeDiscreteComplexType* DeadBandTimeDiscreteComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandTimeDiscreteComplexType (*this, f, c);
  }

  DeadBandTimeDiscreteComplexType::
  ~DeadBandTimeDiscreteComplexType ()
  {
  }

  // DeadBandTimeInputComplexType
  //

  DeadBandTimeInputComplexType::
  DeadBandTimeInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  DeadBandTimeInputComplexType::
  DeadBandTimeInputComplexType (::std::auto_ptr< XType >& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  DeadBandTimeInputComplexType::
  DeadBandTimeInputComplexType (const DeadBandTimeInputComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this)
  {
  }

  DeadBandTimeInputComplexType::
  DeadBandTimeInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeadBandTimeInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  DeadBandTimeInputComplexType* DeadBandTimeInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandTimeInputComplexType (*this, f, c);
  }

  DeadBandTimeInputComplexType::
  ~DeadBandTimeInputComplexType ()
  {
  }

  // DeadBandTimeOutputComplexType
  //

  DeadBandTimeOutputComplexType::
  DeadBandTimeOutputComplexType (const StatusType& status,
                                 const StepsUpType& stepsUp,
                                 const StepsDownType& stepsDown)
  : ::xml_schema::Type (),
    status_ (status, ::xml_schema::Flags (), this),
    stepsUp_ (stepsUp, ::xml_schema::Flags (), this),
    stepsDown_ (stepsDown, ::xml_schema::Flags (), this),
    timeTrue_ (::xml_schema::Flags (), this),
    timeFalse_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandTimeOutputComplexType::
  DeadBandTimeOutputComplexType (const DeadBandTimeOutputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    status_ (x.status_, f, this),
    stepsUp_ (x.stepsUp_, f, this),
    stepsDown_ (x.stepsDown_, f, this),
    timeTrue_ (x.timeTrue_, f, this),
    timeFalse_ (x.timeFalse_, f, this)
  {
  }

  DeadBandTimeOutputComplexType::
  DeadBandTimeOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    status_ (f, this),
    stepsUp_ (f, this),
    stepsDown_ (f, this),
    timeTrue_ (f, this),
    timeFalse_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeadBandTimeOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // status
      //
      if (n.name () == "status" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StatusType > r (
          StatusTraits::create (i, f, this));

        if (!status_.present ())
        {
          this->status_.set (r);
          continue;
        }
      }

      // stepsUp
      //
      if (n.name () == "stepsUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StepsUpType > r (
          StepsUpTraits::create (i, f, this));

        if (!stepsUp_.present ())
        {
          this->stepsUp_.set (r);
          continue;
        }
      }

      // stepsDown
      //
      if (n.name () == "stepsDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StepsDownType > r (
          StepsDownTraits::create (i, f, this));

        if (!stepsDown_.present ())
        {
          this->stepsDown_.set (r);
          continue;
        }
      }

      // timeTrue
      //
      if (n.name () == "timeTrue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeTrueType > r (
          TimeTrueTraits::create (i, f, this));

        if (!this->timeTrue_)
        {
          this->timeTrue_.set (r);
          continue;
        }
      }

      // timeFalse
      //
      if (n.name () == "timeFalse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeFalseType > r (
          TimeFalseTraits::create (i, f, this));

        if (!this->timeFalse_)
        {
          this->timeFalse_.set (r);
          continue;
        }
      }

      break;
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "status",
        "http://www.wldelft.nl/fews");
    }

    if (!stepsUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stepsUp",
        "http://www.wldelft.nl/fews");
    }

    if (!stepsDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stepsDown",
        "http://www.wldelft.nl/fews");
    }
  }

  DeadBandTimeOutputComplexType* DeadBandTimeOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandTimeOutputComplexType (*this, f, c);
  }

  DeadBandTimeOutputComplexType::
  ~DeadBandTimeOutputComplexType ()
  {
  }

  // LimiterComplexType
  //

  LimiterComplexType::
  LimiterComplexType (const ModeType& mode,
                      const InputType& input,
                      const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LimiterComplexType::
  LimiterComplexType (const ModeType& mode,
                      ::std::auto_ptr< InputType >& input,
                      const IdType& id)
  : ::xml_schema::Type (),
    mode_ (mode, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  LimiterComplexType::
  LimiterComplexType (const LimiterComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mode_ (x.mode_, f, this),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  LimiterComplexType::
  LimiterComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mode_ (f, this),
    input_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void LimiterComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mode
      //
      if (n.name () == "mode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ModeType > r (
          ModeTraits::create (i, f, this));

        if (!mode_.present ())
        {
          this->mode_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mode",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  LimiterComplexType* LimiterComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimiterComplexType (*this, f, c);
  }

  LimiterComplexType::
  ~LimiterComplexType ()
  {
  }

  // LimiterInputComplexType
  //

  LimiterInputComplexType::
  LimiterInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    thresholdSeries_ (::xml_schema::Flags (), this),
    thresholdValue_ (::xml_schema::Flags (), this),
    x_ (x, ::xml_schema::Flags (), this)
  {
  }

  LimiterInputComplexType::
  LimiterInputComplexType (const LimiterInputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    thresholdSeries_ (x.thresholdSeries_, f, this),
    thresholdValue_ (x.thresholdValue_, f, this),
    x_ (x.x_, f, this)
  {
  }

  LimiterInputComplexType::
  LimiterInputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    thresholdSeries_ (f, this),
    thresholdValue_ (f, this),
    x_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void LimiterInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // thresholdSeries
      //
      if (n.name () == "thresholdSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ThresholdSeriesType > r (
          ThresholdSeriesTraits::create (i, f, this));

        if (!this->thresholdSeries_)
        {
          this->thresholdSeries_.set (r);
          continue;
        }
      }

      // thresholdValue
      //
      if (n.name () == "thresholdValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->thresholdValue_)
        {
          this->thresholdValue_.set (ThresholdValueTraits::create (i, f, this));
          continue;
        }
      }

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  LimiterInputComplexType* LimiterInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimiterInputComplexType (*this, f, c);
  }

  LimiterInputComplexType::
  ~LimiterInputComplexType ()
  {
  }

  // TriggersComplexType
  //

  TriggersComplexType::
  TriggersComplexType ()
  : ::xml_schema::Type (),
    trigger_ (::xml_schema::Flags (), this)
  {
  }

  TriggersComplexType::
  TriggersComplexType (const TriggersComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    trigger_ (x.trigger_, f, this)
  {
  }

  TriggersComplexType::
  TriggersComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    trigger_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TriggersComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // trigger
      //
      if (n.name () == "trigger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TriggerType > r (
          TriggerTraits::create (i, f, this));

        this->trigger_.push_back (r);
        continue;
      }

      break;
    }
  }

  TriggersComplexType* TriggersComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriggersComplexType (*this, f, c);
  }

  TriggersComplexType::
  ~TriggersComplexType ()
  {
  }

  // TriggerComplexType
  //

  TriggerComplexType::
  TriggerComplexType ()
  : ::xml_schema::Type (),
    standard_ (::xml_schema::Flags (), this),
    deadBand_ (::xml_schema::Flags (), this),
    deadBandTime_ (::xml_schema::Flags (), this),
    expression_ (::xml_schema::Flags (), this),
    lookupTable_ (::xml_schema::Flags (), this),
    merger_ (::xml_schema::Flags (), this),
    polygonLookup_ (::xml_schema::Flags (), this),
    ruleReference_ (::xml_schema::Flags (), this),
    set_ (::xml_schema::Flags (), this),
    spreadsheet_ (::xml_schema::Flags (), this)
  {
  }

  TriggerComplexType::
  TriggerComplexType (const TriggerComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    standard_ (x.standard_, f, this),
    deadBand_ (x.deadBand_, f, this),
    deadBandTime_ (x.deadBandTime_, f, this),
    expression_ (x.expression_, f, this),
    lookupTable_ (x.lookupTable_, f, this),
    merger_ (x.merger_, f, this),
    polygonLookup_ (x.polygonLookup_, f, this),
    ruleReference_ (x.ruleReference_, f, this),
    set_ (x.set_, f, this),
    spreadsheet_ (x.spreadsheet_, f, this)
  {
  }

  TriggerComplexType::
  TriggerComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    standard_ (f, this),
    deadBand_ (f, this),
    deadBandTime_ (f, this),
    expression_ (f, this),
    lookupTable_ (f, this),
    merger_ (f, this),
    polygonLookup_ (f, this),
    ruleReference_ (f, this),
    set_ (f, this),
    spreadsheet_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TriggerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // standard
      //
      if (n.name () == "standard" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StandardType > r (
          StandardTraits::create (i, f, this));

        if (!this->standard_)
        {
          this->standard_.set (r);
          continue;
        }
      }

      // deadBand
      //
      if (n.name () == "deadBand" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeadBandType > r (
          DeadBandTraits::create (i, f, this));

        if (!this->deadBand_)
        {
          this->deadBand_.set (r);
          continue;
        }
      }

      // deadBandTime
      //
      if (n.name () == "deadBandTime" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeadBandTimeType > r (
          DeadBandTimeTraits::create (i, f, this));

        if (!this->deadBandTime_)
        {
          this->deadBandTime_.set (r);
          continue;
        }
      }

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExpressionType > r (
          ExpressionTraits::create (i, f, this));

        if (!this->expression_)
        {
          this->expression_.set (r);
          continue;
        }
      }

      // lookupTable
      //
      if (n.name () == "lookupTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LookupTableType > r (
          LookupTableTraits::create (i, f, this));

        if (!this->lookupTable_)
        {
          this->lookupTable_.set (r);
          continue;
        }
      }

      // merger
      //
      if (n.name () == "merger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MergerType > r (
          MergerTraits::create (i, f, this));

        if (!this->merger_)
        {
          this->merger_.set (r);
          continue;
        }
      }

      // polygonLookup
      //
      if (n.name () == "polygonLookup" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PolygonLookupType > r (
          PolygonLookupTraits::create (i, f, this));

        if (!this->polygonLookup_)
        {
          this->polygonLookup_.set (r);
          continue;
        }
      }

      // ruleReference
      //
      if (n.name () == "ruleReference" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RuleReferenceType > r (
          RuleReferenceTraits::create (i, f, this));

        if (!this->ruleReference_)
        {
          this->ruleReference_.set (r);
          continue;
        }
      }

      // set
      //
      if (n.name () == "set" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetType > r (
          SetTraits::create (i, f, this));

        if (!this->set_)
        {
          this->set_.set (r);
          continue;
        }
      }

      // spreadsheet
      //
      if (n.name () == "spreadsheet" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SpreadsheetType > r (
          SpreadsheetTraits::create (i, f, this));

        if (!this->spreadsheet_)
        {
          this->spreadsheet_.set (r);
          continue;
        }
      }

      break;
    }
  }

  TriggerComplexType* TriggerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriggerComplexType (*this, f, c);
  }

  TriggerComplexType::
  ~TriggerComplexType ()
  {
  }

  // EifelRurRuleComplexType
  //

  EifelRurRuleComplexType::
  EifelRurRuleComplexType (const AType& a,
                           const BType& b,
                           const MinimumRelativeStorageType& minimumRelativeStorage,
                           const IdType& id)
  : ::xml_schema::Type (),
    a_ (a, ::xml_schema::Flags (), this),
    b_ (b, ::xml_schema::Flags (), this),
    minimumRelativeStorage_ (minimumRelativeStorage, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EifelRurRuleComplexType::
  EifelRurRuleComplexType (const AType& a,
                           const BType& b,
                           ::std::auto_ptr< MinimumRelativeStorageType >& minimumRelativeStorage,
                           const IdType& id)
  : ::xml_schema::Type (),
    a_ (a, ::xml_schema::Flags (), this),
    b_ (b, ::xml_schema::Flags (), this),
    minimumRelativeStorage_ (minimumRelativeStorage, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  EifelRurRuleComplexType::
  EifelRurRuleComplexType (const EifelRurRuleComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    minimumRelativeStorage_ (x.minimumRelativeStorage_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  EifelRurRuleComplexType::
  EifelRurRuleComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a_ (f, this),
    b_ (f, this),
    minimumRelativeStorage_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void EifelRurRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // a
      //
      if (n.name () == "a" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!a_.present ())
        {
          this->a_.set (ATraits::create (i, f, this));
          continue;
        }
      }

      // b
      //
      if (n.name () == "b" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!b_.present ())
        {
          this->b_.set (BTraits::create (i, f, this));
          continue;
        }
      }

      // minimumRelativeStorage
      //
      if (n.name () == "minimumRelativeStorage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MinimumRelativeStorageType > r (
          MinimumRelativeStorageTraits::create (i, f, this));

        if (!minimumRelativeStorage_.present ())
        {
          this->minimumRelativeStorage_.set (r);
          continue;
        }
      }

      break;
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a",
        "http://www.wldelft.nl/fews");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "b",
        "http://www.wldelft.nl/fews");
    }

    if (!minimumRelativeStorage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimumRelativeStorage",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  EifelRurRuleComplexType* EifelRurRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EifelRurRuleComplexType (*this, f, c);
  }

  EifelRurRuleComplexType::
  ~EifelRurRuleComplexType ()
  {
  }

  // GuideBandRuleComplexType
  //

  GuideBandRuleComplexType::
  GuideBandRuleComplexType (const XMinType& xMin,
                            const XMaxType& xMax,
                            const InputType& input,
                            const OutputType& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    xMin_ (xMin, ::xml_schema::Flags (), this),
    xMax_ (xMax, ::xml_schema::Flags (), this),
    yMin_ (::xml_schema::Flags (), this),
    yMinSeries_ (::xml_schema::Flags (), this),
    yMax_ (::xml_schema::Flags (), this),
    yMaxSeries_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  GuideBandRuleComplexType::
  GuideBandRuleComplexType (::std::auto_ptr< XMinType >& xMin,
                            ::std::auto_ptr< XMaxType >& xMax,
                            ::std::auto_ptr< InputType >& input,
                            ::std::auto_ptr< OutputType >& output,
                            const IdType& id)
  : ::xml_schema::Type (),
    xMin_ (xMin, ::xml_schema::Flags (), this),
    xMax_ (xMax, ::xml_schema::Flags (), this),
    yMin_ (::xml_schema::Flags (), this),
    yMinSeries_ (::xml_schema::Flags (), this),
    yMax_ (::xml_schema::Flags (), this),
    yMaxSeries_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  GuideBandRuleComplexType::
  GuideBandRuleComplexType (const GuideBandRuleComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    xMin_ (x.xMin_, f, this),
    xMax_ (x.xMax_, f, this),
    yMin_ (x.yMin_, f, this),
    yMinSeries_ (x.yMinSeries_, f, this),
    yMax_ (x.yMax_, f, this),
    yMaxSeries_ (x.yMaxSeries_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  GuideBandRuleComplexType::
  GuideBandRuleComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    xMin_ (f, this),
    xMax_ (f, this),
    yMin_ (f, this),
    yMinSeries_ (f, this),
    yMax_ (f, this),
    yMaxSeries_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void GuideBandRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // xMin
      //
      if (n.name () == "xMin" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XMinType > r (
          XMinTraits::create (i, f, this));

        if (!xMin_.present ())
        {
          this->xMin_.set (r);
          continue;
        }
      }

      // xMax
      //
      if (n.name () == "xMax" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XMaxType > r (
          XMaxTraits::create (i, f, this));

        if (!xMax_.present ())
        {
          this->xMax_.set (r);
          continue;
        }
      }

      // yMin
      //
      if (n.name () == "yMin" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->yMin_)
        {
          this->yMin_.set (YMinTraits::create (i, f, this));
          continue;
        }
      }

      // yMinSeries
      //
      if (n.name () == "yMinSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YMinSeriesType > r (
          YMinSeriesTraits::create (i, f, this));

        if (!this->yMinSeries_)
        {
          this->yMinSeries_.set (r);
          continue;
        }
      }

      // yMax
      //
      if (n.name () == "yMax" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->yMax_)
        {
          this->yMax_.set (YMaxTraits::create (i, f, this));
          continue;
        }
      }

      // yMaxSeries
      //
      if (n.name () == "yMaxSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YMaxSeriesType > r (
          YMaxSeriesTraits::create (i, f, this));

        if (!this->yMaxSeries_)
        {
          this->yMaxSeries_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!xMin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "xMin",
        "http://www.wldelft.nl/fews");
    }

    if (!xMax_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "xMax",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  GuideBandRuleComplexType* GuideBandRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GuideBandRuleComplexType (*this, f, c);
  }

  GuideBandRuleComplexType::
  ~GuideBandRuleComplexType ()
  {
  }

  // GuideBandRuleInputComplexType
  //

  GuideBandRuleInputComplexType::
  GuideBandRuleInputComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  GuideBandRuleInputComplexType::
  GuideBandRuleInputComplexType (const GuideBandRuleInputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  GuideBandRuleInputComplexType::
  GuideBandRuleInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GuideBandRuleInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!this->y_)
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  GuideBandRuleInputComplexType* GuideBandRuleInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GuideBandRuleInputComplexType (*this, f, c);
  }

  GuideBandRuleInputComplexType::
  ~GuideBandRuleInputComplexType ()
  {
  }

  // GuideBandRuleOutputComplexType
  //

  GuideBandRuleOutputComplexType::
  GuideBandRuleOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  GuideBandRuleOutputComplexType::
  GuideBandRuleOutputComplexType (const GuideBandRuleOutputComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  GuideBandRuleOutputComplexType::
  GuideBandRuleOutputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GuideBandRuleOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  GuideBandRuleOutputComplexType* GuideBandRuleOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GuideBandRuleOutputComplexType (*this, f, c);
  }

  GuideBandRuleOutputComplexType::
  ~GuideBandRuleOutputComplexType ()
  {
  }

  // ConstantRuleComplexType
  //

  ConstantRuleComplexType::
  ConstantRuleComplexType (const ConstantType& constant,
                           const OutputType& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    constant_ (constant, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ConstantRuleComplexType::
  ConstantRuleComplexType (const ConstantType& constant,
                           ::std::auto_ptr< OutputType >& output,
                           const IdType& id)
  : ::xml_schema::Type (),
    constant_ (constant, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ConstantRuleComplexType::
  ConstantRuleComplexType (const ConstantRuleComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    constant_ (x.constant_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ConstantRuleComplexType::
  ConstantRuleComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    constant_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ConstantRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!constant_.present ())
        {
          this->constant_.set (ConstantTraits::create (i, f, this));
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!constant_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "constant",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ConstantRuleComplexType* ConstantRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConstantRuleComplexType (*this, f, c);
  }

  ConstantRuleComplexType::
  ~ConstantRuleComplexType ()
  {
  }

  // ConstantRuleOutputComplexType
  //

  ConstantRuleOutputComplexType::
  ConstantRuleOutputComplexType (const YType& y)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this)
  {
  }

  ConstantRuleOutputComplexType::
  ConstantRuleOutputComplexType (const ConstantRuleOutputComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this)
  {
  }

  ConstantRuleOutputComplexType::
  ConstantRuleOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConstantRuleOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }
  }

  ConstantRuleOutputComplexType* ConstantRuleOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConstantRuleOutputComplexType (*this, f, c);
  }

  ConstantRuleOutputComplexType::
  ~ConstantRuleOutputComplexType ()
  {
  }

  // MinSimpleRuleComplexType
  //

  MinSimpleRuleComplexType::
  MinSimpleRuleComplexType (const IdType& id)
  : ::xml_schema::Type (),
    zones_ (::xml_schema::Flags (), this),
    dateTable_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  MinSimpleRuleComplexType::
  MinSimpleRuleComplexType (const MinSimpleRuleComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    zones_ (x.zones_, f, this),
    dateTable_ (x.dateTable_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  MinSimpleRuleComplexType::
  MinSimpleRuleComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    zones_ (f, this),
    dateTable_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void MinSimpleRuleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // zones
      //
      if (n.name () == "zones" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ZonesType > r (
          ZonesTraits::create (i, f, this));

        if (!this->zones_)
        {
          this->zones_.set (r);
          continue;
        }
      }

      // dateTable
      //
      if (n.name () == "dateTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DateTableType > r (
          DateTableTraits::create (i, f, this));

        if (!this->dateTable_)
        {
          this->dateTable_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  MinSimpleRuleComplexType* MinSimpleRuleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MinSimpleRuleComplexType (*this, f, c);
  }

  MinSimpleRuleComplexType::
  ~MinSimpleRuleComplexType ()
  {
  }

  // StorageCharacteristicsComplexType
  //

  StorageCharacteristicsComplexType::
  StorageCharacteristicsComplexType ()
  : ::xml_schema::Type (),
    storageTable_ (::xml_schema::Flags (), this),
    storageEquation_ (::xml_schema::Flags (), this),
    maximumLevel_ (::xml_schema::Flags (), this)
  {
  }

  StorageCharacteristicsComplexType::
  StorageCharacteristicsComplexType (const StorageCharacteristicsComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    storageTable_ (x.storageTable_, f, this),
    storageEquation_ (x.storageEquation_, f, this),
    maximumLevel_ (x.maximumLevel_, f, this)
  {
  }

  StorageCharacteristicsComplexType::
  StorageCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    storageTable_ (f, this),
    storageEquation_ (f, this),
    maximumLevel_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void StorageCharacteristicsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // storageTable
      //
      if (n.name () == "storageTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageTableType > r (
          StorageTableTraits::create (i, f, this));

        if (!this->storageTable_)
        {
          this->storageTable_.set (r);
          continue;
        }
      }

      // storageEquation
      //
      if (n.name () == "storageEquation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageEquationType > r (
          StorageEquationTraits::create (i, f, this));

        if (!this->storageEquation_)
        {
          this->storageEquation_.set (r);
          continue;
        }
      }

      // maximumLevel
      //
      if (n.name () == "maximumLevel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->maximumLevel_)
        {
          this->maximumLevel_.set (MaximumLevelTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  StorageCharacteristicsComplexType* StorageCharacteristicsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StorageCharacteristicsComplexType (*this, f, c);
  }

  StorageCharacteristicsComplexType::
  ~StorageCharacteristicsComplexType ()
  {
  }

  // CapacityCharacteristicsComplexType
  //

  CapacityCharacteristicsComplexType::
  CapacityCharacteristicsComplexType ()
  : ::xml_schema::Type (),
    capacityTable_ (::xml_schema::Flags (), this),
    capacityEquation_ (::xml_schema::Flags (), this),
    reference_ (::xml_schema::Flags (), this)
  {
  }

  CapacityCharacteristicsComplexType::
  CapacityCharacteristicsComplexType (const CapacityCharacteristicsComplexType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    capacityTable_ (x.capacityTable_, f, this),
    capacityEquation_ (x.capacityEquation_, f, this),
    reference_ (x.reference_, f, this)
  {
  }

  CapacityCharacteristicsComplexType::
  CapacityCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    capacityTable_ (f, this),
    capacityEquation_ (f, this),
    reference_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void CapacityCharacteristicsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // capacityTable
      //
      if (n.name () == "capacityTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityTableType > r (
          CapacityTableTraits::create (i, f, this));

        if (!this->capacityTable_)
        {
          this->capacityTable_.set (r);
          continue;
        }
      }

      // capacityEquation
      //
      if (n.name () == "capacityEquation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityEquationType > r (
          CapacityEquationTraits::create (i, f, this));

        if (!this->capacityEquation_)
        {
          this->capacityEquation_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "reference" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ReferenceType > r (
          ReferenceTraits::create (i, f, this));

        this->reference_.set (r);
        continue;
      }
    }
  }

  CapacityCharacteristicsComplexType* CapacityCharacteristicsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CapacityCharacteristicsComplexType (*this, f, c);
  }

  CapacityCharacteristicsComplexType::
  ~CapacityCharacteristicsComplexType ()
  {
  }

  // TurbineCharacteristicsComplexType
  //

  TurbineCharacteristicsComplexType::
  TurbineCharacteristicsComplexType (const EfficiencyTableType& efficiencyTable,
                                     const OutputType& output)
  : ::xml_schema::Type (),
    efficiencyTable_ (efficiencyTable, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  TurbineCharacteristicsComplexType::
  TurbineCharacteristicsComplexType (::std::auto_ptr< EfficiencyTableType >& efficiencyTable,
                                     ::std::auto_ptr< OutputType >& output)
  : ::xml_schema::Type (),
    efficiencyTable_ (efficiencyTable, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  TurbineCharacteristicsComplexType::
  TurbineCharacteristicsComplexType (const TurbineCharacteristicsComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    efficiencyTable_ (x.efficiencyTable_, f, this),
    output_ (x.output_, f, this)
  {
  }

  TurbineCharacteristicsComplexType::
  TurbineCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    efficiencyTable_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineCharacteristicsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // efficiencyTable
      //
      if (n.name () == "efficiencyTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EfficiencyTableType > r (
          EfficiencyTableTraits::create (i, f, this));

        if (!efficiencyTable_.present ())
        {
          this->efficiencyTable_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!efficiencyTable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "efficiencyTable",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }
  }

  TurbineCharacteristicsComplexType* TurbineCharacteristicsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineCharacteristicsComplexType (*this, f, c);
  }

  TurbineCharacteristicsComplexType::
  ~TurbineCharacteristicsComplexType ()
  {
  }

  // TurbineOutputCharacteristicsComplexType
  //

  TurbineOutputCharacteristicsComplexType::
  TurbineOutputCharacteristicsComplexType (const PowerType& power)
  : ::xml_schema::Type (),
    power_ (power, ::xml_schema::Flags (), this)
  {
  }

  TurbineOutputCharacteristicsComplexType::
  TurbineOutputCharacteristicsComplexType (const TurbineOutputCharacteristicsComplexType& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    power_ (x.power_, f, this)
  {
  }

  TurbineOutputCharacteristicsComplexType::
  TurbineOutputCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    power_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineOutputCharacteristicsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // power
      //
      if (n.name () == "power" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PowerType > r (
          PowerTraits::create (i, f, this));

        if (!power_.present ())
        {
          this->power_.set (r);
          continue;
        }
      }

      break;
    }

    if (!power_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "power",
        "http://www.wldelft.nl/fews");
    }
  }

  TurbineOutputCharacteristicsComplexType* TurbineOutputCharacteristicsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineOutputCharacteristicsComplexType (*this, f, c);
  }

  TurbineOutputCharacteristicsComplexType::
  ~TurbineOutputCharacteristicsComplexType ()
  {
  }

  // ElevationTableComplexType
  //

  ElevationTableComplexType::
  ElevationTableComplexType ()
  : ::xml_schema::Type (),
    elevationRecord_ (::xml_schema::Flags (), this)
  {
  }

  ElevationTableComplexType::
  ElevationTableComplexType (const ElevationTableComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    elevationRecord_ (x.elevationRecord_, f, this)
  {
  }

  ElevationTableComplexType::
  ElevationTableComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    elevationRecord_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ElevationTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // elevationRecord
      //
      if (n.name () == "elevationRecord" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ElevationRecordType > r (
          ElevationRecordTraits::create (i, f, this));

        this->elevationRecord_.push_back (r);
        continue;
      }

      break;
    }
  }

  ElevationTableComplexType* ElevationTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ElevationTableComplexType (*this, f, c);
  }

  ElevationTableComplexType::
  ~ElevationTableComplexType ()
  {
  }

  // TailwaterComplexType
  //

  TailwaterComplexType::
  TailwaterComplexType (const OutputType& output)
  : ::xml_schema::Type (),
    constant_ (::xml_schema::Flags (), this),
    ratingCurve_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  TailwaterComplexType::
  TailwaterComplexType (::std::auto_ptr< OutputType >& output)
  : ::xml_schema::Type (),
    constant_ (::xml_schema::Flags (), this),
    ratingCurve_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  TailwaterComplexType::
  TailwaterComplexType (const TailwaterComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    constant_ (x.constant_, f, this),
    ratingCurve_ (x.ratingCurve_, f, this),
    output_ (x.output_, f, this)
  {
  }

  TailwaterComplexType::
  TailwaterComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    constant_ (f, this),
    ratingCurve_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TailwaterComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->constant_)
        {
          this->constant_.set (ConstantTraits::create (i, f, this));
          continue;
        }
      }

      // ratingCurve
      //
      if (n.name () == "ratingCurve" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RatingCurveType > r (
          RatingCurveTraits::create (i, f, this));

        if (!this->ratingCurve_)
        {
          this->ratingCurve_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }
  }

  TailwaterComplexType* TailwaterComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TailwaterComplexType (*this, f, c);
  }

  TailwaterComplexType::
  ~TailwaterComplexType ()
  {
  }

  // TailwaterOutputComplexType
  //

  TailwaterOutputComplexType::
  TailwaterOutputComplexType (const LevelType& level,
                              const HeadType& head)
  : ::xml_schema::Type (),
    level_ (level, ::xml_schema::Flags (), this),
    head_ (head, ::xml_schema::Flags (), this)
  {
  }

  TailwaterOutputComplexType::
  TailwaterOutputComplexType (const TailwaterOutputComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    level_ (x.level_, f, this),
    head_ (x.head_, f, this)
  {
  }

  TailwaterOutputComplexType::
  TailwaterOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    level_ (f, this),
    head_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TailwaterOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // level
      //
      if (n.name () == "level" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelType > r (
          LevelTraits::create (i, f, this));

        if (!level_.present ())
        {
          this->level_.set (r);
          continue;
        }
      }

      // head
      //
      if (n.name () == "head" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HeadType > r (
          HeadTraits::create (i, f, this));

        if (!head_.present ())
        {
          this->head_.set (r);
          continue;
        }
      }

      break;
    }

    if (!level_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "level",
        "http://www.wldelft.nl/fews");
    }

    if (!head_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "head",
        "http://www.wldelft.nl/fews");
    }
  }

  TailwaterOutputComplexType* TailwaterOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TailwaterOutputComplexType (*this, f, c);
  }

  TailwaterOutputComplexType::
  ~TailwaterOutputComplexType ()
  {
  }

  // ElevationRecordComplexType
  //

  ElevationRecordComplexType::
  ElevationRecordComplexType (const ElevationType& elevation,
                              const ValueType& value)
  : ::xml_schema::Type (),
    elevation_ (elevation, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  ElevationRecordComplexType::
  ElevationRecordComplexType (const ElevationRecordComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    elevation_ (x.elevation_, f, this),
    value_ (x.value_, f, this)
  {
  }

  ElevationRecordComplexType::
  ElevationRecordComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    elevation_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ElevationRecordComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "elevation" && n.namespace_ ().empty ())
      {
        this->elevation_.set (ElevationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }

    if (!elevation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "elevation",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  ElevationRecordComplexType* ElevationRecordComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ElevationRecordComplexType (*this, f, c);
  }

  ElevationRecordComplexType::
  ~ElevationRecordComplexType ()
  {
  }

  // ControlledOutletComplexType
  //

  ControlledOutletComplexType::
  ControlledOutletComplexType (const CapacityCharacteristicsType& capacityCharacteristics,
                               const InputType& input,
                               const OutputType& output,
                               const IdType& id)
  : ::xml_schema::Type (),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    turbineCharacteristics_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ControlledOutletComplexType::
  ControlledOutletComplexType (::std::auto_ptr< CapacityCharacteristicsType >& capacityCharacteristics,
                               ::std::auto_ptr< InputType >& input,
                               ::std::auto_ptr< OutputType >& output,
                               const IdType& id)
  : ::xml_schema::Type (),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    turbineCharacteristics_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ControlledOutletComplexType::
  ControlledOutletComplexType (const ControlledOutletComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    capacityCharacteristics_ (x.capacityCharacteristics_, f, this),
    turbineCharacteristics_ (x.turbineCharacteristics_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ControlledOutletComplexType::
  ControlledOutletComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    capacityCharacteristics_ (f, this),
    turbineCharacteristics_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ControlledOutletComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // capacityCharacteristics
      //
      if (n.name () == "capacityCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityCharacteristicsType > r (
          CapacityCharacteristicsTraits::create (i, f, this));

        if (!capacityCharacteristics_.present ())
        {
          this->capacityCharacteristics_.set (r);
          continue;
        }
      }

      // turbineCharacteristics
      //
      if (n.name () == "turbineCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TurbineCharacteristicsType > r (
          TurbineCharacteristicsTraits::create (i, f, this));

        if (!this->turbineCharacteristics_)
        {
          this->turbineCharacteristics_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!capacityCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "capacityCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ControlledOutletComplexType* ControlledOutletComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ControlledOutletComplexType (*this, f, c);
  }

  ControlledOutletComplexType::
  ~ControlledOutletComplexType ()
  {
  }

  // UncontrolledOutletComplexType
  //

  UncontrolledOutletComplexType::
  UncontrolledOutletComplexType (const CapacityCharacteristicsType& capacityCharacteristics,
                                 const OutputType& output,
                                 const IdType& id)
  : ::xml_schema::Type (),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  UncontrolledOutletComplexType::
  UncontrolledOutletComplexType (::std::auto_ptr< CapacityCharacteristicsType >& capacityCharacteristics,
                                 ::std::auto_ptr< OutputType >& output,
                                 const IdType& id)
  : ::xml_schema::Type (),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  UncontrolledOutletComplexType::
  UncontrolledOutletComplexType (const UncontrolledOutletComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    capacityCharacteristics_ (x.capacityCharacteristics_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  UncontrolledOutletComplexType::
  UncontrolledOutletComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    capacityCharacteristics_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void UncontrolledOutletComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // capacityCharacteristics
      //
      if (n.name () == "capacityCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityCharacteristicsType > r (
          CapacityCharacteristicsTraits::create (i, f, this));

        if (!capacityCharacteristics_.present ())
        {
          this->capacityCharacteristics_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!this->input_)
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!capacityCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "capacityCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  UncontrolledOutletComplexType* UncontrolledOutletComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UncontrolledOutletComplexType (*this, f, c);
  }

  UncontrolledOutletComplexType::
  ~UncontrolledOutletComplexType ()
  {
  }

  // UOutletInputComplexType
  //

  UOutletInputComplexType::
  UOutletInputComplexType (const ReleaseType& release)
  : ::xml_schema::Type (),
    release_ (release, ::xml_schema::Flags (), this)
  {
  }

  UOutletInputComplexType::
  UOutletInputComplexType (const UOutletInputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    release_ (x.release_, f, this)
  {
  }

  UOutletInputComplexType::
  UOutletInputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    release_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void UOutletInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // release
      //
      if (n.name () == "release" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseType > r (
          ReleaseTraits::create (i, f, this));

        if (!release_.present ())
        {
          this->release_.set (r);
          continue;
        }
      }

      break;
    }

    if (!release_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "release",
        "http://www.wldelft.nl/fews");
    }
  }

  UOutletInputComplexType* UOutletInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UOutletInputComplexType (*this, f, c);
  }

  UOutletInputComplexType::
  ~UOutletInputComplexType ()
  {
  }

  // EquationsComplexType
  //

  EquationsComplexType::
  EquationsComplexType ()
  : ::xml_schema::Type (),
    equation_ (::xml_schema::Flags (), this)
  {
  }

  EquationsComplexType::
  EquationsComplexType (const EquationsComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    equation_ (x.equation_, f, this)
  {
  }

  EquationsComplexType::
  EquationsComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    equation_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void EquationsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // equation
      //
      if (n.name () == "equation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EquationType > r (
          EquationTraits::create (i, f, this));

        this->equation_.push_back (r);
        continue;
      }

      break;
    }
  }

  EquationsComplexType* EquationsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EquationsComplexType (*this, f, c);
  }

  EquationsComplexType::
  ~EquationsComplexType ()
  {
  }

  // EquationComplexType
  //

  EquationComplexType::
  EquationComplexType (const AType& a,
                       const BType& b,
                       const CType& c)
  : ::xml_schema::Type (),
    lowerLevel_ (::xml_schema::Flags (), this),
    upperLevel_ (::xml_schema::Flags (), this),
    a_ (a, ::xml_schema::Flags (), this),
    b_ (b, ::xml_schema::Flags (), this),
    c_ (c, ::xml_schema::Flags (), this)
  {
  }

  EquationComplexType::
  EquationComplexType (const EquationComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lowerLevel_ (x.lowerLevel_, f, this),
    upperLevel_ (x.upperLevel_, f, this),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this),
    c_ (x.c_, f, this)
  {
  }

  EquationComplexType::
  EquationComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lowerLevel_ (f, this),
    upperLevel_ (f, this),
    a_ (f, this),
    b_ (f, this),
    c_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void EquationComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lowerLevel
      //
      if (n.name () == "lowerLevel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->lowerLevel_)
        {
          this->lowerLevel_.set (LowerLevelTraits::create (i, f, this));
          continue;
        }
      }

      // upperLevel
      //
      if (n.name () == "upperLevel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->upperLevel_)
        {
          this->upperLevel_.set (UpperLevelTraits::create (i, f, this));
          continue;
        }
      }

      // a
      //
      if (n.name () == "a" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AType > r (
          ATraits::create (i, f, this));

        if (!a_.present ())
        {
          this->a_.set (r);
          continue;
        }
      }

      // b
      //
      if (n.name () == "b" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BType > r (
          BTraits::create (i, f, this));

        if (!b_.present ())
        {
          this->b_.set (r);
          continue;
        }
      }

      // c
      //
      if (n.name () == "c" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CType > r (
          CTraits::create (i, f, this));

        if (!c_.present ())
        {
          this->c_.set (r);
          continue;
        }
      }

      break;
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a",
        "http://www.wldelft.nl/fews");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "b",
        "http://www.wldelft.nl/fews");
    }

    if (!c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "c",
        "http://www.wldelft.nl/fews");
    }
  }

  EquationComplexType* EquationComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EquationComplexType (*this, f, c);
  }

  EquationComplexType::
  ~EquationComplexType ()
  {
  }

  // ZonesComplexType
  //

  ZonesComplexType::
  ZonesComplexType ()
  : ::xml_schema::Type (),
    zone_ (::xml_schema::Flags (), this)
  {
  }

  ZonesComplexType::
  ZonesComplexType (const ZonesComplexType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    zone_ (x.zone_, f, this)
  {
  }

  ZonesComplexType::
  ZonesComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    zone_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ZonesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // zone
      //
      if (n.name () == "zone" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ZoneType > r (
          ZoneTraits::create (i, f, this));

        this->zone_.push_back (r);
        continue;
      }

      break;
    }
  }

  ZonesComplexType* ZonesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ZonesComplexType (*this, f, c);
  }

  ZonesComplexType::
  ~ZonesComplexType ()
  {
  }

  // ZoneComplexType
  //

  ZoneComplexType::
  ZoneComplexType (const DateTableType& dateTable)
  : ::xml_schema::Type (),
    dateTable_ (dateTable, ::xml_schema::Flags (), this),
    min_ (::xml_schema::Flags (), this),
    max_ (::xml_schema::Flags (), this)
  {
  }

  ZoneComplexType::
  ZoneComplexType (::std::auto_ptr< DateTableType >& dateTable)
  : ::xml_schema::Type (),
    dateTable_ (dateTable, ::xml_schema::Flags (), this),
    min_ (::xml_schema::Flags (), this),
    max_ (::xml_schema::Flags (), this)
  {
  }

  ZoneComplexType::
  ZoneComplexType (const ZoneComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dateTable_ (x.dateTable_, f, this),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this)
  {
  }

  ZoneComplexType::
  ZoneComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dateTable_ (f, this),
    min_ (f, this),
    max_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ZoneComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dateTable
      //
      if (n.name () == "dateTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DateTableType > r (
          DateTableTraits::create (i, f, this));

        if (!dateTable_.present ())
        {
          this->dateTable_.set (r);
          continue;
        }
      }

      break;
    }

    if (!dateTable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dateTable",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MinType > r (
          MinTraits::create (i, f, this));

        this->min_.set (r);
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MaxType > r (
          MaxTraits::create (i, f, this));

        this->max_.set (r);
        continue;
      }
    }
  }

  ZoneComplexType* ZoneComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ZoneComplexType (*this, f, c);
  }

  ZoneComplexType::
  ~ZoneComplexType ()
  {
  }

  // DateTableComplexType
  //

  DateTableComplexType::
  DateTableComplexType ()
  : ::xml_schema::Type (),
    data_ (::xml_schema::Flags (), this)
  {
  }

  DateTableComplexType::
  DateTableComplexType (const DateTableComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    data_ (x.data_, f, this)
  {
  }

  DateTableComplexType::
  DateTableComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    data_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DateTableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // data
      //
      if (n.name () == "data" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DataType > r (
          DataTraits::create (i, f, this));

        this->data_.push_back (r);
        continue;
      }

      break;
    }
  }

  DateTableComplexType* DateTableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateTableComplexType (*this, f, c);
  }

  DateTableComplexType::
  ~DateTableComplexType ()
  {
  }

  // DateRecordComplexType
  //

  DateRecordComplexType::
  DateRecordComplexType (const ValueType& value)
  : ::xml_schema::Type (),
    monthDay_ (::xml_schema::Flags (), this),
    dateTime_ (::xml_schema::Flags (), this),
    time_ (::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this),
    comment_ (::xml_schema::Flags (), this)
  {
  }

  DateRecordComplexType::
  DateRecordComplexType (const DateRecordComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    monthDay_ (x.monthDay_, f, this),
    dateTime_ (x.dateTime_, f, this),
    time_ (x.time_, f, this),
    value_ (x.value_, f, this),
    comment_ (x.comment_, f, this)
  {
  }

  DateRecordComplexType::
  DateRecordComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    monthDay_ (f, this),
    dateTime_ (f, this),
    time_ (f, this),
    value_ (f, this),
    comment_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void DateRecordComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "monthDay" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MonthDayType > r (
          MonthDayTraits::create (i, f, this));

        this->monthDay_.set (r);
        continue;
      }

      if (n.name () == "dateTime" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DateTimeType > r (
          DateTimeTraits::create (i, f, this));

        this->dateTime_.set (r);
        continue;
      }

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TimeType > r (
          TimeTraits::create (i, f, this));

        this->time_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "comment" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CommentType > r (
          CommentTraits::create (i, f, this));

        this->comment_.set (r);
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  DateRecordComplexType* DateRecordComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateRecordComplexType (*this, f, c);
  }

  DateRecordComplexType::
  ~DateRecordComplexType ()
  {
  }

  // ReservoirInputComplexType
  //

  ReservoirInputComplexType::
  ReservoirInputComplexType ()
  : ::xml_schema::Type (),
    inflow_ (::xml_schema::Flags (), this),
    level_ (::xml_schema::Flags (), this),
    precipitation_ (::xml_schema::Flags (), this),
    evaporation_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirInputComplexType::
  ReservoirInputComplexType (const ReservoirInputComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    inflow_ (x.inflow_, f, this),
    level_ (x.level_, f, this),
    precipitation_ (x.precipitation_, f, this),
    evaporation_ (x.evaporation_, f, this)
  {
  }

  ReservoirInputComplexType::
  ReservoirInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    inflow_ (f, this),
    level_ (f, this),
    precipitation_ (f, this),
    evaporation_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inflow
      //
      if (n.name () == "inflow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InflowType > r (
          InflowTraits::create (i, f, this));

        this->inflow_.push_back (r);
        continue;
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelType > r (
          LevelTraits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (r);
          continue;
        }
      }

      // precipitation
      //
      if (n.name () == "precipitation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PrecipitationType > r (
          PrecipitationTraits::create (i, f, this));

        if (!this->precipitation_)
        {
          this->precipitation_.set (r);
          continue;
        }
      }

      // evaporation
      //
      if (n.name () == "evaporation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EvaporationType > r (
          EvaporationTraits::create (i, f, this));

        if (!this->evaporation_)
        {
          this->evaporation_.set (r);
          continue;
        }
      }

      break;
    }
  }

  ReservoirInputComplexType* ReservoirInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirInputComplexType (*this, f, c);
  }

  ReservoirInputComplexType::
  ~ReservoirInputComplexType ()
  {
  }

  // ReservoirOutputComplexType
  //

  ReservoirOutputComplexType::
  ReservoirOutputComplexType (const InflowType& inflow,
                              const ReleaseType& release,
                              const StorageType& storage,
                              const LevelType& level)
  : ::xml_schema::Type (),
    inflow_ (inflow, ::xml_schema::Flags (), this),
    release_ (release, ::xml_schema::Flags (), this),
    storage_ (storage, ::xml_schema::Flags (), this),
    relativeStorage_ (::xml_schema::Flags (), this),
    level_ (level, ::xml_schema::Flags (), this),
    error_ (::xml_schema::Flags (), this),
    residuum_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirOutputComplexType::
  ReservoirOutputComplexType (const ReservoirOutputComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    inflow_ (x.inflow_, f, this),
    release_ (x.release_, f, this),
    storage_ (x.storage_, f, this),
    relativeStorage_ (x.relativeStorage_, f, this),
    level_ (x.level_, f, this),
    error_ (x.error_, f, this),
    residuum_ (x.residuum_, f, this)
  {
  }

  ReservoirOutputComplexType::
  ReservoirOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    inflow_ (f, this),
    release_ (f, this),
    storage_ (f, this),
    relativeStorage_ (f, this),
    level_ (f, this),
    error_ (f, this),
    residuum_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // inflow
      //
      if (n.name () == "inflow" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InflowType > r (
          InflowTraits::create (i, f, this));

        if (!inflow_.present ())
        {
          this->inflow_.set (r);
          continue;
        }
      }

      // release
      //
      if (n.name () == "release" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseType > r (
          ReleaseTraits::create (i, f, this));

        if (!release_.present ())
        {
          this->release_.set (r);
          continue;
        }
      }

      // storage
      //
      if (n.name () == "storage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageType > r (
          StorageTraits::create (i, f, this));

        if (!storage_.present ())
        {
          this->storage_.set (r);
          continue;
        }
      }

      // relativeStorage
      //
      if (n.name () == "relativeStorage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RelativeStorageType > r (
          RelativeStorageTraits::create (i, f, this));

        if (!this->relativeStorage_)
        {
          this->relativeStorage_.set (r);
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LevelType > r (
          LevelTraits::create (i, f, this));

        if (!level_.present ())
        {
          this->level_.set (r);
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!this->error_)
        {
          this->error_.set (r);
          continue;
        }
      }

      // residuum
      //
      if (n.name () == "residuum" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ResiduumType > r (
          ResiduumTraits::create (i, f, this));

        if (!this->residuum_)
        {
          this->residuum_.set (r);
          continue;
        }
      }

      break;
    }

    if (!inflow_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "inflow",
        "http://www.wldelft.nl/fews");
    }

    if (!release_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "release",
        "http://www.wldelft.nl/fews");
    }

    if (!storage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storage",
        "http://www.wldelft.nl/fews");
    }

    if (!level_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "level",
        "http://www.wldelft.nl/fews");
    }
  }

  ReservoirOutputComplexType* ReservoirOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirOutputComplexType (*this, f, c);
  }

  ReservoirOutputComplexType::
  ~ReservoirOutputComplexType ()
  {
  }

  // ReservoirGradientComplexType
  //

  ReservoirGradientComplexType::
  ReservoirGradientComplexType (const LambdaType& lambda)
  : ::xml_schema::Type (),
    lambda_ (lambda, ::xml_schema::Flags (), this),
    lambdaDown_ (::xml_schema::Flags (), this)
  {
  }

  ReservoirGradientComplexType::
  ReservoirGradientComplexType (const ReservoirGradientComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lambda_ (x.lambda_, f, this),
    lambdaDown_ (x.lambdaDown_, f, this)
  {
  }

  ReservoirGradientComplexType::
  ReservoirGradientComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lambda_ (f, this),
    lambdaDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReservoirGradientComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lambda
      //
      if (n.name () == "lambda" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LambdaType > r (
          LambdaTraits::create (i, f, this));

        if (!lambda_.present ())
        {
          this->lambda_.set (r);
          continue;
        }
      }

      // lambdaDown
      //
      if (n.name () == "lambdaDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LambdaDownType > r (
          LambdaDownTraits::create (i, f, this));

        if (!this->lambdaDown_)
        {
          this->lambdaDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!lambda_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lambda",
        "http://www.wldelft.nl/fews");
    }
  }

  ReservoirGradientComplexType* ReservoirGradientComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReservoirGradientComplexType (*this, f, c);
  }

  ReservoirGradientComplexType::
  ~ReservoirGradientComplexType ()
  {
  }

  // NodeGradientComplexType
  //

  NodeGradientComplexType::
  NodeGradientComplexType (const LambdaType& lambda,
                           const SurfaceAreaType& surfaceArea)
  : ::xml_schema::Type (),
    lambda_ (lambda, ::xml_schema::Flags (), this),
    surfaceArea_ (surfaceArea, ::xml_schema::Flags (), this)
  {
  }

  NodeGradientComplexType::
  NodeGradientComplexType (const NodeGradientComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lambda_ (x.lambda_, f, this),
    surfaceArea_ (x.surfaceArea_, f, this)
  {
  }

  NodeGradientComplexType::
  NodeGradientComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lambda_ (f, this),
    surfaceArea_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NodeGradientComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lambda
      //
      if (n.name () == "lambda" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LambdaType > r (
          LambdaTraits::create (i, f, this));

        if (!lambda_.present ())
        {
          this->lambda_.set (r);
          continue;
        }
      }

      // surfaceArea
      //
      if (n.name () == "surfaceArea" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SurfaceAreaType > r (
          SurfaceAreaTraits::create (i, f, this));

        if (!surfaceArea_.present ())
        {
          this->surfaceArea_.set (r);
          continue;
        }
      }

      break;
    }

    if (!lambda_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "lambda",
        "http://www.wldelft.nl/fews");
    }

    if (!surfaceArea_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surfaceArea",
        "http://www.wldelft.nl/fews");
    }
  }

  NodeGradientComplexType* NodeGradientComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NodeGradientComplexType (*this, f, c);
  }

  NodeGradientComplexType::
  ~NodeGradientComplexType ()
  {
  }

  // OutletInputComplexType
  //

  OutletInputComplexType::
  OutletInputComplexType ()
  : ::xml_schema::Type (),
    release_ (::xml_schema::Flags (), this),
    relativeRelease_ (::xml_schema::Flags (), this)
  {
  }

  OutletInputComplexType::
  OutletInputComplexType (const OutletInputComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    release_ (x.release_, f, this),
    relativeRelease_ (x.relativeRelease_, f, this)
  {
  }

  OutletInputComplexType::
  OutletInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    release_ (f, this),
    relativeRelease_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutletInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // release
      //
      if (n.name () == "release" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseType > r (
          ReleaseTraits::create (i, f, this));

        if (!this->release_)
        {
          this->release_.set (r);
          continue;
        }
      }

      // relativeRelease
      //
      if (n.name () == "relativeRelease" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RelativeReleaseType > r (
          RelativeReleaseTraits::create (i, f, this));

        this->relativeRelease_.push_back (r);
        continue;
      }

      break;
    }
  }

  OutletInputComplexType* OutletInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutletInputComplexType (*this, f, c);
  }

  OutletInputComplexType::
  ~OutletInputComplexType ()
  {
  }

  // OutletOutputComplexType
  //

  OutletOutputComplexType::
  OutletOutputComplexType (const ReleaseType& release)
  : ::xml_schema::Type (),
    release_ (release, ::xml_schema::Flags (), this)
  {
  }

  OutletOutputComplexType::
  OutletOutputComplexType (const OutletOutputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    release_ (x.release_, f, this)
  {
  }

  OutletOutputComplexType::
  OutletOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    release_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutletOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // release
      //
      if (n.name () == "release" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseType > r (
          ReleaseTraits::create (i, f, this));

        if (!release_.present ())
        {
          this->release_.set (r);
          continue;
        }
      }

      break;
    }

    if (!release_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "release",
        "http://www.wldelft.nl/fews");
    }
  }

  OutletOutputComplexType* OutletOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutletOutputComplexType (*this, f, c);
  }

  OutletOutputComplexType::
  ~OutletOutputComplexType ()
  {
  }

  // DeadBandTriggerComplexType
  //

  DeadBandTriggerComplexType::
  DeadBandTriggerComplexType (const ConditionOnType& conditionOn,
                              const ConditionOffType& conditionOff,
                              const OutputType& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    conditionOn_ (conditionOn, ::xml_schema::Flags (), this),
    conditionOff_ (conditionOff, ::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandTriggerComplexType::
  DeadBandTriggerComplexType (::std::auto_ptr< ConditionOnType >& conditionOn,
                              ::std::auto_ptr< ConditionOffType >& conditionOff,
                              ::std::auto_ptr< OutputType >& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    conditionOn_ (conditionOn, ::xml_schema::Flags (), this),
    conditionOff_ (conditionOff, ::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  DeadBandTriggerComplexType::
  DeadBandTriggerComplexType (const DeadBandTriggerComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    conditionOn_ (x.conditionOn_, f, this),
    conditionOff_ (x.conditionOff_, f, this),
    default__ (x.default__, f, this),
    true__ (x.true__, f, this),
    false__ (x.false__, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DeadBandTriggerComplexType::
  DeadBandTriggerComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    conditionOn_ (f, this),
    conditionOff_ (f, this),
    default__ (f, this),
    true__ (f, this),
    false__ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void DeadBandTriggerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // conditionOn
      //
      if (n.name () == "conditionOn" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConditionOnType > r (
          ConditionOnTraits::create (i, f, this));

        if (!conditionOn_.present ())
        {
          this->conditionOn_.set (r);
          continue;
        }
      }

      // conditionOff
      //
      if (n.name () == "conditionOff" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConditionOffType > r (
          ConditionOffTraits::create (i, f, this));

        if (!conditionOff_.present ())
        {
          this->conditionOff_.set (r);
          continue;
        }
      }

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->default__)
        {
          this->default__.set (DefaultTraits::create (i, f, this));
          continue;
        }
      }

      // true
      //
      if (n.name () == "true" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TrueType > r (
          TrueTraits::create (i, f, this));

        if (!this->true__)
        {
          this->true__.set (r);
          continue;
        }
      }

      // false
      //
      if (n.name () == "false" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FalseType > r (
          FalseTraits::create (i, f, this));

        if (!this->false__)
        {
          this->false__.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!conditionOn_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "conditionOn",
        "http://www.wldelft.nl/fews");
    }

    if (!conditionOff_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "conditionOff",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  DeadBandTriggerComplexType* DeadBandTriggerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeadBandTriggerComplexType (*this, f, c);
  }

  DeadBandTriggerComplexType::
  ~DeadBandTriggerComplexType ()
  {
  }

  // TriggerInputComplexType
  //

  TriggerInputComplexType::
  TriggerInputComplexType (const StatusType& status)
  : ::xml_schema::Type (),
    status_ (status, ::xml_schema::Flags (), this)
  {
  }

  TriggerInputComplexType::
  TriggerInputComplexType (const TriggerInputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    status_ (x.status_, f, this)
  {
  }

  TriggerInputComplexType::
  TriggerInputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    status_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TriggerInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // status
      //
      if (n.name () == "status" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StatusType > r (
          StatusTraits::create (i, f, this));

        if (!status_.present ())
        {
          this->status_.set (r);
          continue;
        }
      }

      break;
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "status",
        "http://www.wldelft.nl/fews");
    }
  }

  TriggerInputComplexType* TriggerInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriggerInputComplexType (*this, f, c);
  }

  TriggerInputComplexType::
  ~TriggerInputComplexType ()
  {
  }

  // TriggerOutputComplexType
  //

  TriggerOutputComplexType::
  TriggerOutputComplexType (const StatusType& status)
  : ::xml_schema::Type (),
    status_ (status, ::xml_schema::Flags (), this),
    timeTrue_ (::xml_schema::Flags (), this),
    timeFalse_ (::xml_schema::Flags (), this)
  {
  }

  TriggerOutputComplexType::
  TriggerOutputComplexType (const TriggerOutputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    status_ (x.status_, f, this),
    timeTrue_ (x.timeTrue_, f, this),
    timeFalse_ (x.timeFalse_, f, this)
  {
  }

  TriggerOutputComplexType::
  TriggerOutputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    status_ (f, this),
    timeTrue_ (f, this),
    timeFalse_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TriggerOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // status
      //
      if (n.name () == "status" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StatusType > r (
          StatusTraits::create (i, f, this));

        if (!status_.present ())
        {
          this->status_.set (r);
          continue;
        }
      }

      // timeTrue
      //
      if (n.name () == "timeTrue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeTrueType > r (
          TimeTrueTraits::create (i, f, this));

        if (!this->timeTrue_)
        {
          this->timeTrue_.set (r);
          continue;
        }
      }

      // timeFalse
      //
      if (n.name () == "timeFalse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeFalseType > r (
          TimeFalseTraits::create (i, f, this));

        if (!this->timeFalse_)
        {
          this->timeFalse_.set (r);
          continue;
        }
      }

      break;
    }

    if (!status_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "status",
        "http://www.wldelft.nl/fews");
    }
  }

  TriggerOutputComplexType* TriggerOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriggerOutputComplexType (*this, f, c);
  }

  TriggerOutputComplexType::
  ~TriggerOutputComplexType ()
  {
  }

  // StandardTriggerComplexType
  //

  StandardTriggerComplexType::
  StandardTriggerComplexType (const ConditionType& condition,
                              const OutputType& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    condition_ (condition, ::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  StandardTriggerComplexType::
  StandardTriggerComplexType (::std::auto_ptr< ConditionType >& condition,
                              ::std::auto_ptr< OutputType >& output,
                              const IdType& id)
  : ::xml_schema::Type (),
    condition_ (condition, ::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  StandardTriggerComplexType::
  StandardTriggerComplexType (const StandardTriggerComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    condition_ (x.condition_, f, this),
    default__ (x.default__, f, this),
    true__ (x.true__, f, this),
    false__ (x.false__, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  StandardTriggerComplexType::
  StandardTriggerComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    condition_ (f, this),
    default__ (f, this),
    true__ (f, this),
    false__ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void StandardTriggerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        if (!condition_.present ())
        {
          this->condition_.set (r);
          continue;
        }
      }

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->default__)
        {
          this->default__.set (DefaultTraits::create (i, f, this));
          continue;
        }
      }

      // true
      //
      if (n.name () == "true" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TrueType > r (
          TrueTraits::create (i, f, this));

        if (!this->true__)
        {
          this->true__.set (r);
          continue;
        }
      }

      // false
      //
      if (n.name () == "false" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FalseType > r (
          FalseTraits::create (i, f, this));

        if (!this->false__)
        {
          this->false__.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!condition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "condition",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  StandardTriggerComplexType* StandardTriggerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StandardTriggerComplexType (*this, f, c);
  }

  StandardTriggerComplexType::
  ~StandardTriggerComplexType ()
  {
  }

  // RelationalConditionComplexType
  //

  RelationalConditionComplexType::
  RelationalConditionComplexType (const RelationalOperatorType& relationalOperator)
  : ::xml_schema::Type (),
    x1Value_ (::xml_schema::Flags (), this),
    x1Series_ (::xml_schema::Flags (), this),
    relationalOperator_ (relationalOperator, ::xml_schema::Flags (), this),
    x2Value_ (::xml_schema::Flags (), this),
    x2Series_ (::xml_schema::Flags (), this)
  {
  }

  RelationalConditionComplexType::
  RelationalConditionComplexType (const RelationalConditionComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1Value_ (x.x1Value_, f, this),
    x1Series_ (x.x1Series_, f, this),
    relationalOperator_ (x.relationalOperator_, f, this),
    x2Value_ (x.x2Value_, f, this),
    x2Series_ (x.x2Series_, f, this)
  {
  }

  RelationalConditionComplexType::
  RelationalConditionComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1Value_ (f, this),
    x1Series_ (f, this),
    relationalOperator_ (f, this),
    x2Value_ (f, this),
    x2Series_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RelationalConditionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x1Value
      //
      if (n.name () == "x1Value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1ValueType > r (
          X1ValueTraits::create (i, f, this));

        if (!this->x1Value_)
        {
          this->x1Value_.set (r);
          continue;
        }
      }

      // x1Series
      //
      if (n.name () == "x1Series" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1SeriesType > r (
          X1SeriesTraits::create (i, f, this));

        if (!this->x1Series_)
        {
          this->x1Series_.set (r);
          continue;
        }
      }

      // relationalOperator
      //
      if (n.name () == "relationalOperator" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RelationalOperatorType > r (
          RelationalOperatorTraits::create (i, f, this));

        if (!relationalOperator_.present ())
        {
          this->relationalOperator_.set (r);
          continue;
        }
      }

      // x2Value
      //
      if (n.name () == "x2Value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2ValueType > r (
          X2ValueTraits::create (i, f, this));

        if (!this->x2Value_)
        {
          this->x2Value_.set (r);
          continue;
        }
      }

      // x2Series
      //
      if (n.name () == "x2Series" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2SeriesType > r (
          X2SeriesTraits::create (i, f, this));

        if (!this->x2Series_)
        {
          this->x2Series_.set (r);
          continue;
        }
      }

      break;
    }

    if (!relationalOperator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relationalOperator",
        "http://www.wldelft.nl/fews");
    }
  }

  RelationalConditionComplexType* RelationalConditionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RelationalConditionComplexType (*this, f, c);
  }

  RelationalConditionComplexType::
  ~RelationalConditionComplexType ()
  {
  }

  // SetTriggerComplexType
  //

  SetTriggerComplexType::
  SetTriggerComplexType (const LogicalOperatorType& logicalOperator,
                         const OutputType& output,
                         const IdType& id)
  : ::xml_schema::Type (),
    x1Value_ (::xml_schema::Flags (), this),
    x1Series_ (::xml_schema::Flags (), this),
    x1Trigger_ (::xml_schema::Flags (), this),
    logicalOperator_ (logicalOperator, ::xml_schema::Flags (), this),
    x2Value_ (::xml_schema::Flags (), this),
    x2Series_ (::xml_schema::Flags (), this),
    x2Trigger_ (::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SetTriggerComplexType::
  SetTriggerComplexType (const LogicalOperatorType& logicalOperator,
                         ::std::auto_ptr< OutputType >& output,
                         const IdType& id)
  : ::xml_schema::Type (),
    x1Value_ (::xml_schema::Flags (), this),
    x1Series_ (::xml_schema::Flags (), this),
    x1Trigger_ (::xml_schema::Flags (), this),
    logicalOperator_ (logicalOperator, ::xml_schema::Flags (), this),
    x2Value_ (::xml_schema::Flags (), this),
    x2Series_ (::xml_schema::Flags (), this),
    x2Trigger_ (::xml_schema::Flags (), this),
    default__ (::xml_schema::Flags (), this),
    true__ (::xml_schema::Flags (), this),
    false__ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  SetTriggerComplexType::
  SetTriggerComplexType (const SetTriggerComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x1Value_ (x.x1Value_, f, this),
    x1Series_ (x.x1Series_, f, this),
    x1Trigger_ (x.x1Trigger_, f, this),
    logicalOperator_ (x.logicalOperator_, f, this),
    x2Value_ (x.x2Value_, f, this),
    x2Series_ (x.x2Series_, f, this),
    x2Trigger_ (x.x2Trigger_, f, this),
    default__ (x.default__, f, this),
    true__ (x.true__, f, this),
    false__ (x.false__, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  SetTriggerComplexType::
  SetTriggerComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x1Value_ (f, this),
    x1Series_ (f, this),
    x1Trigger_ (f, this),
    logicalOperator_ (f, this),
    x2Value_ (f, this),
    x2Series_ (f, this),
    x2Trigger_ (f, this),
    default__ (f, this),
    true__ (f, this),
    false__ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void SetTriggerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x1Value
      //
      if (n.name () == "x1Value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->x1Value_)
        {
          this->x1Value_.set (X1ValueTraits::create (i, f, this));
          continue;
        }
      }

      // x1Series
      //
      if (n.name () == "x1Series" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1SeriesType > r (
          X1SeriesTraits::create (i, f, this));

        if (!this->x1Series_)
        {
          this->x1Series_.set (r);
          continue;
        }
      }

      // x1Trigger
      //
      if (n.name () == "x1Trigger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X1TriggerType > r (
          X1TriggerTraits::create (i, f, this));

        if (!this->x1Trigger_)
        {
          this->x1Trigger_.set (r);
          continue;
        }
      }

      // logicalOperator
      //
      if (n.name () == "logicalOperator" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LogicalOperatorType > r (
          LogicalOperatorTraits::create (i, f, this));

        if (!logicalOperator_.present ())
        {
          this->logicalOperator_.set (r);
          continue;
        }
      }

      // x2Value
      //
      if (n.name () == "x2Value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->x2Value_)
        {
          this->x2Value_.set (X2ValueTraits::create (i, f, this));
          continue;
        }
      }

      // x2Series
      //
      if (n.name () == "x2Series" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2SeriesType > r (
          X2SeriesTraits::create (i, f, this));

        if (!this->x2Series_)
        {
          this->x2Series_.set (r);
          continue;
        }
      }

      // x2Trigger
      //
      if (n.name () == "x2Trigger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< X2TriggerType > r (
          X2TriggerTraits::create (i, f, this));

        if (!this->x2Trigger_)
        {
          this->x2Trigger_.set (r);
          continue;
        }
      }

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->default__)
        {
          this->default__.set (DefaultTraits::create (i, f, this));
          continue;
        }
      }

      // true
      //
      if (n.name () == "true" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TrueType > r (
          TrueTraits::create (i, f, this));

        if (!this->true__)
        {
          this->true__.set (r);
          continue;
        }
      }

      // false
      //
      if (n.name () == "false" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FalseType > r (
          FalseTraits::create (i, f, this));

        if (!this->false__)
        {
          this->false__.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!logicalOperator_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "logicalOperator",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  SetTriggerComplexType* SetTriggerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetTriggerComplexType (*this, f, c);
  }

  SetTriggerComplexType::
  ~SetTriggerComplexType ()
  {
  }

  // RuleTriggerComplexType
  //

  RuleTriggerComplexType::
  RuleTriggerComplexType ()
  : ::xml_schema::Type (),
    trigger_ (::xml_schema::Flags (), this)
  {
  }

  RuleTriggerComplexType::
  RuleTriggerComplexType (const RuleTriggerComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    trigger_ (x.trigger_, f, this)
  {
  }

  RuleTriggerComplexType::
  RuleTriggerComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    trigger_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RuleTriggerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // trigger
      //
      if (n.name () == "trigger" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TriggerType > r (
          TriggerTraits::create (i, f, this));

        this->trigger_.push_back (r);
        continue;
      }

      break;
    }
  }

  RuleTriggerComplexType* RuleTriggerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RuleTriggerComplexType (*this, f, c);
  }

  RuleTriggerComplexType::
  ~RuleTriggerComplexType ()
  {
  }

  // ResultComplexType
  //

  ResultComplexType::
  ResultComplexType (const OutputType& output,
                     const ValueType& value)
  : ::xml_schema::Type (),
    output_ (output, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  ResultComplexType::
  ResultComplexType (const ResultComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    output_ (x.output_, f, this),
    value_ (x.value_, f, this)
  {
  }

  ResultComplexType::
  ResultComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    output_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ResultComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!value_.present ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.wldelft.nl/fews");
    }
  }

  ResultComplexType* ResultComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ResultComplexType (*this, f, c);
  }

  ResultComplexType::
  ~ResultComplexType ()
  {
  }

  // ConditionComplexType
  //

  ConditionComplexType::
  ConditionComplexType ()
  : ::xml_schema::Type (),
    lessThan_ (::xml_schema::Flags (), this),
    greaterThan_ (::xml_schema::Flags (), this)
  {
  }

  ConditionComplexType::
  ConditionComplexType (const ConditionComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lessThan_ (x.lessThan_, f, this),
    greaterThan_ (x.greaterThan_, f, this)
  {
  }

  ConditionComplexType::
  ConditionComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lessThan_ (f, this),
    greaterThan_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConditionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // lessThan
      //
      if (n.name () == "lessThan" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->lessThan_)
        {
          this->lessThan_.set (LessThanTraits::create (i, f, this));
          continue;
        }
      }

      // greaterThan
      //
      if (n.name () == "greaterThan" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->greaterThan_)
        {
          this->greaterThan_.set (GreaterThanTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  ConditionComplexType* ConditionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConditionComplexType (*this, f, c);
  }

  ConditionComplexType::
  ~ConditionComplexType ()
  {
  }

  // RuleStateTriggerComplexType
  //

  RuleStateTriggerComplexType::
  RuleStateTriggerComplexType (const RuleIdType& ruleId,
                               const IdType& id)
  : ::xml_schema::Type (),
    ruleId_ (ruleId, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  RuleStateTriggerComplexType::
  RuleStateTriggerComplexType (const RuleStateTriggerComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ruleId_ (x.ruleId_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  RuleStateTriggerComplexType::
  RuleStateTriggerComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ruleId_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RuleStateTriggerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ruleId
      //
      if (n.name () == "ruleId" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RuleIdType > r (
          RuleIdTraits::create (i, f, this));

        if (!ruleId_.present ())
        {
          this->ruleId_.set (r);
          continue;
        }
      }

      break;
    }

    if (!ruleId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ruleId",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  RuleStateTriggerComplexType* RuleStateTriggerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RuleStateTriggerComplexType (*this, f, c);
  }

  RuleStateTriggerComplexType::
  ~RuleStateTriggerComplexType ()
  {
  }

  // InflowComplexType
  //

  InflowComplexType::
  InflowComplexType ()
  : ::xml_schema::Type (),
    factor_ (::xml_schema::Flags (), this)
  {
  }

  InflowComplexType::
  InflowComplexType (const InflowComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    factor_ (x.factor_, f, this)
  {
  }

  InflowComplexType::
  InflowComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    factor_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void InflowComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factor" && n.namespace_ ().empty ())
      {
        this->factor_.set (FactorTraits::create (i, f, this));
        continue;
      }
    }
  }

  InflowComplexType* InflowComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InflowComplexType (*this, f, c);
  }

  InflowComplexType::
  ~InflowComplexType ()
  {
  }

  // NodeComplexType
  //

  NodeComplexType::
  NodeComplexType (const StorageCharacteristicsType& storageCharacteristics,
                   const OutputType& output,
                   const IdType& id)
  : ::xml_schema::Type (),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    x_ (::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  NodeComplexType::
  NodeComplexType (::std::auto_ptr< StorageCharacteristicsType >& storageCharacteristics,
                   ::std::auto_ptr< OutputType >& output,
                   const IdType& id)
  : ::xml_schema::Type (),
    storageCharacteristics_ (storageCharacteristics, ::xml_schema::Flags (), this),
    input_ (::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    x_ (::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  NodeComplexType::
  NodeComplexType (const NodeComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    storageCharacteristics_ (x.storageCharacteristics_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  NodeComplexType::
  NodeComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    storageCharacteristics_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void NodeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // storageCharacteristics
      //
      if (n.name () == "storageCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageCharacteristicsType > r (
          StorageCharacteristicsTraits::create (i, f, this));

        if (!storageCharacteristics_.present ())
        {
          this->storageCharacteristics_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!this->input_)
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!storageCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (XTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  NodeComplexType* NodeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NodeComplexType (*this, f, c);
  }

  NodeComplexType::
  ~NodeComplexType ()
  {
  }

  // NodeInputComplexType
  //

  NodeInputComplexType::
  NodeInputComplexType ()
  : ::xml_schema::Type (),
    HBC_ (::xml_schema::Flags (), this),
    HUpdate_ (::xml_schema::Flags (), this),
    QBC_ (::xml_schema::Flags (), this)
  {
  }

  NodeInputComplexType::
  NodeInputComplexType (const NodeInputComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HBC_ (x.HBC_, f, this),
    HUpdate_ (x.HUpdate_, f, this),
    QBC_ (x.QBC_, f, this)
  {
  }

  NodeInputComplexType::
  NodeInputComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HBC_ (f, this),
    HUpdate_ (f, this),
    QBC_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NodeInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HBC
      //
      if (n.name () == "HBC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HBCType > r (
          HBCTraits::create (i, f, this));

        if (!this->HBC_)
        {
          this->HBC_.set (r);
          continue;
        }
      }

      // HUpdate
      //
      if (n.name () == "HUpdate" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpdateType > r (
          HUpdateTraits::create (i, f, this));

        if (!this->HUpdate_)
        {
          this->HUpdate_.set (r);
          continue;
        }
      }

      // QBC
      //
      if (n.name () == "QBC" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QBCType > r (
          QBCTraits::create (i, f, this));

        this->QBC_.push_back (r);
        continue;
      }

      break;
    }
  }

  NodeInputComplexType* NodeInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NodeInputComplexType (*this, f, c);
  }

  NodeInputComplexType::
  ~NodeInputComplexType ()
  {
  }

  // NodeOutputComplexType
  //

  NodeOutputComplexType::
  NodeOutputComplexType (const HType& H,
                         const SType& S)
  : ::xml_schema::Type (),
    H_ (H, ::xml_schema::Flags (), this),
    S_ (S, ::xml_schema::Flags (), this),
    R_ (::xml_schema::Flags (), this)
  {
  }

  NodeOutputComplexType::
  NodeOutputComplexType (const NodeOutputComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    H_ (x.H_, f, this),
    S_ (x.S_, f, this),
    R_ (x.R_, f, this)
  {
  }

  NodeOutputComplexType::
  NodeOutputComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    H_ (f, this),
    S_ (f, this),
    R_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NodeOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // H
      //
      if (n.name () == "H" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HType > r (
          HTraits::create (i, f, this));

        if (!H_.present ())
        {
          this->H_.set (r);
          continue;
        }
      }

      // S
      //
      if (n.name () == "S" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SType > r (
          STraits::create (i, f, this));

        if (!S_.present ())
        {
          this->S_.set (r);
          continue;
        }
      }

      // R
      //
      if (n.name () == "R" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RType > r (
          RTraits::create (i, f, this));

        if (!this->R_)
        {
          this->R_.set (r);
          continue;
        }
      }

      break;
    }

    if (!H_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "H",
        "http://www.wldelft.nl/fews");
    }

    if (!S_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "S",
        "http://www.wldelft.nl/fews");
    }
  }

  NodeOutputComplexType* NodeOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NodeOutputComplexType (*this, f, c);
  }

  NodeOutputComplexType::
  ~NodeOutputComplexType ()
  {
  }

  // BranchComplexType
  //

  BranchComplexType::
  BranchComplexType (const CrossSectionType& crossSection,
                     const RoughnessType& roughness,
                     const LengthType& length,
                     const InputType& input,
                     const OutputType& output,
                     const IdType& id)
  : ::xml_schema::Type (),
    equationType_ (::xml_schema::Flags (), this),
    spatialScheme_ (::xml_schema::Flags (), this),
    crossSection_ (crossSection, ::xml_schema::Flags (), this),
    roughness_ (roughness, ::xml_schema::Flags (), this),
    length_ (length, ::xml_schema::Flags (), this),
    slope_ (::xml_schema::Flags (), this),
    alpha1_ (::xml_schema::Flags (), this),
    alpha2_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  BranchComplexType::
  BranchComplexType (::std::auto_ptr< CrossSectionType >& crossSection,
                     ::std::auto_ptr< RoughnessType >& roughness,
                     const LengthType& length,
                     ::std::auto_ptr< InputType >& input,
                     ::std::auto_ptr< OutputType >& output,
                     const IdType& id)
  : ::xml_schema::Type (),
    equationType_ (::xml_schema::Flags (), this),
    spatialScheme_ (::xml_schema::Flags (), this),
    crossSection_ (crossSection, ::xml_schema::Flags (), this),
    roughness_ (roughness, ::xml_schema::Flags (), this),
    length_ (length, ::xml_schema::Flags (), this),
    slope_ (::xml_schema::Flags (), this),
    alpha1_ (::xml_schema::Flags (), this),
    alpha2_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  BranchComplexType::
  BranchComplexType (const BranchComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    equationType_ (x.equationType_, f, this),
    spatialScheme_ (x.spatialScheme_, f, this),
    crossSection_ (x.crossSection_, f, this),
    roughness_ (x.roughness_, f, this),
    length_ (x.length_, f, this),
    slope_ (x.slope_, f, this),
    alpha1_ (x.alpha1_, f, this),
    alpha2_ (x.alpha2_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this)
  {
  }

  BranchComplexType::
  BranchComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    equationType_ (f, this),
    spatialScheme_ (f, this),
    crossSection_ (f, this),
    roughness_ (f, this),
    length_ (f, this),
    slope_ (f, this),
    alpha1_ (f, this),
    alpha2_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BranchComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // equationType
      //
      if (n.name () == "equationType" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EquationTypeType > r (
          EquationTypeTraits::create (i, f, this));

        if (!this->equationType_)
        {
          this->equationType_.set (r);
          continue;
        }
      }

      // spatialScheme
      //
      if (n.name () == "spatialScheme" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SpatialSchemeType > r (
          SpatialSchemeTraits::create (i, f, this));

        if (!this->spatialScheme_)
        {
          this->spatialScheme_.set (r);
          continue;
        }
      }

      // crossSection
      //
      if (n.name () == "crossSection" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CrossSectionType > r (
          CrossSectionTraits::create (i, f, this));

        if (!crossSection_.present ())
        {
          this->crossSection_.set (r);
          continue;
        }
      }

      // roughness
      //
      if (n.name () == "roughness" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RoughnessType > r (
          RoughnessTraits::create (i, f, this));

        if (!roughness_.present ())
        {
          this->roughness_.set (r);
          continue;
        }
      }

      // length
      //
      if (n.name () == "length" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!length_.present ())
        {
          this->length_.set (LengthTraits::create (i, f, this));
          continue;
        }
      }

      // slope
      //
      if (n.name () == "slope" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->slope_)
        {
          this->slope_.set (SlopeTraits::create (i, f, this));
          continue;
        }
      }

      // alpha1
      //
      if (n.name () == "alpha1" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->alpha1_)
        {
          this->alpha1_.set (Alpha1Traits::create (i, f, this));
          continue;
        }
      }

      // alpha2
      //
      if (n.name () == "alpha2" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->alpha2_)
        {
          this->alpha2_.set (Alpha2Traits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!crossSection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "crossSection",
        "http://www.wldelft.nl/fews");
    }

    if (!roughness_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "roughness",
        "http://www.wldelft.nl/fews");
    }

    if (!length_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "length",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  BranchComplexType* BranchComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BranchComplexType (*this, f, c);
  }

  BranchComplexType::
  ~BranchComplexType ()
  {
  }

  // CrossSectionComplexType
  //

  CrossSectionComplexType::
  CrossSectionComplexType (const CrossSectionTableType& crossSectionTable)
  : ::xml_schema::Type (),
    crossSectionTable_ (crossSectionTable, ::xml_schema::Flags (), this)
  {
  }

  CrossSectionComplexType::
  CrossSectionComplexType (::std::auto_ptr< CrossSectionTableType >& crossSectionTable)
  : ::xml_schema::Type (),
    crossSectionTable_ (crossSectionTable, ::xml_schema::Flags (), this)
  {
  }

  CrossSectionComplexType::
  CrossSectionComplexType (const CrossSectionComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    crossSectionTable_ (x.crossSectionTable_, f, this)
  {
  }

  CrossSectionComplexType::
  CrossSectionComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    crossSectionTable_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CrossSectionComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // crossSectionTable
      //
      if (n.name () == "crossSectionTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CrossSectionTableType > r (
          CrossSectionTableTraits::create (i, f, this));

        if (!crossSectionTable_.present ())
        {
          this->crossSectionTable_.set (r);
          continue;
        }
      }

      break;
    }

    if (!crossSectionTable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "crossSectionTable",
        "http://www.wldelft.nl/fews");
    }
  }

  CrossSectionComplexType* CrossSectionComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CrossSectionComplexType (*this, f, c);
  }

  CrossSectionComplexType::
  ~CrossSectionComplexType ()
  {
  }

  // CrossSectionRoughnessComplexType
  //

  CrossSectionRoughnessComplexType::
  CrossSectionRoughnessComplexType (const RoughnessTableType& roughnessTable)
  : ::xml_schema::Type (),
    roughnessTable_ (roughnessTable, ::xml_schema::Flags (), this)
  {
  }

  CrossSectionRoughnessComplexType::
  CrossSectionRoughnessComplexType (::std::auto_ptr< RoughnessTableType >& roughnessTable)
  : ::xml_schema::Type (),
    roughnessTable_ (roughnessTable, ::xml_schema::Flags (), this)
  {
  }

  CrossSectionRoughnessComplexType::
  CrossSectionRoughnessComplexType (const CrossSectionRoughnessComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    roughnessTable_ (x.roughnessTable_, f, this)
  {
  }

  CrossSectionRoughnessComplexType::
  CrossSectionRoughnessComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    roughnessTable_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CrossSectionRoughnessComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // roughnessTable
      //
      if (n.name () == "roughnessTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RoughnessTableType > r (
          RoughnessTableTraits::create (i, f, this));

        if (!roughnessTable_.present ())
        {
          this->roughnessTable_.set (r);
          continue;
        }
      }

      break;
    }

    if (!roughnessTable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "roughnessTable",
        "http://www.wldelft.nl/fews");
    }
  }

  CrossSectionRoughnessComplexType* CrossSectionRoughnessComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CrossSectionRoughnessComplexType (*this, f, c);
  }

  CrossSectionRoughnessComplexType::
  ~CrossSectionRoughnessComplexType ()
  {
  }

  // BranchInputComplexType
  //

  BranchInputComplexType::
  BranchInputComplexType (const HUpType& HUp,
                          const HDownType& HDown)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (HDown, ::xml_schema::Flags (), this),
    ux_ (::xml_schema::Flags (), this),
    uy_ (::xml_schema::Flags (), this)
  {
  }

  BranchInputComplexType::
  BranchInputComplexType (const BranchInputComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this),
    ux_ (x.ux_, f, this),
    uy_ (x.uy_, f, this)
  {
  }

  BranchInputComplexType::
  BranchInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this),
    ux_ (f, this),
    uy_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BranchInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!HDown_.present ())
        {
          this->HDown_.set (r);
          continue;
        }
      }

      // ux
      //
      if (n.name () == "ux" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UxType > r (
          UxTraits::create (i, f, this));

        if (!this->ux_)
        {
          this->ux_.set (r);
          continue;
        }
      }

      // uy
      //
      if (n.name () == "uy" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UyType > r (
          UyTraits::create (i, f, this));

        if (!this->uy_)
        {
          this->uy_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!HDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HDown",
        "http://www.wldelft.nl/fews");
    }
  }

  BranchInputComplexType* BranchInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BranchInputComplexType (*this, f, c);
  }

  BranchInputComplexType::
  ~BranchInputComplexType ()
  {
  }

  // BranchOutputComplexType
  //

  BranchOutputComplexType::
  BranchOutputComplexType (const QType& Q)
  : ::xml_schema::Type (),
    Q_ (Q, ::xml_schema::Flags (), this)
  {
  }

  BranchOutputComplexType::
  BranchOutputComplexType (const BranchOutputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Q_ (x.Q_, f, this)
  {
  }

  BranchOutputComplexType::
  BranchOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Q_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BranchOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  BranchOutputComplexType* BranchOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BranchOutputComplexType (*this, f, c);
  }

  BranchOutputComplexType::
  ~BranchOutputComplexType ()
  {
  }

  // HydraulicStructureComplexType
  //

  HydraulicStructureComplexType::
  HydraulicStructureComplexType (const IdType& id)
  : ::xml_schema::Type (),
    orifice_ (::xml_schema::Flags (), this),
    weir_ (::xml_schema::Flags (), this),
    pump_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  HydraulicStructureComplexType::
  HydraulicStructureComplexType (const HydraulicStructureComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    orifice_ (x.orifice_, f, this),
    weir_ (x.weir_, f, this),
    pump_ (x.pump_, f, this),
    id_ (x.id_, f, this)
  {
  }

  HydraulicStructureComplexType::
  HydraulicStructureComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    orifice_ (f, this),
    weir_ (f, this),
    pump_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void HydraulicStructureComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // orifice
      //
      if (n.name () == "orifice" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OrificeType > r (
          OrificeTraits::create (i, f, this));

        if (!this->orifice_)
        {
          this->orifice_.set (r);
          continue;
        }
      }

      // weir
      //
      if (n.name () == "weir" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeirType > r (
          WeirTraits::create (i, f, this));

        if (!this->weir_)
        {
          this->weir_.set (r);
          continue;
        }
      }

      // pump
      //
      if (n.name () == "pump" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PumpType > r (
          PumpTraits::create (i, f, this));

        if (!this->pump_)
        {
          this->pump_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  HydraulicStructureComplexType* HydraulicStructureComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraulicStructureComplexType (*this, f, c);
  }

  HydraulicStructureComplexType::
  ~HydraulicStructureComplexType ()
  {
  }

  // PumpComplexType
  //

  PumpComplexType::
  PumpComplexType (const InputType& input,
                   const OutputType& output)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  PumpComplexType::
  PumpComplexType (::std::auto_ptr< InputType >& input,
                   ::std::auto_ptr< OutputType >& output)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  PumpComplexType::
  PumpComplexType (const PumpComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this)
  {
  }

  PumpComplexType::
  PumpComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    input_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PumpComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }
  }

  PumpComplexType* PumpComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PumpComplexType (*this, f, c);
  }

  PumpComplexType::
  ~PumpComplexType ()
  {
  }

  // PumpInputComplexType
  //

  PumpInputComplexType::
  PumpInputComplexType (const HUpType& HUp,
                        const HDownType& HDown,
                        const QType& Q)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    HDown_ (HDown, ::xml_schema::Flags (), this),
    Q_ (Q, ::xml_schema::Flags (), this)
  {
  }

  PumpInputComplexType::
  PumpInputComplexType (const PumpInputComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    HDown_ (x.HDown_, f, this),
    Q_ (x.Q_, f, this)
  {
  }

  PumpInputComplexType::
  PumpInputComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    HDown_ (f, this),
    Q_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PumpInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!HDown_.present ())
        {
          this->HDown_.set (r);
          continue;
        }
      }

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!HDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HDown",
        "http://www.wldelft.nl/fews");
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  PumpInputComplexType* PumpInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PumpInputComplexType (*this, f, c);
  }

  PumpInputComplexType::
  ~PumpInputComplexType ()
  {
  }

  // PumpOutputComplexType
  //

  PumpOutputComplexType::
  PumpOutputComplexType (const QType& Q)
  : ::xml_schema::Type (),
    Q_ (Q, ::xml_schema::Flags (), this)
  {
  }

  PumpOutputComplexType::
  PumpOutputComplexType (const PumpOutputComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Q_ (x.Q_, f, this)
  {
  }

  PumpOutputComplexType::
  PumpOutputComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Q_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PumpOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }
  }

  PumpOutputComplexType* PumpOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PumpOutputComplexType (*this, f, c);
  }

  PumpOutputComplexType::
  ~PumpOutputComplexType ()
  {
  }

  // PumpGradientComplexType
  //

  PumpGradientComplexType::
  PumpGradientComplexType (const StorageUpType& storageUp,
                           const StorageDownType& storageDown)
  : ::xml_schema::Type (),
    storageUp_ (storageUp, ::xml_schema::Flags (), this),
    storageDown_ (storageDown, ::xml_schema::Flags (), this)
  {
  }

  PumpGradientComplexType::
  PumpGradientComplexType (const PumpGradientComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    storageUp_ (x.storageUp_, f, this),
    storageDown_ (x.storageDown_, f, this)
  {
  }

  PumpGradientComplexType::
  PumpGradientComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    storageUp_ (f, this),
    storageDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PumpGradientComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // storageUp
      //
      if (n.name () == "storageUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageUpType > r (
          StorageUpTraits::create (i, f, this));

        if (!storageUp_.present ())
        {
          this->storageUp_.set (r);
          continue;
        }
      }

      // storageDown
      //
      if (n.name () == "storageDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageDownType > r (
          StorageDownTraits::create (i, f, this));

        if (!storageDown_.present ())
        {
          this->storageDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!storageUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageUp",
        "http://www.wldelft.nl/fews");
    }

    if (!storageDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageDown",
        "http://www.wldelft.nl/fews");
    }
  }

  PumpGradientComplexType* PumpGradientComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PumpGradientComplexType (*this, f, c);
  }

  PumpGradientComplexType::
  ~PumpGradientComplexType ()
  {
  }

  // TurbineComplexType
  //

  TurbineComplexType::
  TurbineComplexType (const NodeUpType& nodeUp,
                      const NodeDownType& nodeDown,
                      const CapacityCharacteristicsType& capacityCharacteristics,
                      const EfficiencyCharacteristicsType& efficiencyCharacteristics,
                      const InputType& input,
                      const OutputType& output)
  : ::xml_schema::Type (),
    nodeUp_ (nodeUp, ::xml_schema::Flags (), this),
    nodeDown_ (nodeDown, ::xml_schema::Flags (), this),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    efficiencyCharacteristics_ (efficiencyCharacteristics, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  TurbineComplexType::
  TurbineComplexType (const NodeUpType& nodeUp,
                      const NodeDownType& nodeDown,
                      ::std::auto_ptr< CapacityCharacteristicsType >& capacityCharacteristics,
                      ::std::auto_ptr< EfficiencyCharacteristicsType >& efficiencyCharacteristics,
                      ::std::auto_ptr< InputType >& input,
                      ::std::auto_ptr< OutputType >& output)
  : ::xml_schema::Type (),
    nodeUp_ (nodeUp, ::xml_schema::Flags (), this),
    nodeDown_ (nodeDown, ::xml_schema::Flags (), this),
    capacityCharacteristics_ (capacityCharacteristics, ::xml_schema::Flags (), this),
    efficiencyCharacteristics_ (efficiencyCharacteristics, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  TurbineComplexType::
  TurbineComplexType (const TurbineComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nodeUp_ (x.nodeUp_, f, this),
    nodeDown_ (x.nodeDown_, f, this),
    capacityCharacteristics_ (x.capacityCharacteristics_, f, this),
    efficiencyCharacteristics_ (x.efficiencyCharacteristics_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this)
  {
  }

  TurbineComplexType::
  TurbineComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nodeUp_ (f, this),
    nodeDown_ (f, this),
    capacityCharacteristics_ (f, this),
    efficiencyCharacteristics_ (f, this),
    input_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nodeUp
      //
      if (n.name () == "nodeUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeUpType > r (
          NodeUpTraits::create (i, f, this));

        if (!nodeUp_.present ())
        {
          this->nodeUp_.set (r);
          continue;
        }
      }

      // nodeDown
      //
      if (n.name () == "nodeDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NodeDownType > r (
          NodeDownTraits::create (i, f, this));

        if (!nodeDown_.present ())
        {
          this->nodeDown_.set (r);
          continue;
        }
      }

      // capacityCharacteristics
      //
      if (n.name () == "capacityCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityCharacteristicsType > r (
          CapacityCharacteristicsTraits::create (i, f, this));

        if (!capacityCharacteristics_.present ())
        {
          this->capacityCharacteristics_.set (r);
          continue;
        }
      }

      // efficiencyCharacteristics
      //
      if (n.name () == "efficiencyCharacteristics" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EfficiencyCharacteristicsType > r (
          EfficiencyCharacteristicsTraits::create (i, f, this));

        if (!efficiencyCharacteristics_.present ())
        {
          this->efficiencyCharacteristics_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!nodeUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeUp",
        "http://www.wldelft.nl/fews");
    }

    if (!nodeDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nodeDown",
        "http://www.wldelft.nl/fews");
    }

    if (!capacityCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "capacityCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!efficiencyCharacteristics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "efficiencyCharacteristics",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }
  }

  TurbineComplexType* TurbineComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineComplexType (*this, f, c);
  }

  TurbineComplexType::
  ~TurbineComplexType ()
  {
  }

  // TurbineCapacityCharacteristicsComplexType
  //

  TurbineCapacityCharacteristicsComplexType::
  TurbineCapacityCharacteristicsComplexType ()
  : ::xml_schema::Type (),
    capacityTable_ (::xml_schema::Flags (), this),
    capacityEquation_ (::xml_schema::Flags (), this)
  {
  }

  TurbineCapacityCharacteristicsComplexType::
  TurbineCapacityCharacteristicsComplexType (const TurbineCapacityCharacteristicsComplexType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    capacityTable_ (x.capacityTable_, f, this),
    capacityEquation_ (x.capacityEquation_, f, this)
  {
  }

  TurbineCapacityCharacteristicsComplexType::
  TurbineCapacityCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    capacityTable_ (f, this),
    capacityEquation_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineCapacityCharacteristicsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // capacityTable
      //
      if (n.name () == "capacityTable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityTableType > r (
          CapacityTableTraits::create (i, f, this));

        if (!this->capacityTable_)
        {
          this->capacityTable_.set (r);
          continue;
        }
      }

      // capacityEquation
      //
      if (n.name () == "capacityEquation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CapacityEquationType > r (
          CapacityEquationTraits::create (i, f, this));

        if (!this->capacityEquation_)
        {
          this->capacityEquation_.set (r);
          continue;
        }
      }

      break;
    }
  }

  TurbineCapacityCharacteristicsComplexType* TurbineCapacityCharacteristicsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineCapacityCharacteristicsComplexType (*this, f, c);
  }

  TurbineCapacityCharacteristicsComplexType::
  ~TurbineCapacityCharacteristicsComplexType ()
  {
  }

  // TurbineEfficiencyCharacteristicsComplexType
  //

  TurbineEfficiencyCharacteristicsComplexType::
  TurbineEfficiencyCharacteristicsComplexType (const EfficiencyConstantType& efficiencyConstant)
  : ::xml_schema::Type (),
    efficiencyConstant_ (efficiencyConstant, ::xml_schema::Flags (), this)
  {
  }

  TurbineEfficiencyCharacteristicsComplexType::
  TurbineEfficiencyCharacteristicsComplexType (const TurbineEfficiencyCharacteristicsComplexType& x,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    efficiencyConstant_ (x.efficiencyConstant_, f, this)
  {
  }

  TurbineEfficiencyCharacteristicsComplexType::
  TurbineEfficiencyCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    efficiencyConstant_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineEfficiencyCharacteristicsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // efficiencyConstant
      //
      if (n.name () == "efficiencyConstant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!efficiencyConstant_.present ())
        {
          this->efficiencyConstant_.set (EfficiencyConstantTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!efficiencyConstant_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "efficiencyConstant",
        "http://www.wldelft.nl/fews");
    }
  }

  TurbineEfficiencyCharacteristicsComplexType* TurbineEfficiencyCharacteristicsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineEfficiencyCharacteristicsComplexType (*this, f, c);
  }

  TurbineEfficiencyCharacteristicsComplexType::
  ~TurbineEfficiencyCharacteristicsComplexType ()
  {
  }

  // TurbineInputComplexType
  //

  TurbineInputComplexType::
  TurbineInputComplexType ()
  : ::xml_schema::Type (),
    release_ (::xml_schema::Flags (), this),
    relativeRelease_ (::xml_schema::Flags (), this)
  {
  }

  TurbineInputComplexType::
  TurbineInputComplexType (const TurbineInputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    release_ (x.release_, f, this),
    relativeRelease_ (x.relativeRelease_, f, this)
  {
  }

  TurbineInputComplexType::
  TurbineInputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    release_ (f, this),
    relativeRelease_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // release
      //
      if (n.name () == "release" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ReleaseType > r (
          ReleaseTraits::create (i, f, this));

        if (!this->release_)
        {
          this->release_.set (r);
          continue;
        }
      }

      // relativeRelease
      //
      if (n.name () == "relativeRelease" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RelativeReleaseType > r (
          RelativeReleaseTraits::create (i, f, this));

        if (!this->relativeRelease_)
        {
          this->relativeRelease_.set (r);
          continue;
        }
      }

      break;
    }
  }

  TurbineInputComplexType* TurbineInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineInputComplexType (*this, f, c);
  }

  TurbineInputComplexType::
  ~TurbineInputComplexType ()
  {
  }

  // TurbineOutputComplexType
  //

  TurbineOutputComplexType::
  TurbineOutputComplexType (const DischargeType& discharge,
                            const PowerProductionType& powerProduction)
  : ::xml_schema::Type (),
    discharge_ (discharge, ::xml_schema::Flags (), this),
    powerProduction_ (powerProduction, ::xml_schema::Flags (), this)
  {
  }

  TurbineOutputComplexType::
  TurbineOutputComplexType (const TurbineOutputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    discharge_ (x.discharge_, f, this),
    powerProduction_ (x.powerProduction_, f, this)
  {
  }

  TurbineOutputComplexType::
  TurbineOutputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    discharge_ (f, this),
    powerProduction_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TurbineOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // discharge
      //
      if (n.name () == "discharge" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DischargeType > r (
          DischargeTraits::create (i, f, this));

        if (!discharge_.present ())
        {
          this->discharge_.set (r);
          continue;
        }
      }

      // powerProduction
      //
      if (n.name () == "powerProduction" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PowerProductionType > r (
          PowerProductionTraits::create (i, f, this));

        if (!powerProduction_.present ())
        {
          this->powerProduction_.set (r);
          continue;
        }
      }

      break;
    }

    if (!discharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "discharge",
        "http://www.wldelft.nl/fews");
    }

    if (!powerProduction_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "powerProduction",
        "http://www.wldelft.nl/fews");
    }
  }

  TurbineOutputComplexType* TurbineOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TurbineOutputComplexType (*this, f, c);
  }

  TurbineOutputComplexType::
  ~TurbineOutputComplexType ()
  {
  }

  // OrificeComplexType
  //

  OrificeComplexType::
  OrificeComplexType (const WidthType& width,
                      const CrestLevelType& crestLevel,
                      const ContractionCoefficientType& contractionCoefficient,
                      const InputType& input,
                      const OutputType& output)
  : ::xml_schema::Type (),
    width_ (width, ::xml_schema::Flags (), this),
    crestLevel_ (crestLevel, ::xml_schema::Flags (), this),
    contractionCoefficient_ (contractionCoefficient, ::xml_schema::Flags (), this),
    exponentGateFormula_ (::xml_schema::Flags (), this),
    exponentWeirFormula_ (::xml_schema::Flags (), this),
    flowDirection_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  OrificeComplexType::
  OrificeComplexType (const WidthType& width,
                      const CrestLevelType& crestLevel,
                      const ContractionCoefficientType& contractionCoefficient,
                      ::std::auto_ptr< InputType >& input,
                      ::std::auto_ptr< OutputType >& output)
  : ::xml_schema::Type (),
    width_ (width, ::xml_schema::Flags (), this),
    crestLevel_ (crestLevel, ::xml_schema::Flags (), this),
    contractionCoefficient_ (contractionCoefficient, ::xml_schema::Flags (), this),
    exponentGateFormula_ (::xml_schema::Flags (), this),
    exponentWeirFormula_ (::xml_schema::Flags (), this),
    flowDirection_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  OrificeComplexType::
  OrificeComplexType (const OrificeComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    width_ (x.width_, f, this),
    crestLevel_ (x.crestLevel_, f, this),
    contractionCoefficient_ (x.contractionCoefficient_, f, this),
    exponentGateFormula_ (x.exponentGateFormula_, f, this),
    exponentWeirFormula_ (x.exponentWeirFormula_, f, this),
    flowDirection_ (x.flowDirection_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this)
  {
  }

  OrificeComplexType::
  OrificeComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    width_ (f, this),
    crestLevel_ (f, this),
    contractionCoefficient_ (f, this),
    exponentGateFormula_ (f, this),
    exponentWeirFormula_ (f, this),
    flowDirection_ (f, this),
    input_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OrificeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!width_.present ())
        {
          this->width_.set (WidthTraits::create (i, f, this));
          continue;
        }
      }

      // crestLevel
      //
      if (n.name () == "crestLevel" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!crestLevel_.present ())
        {
          this->crestLevel_.set (CrestLevelTraits::create (i, f, this));
          continue;
        }
      }

      // contractionCoefficient
      //
      if (n.name () == "contractionCoefficient" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!contractionCoefficient_.present ())
        {
          this->contractionCoefficient_.set (ContractionCoefficientTraits::create (i, f, this));
          continue;
        }
      }

      // exponentGateFormula
      //
      if (n.name () == "exponentGateFormula" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->exponentGateFormula_)
        {
          this->exponentGateFormula_.set (ExponentGateFormulaTraits::create (i, f, this));
          continue;
        }
      }

      // exponentWeirFormula
      //
      if (n.name () == "exponentWeirFormula" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->exponentWeirFormula_)
        {
          this->exponentWeirFormula_.set (ExponentWeirFormulaTraits::create (i, f, this));
          continue;
        }
      }

      // flowDirection
      //
      if (n.name () == "flowDirection" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlowDirectionType > r (
          FlowDirectionTraits::create (i, f, this));

        if (!this->flowDirection_)
        {
          this->flowDirection_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!width_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "width",
        "http://www.wldelft.nl/fews");
    }

    if (!crestLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "crestLevel",
        "http://www.wldelft.nl/fews");
    }

    if (!contractionCoefficient_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "contractionCoefficient",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }
  }

  OrificeComplexType* OrificeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OrificeComplexType (*this, f, c);
  }

  OrificeComplexType::
  ~OrificeComplexType ()
  {
  }

  // OrificeInputComplexType
  //

  OrificeInputComplexType::
  OrificeInputComplexType (const HUpType& HUp,
                           const HDownType& HDown)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    DeltaHUp_ (::xml_schema::Flags (), this),
    HDown_ (HDown, ::xml_schema::Flags (), this),
    DeltaHDown_ (::xml_schema::Flags (), this),
    DConst_ (::xml_schema::Flags (), this),
    DSeries_ (::xml_schema::Flags (), this),
    D_ (::xml_schema::Flags (), this)
  {
  }

  OrificeInputComplexType::
  OrificeInputComplexType (const OrificeInputComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    DeltaHUp_ (x.DeltaHUp_, f, this),
    HDown_ (x.HDown_, f, this),
    DeltaHDown_ (x.DeltaHDown_, f, this),
    DConst_ (x.DConst_, f, this),
    DSeries_ (x.DSeries_, f, this),
    D_ (x.D_, f, this)
  {
  }

  OrificeInputComplexType::
  OrificeInputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    DeltaHUp_ (f, this),
    HDown_ (f, this),
    DeltaHDown_ (f, this),
    DConst_ (f, this),
    DSeries_ (f, this),
    D_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OrificeInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // DeltaHUp
      //
      if (n.name () == "DeltaHUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeltaHUpType > r (
          DeltaHUpTraits::create (i, f, this));

        if (!this->DeltaHUp_)
        {
          this->DeltaHUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!HDown_.present ())
        {
          this->HDown_.set (r);
          continue;
        }
      }

      // DeltaHDown
      //
      if (n.name () == "DeltaHDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeltaHDownType > r (
          DeltaHDownTraits::create (i, f, this));

        if (!this->DeltaHDown_)
        {
          this->DeltaHDown_.set (r);
          continue;
        }
      }

      // DConst
      //
      if (n.name () == "DConst" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->DConst_)
        {
          this->DConst_.set (DConstTraits::create (i, f, this));
          continue;
        }
      }

      // DSeries
      //
      if (n.name () == "DSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DSeriesType > r (
          DSeriesTraits::create (i, f, this));

        if (!this->DSeries_)
        {
          this->DSeries_.set (r);
          continue;
        }
      }

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!this->D_)
        {
          this->D_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!HDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HDown",
        "http://www.wldelft.nl/fews");
    }
  }

  OrificeInputComplexType* OrificeInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OrificeInputComplexType (*this, f, c);
  }

  OrificeInputComplexType::
  ~OrificeInputComplexType ()
  {
  }

  // OrificeOutputComplexType
  //

  OrificeOutputComplexType::
  OrificeOutputComplexType (const QType& Q,
                            const DType& D)
  : ::xml_schema::Type (),
    Q_ (Q, ::xml_schema::Flags (), this),
    D_ (D, ::xml_schema::Flags (), this),
    flowType_ (::xml_schema::Flags (), this)
  {
  }

  OrificeOutputComplexType::
  OrificeOutputComplexType (const OrificeOutputComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Q_ (x.Q_, f, this),
    D_ (x.D_, f, this),
    flowType_ (x.flowType_, f, this)
  {
  }

  OrificeOutputComplexType::
  OrificeOutputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Q_ (f, this),
    D_ (f, this),
    flowType_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OrificeOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      // D
      //
      if (n.name () == "D" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DType > r (
          DTraits::create (i, f, this));

        if (!D_.present ())
        {
          this->D_.set (r);
          continue;
        }
      }

      // flowType
      //
      if (n.name () == "flowType" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlowTypeType > r (
          FlowTypeTraits::create (i, f, this));

        if (!this->flowType_)
        {
          this->flowType_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }

    if (!D_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "D",
        "http://www.wldelft.nl/fews");
    }
  }

  OrificeOutputComplexType* OrificeOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OrificeOutputComplexType (*this, f, c);
  }

  OrificeOutputComplexType::
  ~OrificeOutputComplexType ()
  {
  }

  // BranchGradientComplexType
  //

  BranchGradientComplexType::
  BranchGradientComplexType (const StorageUpType& storageUp,
                             const SurfaceAreaUpType& surfaceAreaUp,
                             const StorageDownType& storageDown,
                             const SurfaceAreaDownType& surfaceAreaDown)
  : ::xml_schema::Type (),
    storageUp_ (storageUp, ::xml_schema::Flags (), this),
    surfaceAreaUp_ (surfaceAreaUp, ::xml_schema::Flags (), this),
    storageDown_ (storageDown, ::xml_schema::Flags (), this),
    surfaceAreaDown_ (surfaceAreaDown, ::xml_schema::Flags (), this)
  {
  }

  BranchGradientComplexType::
  BranchGradientComplexType (const BranchGradientComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    storageUp_ (x.storageUp_, f, this),
    surfaceAreaUp_ (x.surfaceAreaUp_, f, this),
    storageDown_ (x.storageDown_, f, this),
    surfaceAreaDown_ (x.surfaceAreaDown_, f, this)
  {
  }

  BranchGradientComplexType::
  BranchGradientComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    storageUp_ (f, this),
    surfaceAreaUp_ (f, this),
    storageDown_ (f, this),
    surfaceAreaDown_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BranchGradientComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // storageUp
      //
      if (n.name () == "storageUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageUpType > r (
          StorageUpTraits::create (i, f, this));

        if (!storageUp_.present ())
        {
          this->storageUp_.set (r);
          continue;
        }
      }

      // surfaceAreaUp
      //
      if (n.name () == "surfaceAreaUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SurfaceAreaUpType > r (
          SurfaceAreaUpTraits::create (i, f, this));

        if (!surfaceAreaUp_.present ())
        {
          this->surfaceAreaUp_.set (r);
          continue;
        }
      }

      // storageDown
      //
      if (n.name () == "storageDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StorageDownType > r (
          StorageDownTraits::create (i, f, this));

        if (!storageDown_.present ())
        {
          this->storageDown_.set (r);
          continue;
        }
      }

      // surfaceAreaDown
      //
      if (n.name () == "surfaceAreaDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SurfaceAreaDownType > r (
          SurfaceAreaDownTraits::create (i, f, this));

        if (!surfaceAreaDown_.present ())
        {
          this->surfaceAreaDown_.set (r);
          continue;
        }
      }

      break;
    }

    if (!storageUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageUp",
        "http://www.wldelft.nl/fews");
    }

    if (!surfaceAreaUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surfaceAreaUp",
        "http://www.wldelft.nl/fews");
    }

    if (!storageDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "storageDown",
        "http://www.wldelft.nl/fews");
    }

    if (!surfaceAreaDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surfaceAreaDown",
        "http://www.wldelft.nl/fews");
    }
  }

  BranchGradientComplexType* BranchGradientComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BranchGradientComplexType (*this, f, c);
  }

  BranchGradientComplexType::
  ~BranchGradientComplexType ()
  {
  }

  // RiverWeirComplexType
  //

  RiverWeirComplexType::
  RiverWeirComplexType (const WidthType& width,
                        const InputType& input,
                        const OutputType& output)
  : ::xml_schema::Type (),
    width_ (width, ::xml_schema::Flags (), this),
    exponentWeirFormula_ (::xml_schema::Flags (), this),
    submergedFlowRatio_ (::xml_schema::Flags (), this),
    submergedFlowFactor_ (::xml_schema::Flags (), this),
    flowDirection_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  RiverWeirComplexType::
  RiverWeirComplexType (const WidthType& width,
                        ::std::auto_ptr< InputType >& input,
                        ::std::auto_ptr< OutputType >& output)
  : ::xml_schema::Type (),
    width_ (width, ::xml_schema::Flags (), this),
    exponentWeirFormula_ (::xml_schema::Flags (), this),
    submergedFlowRatio_ (::xml_schema::Flags (), this),
    submergedFlowFactor_ (::xml_schema::Flags (), this),
    flowDirection_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this)
  {
  }

  RiverWeirComplexType::
  RiverWeirComplexType (const RiverWeirComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    width_ (x.width_, f, this),
    exponentWeirFormula_ (x.exponentWeirFormula_, f, this),
    submergedFlowRatio_ (x.submergedFlowRatio_, f, this),
    submergedFlowFactor_ (x.submergedFlowFactor_, f, this),
    flowDirection_ (x.flowDirection_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this)
  {
  }

  RiverWeirComplexType::
  RiverWeirComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    width_ (f, this),
    exponentWeirFormula_ (f, this),
    submergedFlowRatio_ (f, this),
    submergedFlowFactor_ (f, this),
    flowDirection_ (f, this),
    input_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RiverWeirComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // width
      //
      if (n.name () == "width" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!width_.present ())
        {
          this->width_.set (WidthTraits::create (i, f, this));
          continue;
        }
      }

      // exponentWeirFormula
      //
      if (n.name () == "exponentWeirFormula" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->exponentWeirFormula_)
        {
          this->exponentWeirFormula_.set (ExponentWeirFormulaTraits::create (i, f, this));
          continue;
        }
      }

      // submergedFlowRatio
      //
      if (n.name () == "submergedFlowRatio" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->submergedFlowRatio_)
        {
          this->submergedFlowRatio_.set (SubmergedFlowRatioTraits::create (i, f, this));
          continue;
        }
      }

      // submergedFlowFactor
      //
      if (n.name () == "submergedFlowFactor" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->submergedFlowFactor_)
        {
          this->submergedFlowFactor_.set (SubmergedFlowFactorTraits::create (i, f, this));
          continue;
        }
      }

      // flowDirection
      //
      if (n.name () == "flowDirection" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlowDirectionType > r (
          FlowDirectionTraits::create (i, f, this));

        if (!this->flowDirection_)
        {
          this->flowDirection_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!width_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "width",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }
  }

  RiverWeirComplexType* RiverWeirComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RiverWeirComplexType (*this, f, c);
  }

  RiverWeirComplexType::
  ~RiverWeirComplexType ()
  {
  }

  // RiverWeirInputComplexType
  //

  RiverWeirInputComplexType::
  RiverWeirInputComplexType (const HUpType& HUp,
                             const HDownType& HDown)
  : ::xml_schema::Type (),
    HUp_ (HUp, ::xml_schema::Flags (), this),
    DeltaHUp_ (::xml_schema::Flags (), this),
    HDown_ (HDown, ::xml_schema::Flags (), this),
    DeltaHDown_ (::xml_schema::Flags (), this),
    CConst_ (::xml_schema::Flags (), this),
    CSeries_ (::xml_schema::Flags (), this)
  {
  }

  RiverWeirInputComplexType::
  RiverWeirInputComplexType (const RiverWeirInputComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    HUp_ (x.HUp_, f, this),
    DeltaHUp_ (x.DeltaHUp_, f, this),
    HDown_ (x.HDown_, f, this),
    DeltaHDown_ (x.DeltaHDown_, f, this),
    CConst_ (x.CConst_, f, this),
    CSeries_ (x.CSeries_, f, this)
  {
  }

  RiverWeirInputComplexType::
  RiverWeirInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    HUp_ (f, this),
    DeltaHUp_ (f, this),
    HDown_ (f, this),
    DeltaHDown_ (f, this),
    CConst_ (f, this),
    CSeries_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RiverWeirInputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HUp
      //
      if (n.name () == "HUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HUpType > r (
          HUpTraits::create (i, f, this));

        if (!HUp_.present ())
        {
          this->HUp_.set (r);
          continue;
        }
      }

      // DeltaHUp
      //
      if (n.name () == "DeltaHUp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeltaHUpType > r (
          DeltaHUpTraits::create (i, f, this));

        if (!this->DeltaHUp_)
        {
          this->DeltaHUp_.set (r);
          continue;
        }
      }

      // HDown
      //
      if (n.name () == "HDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< HDownType > r (
          HDownTraits::create (i, f, this));

        if (!HDown_.present ())
        {
          this->HDown_.set (r);
          continue;
        }
      }

      // DeltaHDown
      //
      if (n.name () == "DeltaHDown" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DeltaHDownType > r (
          DeltaHDownTraits::create (i, f, this));

        if (!this->DeltaHDown_)
        {
          this->DeltaHDown_.set (r);
          continue;
        }
      }

      // CConst
      //
      if (n.name () == "CConst" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->CConst_)
        {
          this->CConst_.set (CConstTraits::create (i, f, this));
          continue;
        }
      }

      // CSeries
      //
      if (n.name () == "CSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CSeriesType > r (
          CSeriesTraits::create (i, f, this));

        if (!this->CSeries_)
        {
          this->CSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!HUp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HUp",
        "http://www.wldelft.nl/fews");
    }

    if (!HDown_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HDown",
        "http://www.wldelft.nl/fews");
    }
  }

  RiverWeirInputComplexType* RiverWeirInputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RiverWeirInputComplexType (*this, f, c);
  }

  RiverWeirInputComplexType::
  ~RiverWeirInputComplexType ()
  {
  }

  // RiverWeirOutputComplexType
  //

  RiverWeirOutputComplexType::
  RiverWeirOutputComplexType (const QType& Q,
                              const CType& C)
  : ::xml_schema::Type (),
    Q_ (Q, ::xml_schema::Flags (), this),
    C_ (C, ::xml_schema::Flags (), this),
    flowType_ (::xml_schema::Flags (), this)
  {
  }

  RiverWeirOutputComplexType::
  RiverWeirOutputComplexType (const RiverWeirOutputComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Q_ (x.Q_, f, this),
    C_ (x.C_, f, this),
    flowType_ (x.flowType_, f, this)
  {
  }

  RiverWeirOutputComplexType::
  RiverWeirOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Q_ (f, this),
    C_ (f, this),
    flowType_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RiverWeirOutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!Q_.present ())
        {
          this->Q_.set (r);
          continue;
        }
      }

      // C
      //
      if (n.name () == "C" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CType > r (
          CTraits::create (i, f, this));

        if (!C_.present ())
        {
          this->C_.set (r);
          continue;
        }
      }

      // flowType
      //
      if (n.name () == "flowType" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlowTypeType > r (
          FlowTypeTraits::create (i, f, this));

        if (!this->flowType_)
        {
          this->flowType_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Q_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Q",
        "http://www.wldelft.nl/fews");
    }

    if (!C_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "C",
        "http://www.wldelft.nl/fews");
    }
  }

  RiverWeirOutputComplexType* RiverWeirOutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RiverWeirOutputComplexType (*this, f, c);
  }

  RiverWeirOutputComplexType::
  ~RiverWeirOutputComplexType ()
  {
  }

  // PoolRoutingEnumStringType
  //

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PoolRoutingEnumStringType_convert ();
  }

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PoolRoutingEnumStringType_convert ();
  }

  PoolRoutingEnumStringType::
  PoolRoutingEnumStringType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PoolRoutingEnumStringType_convert ();
  }

  PoolRoutingEnumStringType* PoolRoutingEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PoolRoutingEnumStringType (*this, f, c);
  }

  PoolRoutingEnumStringType::Value PoolRoutingEnumStringType::
  _xsd_PoolRoutingEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PoolRoutingEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PoolRoutingEnumStringType_indexes_,
                      _xsd_PoolRoutingEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_PoolRoutingEnumStringType_indexes_ + 3 || _xsd_PoolRoutingEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PoolRoutingEnumStringType::
  _xsd_PoolRoutingEnumStringType_literals_[3] =
  {
    "ForwardEuler",
    "BackwardEuler",
    "Theta"
  };

  const PoolRoutingEnumStringType::Value PoolRoutingEnumStringType::
  _xsd_PoolRoutingEnumStringType_indexes_[3] =
  {
    ::fews::PoolRoutingEnumStringType::BackwardEuler,
    ::fews::PoolRoutingEnumStringType::ForwardEuler,
    ::fews::PoolRoutingEnumStringType::Theta
  };

  // InterpolationOptionEnumStringType
  //

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_InterpolationOptionEnumStringType_convert ();
  }

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_InterpolationOptionEnumStringType_convert ();
  }

  InterpolationOptionEnumStringType::
  InterpolationOptionEnumStringType (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_InterpolationOptionEnumStringType_convert ();
  }

  InterpolationOptionEnumStringType* InterpolationOptionEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InterpolationOptionEnumStringType (*this, f, c);
  }

  InterpolationOptionEnumStringType::Value InterpolationOptionEnumStringType::
  _xsd_InterpolationOptionEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InterpolationOptionEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_InterpolationOptionEnumStringType_indexes_,
                      _xsd_InterpolationOptionEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_InterpolationOptionEnumStringType_indexes_ + 2 || _xsd_InterpolationOptionEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InterpolationOptionEnumStringType::
  _xsd_InterpolationOptionEnumStringType_literals_[2] =
  {
    "BLOCK",
    "LINEAR"
  };

  const InterpolationOptionEnumStringType::Value InterpolationOptionEnumStringType::
  _xsd_InterpolationOptionEnumStringType_indexes_[2] =
  {
    ::fews::InterpolationOptionEnumStringType::BLOCK,
    ::fews::InterpolationOptionEnumStringType::LINEAR
  };

  // LimiterOptionEnumStringType
  //

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_LimiterOptionEnumStringType_convert ();
  }

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_LimiterOptionEnumStringType_convert ();
  }

  LimiterOptionEnumStringType::
  LimiterOptionEnumStringType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_LimiterOptionEnumStringType_convert ();
  }

  LimiterOptionEnumStringType* LimiterOptionEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimiterOptionEnumStringType (*this, f, c);
  }

  LimiterOptionEnumStringType::Value LimiterOptionEnumStringType::
  _xsd_LimiterOptionEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LimiterOptionEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_LimiterOptionEnumStringType_indexes_,
                      _xsd_LimiterOptionEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_LimiterOptionEnumStringType_indexes_ + 2 || _xsd_LimiterOptionEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const LimiterOptionEnumStringType::
  _xsd_LimiterOptionEnumStringType_literals_[2] =
  {
    "PERCENTAGE",
    "ABSOLUTE"
  };

  const LimiterOptionEnumStringType::Value LimiterOptionEnumStringType::
  _xsd_LimiterOptionEnumStringType_indexes_[2] =
  {
    ::fews::LimiterOptionEnumStringType::ABSOLUTE,
    ::fews::LimiterOptionEnumStringType::PERCENTAGE
  };

  // TimeRelativeEnumStringType
  //

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_TimeRelativeEnumStringType_convert ();
  }

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_TimeRelativeEnumStringType_convert ();
  }

  TimeRelativeEnumStringType::
  TimeRelativeEnumStringType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_TimeRelativeEnumStringType_convert ();
  }

  TimeRelativeEnumStringType* TimeRelativeEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeRelativeEnumStringType (*this, f, c);
  }

  TimeRelativeEnumStringType::Value TimeRelativeEnumStringType::
  _xsd_TimeRelativeEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TimeRelativeEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_TimeRelativeEnumStringType_indexes_,
                      _xsd_TimeRelativeEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_TimeRelativeEnumStringType_indexes_ + 2 || _xsd_TimeRelativeEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TimeRelativeEnumStringType::
  _xsd_TimeRelativeEnumStringType_literals_[2] =
  {
    "ABSOLUTE",
    "RELATIVE"
  };

  const TimeRelativeEnumStringType::Value TimeRelativeEnumStringType::
  _xsd_TimeRelativeEnumStringType_indexes_[2] =
  {
    ::fews::TimeRelativeEnumStringType::ABSOLUTE,
    ::fews::TimeRelativeEnumStringType::RELATIVE
  };

  // CaseLangetenEnumStringType
  //

  CaseLangetenEnumStringType::
  CaseLangetenEnumStringType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  CaseLangetenEnumStringType::
  CaseLangetenEnumStringType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  CaseLangetenEnumStringType::
  CaseLangetenEnumStringType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  CaseLangetenEnumStringType* CaseLangetenEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CaseLangetenEnumStringType (*this, f, c);
  }

  // FlowDirectionEnumStringType
  //

  FlowDirectionEnumStringType::
  FlowDirectionEnumStringType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  FlowDirectionEnumStringType::
  FlowDirectionEnumStringType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  FlowDirectionEnumStringType::
  FlowDirectionEnumStringType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  FlowDirectionEnumStringType* FlowDirectionEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FlowDirectionEnumStringType (*this, f, c);
  }

  // LogicalOperatorEnumStringType
  //

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_LogicalOperatorEnumStringType_convert ();
  }

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_LogicalOperatorEnumStringType_convert ();
  }

  LogicalOperatorEnumStringType::
  LogicalOperatorEnumStringType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_LogicalOperatorEnumStringType_convert ();
  }

  LogicalOperatorEnumStringType* LogicalOperatorEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LogicalOperatorEnumStringType (*this, f, c);
  }

  LogicalOperatorEnumStringType::Value LogicalOperatorEnumStringType::
  _xsd_LogicalOperatorEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LogicalOperatorEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_LogicalOperatorEnumStringType_indexes_,
                      _xsd_LogicalOperatorEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_LogicalOperatorEnumStringType_indexes_ + 3 || _xsd_LogicalOperatorEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const LogicalOperatorEnumStringType::
  _xsd_LogicalOperatorEnumStringType_literals_[3] =
  {
    "AND",
    "OR",
    "XOR"
  };

  const LogicalOperatorEnumStringType::Value LogicalOperatorEnumStringType::
  _xsd_LogicalOperatorEnumStringType_indexes_[3] =
  {
    ::fews::LogicalOperatorEnumStringType::AND,
    ::fews::LogicalOperatorEnumStringType::OR,
    ::fews::LogicalOperatorEnumStringType::XOR
  };

  // RelationalOperatorEnumStringType
  //

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_RelationalOperatorEnumStringType_convert ();
  }

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_RelationalOperatorEnumStringType_convert ();
  }

  RelationalOperatorEnumStringType::
  RelationalOperatorEnumStringType (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_RelationalOperatorEnumStringType_convert ();
  }

  RelationalOperatorEnumStringType* RelationalOperatorEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RelationalOperatorEnumStringType (*this, f, c);
  }

  RelationalOperatorEnumStringType::Value RelationalOperatorEnumStringType::
  _xsd_RelationalOperatorEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RelationalOperatorEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_RelationalOperatorEnumStringType_indexes_,
                      _xsd_RelationalOperatorEnumStringType_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_RelationalOperatorEnumStringType_indexes_ + 6 || _xsd_RelationalOperatorEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RelationalOperatorEnumStringType::
  _xsd_RelationalOperatorEnumStringType_literals_[6] =
  {
    "Less",
    "LessEqual",
    "Equal",
    "Unequal",
    "GreaterEqual",
    "Greater"
  };

  const RelationalOperatorEnumStringType::Value RelationalOperatorEnumStringType::
  _xsd_RelationalOperatorEnumStringType_indexes_[6] =
  {
    ::fews::RelationalOperatorEnumStringType::Equal,
    ::fews::RelationalOperatorEnumStringType::Greater,
    ::fews::RelationalOperatorEnumStringType::GreaterEqual,
    ::fews::RelationalOperatorEnumStringType::Less,
    ::fews::RelationalOperatorEnumStringType::LessEqual,
    ::fews::RelationalOperatorEnumStringType::Unequal
  };

  // MathematicalOperatorEnumStringType
  //

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MathematicalOperatorEnumStringType_convert ();
  }

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MathematicalOperatorEnumStringType_convert ();
  }

  MathematicalOperatorEnumStringType::
  MathematicalOperatorEnumStringType (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MathematicalOperatorEnumStringType_convert ();
  }

  MathematicalOperatorEnumStringType* MathematicalOperatorEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MathematicalOperatorEnumStringType (*this, f, c);
  }

  MathematicalOperatorEnumStringType::Value MathematicalOperatorEnumStringType::
  _xsd_MathematicalOperatorEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MathematicalOperatorEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MathematicalOperatorEnumStringType_indexes_,
                      _xsd_MathematicalOperatorEnumStringType_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_MathematicalOperatorEnumStringType_indexes_ + 7 || _xsd_MathematicalOperatorEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MathematicalOperatorEnumStringType::
  _xsd_MathematicalOperatorEnumStringType_literals_[7] =
  {
    "+",
    "-",
    "*",
    "/",
    "min",
    "max",
    "^"
  };

  const MathematicalOperatorEnumStringType::Value MathematicalOperatorEnumStringType::
  _xsd_MathematicalOperatorEnumStringType_indexes_[7] =
  {
    ::fews::MathematicalOperatorEnumStringType::cxx_2,
    ::fews::MathematicalOperatorEnumStringType::cxx_,
    ::fews::MathematicalOperatorEnumStringType::cxx_1,
    ::fews::MathematicalOperatorEnumStringType::cxx_3,
    ::fews::MathematicalOperatorEnumStringType::cxx_4,
    ::fews::MathematicalOperatorEnumStringType::max,
    ::fews::MathematicalOperatorEnumStringType::min
  };

  // SpatialEnumStringType
  //

  SpatialEnumStringType::
  SpatialEnumStringType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_SpatialEnumStringType_convert ();
  }

  SpatialEnumStringType::
  SpatialEnumStringType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_SpatialEnumStringType_convert ();
  }

  SpatialEnumStringType::
  SpatialEnumStringType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_SpatialEnumStringType_convert ();
  }

  SpatialEnumStringType* SpatialEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SpatialEnumStringType (*this, f, c);
  }

  SpatialEnumStringType::Value SpatialEnumStringType::
  _xsd_SpatialEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SpatialEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_SpatialEnumStringType_indexes_,
                      _xsd_SpatialEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_SpatialEnumStringType_indexes_ + 2 || _xsd_SpatialEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SpatialEnumStringType::
  _xsd_SpatialEnumStringType_literals_[2] =
  {
    "CENTRAL",
    "UPWIND"
  };

  const SpatialEnumStringType::Value SpatialEnumStringType::
  _xsd_SpatialEnumStringType_indexes_[2] =
  {
    ::fews::SpatialEnumStringType::CENTRAL,
    ::fews::SpatialEnumStringType::UPWIND
  };

  // CapacityReferenceEnumStringType
  //

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_CapacityReferenceEnumStringType_convert ();
  }

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_CapacityReferenceEnumStringType_convert ();
  }

  CapacityReferenceEnumStringType::
  CapacityReferenceEnumStringType (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_CapacityReferenceEnumStringType_convert ();
  }

  CapacityReferenceEnumStringType* CapacityReferenceEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CapacityReferenceEnumStringType (*this, f, c);
  }

  CapacityReferenceEnumStringType::Value CapacityReferenceEnumStringType::
  _xsd_CapacityReferenceEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CapacityReferenceEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CapacityReferenceEnumStringType_indexes_,
                      _xsd_CapacityReferenceEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_CapacityReferenceEnumStringType_indexes_ + 2 || _xsd_CapacityReferenceEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CapacityReferenceEnumStringType::
  _xsd_CapacityReferenceEnumStringType_literals_[2] =
  {
    "UPSTREAMLEVEL",
    "HEAD"
  };

  const CapacityReferenceEnumStringType::Value CapacityReferenceEnumStringType::
  _xsd_CapacityReferenceEnumStringType_indexes_[2] =
  {
    ::fews::CapacityReferenceEnumStringType::HEAD,
    ::fews::CapacityReferenceEnumStringType::UPSTREAMLEVEL
  };

  // InputReferenceEnumStringType
  //

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_InputReferenceEnumStringType_convert ();
  }

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_InputReferenceEnumStringType_convert ();
  }

  InputReferenceEnumStringType::
  InputReferenceEnumStringType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_InputReferenceEnumStringType_convert ();
  }

  InputReferenceEnumStringType* InputReferenceEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputReferenceEnumStringType (*this, f, c);
  }

  InputReferenceEnumStringType::Value InputReferenceEnumStringType::
  _xsd_InputReferenceEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InputReferenceEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_InputReferenceEnumStringType_indexes_,
                      _xsd_InputReferenceEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_InputReferenceEnumStringType_indexes_ + 2 || _xsd_InputReferenceEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InputReferenceEnumStringType::
  _xsd_InputReferenceEnumStringType_literals_[2] =
  {
    "EXPLICIT",
    "IMPLICIT"
  };

  const InputReferenceEnumStringType::Value InputReferenceEnumStringType::
  _xsd_InputReferenceEnumStringType_indexes_[2] =
  {
    ::fews::InputReferenceEnumStringType::EXPLICIT,
    ::fews::InputReferenceEnumStringType::IMPLICIT
  };

  // BranchTypeEnumStringType
  //

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_BranchTypeEnumStringType_convert ();
  }

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_BranchTypeEnumStringType_convert ();
  }

  BranchTypeEnumStringType::
  BranchTypeEnumStringType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_BranchTypeEnumStringType_convert ();
  }

  BranchTypeEnumStringType* BranchTypeEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BranchTypeEnumStringType (*this, f, c);
  }

  BranchTypeEnumStringType::Value BranchTypeEnumStringType::
  _xsd_BranchTypeEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BranchTypeEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_BranchTypeEnumStringType_indexes_,
                      _xsd_BranchTypeEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_BranchTypeEnumStringType_indexes_ + 3 || _xsd_BranchTypeEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const BranchTypeEnumStringType::
  _xsd_BranchTypeEnumStringType_literals_[3] =
  {
    "KINEMATIC",
    "DIFFUSIVE",
    "DIFFUSIVEPLUSLOCAL"
  };

  const BranchTypeEnumStringType::Value BranchTypeEnumStringType::
  _xsd_BranchTypeEnumStringType_indexes_[3] =
  {
    ::fews::BranchTypeEnumStringType::DIFFUSIVE,
    ::fews::BranchTypeEnumStringType::DIFFUSIVEPLUSLOCAL,
    ::fews::BranchTypeEnumStringType::KINEMATIC
  };

  // EquationEnumStringType
  //

  EquationEnumStringType::
  EquationEnumStringType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_EquationEnumStringType_convert ();
  }

  EquationEnumStringType::
  EquationEnumStringType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_EquationEnumStringType_convert ();
  }

  EquationEnumStringType::
  EquationEnumStringType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_EquationEnumStringType_convert ();
  }

  EquationEnumStringType* EquationEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EquationEnumStringType (*this, f, c);
  }

  EquationEnumStringType::Value EquationEnumStringType::
  _xsd_EquationEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EquationEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_EquationEnumStringType_indexes_,
                      _xsd_EquationEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_EquationEnumStringType_indexes_ + 3 || _xsd_EquationEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const EquationEnumStringType::
  _xsd_EquationEnumStringType_literals_[3] =
  {
    "KINEMATIC",
    "DIFFUSIVE",
    "INERTIAL"
  };

  const EquationEnumStringType::Value EquationEnumStringType::
  _xsd_EquationEnumStringType_indexes_[3] =
  {
    ::fews::EquationEnumStringType::DIFFUSIVE,
    ::fews::EquationEnumStringType::INERTIAL,
    ::fews::EquationEnumStringType::KINEMATIC
  };

  // MergerSplitterEnumStringType
  //

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MergerSplitterEnumStringType_convert ();
  }

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MergerSplitterEnumStringType_convert ();
  }

  MergerSplitterEnumStringType::
  MergerSplitterEnumStringType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MergerSplitterEnumStringType_convert ();
  }

  MergerSplitterEnumStringType* MergerSplitterEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MergerSplitterEnumStringType (*this, f, c);
  }

  MergerSplitterEnumStringType::Value MergerSplitterEnumStringType::
  _xsd_MergerSplitterEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MergerSplitterEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MergerSplitterEnumStringType_indexes_,
                      _xsd_MergerSplitterEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_MergerSplitterEnumStringType_indexes_ + 3 || _xsd_MergerSplitterEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MergerSplitterEnumStringType::
  _xsd_MergerSplitterEnumStringType_literals_[3] =
  {
    "AVERAGE",
    "DATAHIERARCHY",
    "SUM"
  };

  const MergerSplitterEnumStringType::Value MergerSplitterEnumStringType::
  _xsd_MergerSplitterEnumStringType_indexes_[3] =
  {
    ::fews::MergerSplitterEnumStringType::AVERAGE,
    ::fews::MergerSplitterEnumStringType::DATAHIERARCHY,
    ::fews::MergerSplitterEnumStringType::SUM
  };

  // HydraulicModelModeEnumStringType
  //

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_HydraulicModelModeEnumStringType_convert ();
  }

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_HydraulicModelModeEnumStringType_convert ();
  }

  HydraulicModelModeEnumStringType::
  HydraulicModelModeEnumStringType (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_HydraulicModelModeEnumStringType_convert ();
  }

  HydraulicModelModeEnumStringType* HydraulicModelModeEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraulicModelModeEnumStringType (*this, f, c);
  }

  HydraulicModelModeEnumStringType::Value HydraulicModelModeEnumStringType::
  _xsd_HydraulicModelModeEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_HydraulicModelModeEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_HydraulicModelModeEnumStringType_indexes_,
                      _xsd_HydraulicModelModeEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_HydraulicModelModeEnumStringType_indexes_ + 3 || _xsd_HydraulicModelModeEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const HydraulicModelModeEnumStringType::
  _xsd_HydraulicModelModeEnumStringType_literals_[3] =
  {
    "SEQUENTIAL_EXPLICIT",
    "SEQUENTIAL_IMPLICIT",
    "SIMULTANEOUS"
  };

  const HydraulicModelModeEnumStringType::Value HydraulicModelModeEnumStringType::
  _xsd_HydraulicModelModeEnumStringType_indexes_[3] =
  {
    ::fews::HydraulicModelModeEnumStringType::SEQUENTIAL_EXPLICIT,
    ::fews::HydraulicModelModeEnumStringType::SEQUENTIAL_IMPLICIT,
    ::fews::HydraulicModelModeEnumStringType::SIMULTANEOUS
  };

  // TransferFunctionEnumStringType
  //

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_TransferFunctionEnumStringType_convert ();
  }

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_TransferFunctionEnumStringType_convert ();
  }

  TransferFunctionEnumStringType::
  TransferFunctionEnumStringType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_TransferFunctionEnumStringType_convert ();
  }

  TransferFunctionEnumStringType* TransferFunctionEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransferFunctionEnumStringType (*this, f, c);
  }

  TransferFunctionEnumStringType::Value TransferFunctionEnumStringType::
  _xsd_TransferFunctionEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TransferFunctionEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_TransferFunctionEnumStringType_indexes_,
                      _xsd_TransferFunctionEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_TransferFunctionEnumStringType_indexes_ + 3 || _xsd_TransferFunctionEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TransferFunctionEnumStringType::
  _xsd_TransferFunctionEnumStringType_literals_[3] =
  {
    "Linear",
    "SigmoidLogistic",
    "Tansig"
  };

  const TransferFunctionEnumStringType::Value TransferFunctionEnumStringType::
  _xsd_TransferFunctionEnumStringType_indexes_[3] =
  {
    ::fews::TransferFunctionEnumStringType::Linear,
    ::fews::TransferFunctionEnumStringType::SigmoidLogistic,
    ::fews::TransferFunctionEnumStringType::Tansig
  };

  // PidComplexType
  //

  const PidComplexType::ModeType PidComplexType::mode_default_value_ (
    "NATIVE");

  PidComplexType::
  PidComplexType (const SettingMinType& settingMin,
                  const SettingMaxType& settingMax,
                  const SettingMaxSpeedType& settingMaxSpeed,
                  const KpType& kp,
                  const KiType& ki,
                  const KdType& kd,
                  const InputType& input,
                  const OutputType& output,
                  const IdType& id)
  : ::xml_schema::Type (),
    mode_ (::xml_schema::Flags (), this),
    settingMin_ (settingMin, ::xml_schema::Flags (), this),
    settingMax_ (settingMax, ::xml_schema::Flags (), this),
    settingMaxSpeed_ (settingMaxSpeed, ::xml_schema::Flags (), this),
    kp_ (kp, ::xml_schema::Flags (), this),
    ki_ (ki, ::xml_schema::Flags (), this),
    kd_ (kd, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  PidComplexType::
  PidComplexType (const SettingMinType& settingMin,
                  const SettingMaxType& settingMax,
                  const SettingMaxSpeedType& settingMaxSpeed,
                  const KpType& kp,
                  const KiType& ki,
                  const KdType& kd,
                  ::std::auto_ptr< InputType >& input,
                  ::std::auto_ptr< OutputType >& output,
                  const IdType& id)
  : ::xml_schema::Type (),
    mode_ (::xml_schema::Flags (), this),
    settingMin_ (settingMin, ::xml_schema::Flags (), this),
    settingMax_ (settingMax, ::xml_schema::Flags (), this),
    settingMaxSpeed_ (settingMaxSpeed, ::xml_schema::Flags (), this),
    kp_ (kp, ::xml_schema::Flags (), this),
    ki_ (ki, ::xml_schema::Flags (), this),
    kd_ (kd, ::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    output_ (output, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  PidComplexType::
  PidComplexType (const PidComplexType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mode_ (x.mode_, f, this),
    settingMin_ (x.settingMin_, f, this),
    settingMax_ (x.settingMax_, f, this),
    settingMaxSpeed_ (x.settingMaxSpeed_, f, this),
    kp_ (x.kp_, f, this),
    ki_ (x.ki_, f, this),
    kd_ (x.kd_, f, this),
    input_ (x.input_, f, this),
    output_ (x.output_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  PidComplexType::
  PidComplexType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mode_ (f, this),
    settingMin_ (f, this),
    settingMax_ (f, this),
    settingMaxSpeed_ (f, this),
    kp_ (f, this),
    ki_ (f, this),
    kd_ (f, this),
    input_ (f, this),
    output_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PidComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mode
      //
      if (n.name () == "mode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ModeType > r (
          ModeTraits::create (i, f, this));

        if (!this->mode_)
        {
          this->mode_.set (r);
          continue;
        }
      }

      // settingMin
      //
      if (n.name () == "settingMin" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!settingMin_.present ())
        {
          this->settingMin_.set (SettingMinTraits::create (i, f, this));
          continue;
        }
      }

      // settingMax
      //
      if (n.name () == "settingMax" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!settingMax_.present ())
        {
          this->settingMax_.set (SettingMaxTraits::create (i, f, this));
          continue;
        }
      }

      // settingMaxSpeed
      //
      if (n.name () == "settingMaxSpeed" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!settingMaxSpeed_.present ())
        {
          this->settingMaxSpeed_.set (SettingMaxSpeedTraits::create (i, f, this));
          continue;
        }
      }

      // kp
      //
      if (n.name () == "kp" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!kp_.present ())
        {
          this->kp_.set (KpTraits::create (i, f, this));
          continue;
        }
      }

      // ki
      //
      if (n.name () == "ki" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!ki_.present ())
        {
          this->ki_.set (KiTraits::create (i, f, this));
          continue;
        }
      }

      // kd
      //
      if (n.name () == "kd" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!kd_.present ())
        {
          this->kd_.set (KdTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!output_.present ())
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }

    if (!settingMin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "settingMin",
        "http://www.wldelft.nl/fews");
    }

    if (!settingMax_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "settingMax",
        "http://www.wldelft.nl/fews");
    }

    if (!settingMaxSpeed_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "settingMaxSpeed",
        "http://www.wldelft.nl/fews");
    }

    if (!kp_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "kp",
        "http://www.wldelft.nl/fews");
    }

    if (!ki_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ki",
        "http://www.wldelft.nl/fews");
    }

    if (!kd_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "kd",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!output_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "output",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  PidComplexType* PidComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PidComplexType (*this, f, c);
  }

  PidComplexType::
  ~PidComplexType ()
  {
  }

  // InputPidComplexType
  //

  InputPidComplexType::
  InputPidComplexType (const XType& x)
  : ::xml_schema::Type (),
    x_ (x, ::xml_schema::Flags (), this),
    setpointSeries_ (::xml_schema::Flags (), this),
    setpointValue_ (::xml_schema::Flags (), this),
    disturbance_ (::xml_schema::Flags (), this)
  {
  }

  InputPidComplexType::
  InputPidComplexType (const InputPidComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    setpointSeries_ (x.setpointSeries_, f, this),
    setpointValue_ (x.setpointValue_, f, this),
    disturbance_ (x.disturbance_, f, this)
  {
  }

  InputPidComplexType::
  InputPidComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (f, this),
    setpointSeries_ (f, this),
    setpointValue_ (f, this),
    disturbance_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void InputPidComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< XType > r (
          XTraits::create (i, f, this));

        if (!x_.present ())
        {
          this->x_.set (r);
          continue;
        }
      }

      // setpointSeries
      //
      if (n.name () == "setpointSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetpointSeriesType > r (
          SetpointSeriesTraits::create (i, f, this));

        if (!this->setpointSeries_)
        {
          this->setpointSeries_.set (r);
          continue;
        }
      }

      // setpointValue
      //
      if (n.name () == "setpointValue" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->setpointValue_)
        {
          this->setpointValue_.set (SetpointValueTraits::create (i, f, this));
          continue;
        }
      }

      // disturbance
      //
      if (n.name () == "disturbance" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DisturbanceType > r (
          DisturbanceTraits::create (i, f, this));

        if (!this->disturbance_)
        {
          this->disturbance_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.wldelft.nl/fews");
    }
  }

  InputPidComplexType* InputPidComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InputPidComplexType (*this, f, c);
  }

  InputPidComplexType::
  ~InputPidComplexType ()
  {
  }

  // OutputPidComplexType
  //

  OutputPidComplexType::
  OutputPidComplexType (const YType& y,
                        const IntegralPartType& integralPart,
                        const DifferentialPartType& differentialPart)
  : ::xml_schema::Type (),
    y_ (y, ::xml_schema::Flags (), this),
    integralPart_ (integralPart, ::xml_schema::Flags (), this),
    differentialPart_ (differentialPart, ::xml_schema::Flags (), this)
  {
  }

  OutputPidComplexType::
  OutputPidComplexType (const OutputPidComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    y_ (x.y_, f, this),
    integralPart_ (x.integralPart_, f, this),
    differentialPart_ (x.differentialPart_, f, this)
  {
  }

  OutputPidComplexType::
  OutputPidComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    y_ (f, this),
    integralPart_ (f, this),
    differentialPart_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputPidComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!y_.present ())
        {
          this->y_.set (r);
          continue;
        }
      }

      // integralPart
      //
      if (n.name () == "integralPart" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< IntegralPartType > r (
          IntegralPartTraits::create (i, f, this));

        if (!integralPart_.present ())
        {
          this->integralPart_.set (r);
          continue;
        }
      }

      // differentialPart
      //
      if (n.name () == "differentialPart" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< DifferentialPartType > r (
          DifferentialPartTraits::create (i, f, this));

        if (!differentialPart_.present ())
        {
          this->differentialPart_.set (r);
          continue;
        }
      }

      break;
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.wldelft.nl/fews");
    }

    if (!integralPart_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "integralPart",
        "http://www.wldelft.nl/fews");
    }

    if (!differentialPart_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "differentialPart",
        "http://www.wldelft.nl/fews");
    }
  }

  OutputPidComplexType* OutputPidComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputPidComplexType (*this, f, c);
  }

  OutputPidComplexType::
  ~OutputPidComplexType ()
  {
  }

  // TriggerControllerComplexType
  //

  TriggerControllerComplexType::
  TriggerControllerComplexType (const InputType& input,
                                const ValueType& value)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  TriggerControllerComplexType::
  TriggerControllerComplexType (const TriggerControllerComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    input_ (x.input_, f, this),
    value_ (x.value_, f, this)
  {
  }

  TriggerControllerComplexType::
  TriggerControllerComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    input_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TriggerControllerComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!value_.present ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.wldelft.nl/fews");
    }
  }

  TriggerControllerComplexType* TriggerControllerComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriggerControllerComplexType (*this, f, c);
  }

  TriggerControllerComplexType::
  ~TriggerControllerComplexType ()
  {
  }

  // LayerIDSimpleType
  //

  LayerIDSimpleType::
  LayerIDSimpleType ()
  : ::xml_schema::String ()
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const LayerIDSimpleType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  LayerIDSimpleType::
  LayerIDSimpleType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  LayerIDSimpleType* LayerIDSimpleType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LayerIDSimpleType (*this, f, c);
  }

  LayerIDSimpleType::
  ~LayerIDSimpleType ()
  {
  }

  // NeuronIDSimpleType
  //

  NeuronIDSimpleType::
  NeuronIDSimpleType ()
  : ::xml_schema::String ()
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const NeuronIDSimpleType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  NeuronIDSimpleType::
  NeuronIDSimpleType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  NeuronIDSimpleType* NeuronIDSimpleType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeuronIDSimpleType (*this, f, c);
  }

  NeuronIDSimpleType::
  ~NeuronIDSimpleType ()
  {
  }

  // UnitTypeEnumStringType
  //

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_UnitTypeEnumStringType_convert ();
  }

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_UnitTypeEnumStringType_convert ();
  }

  UnitTypeEnumStringType::
  UnitTypeEnumStringType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_UnitTypeEnumStringType_convert ();
  }

  UnitTypeEnumStringType* UnitTypeEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitTypeEnumStringType (*this, f, c);
  }

  UnitTypeEnumStringType::Value UnitTypeEnumStringType::
  _xsd_UnitTypeEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_UnitTypeEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_UnitTypeEnumStringType_indexes_,
                      _xsd_UnitTypeEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_UnitTypeEnumStringType_indexes_ + 2 || _xsd_UnitTypeEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const UnitTypeEnumStringType::
  _xsd_UnitTypeEnumStringType_literals_[2] =
  {
    "SI",
    "Imperial"
  };

  const UnitTypeEnumStringType::Value UnitTypeEnumStringType::
  _xsd_UnitTypeEnumStringType_indexes_[2] =
  {
    ::fews::UnitTypeEnumStringType::Imperial,
    ::fews::UnitTypeEnumStringType::SI
  };

  // Row
  //

  Row::
  Row (const IdType& id,
       const ValueType& value)
  : ::xml_schema::Type (),
    id_ (id, ::xml_schema::Flags (), this),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  Row::
  Row (const Row& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this),
    value_ (x.value_, f, this)
  {
  }

  Row::
  Row (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Row::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Row* Row::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Row (*this, f, c);
  }

  Row::
  ~Row ()
  {
  }

  // Y
  //

  Y::
  Y (const IdType& id)
  : ::fews::TimeSeriesSimpleType (),
    id_ (id, ::xml_schema::Flags (), this),
    selectingColumnId_ (::xml_schema::Flags (), this)
  {
  }

  Y::
  Y (const char* _xsd_String_base,
     const IdType& id)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    id_ (id, ::xml_schema::Flags (), this),
    selectingColumnId_ (::xml_schema::Flags (), this)
  {
  }

  Y::
  Y (const ::std::string& _xsd_String_base,
     const IdType& id)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    id_ (id, ::xml_schema::Flags (), this),
    selectingColumnId_ (::xml_schema::Flags (), this)
  {
  }

  Y::
  Y (const ::xml_schema::String& _xsd_String_base,
     const IdType& id)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    id_ (id, ::xml_schema::Flags (), this),
    selectingColumnId_ (::xml_schema::Flags (), this)
  {
  }

  Y::
  Y (const Y& x,
     ::xml_schema::Flags f,
     ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    id_ (x.id_, f, this),
    selectingColumnId_ (x.selectingColumnId_, f, this)
  {
  }

  Y::
  Y (const ::xercesc::DOMElement& e,
     ::xml_schema::Flags f,
     ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    id_ (f, this),
    selectingColumnId_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Y::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "selectingColumnId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< SelectingColumnIdType > r (
          SelectingColumnIdTraits::create (i, f, this));

        this->selectingColumnId_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  Y* Y::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Y (*this, f, c);
  }

  Y::
  ~Y ()
  {
  }

  // MonthOfYear
  //

  MonthOfYear::
  MonthOfYear (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MonthOfYear_convert ();
  }

  MonthOfYear::
  MonthOfYear (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MonthOfYear_convert ();
  }

  MonthOfYear::
  MonthOfYear (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MonthOfYear_convert ();
  }

  MonthOfYear* MonthOfYear::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonthOfYear (*this, f, c);
  }

  MonthOfYear::Value MonthOfYear::
  _xsd_MonthOfYear_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MonthOfYear_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MonthOfYear_indexes_,
                      _xsd_MonthOfYear_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_MonthOfYear_indexes_ + 12 || _xsd_MonthOfYear_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MonthOfYear::
  _xsd_MonthOfYear_literals_[12] =
  {
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  };

  const MonthOfYear::Value MonthOfYear::
  _xsd_MonthOfYear_indexes_[12] =
  {
    ::fews::MonthOfYear::April,
    ::fews::MonthOfYear::August,
    ::fews::MonthOfYear::December,
    ::fews::MonthOfYear::February,
    ::fews::MonthOfYear::January,
    ::fews::MonthOfYear::July,
    ::fews::MonthOfYear::June,
    ::fews::MonthOfYear::March,
    ::fews::MonthOfYear::May,
    ::fews::MonthOfYear::November,
    ::fews::MonthOfYear::October,
    ::fews::MonthOfYear::September
  };

  // QSPercentage
  //

  QSPercentage::
  QSPercentage ()
  : ::fews::TimeSeriesSimpleType (),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentage::
  QSPercentage (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentage::
  QSPercentage (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentage::
  QSPercentage (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentage::
  QSPercentage (const QSPercentage& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    useAbsoluteAsSpillCap_ (x.useAbsoluteAsSpillCap_, f, this)
  {
  }

  QSPercentage::
  QSPercentage (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    useAbsoluteAsSpillCap_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void QSPercentage::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "useAbsoluteAsSpillCap" && n.namespace_ ().empty ())
      {
        this->useAbsoluteAsSpillCap_.set (UseAbsoluteAsSpillCapTraits::create (i, f, this));
        continue;
      }
    }
  }

  QSPercentage* QSPercentage::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class QSPercentage (*this, f, c);
  }

  QSPercentage::
  ~QSPercentage ()
  {
  }

  // QSPercentageValue
  //

  QSPercentageValue::
  QSPercentageValue (const char* _xsd_ExternalParameterSimpleType_base)
  : ::fews::ExternalParameterSimpleType (_xsd_ExternalParameterSimpleType_base),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentageValue::
  QSPercentageValue (const ::std::string& _xsd_ExternalParameterSimpleType_base)
  : ::fews::ExternalParameterSimpleType (_xsd_ExternalParameterSimpleType_base),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentageValue::
  QSPercentageValue (const ::fews::ExternalParameterSimpleType& _xsd_ExternalParameterSimpleType_base)
  : ::fews::ExternalParameterSimpleType (_xsd_ExternalParameterSimpleType_base),
    useAbsoluteAsSpillCap_ (::xml_schema::Flags (), this)
  {
  }

  QSPercentageValue::
  QSPercentageValue (const QSPercentageValue& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::fews::ExternalParameterSimpleType (x, f, c),
    useAbsoluteAsSpillCap_ (x.useAbsoluteAsSpillCap_, f, this)
  {
  }

  QSPercentageValue::
  QSPercentageValue (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::fews::ExternalParameterSimpleType (e, f | ::xml_schema::Flags::base, c),
    useAbsoluteAsSpillCap_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void QSPercentageValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "useAbsoluteAsSpillCap" && n.namespace_ ().empty ())
      {
        this->useAbsoluteAsSpillCap_.set (UseAbsoluteAsSpillCapTraits::create (i, f, this));
        continue;
      }
    }
  }

  QSPercentageValue* QSPercentageValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class QSPercentageValue (*this, f, c);
  }

  QSPercentageValue::
  ~QSPercentageValue ()
  {
  }

  // External
  //

  External::
  External (const WeightType& weight)
  : ::xml_schema::String (),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  External::
  External (const char* _xsd_String_base,
            const WeightType& weight)
  : ::xml_schema::String (_xsd_String_base),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  External::
  External (const ::std::string& _xsd_String_base,
            const WeightType& weight)
  : ::xml_schema::String (_xsd_String_base),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  External::
  External (const ::xml_schema::String& _xsd_String_base,
            const WeightType& weight)
  : ::xml_schema::String (_xsd_String_base),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  External::
  External (const External& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    weight_ (x.weight_, f, this)
  {
  }

  External::
  External (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    weight_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void External::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< WeightType > r (
          WeightTraits::create (i, f, this));

        this->weight_.set (r);
        continue;
      }
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }
  }

  External* External::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class External (*this, f, c);
  }

  External::
  ~External ()
  {
  }

  // Internal
  //

  Internal::
  Internal (const WeightType& weight)
  : ::xml_schema::String (),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  Internal::
  Internal (const char* _xsd_String_base,
            const WeightType& weight)
  : ::xml_schema::String (_xsd_String_base),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  Internal::
  Internal (const ::std::string& _xsd_String_base,
            const WeightType& weight)
  : ::xml_schema::String (_xsd_String_base),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  Internal::
  Internal (const ::xml_schema::String& _xsd_String_base,
            const WeightType& weight)
  : ::xml_schema::String (_xsd_String_base),
    weight_ (weight, ::xml_schema::Flags (), this)
  {
  }

  Internal::
  Internal (const Internal& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    weight_ (x.weight_, f, this)
  {
  }

  Internal::
  Internal (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    weight_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Internal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< WeightType > r (
          WeightTraits::create (i, f, this));

        this->weight_.set (r);
        continue;
      }
    }

    if (!weight_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weight",
        "");
    }
  }

  Internal* Internal::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Internal (*this, f, c);
  }

  Internal::
  ~Internal ()
  {
  }

  // Multiplier
  //

  Multiplier::
  Multiplier (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  Multiplier::
  Multiplier (const Multiplier& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  Multiplier::
  Multiplier (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  Multiplier::
  Multiplier (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  Multiplier::
  Multiplier (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  Multiplier* Multiplier::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Multiplier (*this, f, c);
  }

  Multiplier::
  ~Multiplier ()
  {
  }

  // Property
  //

  Property::
  Property (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Property_convert ();
  }

  Property::
  Property (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Property_convert ();
  }

  Property::
  Property (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Property_convert ();
  }

  Property* Property::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Property (*this, f, c);
  }

  Property::Value Property::
  _xsd_Property_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Property_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Property_indexes_,
                      _xsd_Property_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Property_indexes_ + 2 || _xsd_Property_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Property::
  _xsd_Property_literals_[2] =
  {
    "MONOTON",
    "POSITIVE"
  };

  const Property::Value Property::
  _xsd_Property_indexes_[2] =
  {
    ::fews::Property::MONOTON,
    ::fews::Property::POSITIVE
  };

  // X
  //

  const X::RefType X::ref_default_value_ (
    "EXPLICIT");

  X::
  X ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X::
  X (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X::
  X (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X::
  X (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X::
  X (const X& x,
     ::xml_schema::Flags f,
     ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X::
  X (const ::xercesc::DOMElement& e,
     ::xml_schema::Flags f,
     ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X* X::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X (*this, f, c);
  }

  X::
  ~X ()
  {
  }

  // X1
  //

  const X1::RefType X1::ref_default_value_ (
    "EXPLICIT");

  X1::
  X1 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1::
  X1 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1::
  X1 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1::
  X1 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1::
  X1 (const X1& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X1::
  X1 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X1* X1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X1 (*this, f, c);
  }

  X1::
  ~X1 ()
  {
  }

  // X11
  //

  const X11::RefType X11::ref_default_value_ (
    "EXPLICIT");

  X11::
  X11 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X11::
  X11 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X11::
  X11 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X11::
  X11 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X11::
  X11 (const X11& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X11::
  X11 (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X11::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X11* X11::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X11 (*this, f, c);
  }

  X11::
  ~X11 ()
  {
  }

  // X2
  //

  const X2::RefType X2::ref_default_value_ (
    "EXPLICIT");

  X2::
  X2 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2::
  X2 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2::
  X2 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2::
  X2 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2::
  X2 (const X2& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X2::
  X2 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X2* X2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X2 (*this, f, c);
  }

  X2::
  ~X2 ()
  {
  }

  // X12
  //

  const X12::RefType X12::ref_default_value_ (
    "EXPLICIT");

  X12::
  X12 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X12::
  X12 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X12::
  X12 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X12::
  X12 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X12::
  X12 (const X12& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X12::
  X12 (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X12::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X12* X12::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X12 (*this, f, c);
  }

  X12::
  ~X12 ()
  {
  }

  // X21
  //

  const X21::RefType X21::ref_default_value_ (
    "EXPLICIT");

  X21::
  X21 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X21::
  X21 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X21::
  X21 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X21::
  X21 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X21::
  X21 (const X21& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X21::
  X21 (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X21::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X21* X21::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X21 (*this, f, c);
  }

  X21::
  ~X21 ()
  {
  }

  // X3
  //

  const X3::RefType X3::ref_default_value_ (
    "EXPLICIT");

  X3::
  X3 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X3::
  X3 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X3::
  X3 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X3::
  X3 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X3::
  X3 (const X3& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X3::
  X3 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X3* X3::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X3 (*this, f, c);
  }

  X3::
  ~X3 ()
  {
  }

  // X4
  //

  const X4::RefType X4::ref_default_value_ (
    "EXPLICIT");

  X4::
  X4 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X4::
  X4 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X4::
  X4 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X4::
  X4 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X4::
  X4 (const X4& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X4::
  X4 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X4* X4::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X4 (*this, f, c);
  }

  X4::
  ~X4 ()
  {
  }

  // X5
  //

  const X5::RefType X5::ref_default_value_ (
    "EXPLICIT");

  X5::
  X5 ()
  : ::fews::TimeSeriesSimpleType (),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X5::
  X5 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X5::
  X5 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X5::
  X5 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X5::
  X5 (const X5& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    factor_ (x.factor_, f, this),
    ref_ (x.ref_, f, this)
  {
  }

  X5::
  X5 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    factor_ (f, this),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X5::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factor" && n.namespace_ ().empty ())
      {
        this->factor_.set (FactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!factor_.present ())
    {
      this->factor_.set (getFactorDefaultValue ());
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X5* X5::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X5 (*this, f, c);
  }

  X5::
  ~X5 ()
  {
  }

  // XVector
  //

  const XVector::RefType XVector::ref_default_value_ (
    "EXPLICIT");

  XVector::
  XVector ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this),
    nStepSeriesStart_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this)
  {
  }

  XVector::
  XVector (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this),
    nStepSeriesStart_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this)
  {
  }

  XVector::
  XVector (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this),
    nStepSeriesStart_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this)
  {
  }

  XVector::
  XVector (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this),
    nStepSeriesStart_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this)
  {
  }

  XVector::
  XVector (const XVector& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this),
    nStepSeriesStart_ (x.nStepSeriesStart_, f, this),
    nStepSeries_ (x.nStepSeries_, f, this)
  {
  }

  XVector::
  XVector (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this),
    nStepSeriesStart_ (f, this),
    nStepSeries_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void XVector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }

      if (n.name () == "nStepSeriesStart" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NStepSeriesStartType > r (
          NStepSeriesStartTraits::create (i, f, this));

        this->nStepSeriesStart_.set (r);
        continue;
      }

      if (n.name () == "nStepSeries" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NStepSeriesType > r (
          NStepSeriesTraits::create (i, f, this));

        this->nStepSeries_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  XVector* XVector::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class XVector (*this, f, c);
  }

  XVector::
  ~XVector ()
  {
  }

  // Y1
  //

  Y1::
  Y1 ()
  : ::fews::TimeSeriesSimpleType (),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Y1::
  Y1 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Y1::
  Y1 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Y1::
  Y1 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Y1::
  Y1 (const Y1& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    factor_ (x.factor_, f, this)
  {
  }

  Y1::
  Y1 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    factor_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Y1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factor" && n.namespace_ ().empty ())
      {
        this->factor_.set (FactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!factor_.present ())
    {
      this->factor_.set (getFactorDefaultValue ());
    }
  }

  Y1* Y1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Y1 (*this, f, c);
  }

  Y1::
  ~Y1 ()
  {
  }

  // Mode
  //

  Mode::
  Mode (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Mode_convert ();
  }

  Mode::
  Mode (const ::xercesc::DOMAttr& a,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Mode_convert ();
  }

  Mode::
  Mode (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Mode_convert ();
  }

  Mode* Mode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Mode (*this, f, c);
  }

  Mode::Value Mode::
  _xsd_Mode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Mode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Mode_indexes_,
                      _xsd_Mode_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Mode_indexes_ + 2 || _xsd_Mode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Mode::
  _xsd_Mode_literals_[2] =
  {
    "NATIVE",
    "RETAINVALUEWHENINACTIVE"
  };

  const Mode::Value Mode::
  _xsd_Mode_indexes_[2] =
  {
    ::fews::Mode::NATIVE,
    ::fews::Mode::RETAINVALUEWHENINACTIVE
  };

  // X1Series
  //

  const X1Series::RefType X1Series::ref_default_value_ (
    "EXPLICIT");

  X1Series::
  X1Series ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series::
  X1Series (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series::
  X1Series (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series::
  X1Series (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series::
  X1Series (const X1Series& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X1Series::
  X1Series (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X1Series::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X1Series* X1Series::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X1Series (*this, f, c);
  }

  X1Series::
  ~X1Series ()
  {
  }

  // X1SeriesVector
  //

  const X1SeriesVector::RefType X1SeriesVector::ref_default_value_ (
    "EXPLICIT");

  X1SeriesVector::
  X1SeriesVector ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1SeriesVector::
  X1SeriesVector (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1SeriesVector::
  X1SeriesVector (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1SeriesVector::
  X1SeriesVector (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1SeriesVector::
  X1SeriesVector (const X1SeriesVector& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X1SeriesVector::
  X1SeriesVector (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X1SeriesVector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X1SeriesVector* X1SeriesVector::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X1SeriesVector (*this, f, c);
  }

  X1SeriesVector::
  ~X1SeriesVector ()
  {
  }

  // X2Series
  //

  const X2Series::RefType X2Series::ref_default_value_ (
    "EXPLICIT");

  X2Series::
  X2Series ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series::
  X2Series (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series::
  X2Series (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series::
  X2Series (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series::
  X2Series (const X2Series& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X2Series::
  X2Series (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X2Series::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X2Series* X2Series::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X2Series (*this, f, c);
  }

  X2Series::
  ~X2Series ()
  {
  }

  // X2SeriesVector
  //

  const X2SeriesVector::RefType X2SeriesVector::ref_default_value_ (
    "EXPLICIT");

  X2SeriesVector::
  X2SeriesVector ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2SeriesVector::
  X2SeriesVector (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2SeriesVector::
  X2SeriesVector (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2SeriesVector::
  X2SeriesVector (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2SeriesVector::
  X2SeriesVector (const X2SeriesVector& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X2SeriesVector::
  X2SeriesVector (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X2SeriesVector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X2SeriesVector* X2SeriesVector::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X2SeriesVector (*this, f, c);
  }

  X2SeriesVector::
  ~X2SeriesVector ()
  {
  }

  // X6
  //

  const X6::RefType X6::ref_default_value_ (
    "EXPLICIT");

  X6::
  X6 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X6::
  X6 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X6::
  X6 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X6::
  X6 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X6::
  X6 (const X6& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X6::
  X6 (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X6::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X6* X6::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X6 (*this, f, c);
  }

  X6::
  ~X6 ()
  {
  }

  // ThresholdSeries
  //

  const ThresholdSeries::RefType ThresholdSeries::ref_default_value_ (
    "EXPLICIT");

  ThresholdSeries::
  ThresholdSeries ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  ThresholdSeries::
  ThresholdSeries (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  ThresholdSeries::
  ThresholdSeries (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  ThresholdSeries::
  ThresholdSeries (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  ThresholdSeries::
  ThresholdSeries (const ThresholdSeries& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  ThresholdSeries::
  ThresholdSeries (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ThresholdSeries::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  ThresholdSeries* ThresholdSeries::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ThresholdSeries (*this, f, c);
  }

  ThresholdSeries::
  ~ThresholdSeries ()
  {
  }

  // X1Series1
  //

  const X1Series1::RefType X1Series1::ref_default_value_ (
    "EXPLICIT");

  X1Series1::
  X1Series1 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series1::
  X1Series1 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series1::
  X1Series1 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series1::
  X1Series1 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series1::
  X1Series1 (const X1Series1& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X1Series1::
  X1Series1 (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X1Series1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X1Series1* X1Series1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X1Series1 (*this, f, c);
  }

  X1Series1::
  ~X1Series1 ()
  {
  }

  // X2Series1
  //

  const X2Series1::RefType X2Series1::ref_default_value_ (
    "EXPLICIT");

  X2Series1::
  X2Series1 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series1::
  X2Series1 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series1::
  X2Series1 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series1::
  X2Series1 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series1::
  X2Series1 (const X2Series1& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X2Series1::
  X2Series1 (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X2Series1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X2Series1* X2Series1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X2Series1 (*this, f, c);
  }

  X2Series1::
  ~X2Series1 ()
  {
  }

  // X1Series2
  //

  const X1Series2::RefType X1Series2::ref_default_value_ (
    "EXPLICIT");

  X1Series2::
  X1Series2 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series2::
  X1Series2 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series2::
  X1Series2 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series2::
  X1Series2 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X1Series2::
  X1Series2 (const X1Series2& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X1Series2::
  X1Series2 (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X1Series2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X1Series2* X1Series2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X1Series2 (*this, f, c);
  }

  X1Series2::
  ~X1Series2 ()
  {
  }

  // X2Series2
  //

  const X2Series2::RefType X2Series2::ref_default_value_ (
    "EXPLICIT");

  X2Series2::
  X2Series2 ()
  : ::fews::TimeSeriesSimpleType (),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series2::
  X2Series2 (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series2::
  X2Series2 (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series2::
  X2Series2 (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    ref_ (getRefDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  X2Series2::
  X2Series2 (const X2Series2& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    ref_ (x.ref_, f, this)
  {
  }

  X2Series2::
  X2Series2 (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void X2Series2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!ref_.present ())
    {
      this->ref_.set (getRefDefaultValue ());
    }
  }

  X2Series2* X2Series2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X2Series2 (*this, f, c);
  }

  X2Series2::
  ~X2Series2 ()
  {
  }

  // QBC
  //

  QBC::
  QBC ()
  : ::fews::TimeSeriesSimpleType (),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  QBC::
  QBC (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  QBC::
  QBC (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  QBC::
  QBC (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  QBC::
  QBC (const QBC& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    factor_ (x.factor_, f, this)
  {
  }

  QBC::
  QBC (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    factor_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void QBC::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factor" && n.namespace_ ().empty ())
      {
        this->factor_.set (FactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!factor_.present ())
    {
      this->factor_.set (getFactorDefaultValue ());
    }
  }

  QBC* QBC::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class QBC (*this, f, c);
  }

  QBC::
  ~QBC ()
  {
  }

  // FlowDirectionEnumStringType_member
  //

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_FlowDirectionEnumStringType_member_convert ();
  }

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_FlowDirectionEnumStringType_member_convert ();
  }

  FlowDirectionEnumStringType_member::
  FlowDirectionEnumStringType_member (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_FlowDirectionEnumStringType_member_convert ();
  }

  FlowDirectionEnumStringType_member* FlowDirectionEnumStringType_member::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FlowDirectionEnumStringType_member (*this, f, c);
  }

  FlowDirectionEnumStringType_member::Value FlowDirectionEnumStringType_member::
  _xsd_FlowDirectionEnumStringType_member_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FlowDirectionEnumStringType_member_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_FlowDirectionEnumStringType_member_indexes_,
                      _xsd_FlowDirectionEnumStringType_member_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_FlowDirectionEnumStringType_member_indexes_ + 3 || _xsd_FlowDirectionEnumStringType_member_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const FlowDirectionEnumStringType_member::
  _xsd_FlowDirectionEnumStringType_member_literals_[3] =
  {
    "POSITIVE",
    "NEGATIVE",
    "BOTH"
  };

  const FlowDirectionEnumStringType_member::Value FlowDirectionEnumStringType_member::
  _xsd_FlowDirectionEnumStringType_member_indexes_[3] =
  {
    ::fews::FlowDirectionEnumStringType_member::BOTH,
    ::fews::FlowDirectionEnumStringType_member::NEGATIVE,
    ::fews::FlowDirectionEnumStringType_member::POSITIVE
  };

  // FlowDirectionEnumStringType_member1
  //

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 ()
  : ::xml_schema::String ()
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const FlowDirectionEnumStringType_member1& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  FlowDirectionEnumStringType_member1::
  FlowDirectionEnumStringType_member1 (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  FlowDirectionEnumStringType_member1* FlowDirectionEnumStringType_member1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FlowDirectionEnumStringType_member1 (*this, f, c);
  }

  FlowDirectionEnumStringType_member1::
  ~FlowDirectionEnumStringType_member1 ()
  {
  }

  // Mode1
  //

  Mode1::
  Mode1 (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Mode1_convert ();
  }

  Mode1::
  Mode1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Mode1_convert ();
  }

  Mode1::
  Mode1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Mode1_convert ();
  }

  Mode1* Mode1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Mode1 (*this, f, c);
  }

  Mode1::Value Mode1::
  _xsd_Mode1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Mode1_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Mode1_indexes_,
                      _xsd_Mode1_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_Mode1_indexes_ + 4 || _xsd_Mode1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Mode1::
  _xsd_Mode1_literals_[4] =
  {
    "NATIVE",
    "SOBEK2",
    "PIDPOS",
    "PIDVEL"
  };

  const Mode1::Value Mode1::
  _xsd_Mode1_indexes_[4] =
  {
    ::fews::Mode1::NATIVE,
    ::fews::Mode1::PIDPOS,
    ::fews::Mode1::PIDVEL,
    ::fews::Mode1::SOBEK2
  };

  // Disturbance
  //

  Disturbance::
  Disturbance ()
  : ::fews::TimeSeriesSimpleType (),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Disturbance::
  Disturbance (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Disturbance::
  Disturbance (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Disturbance::
  Disturbance (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base),
    factor_ (getFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  Disturbance::
  Disturbance (const Disturbance& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c),
    factor_ (x.factor_, f, this)
  {
  }

  Disturbance::
  Disturbance (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f | ::xml_schema::Flags::base, c),
    factor_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Disturbance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "factor" && n.namespace_ ().empty ())
      {
        this->factor_.set (FactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!factor_.present ())
    {
      this->factor_.set (getFactorDefaultValue ());
    }
  }

  Disturbance* Disturbance::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Disturbance (*this, f, c);
  }

  Disturbance::
  ~Disturbance ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace fews
{
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::std::string& u,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
      ::fews::parseRtcToolsConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::std::string& u,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
      ::fews::parseRtcToolsConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
      ::fews::parseRtcToolsConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcToolsConfig (isrc, f, p);
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcToolsConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcToolsConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcToolsConfig (isrc, f, p);
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcToolsConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcToolsConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xercesc::InputSource& i,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
      ::fews::parseRtcToolsConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xercesc::InputSource& i,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
      ::fews::parseRtcToolsConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
      ::fews::parseRtcToolsConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::xercesc::DOMDocument& d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
        ::fews::parseRtcToolsConfig (
          c, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "rtcToolsConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
        ::xsd::cxx::tree::traits< ::fews::RtcToolsConfigComplexType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rtcToolsConfig",
      "http://www.wldelft.nl/fews");
  }

  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "rtcToolsConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      ::std::auto_ptr< ::fews::RtcToolsConfigComplexType > r (
        ::xsd::cxx::tree::traits< ::fews::RtcToolsConfigComplexType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rtcToolsConfig",
      "http://www.wldelft.nl/fews");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace fews
{
  void
  serializeRtcToolsConfig (::std::ostream& o,
                           const ::fews::RtcToolsConfigComplexType& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcToolsConfig (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRtcToolsConfig (::std::ostream& o,
                           const ::fews::RtcToolsConfigComplexType& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcToolsConfig (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcToolsConfig (::std::ostream& o,
                           const ::fews::RtcToolsConfigComplexType& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcToolsConfig (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcToolsConfig (::xercesc::XMLFormatTarget& t,
                           const ::fews::RtcToolsConfigComplexType& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcToolsConfig (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRtcToolsConfig (::xercesc::XMLFormatTarget& t,
                           const ::fews::RtcToolsConfigComplexType& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcToolsConfig (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcToolsConfig (::xercesc::XMLFormatTarget& t,
                           const ::fews::RtcToolsConfigComplexType& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcToolsConfig (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcToolsConfig (::xercesc::DOMDocument& d,
                           const ::fews::RtcToolsConfigComplexType& s,
                           ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "rtcToolsConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "rtcToolsConfig",
        "http://www.wldelft.nl/fews");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeRtcToolsConfig (const ::fews::RtcToolsConfigComplexType& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "rtcToolsConfig",
        "http://www.wldelft.nl/fews",
        m, f));

    ::fews::serializeRtcToolsConfig (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const RtcToolsConfigComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // general
    //
    if (i.getGeneral ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "general",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getGeneral ();
    }

    // components
    //
    if (i.getComponents ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "components",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getComponents ();
    }

    // rules
    //
    if (i.getRules ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rules",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRules ();
    }

    // triggers
    //
    if (i.getTriggers ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "triggers",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTriggers ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GeneralModuleConfigComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // description
    //
    if (i.getDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDescription ();
    }

    // poolRoutingScheme
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "poolRoutingScheme",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPoolRoutingScheme ();
    }

    // theta
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "theta",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getTheta ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // component
    //
    for (ComponentsComplexType::ComponentConstIterator
         b (i.getComponent ().begin ()), n (i.getComponent ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // accumulation
    //
    if (i.getAccumulation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "accumulation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAccumulation ();
    }

    // allocationTable
    //
    if (i.getAllocationTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "allocationTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAllocationTable ();
    }

    // arma
    //
    if (i.getArma ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arma",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getArma ();
    }

    // expression
    //
    if (i.getExpression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getExpression ();
    }

    // gradient
    //
    if (i.getGradient ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "gradient",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getGradient ();
    }

    // hbv
    //
    if (i.getHbv ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hbv",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHbv ();
    }

    // hydraulicModel
    //
    if (i.getHydraulicModel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hydraulicModel",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHydraulicModel ();
    }

    // hydrologicalModel
    //
    if (i.getHydrologicalModel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hydrologicalModel",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHydrologicalModel ();
    }

    // lookupTable
    //
    if (i.getLookupTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookupTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLookupTable ();
    }

    // lookup2DTable
    //
    if (i.getLookup2DTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookup2DTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLookup2DTable ();
    }

    // merger
    //
    if (i.getMerger ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "merger",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMerger ();
    }

    // mergerSplitter
    //
    if (i.getMergerSplitter ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mergerSplitter",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMergerSplitter ();
    }

    // neuralNetwork
    //
    if (i.getNeuralNetwork ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "neuralNetwork",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNeuralNetwork ();
    }

    // reservoir
    //
    if (i.getReservoir ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reservoir",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getReservoir ();
    }

    // reservoirCompact
    //
    if (i.getReservoirCompact ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reservoirCompact",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getReservoirCompact ();
    }

    // lorentGevers
    //
    if (i.getLorentGevers ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lorentGevers",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLorentGevers ();
    }

    // routing
    //
    if (i.getRouting ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "routing",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRouting ();
    }

    // srm
    //
    if (i.getSrm ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "srm",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSrm ();
    }

    // unitDelay
    //
    if (i.getUnitDelay ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unitDelay",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUnitDelay ();
    }

    // unitHydrograph
    //
    if (i.getUnitHydrograph ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unitHydrograph",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUnitHydrograph ();
    }

    // template
    //
    if (i.getTemplate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "template",
          e));

      a << *i.getTemplate ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AllocationTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // table
    //
    if (i.getTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "table",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTable ();
    }

    // tableExternal
    //
    if (i.getTableExternal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tableExternal",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTableExternal ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ATableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // row
    //
    for (ATableComplexType::RowConstIterator
         b (i.getRow ().begin ()), n (i.getRow ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "row",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputATableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // valueSelection
    //
    if (i.getValueSelection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueSelection",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getValueSelection ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputATableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    for (OutputATableComplexType::YConstIterator
         b (i.getY ().begin ()), n (i.getY ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydrologicalModelComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // submodel
    //
    for (HydrologicalModelComplexType::SubmodelConstIterator
         b (i.getSubmodel ().begin ()), n (i.getSubmodel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "submodel",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SubmodelComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // typicalProfile
    //
    if (i.getTypicalProfile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "typicalProfile",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTypicalProfile ();
    }

    // snowRainJunction
    //
    if (i.getSnowRainJunction ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "snowRainJunction",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSnowRainJunction ();
    }

    // evaporationPotential
    //
    if (i.getEvaporationPotential ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "evaporationPotential",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEvaporationPotential ();
    }

    // storageSystem
    //
    if (i.getStorageSystem ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageSystem",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStorageSystem ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReleaseTotalComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterReleaseTotalComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAREA ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputReleaseTotalComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // discharge
    //
    for (InputReleaseTotalComplexType::DischargeConstIterator
         b (i.getDischarge ().begin ()), n (i.getDischarge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discharge",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EvaporationPotentialComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterEvaporationPotentialComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ECORR
    //
    if (i.getECORR ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ECORR",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getECORR ();
    }

    // ETF
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ETF",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getETF ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputEvaporationPotentialComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EPM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EPM",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEPM ();
    }

    // TM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TM",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTM ();
    }

    // T
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "T",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getT ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputEvaporationPotentialComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEP ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TypicalProfileComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // data
    //
    for (TypicalProfileComplexType::DataConstIterator
         b (i.getData ().begin ()), n (i.getData ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DataTypicalProfileComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // monthOfYear
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monthOfYear",
          e));

      a << i.getMonthOfYear ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.getValue ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SnowRainJunctionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterSnowRainJunctionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // D
    //
    if (i.getD ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getD ();
    }

    // RFCF
    //
    if (i.getRFCF ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RFCF",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRFCF ();
    }

    // SFCF
    //
    if (i.getSFCF ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SFCF",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSFCF ();
    }

    // TT
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TT",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTT ();
    }

    // TTI
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TTI",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTTI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputSnowRainJunctionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // P
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getP ();
    }

    // T
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "T",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getT ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputSnowRainJunctionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // RF
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RF",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRF ();
    }

    // SF
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SF",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSF ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // settings
    //
    if (i.getSettings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settings",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSettings ();
    }

    // storageNode
    //
    for (StorageSystemComplexType::StorageNodeConstIterator
         b (i.getStorageNode ().begin ()), n (i.getStorageNode ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageNode",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // link
    //
    for (StorageSystemComplexType::LinkConstIterator
         b (i.getLink ().begin ()), n (i.getLink ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "link",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // output
    //
    if (i.getOutput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StorageSystemSettingsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // convergenceThreshold
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "convergenceThreshold",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getConvergenceThreshold ());
    }

    // acceptableConvergenceThreshold
    //
    if (i.getAcceptableConvergenceThreshold ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "acceptableConvergenceThreshold",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getAcceptableConvergenceThreshold ());
    }

    // treatNonConvergenceAsError
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "treatNonConvergenceAsError",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTreatNonConvergenceAsError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nJac
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nJac",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNJac ();
    }

    // nFun
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nFun",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNFun ();
    }

    // res
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "res",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRes ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NodeStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // stateMin
    //
    if (i.getStateMin ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stateMin",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStateMin ();
    }

    // stateMax
    //
    if (i.getStateMax ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stateMax",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStateMax ();
    }

    // input
    //
    if (i.getInput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInput ();
    }

    // state
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getState ();
    }

    // residuum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "residuum",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getResiduum ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputNodeStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // discharge
    //
    for (InputNodeStorageSystemComplexType::DischargeConstIterator
         b (i.getDischarge ().begin ()), n (i.getDischarge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discharge",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // unitVolume
    //
    for (InputNodeStorageSystemComplexType::UnitVolumeConstIterator
         b (i.getUnitVolume ().begin ()), n (i.getUnitVolume ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unitVolume",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // state
    //
    if (i.getState ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getState ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LinkStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // capillaryFlow
    //
    if (i.getCapillaryFlow ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capillaryFlow",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCapillaryFlow ();
    }

    // evaporationActual
    //
    if (i.getEvaporationActual ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "evaporationActual",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEvaporationActual ();
    }

    // evaporationInterception
    //
    if (i.getEvaporationInterception ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "evaporationInterception",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEvaporationInterception ();
    }

    // groundwaterFlow
    //
    if (i.getGroundwaterFlow ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "groundwaterFlow",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getGroundwaterFlow ();
    }

    // percolation
    //
    if (i.getPercolation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "percolation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPercolation ();
    }

    // releaseInterception
    //
    if (i.getReleaseInterception ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "releaseInterception",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getReleaseInterception ();
    }

    // response
    //
    if (i.getResponse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "response",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getResponse ();
    }

    // sewerOverflow
    //
    if (i.getSewerOverflow ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sewerOverflow",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSewerOverflow ();
    }

    // soilRunoff
    //
    if (i.getSoilRunoff ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "soilRunoff",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSoilRunoff ();
    }

    // wasteWaterTreatmentPlant
    //
    if (i.getWasteWaterTreatmentPlant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "wasteWaterTreatmentPlant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWasteWaterTreatmentPlant ();
    }

    // waterDistributionConstant
    //
    if (i.getWaterDistributionConstant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "waterDistributionConstant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWaterDistributionConstant ();
    }

    // waterDistributionVariable
    //
    if (i.getWaterDistributionVariable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "waterDistributionVariable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWaterDistributionVariable ();
    }

    // meltRefreezing
    //
    if (i.getMeltRefreezing ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "meltRefreezing",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMeltRefreezing ();
    }

    // releaseWaterContent
    //
    if (i.getReleaseWaterContent ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "releaseWaterContent",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getReleaseWaterContent ();
    }

    // irrigation
    //
    if (i.getIrrigation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "irrigation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getIrrigation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputLinkStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // H
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "H",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getH ();
    }

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MeltRefreezingStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // nodeU
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeU",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeU ();
    }

    // nodeD
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeD",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeD ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterMeltRefreezingStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // CFMAX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CFMAX",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCFMAX ();
    }

    // CFR
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CFR",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCFR ();
    }

    // M
    //
    if (i.getM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "M",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getM ();
    }

    // TTM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TTM",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTTM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReleaseWaterContentStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // nodeU
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeU",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeU ();
    }

    // nodeA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeA ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterReleaseWaterContentStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // WHC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "WHC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getWHC ();
    }

    // M
    //
    if (i.getM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "M",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EvaporationInterceptionStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputEvaporationInterceptionStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // EP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEP ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterEvaporationInterceptionStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReleaseAboveThresholdStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterReleaseAboveThresholdStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // FRAC
    //
    if (i.getFRAC ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FRAC",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFRAC ();
    }

    // LIC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LIC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLIC ();
    }

    // M
    //
    if (i.getM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "M",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputReleaseAboveThresholdStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    if (i.getHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IrrigationStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // nodeU
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeU",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeU ();
    }

    // nodeD
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeD",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeD ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterIrrigationStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // IRR_CONST
    //
    if (i.getIRR_CONST ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IRR_CONST",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getIRR_CONST ();
    }

    // IRR_THR
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IRR_THR",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getIRR_THR ();
    }

    // M
    //
    if (i.getM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "M",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const WaterDistributionConstantStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterWaterDistributionConstantStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // D
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getD ();
    }

    // MIN_UP
    //
    if (i.getMIN_UP ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MIN_UP",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMIN_UP ();
    }

    // M
    //
    if (i.getM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "M",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputWaterDistributionConstantStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    if (i.getHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const WaterDistributionVariableStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterWaterDistributionVariableStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // MIN_UP
    //
    if (i.getMIN_UP ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MIN_UP",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMIN_UP ();
    }

    // M
    //
    if (i.getM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "M",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputWaterDistributionVariableStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    if (i.getHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHDown ();
    }

    // D
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getD ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GroundwaterFlowStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputGroundwaterFlowStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParametergroundwaterFlowStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ALPHA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ALPHA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getALPHA ();
    }

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // K
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "K",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getK ();
    }

    // MAX_GFLOW
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MAX_GFLOW",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMAX_GFLOW ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EvaporationActualStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputEvaporationActualStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // EP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEP ();
    }

    // EI
    //
    if (i.getEI ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EI",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterEvaporationActualStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // D
    //
    if (i.getD ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getD ();
    }

    // FC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getFC ();
    }

    // LP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLP ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SoilRunoffStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputSoilRunoffStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    if (i.getHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHDown ();
    }

    // INF
    //
    for (InputSoilRunoffStorageSystemComplexType::INFConstIterator
         b (i.getINF ().begin ()), n (i.getINF ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "INF",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterSoilRunoffStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // BETA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BETA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getBETA ();
    }

    // FC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getFC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CapillaryFlowStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputCapillaryFlowStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterCapillaryFlowStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // CFLUX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CFLUX",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCFLUX ();
    }

    // FC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getFC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ResponseStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterResponseStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // K
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "K",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getK ();
    }

    // ALPHA
    //
    if (i.getALPHA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ALPHA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getALPHA ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputResponseStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PercolationStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterPercolationStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    if (i.getAREA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAREA ();
    }

    // PERC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PERC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPERC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputPercolationStorageSystemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    if (i.getHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ArmaComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // arCoef
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arCoef",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getArCoef ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ArmaInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // obs
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "obs",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getObs ();
    }

    // sim
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sim",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSim ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ArmaOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // arma
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arma",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getArma ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AccumulationComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // multiplier
    //
    if (i.getMultiplier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "multiplier",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getMultiplier ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AccumulationInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AccumulationOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GradientComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // multiplier
    //
    if (i.getMultiplier ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "multiplier",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getMultiplier ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GradientInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GradientOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // dx
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dx",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDx ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameterSoil
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterSoil",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterSoil ();
    }

    // parameterResponse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterResponse",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterResponse ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // state
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getState ();
    }

    // stateUpdate
    //
    if (i.getStateUpdate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stateUpdate",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStateUpdate ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversParameterSoilComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // BETA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BETA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getBETA ();
    }

    // PMAX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PMAX",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPMAX ();
    }

    // SMAX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SMAX",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSMAX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversParameterResponseComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AREA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAREA ();
    }

    // KS
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KS",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getKS ();
    }

    // TS1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TS1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTS1 ();
    }

    // TS2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TS2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTS2 ();
    }

    // KB
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KB",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getKB ();
    }

    // TB1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TB1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTB1 ();
    }

    // TB2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TB2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTB2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEP ();
    }

    // P
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getP ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversStateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // S
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "S",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getS ();
    }

    // QS1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QS1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQS1 ();
    }

    // QS2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QS2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQS2 ();
    }

    // QB1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QB1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQB1 ();
    }

    // QB2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QB2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQB2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversStateUpdateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // S
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "S",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getS ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LorentGeversOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameterInput
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterInput",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterInput ();
    }

    // parameterSnow
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterSnow",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterSnow ();
    }

    // parameterInterception
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterInterception",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterInterception ();
    }

    // parameterSoil
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterSoil",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterSoil ();
    }

    // parameterResponse
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterResponse",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterResponse ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // link
    //
    if (i.getLink ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "link",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLink ();
    }

    // state
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getState ();
    }

    // stateUpdate
    //
    if (i.getStateUpdate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stateUpdate",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStateUpdate ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVParameterInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ECORR
    //
    if (i.getECORR ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ECORR",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getECORR ();
    }

    // RFCF
    //
    if (i.getRFCF ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RFCF",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRFCF ();
    }

    // SFCF
    //
    if (i.getSFCF ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SFCF",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSFCF ();
    }

    // TT
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TT",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTT ();
    }

    // TTI
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TTI",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTTI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVParameterSnowComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // CFMAX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CFMAX",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCFMAX ();
    }

    // CFR
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CFR",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCFR ();
    }

    // CWH
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CWH",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCWH ();
    }

    // TTM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TTM",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTTM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVParameterInterceptionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // LIC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LIC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLIC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVParameterSoilComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // BETA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BETA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getBETA ();
    }

    // CFLUX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CFLUX",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCFLUX ();
    }

    // ETF
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ETF",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getETF ();
    }

    // FC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getFC ();
    }

    // LP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLP ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVParameterResponseComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ALPHA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ALPHA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getALPHA ();
    }

    // AREA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AREA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAREA ();
    }

    // K
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "K",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getK ();
    }

    // K1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "K1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getK1 ();
    }

    // PERC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PERC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPERC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEP ();
    }

    // P
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getP ();
    }

    // T
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "T",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getT ();
    }

    // TM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TM",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVLinkComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // CF
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CF",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCF ();
    }

    // EA
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EA",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEA ();
    }

    // EI
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EI",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEI ();
    }

    // EP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEP ();
    }

    // IN
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IN",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getIN ();
    }

    // INI
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "INI",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getINI ();
    }

    // PERC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PERC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPERC ();
    }

    // R
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "R",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getR ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVStateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // IC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getIC ();
    }

    // LZ
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LZ",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLZ ();
    }

    // SM
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SM",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSM ();
    }

    // SP
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SP",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSP ();
    }

    // UZ
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UZ",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getUZ ();
    }

    // WC
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "WC",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getWC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVStateUpdateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // IC
    //
    if (i.getIC ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IC",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getIC ();
    }

    // LZ
    //
    if (i.getLZ ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LZ",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLZ ();
    }

    // SM
    //
    if (i.getSM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SM",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSM ();
    }

    // SP
    //
    if (i.getSP ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SP",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSP ();
    }

    // UZ
    //
    if (i.getUZ ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UZ",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUZ ();
    }

    // WC
    //
    if (i.getWC ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "WC",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HBVOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }

    // SMPercentage
    //
    if (i.getSMPercentage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SMPercentage",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSMPercentage ();
    }

    // SWE
    //
    if (i.getSWE ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SWE",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSWE ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SRMComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameter ();
    }

    // parameterZone
    //
    for (SRMComplexType::ParameterZoneConstIterator
         b (i.getParameterZone ().begin ()), n (i.getParameterZone ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterZone",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // state
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getState ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SRMParameterComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Pt
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Pt",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPt ();
    }

    // TLag
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TLag",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTLag ();
    }

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SRMParameterZoneComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // a
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "a",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getA ();
    }

    // area
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "area",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getArea ();
    }

    // Tcr1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Tcr1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTcr1 ();
    }

    // Tcr2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Tcr2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTcr2 ();
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SRMInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // P
    //
    if (i.getP ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getP ();
    }

    // P-Vector
    //
    if (i.getP_Vector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getP_Vector ();
    }

    // T
    //
    if (i.getT ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "T",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getT ();
    }

    // T-Vector
    //
    if (i.getT_Vector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "T-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getT_Vector ();
    }

    // SCA
    //
    if (i.getSCA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SCA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSCA ();
    }

    // SCA-Vector
    //
    if (i.getSCA_Vector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SCA-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSCA_Vector ();
    }

    // RCA
    //
    if (i.getRCA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RCA",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRCA ();
    }

    // RCA-Vector
    //
    if (i.getRCA_Vector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RCA-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRCA_Vector ();
    }

    // cr
    //
    if (i.getCr ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cr",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCr ();
    }

    // cr-Vector
    //
    if (i.getCr_Vector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cr-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCr_Vector ();
    }

    // cs
    //
    if (i.getCs ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cs",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCs ();
    }

    // cs-Vector
    //
    if (i.getCs_Vector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cs-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCs_Vector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SRMStateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PStorage-Vector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PStorage-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPStorage_Vector ();
    }

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SRMOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // QRain-Vector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QRain-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQRain_Vector ();
    }

    // QSnow-Vector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QSnow-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQSnow_Vector ();
    }

    // QStorage-Vector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QStorage-Vector",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQStorage_Vector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitDelayComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nStep
    //
    if (i.getNStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStep ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitDelayInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitDelayOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    for (UnitDelayOutputComplexType::YConstIterator
         b (i.getY ().begin ()), n (i.getY ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // yVector
    //
    if (i.getYVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYVector ();
    }

    // yFinal
    //
    if (i.getYFinal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yFinal",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYFinal ();
    }

    // yMin
    //
    if (i.getYMin ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMin",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYMin ();
    }

    // yMean
    //
    if (i.getYMean ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMean",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYMean ();
    }

    // yMax
    //
    if (i.getYMax ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMax",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYMax ();
    }

    // ySum
    //
    if (i.getYSum ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ySum",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYSum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitHydrographComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // weights
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weights",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getWeights ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitHydrographWeightComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // triangular
    //
    if (i.getTriangular ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "triangular",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTriangular ();
    }

    // custom
    //
    if (i.getCustom ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "custom",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCustom ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitHydrographWeightTriangularComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nSteps
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNSteps ();
    }

    // factor
    //
    if (i.getFactor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "factor",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getFactor ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitHydrographWeightCustomComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // weight
    //
    for (UnitHydrographWeightCustomComplexType::WeightConstIterator
         b (i.getWeight ().begin ()), n (i.getWeight ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weight",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble (*b);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitHydrographInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitHydrographOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // xDelay
    //
    for (UnitHydrographOutputComplexType::XDelayConstIterator
         b (i.getXDelay ().begin ()), n (i.getXDelay ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xDelay",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // xDelayVector
    //
    if (i.getXDelayVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xDelayVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getXDelayVector ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirCompactComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // units
    //
    if (i.getUnits ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "units",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUnits ();
    }

    // levelStorageTable
    //
    if (i.getLevelStorageTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "levelStorageTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLevelStorageTable ();
    }

    // levelStorageTableExternal
    //
    if (i.getLevelStorageTableExternal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "levelStorageTableExternal",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLevelStorageTableExternal ();
    }

    // levelStorageEquation
    //
    if (i.getLevelStorageEquation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "levelStorageEquation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLevelStorageEquation ();
    }

    // tailwaterTable
    //
    if (i.getTailwaterTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwaterTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwaterTable ();
    }

    // tailwaterEquation
    //
    if (i.getTailwaterEquation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwaterEquation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwaterEquation ();
    }

    // tailwaterTidalEquation
    //
    if (i.getTailwaterTidalEquation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwaterTidalEquation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwaterTidalEquation ();
    }

    // tailwaterExternalTable
    //
    if (i.getTailwaterExternalTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwaterExternalTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwaterExternalTable ();
    }

    // tailwaterExternalTimeSeries
    //
    if (i.getTailwaterExternalTimeSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwaterExternalTimeSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwaterExternalTimeSeries ();
    }

    // tailwaterConstant
    //
    if (i.getTailwaterConstant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwaterConstant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwaterConstant ();
    }

    // turbineEfficiencyConstant
    //
    if (i.getTurbineEfficiencyConstant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "turbineEfficiencyConstant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTurbineEfficiencyConstant ();
    }

    // turbineEfficiencyTable
    //
    if (i.getTurbineEfficiencyTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "turbineEfficiencyTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTurbineEfficiencyTable ();
    }

    // turbineEfficiencyTableExternal
    //
    if (i.getTurbineEfficiencyTableExternal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "turbineEfficiencyTableExternal",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTurbineEfficiencyTableExternal ();
    }

    // turbineEfficiencyTable2D
    //
    if (i.getTurbineEfficiencyTable2D ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "turbineEfficiencyTable2D",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTurbineEfficiencyTable2D ();
    }

    // turbineEfficiencyTable2DExternal
    //
    if (i.getTurbineEfficiencyTable2DExternal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "turbineEfficiencyTable2DExternal",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTurbineEfficiencyTable2DExternal ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LevelStorageEquationComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // A0
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A0",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getA0 ());
    }

    // A1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A1",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getA1 ());
    }

    // A2
    //
    if (i.getA2 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A2",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getA2 ());
    }

    // A3
    //
    if (i.getA3 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A3",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getA3 ());
    }

    // A4
    //
    if (i.getA4 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A4",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getA4 ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TailwaterEquationComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // A
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getA ();
    }

    // B
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "B",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getB ();
    }

    // C
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "C",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getC ();
    }

    // D
    //
    if (i.getD ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getD ();
    }

    // FBDown
    //
    if (i.getFBDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FBDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFBDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TailwaterTidalEquationComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // A
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "A",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getA ();
    }

    // TWObs
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TWObs",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTWObs ();
    }

    // QObs
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QObs",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQObs ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineEfficiencyTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // columns
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "columns",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getColumns ();
    }

    // row
    //
    for (TurbineEfficiencyTableComplexType::RowConstIterator
         b (i.getRow ().begin ()), n (i.getRow ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "row",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // maxFlows
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maxFlows",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMaxFlows ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ColumnsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // head01
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head01",
          e));

      a << ::xml_schema::AsDouble(i.getHead01 ());
    }

    // head02
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head02",
          e));

      a << ::xml_schema::AsDouble(i.getHead02 ());
    }

    // head03
    //
    if (i.getHead03 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head03",
          e));

      a << ::xml_schema::AsDouble(*i.getHead03 ());
    }

    // head04
    //
    if (i.getHead04 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head04",
          e));

      a << ::xml_schema::AsDouble(*i.getHead04 ());
    }

    // head05
    //
    if (i.getHead05 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head05",
          e));

      a << ::xml_schema::AsDouble(*i.getHead05 ());
    }

    // head06
    //
    if (i.getHead06 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head06",
          e));

      a << ::xml_schema::AsDouble(*i.getHead06 ());
    }

    // head07
    //
    if (i.getHead07 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head07",
          e));

      a << ::xml_schema::AsDouble(*i.getHead07 ());
    }

    // head08
    //
    if (i.getHead08 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head08",
          e));

      a << ::xml_schema::AsDouble(*i.getHead08 ());
    }

    // head09
    //
    if (i.getHead09 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head09",
          e));

      a << ::xml_schema::AsDouble(*i.getHead09 ());
    }

    // head10
    //
    if (i.getHead10 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head10",
          e));

      a << ::xml_schema::AsDouble(*i.getHead10 ());
    }

    // head11
    //
    if (i.getHead11 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head11",
          e));

      a << ::xml_schema::AsDouble(*i.getHead11 ());
    }

    // head12
    //
    if (i.getHead12 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head12",
          e));

      a << ::xml_schema::AsDouble(*i.getHead12 ());
    }

    // head13
    //
    if (i.getHead13 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head13",
          e));

      a << ::xml_schema::AsDouble(*i.getHead13 ());
    }

    // head14
    //
    if (i.getHead14 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head14",
          e));

      a << ::xml_schema::AsDouble(*i.getHead14 ());
    }

    // head15
    //
    if (i.getHead15 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head15",
          e));

      a << ::xml_schema::AsDouble(*i.getHead15 ());
    }

    // head16
    //
    if (i.getHead16 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head16",
          e));

      a << ::xml_schema::AsDouble(*i.getHead16 ());
    }

    // head17
    //
    if (i.getHead17 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head17",
          e));

      a << ::xml_schema::AsDouble(*i.getHead17 ());
    }

    // head18
    //
    if (i.getHead18 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head18",
          e));

      a << ::xml_schema::AsDouble(*i.getHead18 ());
    }

    // head19
    //
    if (i.getHead19 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head19",
          e));

      a << ::xml_schema::AsDouble(*i.getHead19 ());
    }

    // head20
    //
    if (i.getHead20 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "head20",
          e));

      a << ::xml_schema::AsDouble(*i.getHead20 ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RowComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flow
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "flow",
          e));

      a << ::xml_schema::AsDouble(i.getFlow ());
    }

    // eta_head01
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head01",
          e));

      a << ::xml_schema::AsDouble(i.getEta_head01 ());
    }

    // eta_head02
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head02",
          e));

      a << ::xml_schema::AsDouble(i.getEta_head02 ());
    }

    // eta_head03
    //
    if (i.getEta_head03 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head03",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head03 ());
    }

    // eta_head04
    //
    if (i.getEta_head04 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head04",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head04 ());
    }

    // eta_head05
    //
    if (i.getEta_head05 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head05",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head05 ());
    }

    // eta_head06
    //
    if (i.getEta_head06 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head06",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head06 ());
    }

    // eta_head07
    //
    if (i.getEta_head07 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head07",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head07 ());
    }

    // eta_head08
    //
    if (i.getEta_head08 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head08",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head08 ());
    }

    // eta_head09
    //
    if (i.getEta_head09 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head09",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head09 ());
    }

    // eta_head10
    //
    if (i.getEta_head10 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head10",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head10 ());
    }

    // eta_head11
    //
    if (i.getEta_head11 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head11",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head11 ());
    }

    // eta_head12
    //
    if (i.getEta_head12 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head12",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head12 ());
    }

    // eta_head13
    //
    if (i.getEta_head13 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head13",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head13 ());
    }

    // eta_head14
    //
    if (i.getEta_head14 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head14",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head14 ());
    }

    // eta_head15
    //
    if (i.getEta_head15 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head15",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head15 ());
    }

    // eta_head16
    //
    if (i.getEta_head16 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head16",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head16 ());
    }

    // eta_head17
    //
    if (i.getEta_head17 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head17",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head17 ());
    }

    // eta_head18
    //
    if (i.getEta_head18 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head18",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head18 ());
    }

    // eta_head19
    //
    if (i.getEta_head19 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head19",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head19 ());
    }

    // eta_head20
    //
    if (i.getEta_head20 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eta_head20",
          e));

      a << ::xml_schema::AsDouble(*i.getEta_head20 ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MaxFlowsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // maxFlow_head01
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head01",
          e));

      a << ::xml_schema::AsDouble(i.getMaxFlow_head01 ());
    }

    // maxFlow_head02
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head02",
          e));

      a << ::xml_schema::AsDouble(i.getMaxFlow_head02 ());
    }

    // maxFlow_head03
    //
    if (i.getMaxFlow_head03 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head03",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head03 ());
    }

    // maxFlow_head04
    //
    if (i.getMaxFlow_head04 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head04",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head04 ());
    }

    // maxFlow_head05
    //
    if (i.getMaxFlow_head05 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head05",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head05 ());
    }

    // maxFlow_head06
    //
    if (i.getMaxFlow_head06 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head06",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head06 ());
    }

    // maxFlow_head07
    //
    if (i.getMaxFlow_head07 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head07",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head07 ());
    }

    // maxFlow_head08
    //
    if (i.getMaxFlow_head08 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head08",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head08 ());
    }

    // maxFlow_head09
    //
    if (i.getMaxFlow_head09 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head09",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head09 ());
    }

    // maxFlow_head10
    //
    if (i.getMaxFlow_head10 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head10",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head10 ());
    }

    // maxFlow_head11
    //
    if (i.getMaxFlow_head11 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head11",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head11 ());
    }

    // maxFlow_head12
    //
    if (i.getMaxFlow_head12 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head12",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head12 ());
    }

    // maxFlow_head13
    //
    if (i.getMaxFlow_head13 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head13",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head13 ());
    }

    // maxFlow_head14
    //
    if (i.getMaxFlow_head14 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head14",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head14 ());
    }

    // maxFlow_head15
    //
    if (i.getMaxFlow_head15 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head15",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head15 ());
    }

    // maxFlow_head16
    //
    if (i.getMaxFlow_head16 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head16",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head16 ());
    }

    // maxFlow_head17
    //
    if (i.getMaxFlow_head17 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head17",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head17 ());
    }

    // maxFlow_head18
    //
    if (i.getMaxFlow_head18 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head18",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head18 ());
    }

    // maxFlow_head19
    //
    if (i.getMaxFlow_head19 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head19",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head19 ());
    }

    // maxFlow_head20
    //
    if (i.getMaxFlow_head20 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxFlow_head20",
          e));

      a << ::xml_schema::AsDouble(*i.getMaxFlow_head20 ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirCompactInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // FB
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FB",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getFB ();
    }

    // QI
    //
    for (ReservoirCompactInputComplexType::QIConstIterator
         b (i.getQI ().begin ()), n (i.getQI ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QI",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }

    // QSPercentage
    //
    if (i.getQSPercentage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QSPercentage",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQSPercentage ();
    }

    // QSPercentageValue
    //
    if (i.getQSPercentageValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QSPercentageValue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQSPercentageValue ();
    }

    // QS
    //
    if (i.getQS ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QS",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQS ();
    }

    // QSValue
    //
    if (i.getQSValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QSValue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQSValue ();
    }

    // QMISC
    //
    if (i.getQMISC ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QMISC",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQMISC ();
    }

    // PM
    //
    if (i.getPM ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PM",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPM ();
    }

    // PMValue
    //
    if (i.getPMValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PMValue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPMValue ();
    }

    // PX
    //
    if (i.getPX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PX",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPX ();
    }

    // PXValue
    //
    if (i.getPXValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PXValue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPXValue ();
    }

    // QTX
    //
    if (i.getQTX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QTX",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQTX ();
    }

    // QTXValue
    //
    if (i.getQTXValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QTXValue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQTXValue ();
    }

    // OF
    //
    if (i.getOF ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OF",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getOF ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirCompactOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // S
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "S",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getS ();
    }

    // FB
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FB",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getFB ();
    }

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }

    // QI
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QI",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQI ();
    }

    // QT
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QT",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQT ();
    }

    // QTX
    //
    if (i.getQTX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QTX",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQTX ();
    }

    // QS
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QS",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQS ();
    }

    // QSPercentage
    //
    if (i.getQSPercentage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QSPercentage",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQSPercentage ();
    }

    // QMISC
    //
    if (i.getQMISC ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QMISC",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getQMISC ();
    }

    // DQ
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DQ",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDQ ();
    }

    // TW
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TW",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTW ();
    }

    // H
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "H",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getH ();
    }

    // P
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getP ();
    }

    // PX
    //
    if (i.getPX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PX",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPX ();
    }

    // R
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "R",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getR ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mode
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mode",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMode ();
    }

    // theta
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "theta",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getTheta ());
    }

    // storageCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageCharacteristics ();
    }

    // controlledOutlet
    //
    for (ReservoirComplexType::ControlledOutletConstIterator
         b (i.getControlledOutlet ().begin ()), n (i.getControlledOutlet ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "controlledOutlet",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // uncontrolledOutlet
    //
    for (ReservoirComplexType::UncontrolledOutletConstIterator
         b (i.getUncontrolledOutlet ().begin ()), n (i.getUncontrolledOutlet ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "uncontrolledOutlet",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // tailwater
    //
    if (i.getTailwater ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tailwater",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTailwater ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RoutingComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // inflow
    //
    for (RoutingComplexType::InflowConstIterator
         b (i.getInflow ().begin ()), n (i.getInflow ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inflow",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // reservoirRouting
    //
    if (i.getReservoirRouting ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reservoirRouting",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getReservoirRouting ();
    }

    // dischargeRef
    //
    if (i.getDischargeRef ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dischargeRef",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDischargeRef ();
    }

    // outputReferences
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "outputReferences",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutputReferences ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuralNetworkComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // layer
    //
    for (NeuralNetworkComplexType::LayerConstIterator
         b (i.getLayer ().begin ()), n (i.getLayer ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "layer",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LayerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // neuron
    //
    for (LayerComplexType::NeuronConstIterator
         b (i.getNeuron ().begin ()), n (i.getNeuron ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "neuron",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuronComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // bias
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bias",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getBias ();
    }

    // transferFunction
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transferFunction",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTransferFunction ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuronInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // external
    //
    for (NeuronInputComplexType::ExternalConstIterator
         b (i.getExternal ().begin ()), n (i.getExternal ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "external",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // internal
    //
    for (NeuronInputComplexType::InternalConstIterator
         b (i.getInternal ().begin ()), n (i.getInternal ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "internal",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuronOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydraulicModelComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mode
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mode",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMode ();
    }

    // sequentialImplicitSettings
    //
    if (i.getSequentialImplicitSettings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequentialImplicitSettings",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSequentialImplicitSettings ();
    }

    // simultaneousSettings
    //
    if (i.getSimultaneousSettings ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simultaneousSettings",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSimultaneousSettings ();
    }

    // numericalTolerance
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "numericalTolerance",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getNumericalTolerance ());
    }

    // node
    //
    for (HydraulicModelComplexType::NodeConstIterator
         b (i.getNode ().begin ()), n (i.getNode ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // branch
    //
    for (HydraulicModelComplexType::BranchConstIterator
         b (i.getBranch ().begin ()), n (i.getBranch ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "branch",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // hydraulicStructure
    //
    for (HydraulicModelComplexType::HydraulicStructureConstIterator
         b (i.getHydraulicStructure ().begin ()), n (i.getHydraulicStructure ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hydraulicStructure",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // output
    //
    if (i.getOutput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydraulicModelSequentialImplicitComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // theta
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "theta",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getTheta ());
    }

    // convergenceThreshold
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "convergenceThreshold",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getConvergenceThreshold ());
    }

    // treatNonConvergenceAsError
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "treatNonConvergenceAsError",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTreatNonConvergenceAsError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydraulicModelSimultaneousComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // theta
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "theta",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getTheta ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydraulicModelOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nJac
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nJac",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNJac ();
    }

    // nFun
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nFun",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNFun ();
    }

    // res
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "res",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRes ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConnectionInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // upstreamLevel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upstreamLevel",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getUpstreamLevel ();
    }

    // downstreamLevel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "downstreamLevel",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDownstreamLevel ();
    }

    // discharge
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discharge",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDischarge ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConnectionOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // discharge
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discharge",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDischarge ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RoutingOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // discharge
    //
    if (i.getDischarge ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discharge",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDischarge ();
    }

    // error
    //
    if (i.getError ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirRoutingComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // simpleReservoir
    //
    for (ReservoirRoutingComplexType::SimpleReservoirConstIterator
         b (i.getSimpleReservoir ().begin ()), n (i.getSimpleReservoir ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simpleReservoir",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SimpleReservoirComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // storageCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageCharacteristics ();
    }

    // capacityCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCapacityCharacteristics ();
    }

    // multiplier
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "multiplier",
          e));

      a << i.getMultiplier ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConnectionCoefficientsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // a
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "a",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getA ();
    }

    // b
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "b",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getB ();
    }

    // c
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "c",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getC ();
    }

    // d
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "d",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getD ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RulesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // rule
    //
    for (RulesComplexType::RuleConstIterator
         b (i.getRule ().begin ()), n (i.getRule ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rule",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // constant
    //
    if (i.getConstant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getConstant ();
    }

    // dateLookupTable
    //
    if (i.getDateLookupTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateLookupTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDateLookupTable ();
    }

    // deadBandValue
    //
    if (i.getDeadBandValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deadBandValue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeadBandValue ();
    }

    // deadBandTime
    //
    if (i.getDeadBandTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deadBandTime",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeadBandTime ();
    }

    // dedicated-Aebi
    //
    if (i.getDedicated_Aebi ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dedicated-Aebi",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDedicated_Aebi ();
    }

    // dedicated-Thunersee
    //
    if (i.getDedicated_Thunersee ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dedicated-Thunersee",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDedicated_Thunersee ();
    }

    // expression
    //
    if (i.getExpression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getExpression ();
    }

    // guideband
    //
    if (i.getGuideband ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "guideband",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getGuideband ();
    }

    // interval
    //
    if (i.getInterval ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interval",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInterval ();
    }

    // limiter
    //
    if (i.getLimiter ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "limiter",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLimiter ();
    }

    // lookupTable
    //
    if (i.getLookupTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookupTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLookupTable ();
    }

    // lookup2DTable
    //
    if (i.getLookup2DTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookup2DTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLookup2DTable ();
    }

    // merger
    //
    if (i.getMerger ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "merger",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMerger ();
    }

    // pid
    //
    if (i.getPid ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pid",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPid ();
    }

    // timeAbsolute
    //
    if (i.getTimeAbsolute ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeAbsolute",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeAbsolute ();
    }

    // timeRelative
    //
    if (i.getTimeRelative ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeRelative",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeRelative ();
    }

    // unitDelay
    //
    if (i.getUnitDelay ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unitDelay",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUnitDelay ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ThunerseeRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // levelSetpoint
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "levelSetpoint",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getLevelSetpoint ());
    }

    // releaseLimiterPercentage
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "releaseLimiterPercentage",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getReleaseLimiterPercentage ());
    }

    // reservoir
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reservoir",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getReservoir ();
    }

    // weir
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weir",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getWeir ();
    }

    // tunnel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tunnel",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTunnel ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirThunerseeRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // storageCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageCharacteristics ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const WeirThunerseeRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // capacityCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCapacityCharacteristics ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TunnelThunerseeRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // levelThreshold
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "levelThreshold",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getLevelThreshold ());
    }

    // capacityCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCapacityCharacteristics ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ThunerseeRuleInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // inflow
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inflow",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInflow ();
    }

    // level
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "level",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLevel ();
    }

    // catchment
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "catchment",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCatchment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ThunerseeRuleOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // releaseWeir
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "releaseWeir",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getReleaseWeir ();
    }

    // releaseTunnel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "releaseTunnel",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getReleaseTunnel ();
    }

    // releaseTotal
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "releaseTotal",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getReleaseTotal ();
    }

    // active
    //
    if (i.getActive ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "active",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getActive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AebiRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // FactorRTG
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FactorRTG",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getFactorRTG ());
    }

    // LangeteFall
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LangeteFall",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLangeteFall ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AebiRuleInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AareBruegg
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AareBruegg",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAareBruegg ();
    }

    // AareBrueggMin2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AareBrueggMin2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAareBrueggMin2 ();
    }

    // Emenmatt
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Emenmatt",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEmenmatt ();
    }

    // EmenmattMin4
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EmenmattMin4",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEmenmattMin4 ();
    }

    // Langeten
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Langeten",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLangeten ();
    }

    // LangetenMin4
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LangetenMin4",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLangetenMin4 ();
    }

    // AareMurg
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AareMurg",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAareMurg ();
    }

    // PegelBielersee
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PegelBielersee",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPegelBielersee ();
    }

    // AbflussReglementPort
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AbflussReglementPort",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAbflussReglementPort ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AebiRuleOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // RTG
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RTG",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRTG ();
    }

    // AareMurg_oKWMin1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AareMurg_oKWMin1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAareMurg_oKWMin1 ();
    }

    // ProvMaxAbflussPort
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProvMaxAbflussPort",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getProvMaxAbflussPort ();
    }

    // MaxAbflussPort
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MaxAbflussPort",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMaxAbflussPort ();
    }

    // AbflussaenderungPort
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AbflussaenderungPort",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAbflussaenderungPort ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LookupTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // property
    //
    for (LookupTableComplexType::PropertyConstIterator
         b (i.getProperty ().begin ()), n (i.getProperty ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "property",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // table
    //
    if (i.getTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "table",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTable ();
    }

    // tableExternal
    //
    if (i.getTableExternal ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tableExternal",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTableExternal ();
    }

    // interpolationOption
    //
    if (i.getInterpolationOption ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interpolationOption",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInterpolationOption ();
    }

    // extrapolationOption
    //
    if (i.getExtrapolationOption ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extrapolationOption",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getExtrapolationOption ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TableLookupTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // record
    //
    for (TableLookupTableComplexType::RecordConstIterator
         b (i.getRecord ().begin ()), n (i.getRecord ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "record",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Lookup2DTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // table
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "table",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTable ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Table2DLookupTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }

    // matrix
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrix",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMatrix ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const XDimComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // xDim
    //
    for (XDimComplexType::XDimConstIterator
         b (i.getXDim ().begin ()), n (i.getXDim ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xDim",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const YDimComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // yDim
    //
    for (YDimComplexType::YDimConstIterator
         b (i.getYDim ().begin ()), n (i.getYDim ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yDim",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ValueArrayComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value
    //
    for (ValueArrayComplexType::ValueConstIterator
         b (i.getValue ().begin ()), n (i.getValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IntervalComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // settingBelow
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingBelow",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getSettingBelow ());
    }

    // settingAbove
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingAbove",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getSettingAbove ());
    }

    // settingMaxSpeed
    //
    if (i.getSettingMaxSpeed ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingMaxSpeed",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSettingMaxSpeed ());
    }

    // settingMaxStep
    //
    if (i.getSettingMaxStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingMaxStep",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSettingMaxStep ());
    }

    // deadbandSetpointAbsolute
    //
    if (i.getDeadbandSetpointAbsolute ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deadbandSetpointAbsolute",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getDeadbandSetpointAbsolute ());
    }

    // deadbandSetpointRelative
    //
    if (i.getDeadbandSetpointRelative ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deadbandSetpointRelative",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getDeadbandSetpointRelative ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IntervalInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // setpoint
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setpoint",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSetpoint ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const IntervalOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }

    // status
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "status",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStatus ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateLookupTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // interpolationOptions
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interpolationOptions",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInterpolationOptions ();
    }

    // dateRecord
    //
    for (DateLookupTableComplexType::DateRecordConstIterator
         b (i.getDateRecord ().begin ()), n (i.getDateRecord ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateRecord",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InterpolationOptionsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // date
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "date",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDate ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateRecord2ComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // record
    //
    for (DateRecord2ComplexType::RecordConstIterator
         b (i.getRecord ().begin ()), n (i.getRecord ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "record",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // monthDay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monthDay",
          e));

      a << i.getMonthDay ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateRecord2DataComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << ::xml_schema::AsDouble(i.getX ());
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << ::xml_schema::AsDouble(i.getY ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateLookupTableInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    if (i.getY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateLookupTableOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }

    // active
    //
    if (i.getActive ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "active",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getActive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LookupTableInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    if (i.getY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LookupTableOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Lookup2DTableInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }

    // z
    //
    if (i.getZ ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "z",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getZ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Lookup2DTableOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // z
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "z",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getZ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PolygonLookupComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // polygons
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "polygons",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPolygons ();
    }

    // default
    //
    if (i.getDefault ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getDefault ());
    }

    // true
    //
    if (i.getTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "true",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTrue ();
    }

    // false
    //
    if (i.getFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "false",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFalse ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PolygonsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // polygon
    //
    for (PolygonsComplexType::PolygonConstIterator
         b (i.getPolygon ().begin ()), n (i.getPolygon ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "polygon",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PolygonComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value
    //
    if (i.getValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getValue ());
    }

    // edges
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edges",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEdges ();
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EdgesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // edge
    //
    for (EdgesComplexType::EdgeConstIterator
         b (i.getEdge ().begin ()), n (i.getEdge ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edge",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EdgeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x1",
          e));

      a << ::xml_schema::AsDouble(i.getX1 ());
    }

    // x2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x2",
          e));

      a << ::xml_schema::AsDouble(i.getX2 ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PolygonLookupInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX1 ();
    }

    // x2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PolygonLookupOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // status
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "status",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStatus ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpreadsheetComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // validPeriods
    //
    if (i.getValidPeriods ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "validPeriods",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getValidPeriods ();
    }

    // defaultInputValue
    //
    if (i.getDefaultInputValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "defaultInputValue",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getDefaultInputValue ());
    }

    // defaultOutputValue
    //
    if (i.getDefaultOutputValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "defaultOutputValue",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getDefaultOutputValue ());
    }

    // tolerance
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tolerance",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getTolerance ());
    }

    // tables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tables",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTables ();
    }

    // true
    //
    if (i.getTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "true",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTrue ();
    }

    // false
    //
    if (i.getFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "false",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFalse ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ValidPeriodsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // validPeriod
    //
    for (ValidPeriodsComplexType::ValidPeriodConstIterator
         b (i.getValidPeriod ().begin ()), n (i.getValidPeriod ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "validPeriod",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ValidPeriodComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // startDate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "startDate",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStartDate ();
    }

    // endDate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "endDate",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEndDate ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // monthDay
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monthDay",
          e));

      a << i.getMonthDay ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpreadsheetTablesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // table
    //
    for (SpreadsheetTablesComplexType::TableConstIterator
         b (i.getTable ().begin ()), n (i.getTable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "table",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpreadsheetTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // record
    //
    for (SpreadsheetTableComplexType::RecordConstIterator
         b (i.getRecord ().begin ()), n (i.getRecord ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "record",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // initialState
    //
    if (i.getInitialState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialState",
          e));

      a << ::xml_schema::AsDouble(*i.getInitialState ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpreadsheetRecordComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x1",
          e));

      a << ::xml_schema::AsDouble(i.getX1 ());
    }

    // x2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x2",
          e));

      a << ::xml_schema::AsDouble(i.getX2 ());
    }

    // x3
    //
    if (i.getX3 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x3",
          e));

      a << ::xml_schema::AsDouble(*i.getX3 ());
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << ::xml_schema::AsDouble(i.getY ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpreadsheetInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX1 ();
    }

    // x2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX2 ();
    }

    // x3
    //
    if (i.getX3 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x3",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX3 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpreadsheetOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // status
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "status",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStatus ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    for (MergerInputComplexType::XConstIterator
         b (i.getX ().begin ()), n (i.getX ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    if (i.getY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getY ();
    }

    // ySum
    //
    if (i.getYSum ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ySum",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYSum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerSplitterComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mode
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mode",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMode ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerSplitterInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    for (MergerSplitterInputComplexType::XConstIterator
         b (i.getX ().begin ()), n (i.getX ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // xVector
    //
    if (i.getXVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getXVector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerSplitterOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    for (MergerSplitterOutputComplexType::YConstIterator
         b (i.getY ().begin ()), n (i.getY ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeAbsoluteComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeAbsoluteInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeAbsoluteOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeRelativeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mode
    //
    if (i.getMode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mode",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMode ();
    }

    // valueOption
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueOption",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getValueOption ();
    }

    // maximumPeriod
    //
    if (i.getMaximumPeriod ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maximumPeriod",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getMaximumPeriod ());
    }

    // interpolationOption
    //
    if (i.getInterpolationOption ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interpolationOption",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInterpolationOption ();
    }

    // controlTable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "controlTable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getControlTable ();
    }

    // input
    //
    if (i.getInput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeRelativeControlTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // record
    //
    for (TimeRelativeControlTableComplexType::RecordConstIterator
         b (i.getRecord ().begin ()), n (i.getRecord ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "record",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeRelativeControlTableRecordComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << ::xml_schema::AsDouble(i.getTime ());
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.getValue ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeRelativeInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeRelativeOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }

    // timeActive
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeActive",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTimeActive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ExpressionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1Value
    //
    if (i.getX1Value ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Value",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Value ();
    }

    // x1Series
    //
    if (i.getX1Series ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Series",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Series ();
    }

    // x1SeriesVector
    //
    if (i.getX1SeriesVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1SeriesVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1SeriesVector ();
    }

    // mathematicalOperator
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mathematicalOperator",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMathematicalOperator ();
    }

    // x2Value
    //
    if (i.getX2Value ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Value",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Value ();
    }

    // x2Series
    //
    if (i.getX2Series ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Series",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Series ();
    }

    // x2SeriesVector
    //
    if (i.getX2SeriesVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2SeriesVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2SeriesVector ();
    }

    // y
    //
    if (i.getY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getY ();
    }

    // yVector
    //
    if (i.getYVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYVector ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandValueComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // threshold
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "threshold",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getThreshold ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandValueInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandTimeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // discrete
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discrete",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDiscrete ();
    }

    // true
    //
    if (i.getTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "true",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTrue ();
    }

    // false
    //
    if (i.getFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "false",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFalse ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandTimeDiscreteComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // numberOfStepsUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "numberOfStepsUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNumberOfStepsUp ();
    }

    // numberOfStepsDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "numberOfStepsDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNumberOfStepsDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandTimeInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandTimeOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // status
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "status",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStatus ();
    }

    // stepsUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stepsUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStepsUp ();
    }

    // stepsDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stepsDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStepsDown ();
    }

    // timeTrue
    //
    if (i.getTimeTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeTrue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeTrue ();
    }

    // timeFalse
    //
    if (i.getTimeFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeFalse",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeFalse ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LimiterComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mode
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mode",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMode ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LimiterInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // thresholdSeries
    //
    if (i.getThresholdSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "thresholdSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getThresholdSeries ();
    }

    // thresholdValue
    //
    if (i.getThresholdValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "thresholdValue",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getThresholdValue ());
    }

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TriggersComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // trigger
    //
    for (TriggersComplexType::TriggerConstIterator
         b (i.getTrigger ().begin ()), n (i.getTrigger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trigger",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TriggerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // standard
    //
    if (i.getStandard ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "standard",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStandard ();
    }

    // deadBand
    //
    if (i.getDeadBand ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deadBand",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeadBand ();
    }

    // deadBandTime
    //
    if (i.getDeadBandTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deadBandTime",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeadBandTime ();
    }

    // expression
    //
    if (i.getExpression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getExpression ();
    }

    // lookupTable
    //
    if (i.getLookupTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lookupTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLookupTable ();
    }

    // merger
    //
    if (i.getMerger ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "merger",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMerger ();
    }

    // polygonLookup
    //
    if (i.getPolygonLookup ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "polygonLookup",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPolygonLookup ();
    }

    // ruleReference
    //
    if (i.getRuleReference ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ruleReference",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRuleReference ();
    }

    // set
    //
    if (i.getSet ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "set",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSet ();
    }

    // spreadsheet
    //
    if (i.getSpreadsheet ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spreadsheet",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSpreadsheet ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EifelRurRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // a
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "a",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getA ());
    }

    // b
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "b",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getB ());
    }

    // minimumRelativeStorage
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimumRelativeStorage",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getMinimumRelativeStorage ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GuideBandRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // xMin
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xMin",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getXMin ();
    }

    // xMax
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xMax",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getXMax ();
    }

    // yMin
    //
    if (i.getYMin ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMin",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getYMin ());
    }

    // yMinSeries
    //
    if (i.getYMinSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMinSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYMinSeries ();
    }

    // yMax
    //
    if (i.getYMax ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMax",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getYMax ());
    }

    // yMaxSeries
    //
    if (i.getYMaxSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yMaxSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getYMaxSeries ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GuideBandRuleInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // y
    //
    if (i.getY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GuideBandRuleOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConstantRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // constant
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getConstant ());
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConstantRuleOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MinSimpleRuleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // zones
    //
    if (i.getZones ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "zones",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getZones ();
    }

    // dateTable
    //
    if (i.getDateTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDateTable ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StorageCharacteristicsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // storageTable
    //
    if (i.getStorageTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStorageTable ();
    }

    // storageEquation
    //
    if (i.getStorageEquation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageEquation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStorageEquation ();
    }

    // maximumLevel
    //
    if (i.getMaximumLevel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maximumLevel",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getMaximumLevel ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CapacityCharacteristicsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // capacityTable
    //
    if (i.getCapacityTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCapacityTable ();
    }

    // capacityEquation
    //
    if (i.getCapacityEquation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityEquation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCapacityEquation ();
    }

    // reference
    //
    if (i.getReference ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reference",
          e));

      a << *i.getReference ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineCharacteristicsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // efficiencyTable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "efficiencyTable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEfficiencyTable ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineOutputCharacteristicsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // power
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "power",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPower ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ElevationTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // elevationRecord
    //
    for (ElevationTableComplexType::ElevationRecordConstIterator
         b (i.getElevationRecord ().begin ()), n (i.getElevationRecord ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elevationRecord",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TailwaterComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // constant
    //
    if (i.getConstant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getConstant ());
    }

    // ratingCurve
    //
    if (i.getRatingCurve ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ratingCurve",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRatingCurve ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TailwaterOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // level
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "level",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLevel ();
    }

    // head
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "head",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHead ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ElevationRecordComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // elevation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "elevation",
          e));

      a << ::xml_schema::AsDouble(i.getElevation ());
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.getValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ControlledOutletComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // capacityCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCapacityCharacteristics ();
    }

    // turbineCharacteristics
    //
    if (i.getTurbineCharacteristics ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "turbineCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTurbineCharacteristics ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UncontrolledOutletComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // capacityCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCapacityCharacteristics ();
    }

    // input
    //
    if (i.getInput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UOutletInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // release
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "release",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRelease ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EquationsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // equation
    //
    for (EquationsComplexType::EquationConstIterator
         b (i.getEquation ().begin ()), n (i.getEquation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "equation",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EquationComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // lowerLevel
    //
    if (i.getLowerLevel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerLevel",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getLowerLevel ());
    }

    // upperLevel
    //
    if (i.getUpperLevel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperLevel",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getUpperLevel ());
    }

    // a
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "a",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getA ();
    }

    // b
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "b",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getB ();
    }

    // c
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "c",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ZonesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // zone
    //
    for (ZonesComplexType::ZoneConstIterator
         b (i.getZone ().begin ()), n (i.getZone ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "zone",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ZoneComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // dateTable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dateTable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDateTable ();
    }

    // min
    //
    if (i.getMin ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min",
          e));

      a << *i.getMin ();
    }

    // max
    //
    if (i.getMax ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "max",
          e));

      a << *i.getMax ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateTableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // data
    //
    for (DateTableComplexType::DataConstIterator
         b (i.getData ().begin ()), n (i.getData ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateRecordComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // monthDay
    //
    if (i.getMonthDay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monthDay",
          e));

      a << *i.getMonthDay ();
    }

    // dateTime
    //
    if (i.getDateTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dateTime",
          e));

      a << *i.getDateTime ();
    }

    // time
    //
    if (i.getTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << *i.getTime ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.getValue ());
    }

    // comment
    //
    if (i.getComment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "comment",
          e));

      a << *i.getComment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // inflow
    //
    for (ReservoirInputComplexType::InflowConstIterator
         b (i.getInflow ().begin ()), n (i.getInflow ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inflow",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // level
    //
    if (i.getLevel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "level",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLevel ();
    }

    // precipitation
    //
    if (i.getPrecipitation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "precipitation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPrecipitation ();
    }

    // evaporation
    //
    if (i.getEvaporation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "evaporation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEvaporation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // inflow
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inflow",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInflow ();
    }

    // release
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "release",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRelease ();
    }

    // storage
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storage",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorage ();
    }

    // relativeStorage
    //
    if (i.getRelativeStorage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relativeStorage",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRelativeStorage ();
    }

    // level
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "level",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLevel ();
    }

    // error
    //
    if (i.getError ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getError ();
    }

    // residuum
    //
    if (i.getResiduum ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "residuum",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getResiduum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReservoirGradientComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // lambda
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lambda",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLambda ();
    }

    // lambdaDown
    //
    if (i.getLambdaDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lambdaDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLambdaDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NodeGradientComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // lambda
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lambda",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLambda ();
    }

    // surfaceArea
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceArea",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSurfaceArea ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutletInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // release
    //
    if (i.getRelease ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "release",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRelease ();
    }

    // relativeRelease
    //
    for (OutletInputComplexType::RelativeReleaseConstIterator
         b (i.getRelativeRelease ().begin ()), n (i.getRelativeRelease ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relativeRelease",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutletOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // release
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "release",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRelease ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeadBandTriggerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // conditionOn
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "conditionOn",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getConditionOn ();
    }

    // conditionOff
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "conditionOff",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getConditionOff ();
    }

    // default
    //
    if (i.getDefault ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDefault ();
    }

    // true
    //
    if (i.getTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "true",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTrue ();
    }

    // false
    //
    if (i.getFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "false",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFalse ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TriggerInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // status
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "status",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStatus ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TriggerOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // status
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "status",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStatus ();
    }

    // timeTrue
    //
    if (i.getTimeTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeTrue",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeTrue ();
    }

    // timeFalse
    //
    if (i.getTimeFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeFalse",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeFalse ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StandardTriggerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // condition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "condition",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCondition ();
    }

    // default
    //
    if (i.getDefault ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDefault ();
    }

    // true
    //
    if (i.getTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "true",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTrue ();
    }

    // false
    //
    if (i.getFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "false",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFalse ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RelationalConditionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1Value
    //
    if (i.getX1Value ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Value",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Value ();
    }

    // x1Series
    //
    if (i.getX1Series ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Series",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Series ();
    }

    // relationalOperator
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relationalOperator",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRelationalOperator ();
    }

    // x2Value
    //
    if (i.getX2Value ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Value",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Value ();
    }

    // x2Series
    //
    if (i.getX2Series ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Series",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Series ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetTriggerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x1Value
    //
    if (i.getX1Value ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Value",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Value ();
    }

    // x1Series
    //
    if (i.getX1Series ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Series",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Series ();
    }

    // x1Trigger
    //
    if (i.getX1Trigger ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x1Trigger",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX1Trigger ();
    }

    // logicalOperator
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "logicalOperator",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLogicalOperator ();
    }

    // x2Value
    //
    if (i.getX2Value ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Value",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Value ();
    }

    // x2Series
    //
    if (i.getX2Series ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Series",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Series ();
    }

    // x2Trigger
    //
    if (i.getX2Trigger ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x2Trigger",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getX2Trigger ();
    }

    // default
    //
    if (i.getDefault ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDefault ();
    }

    // true
    //
    if (i.getTrue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "true",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTrue ();
    }

    // false
    //
    if (i.getFalse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "false",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFalse ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RuleTriggerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // trigger
    //
    for (RuleTriggerComplexType::TriggerConstIterator
         b (i.getTrigger ().begin ()), n (i.getTrigger ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trigger",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ResultComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConditionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // lessThan
    //
    if (i.getLessThan ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lessThan",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getLessThan ());
    }

    // greaterThan
    //
    if (i.getGreaterThan ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "greaterThan",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getGreaterThan ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RuleStateTriggerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ruleId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ruleId",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRuleId ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InflowComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // factor
    //
    if (i.getFactor ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factor",
          e));

      a << ::xml_schema::AsDouble(*i.getFactor ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NodeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // storageCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageCharacteristics ();
    }

    // input
    //
    if (i.getInput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // x
    //
    if (i.getX ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << ::xml_schema::AsDouble(*i.getX ());
    }

    // y
    //
    if (i.getY ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << ::xml_schema::AsDouble(*i.getY ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NodeInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HBC
    //
    if (i.getHBC ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HBC",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHBC ();
    }

    // HUpdate
    //
    if (i.getHUpdate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUpdate",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getHUpdate ();
    }

    // QBC
    //
    for (NodeInputComplexType::QBCConstIterator
         b (i.getQBC ().begin ()), n (i.getQBC ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "QBC",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NodeOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // H
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "H",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getH ();
    }

    // S
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "S",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getS ();
    }

    // R
    //
    if (i.getR ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "R",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getR ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BranchComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // equationType
    //
    if (i.getEquationType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "equationType",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEquationType ();
    }

    // spatialScheme
    //
    if (i.getSpatialScheme ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "spatialScheme",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSpatialScheme ();
    }

    // crossSection
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "crossSection",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCrossSection ();
    }

    // roughness
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "roughness",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRoughness ();
    }

    // length
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "length",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getLength ());
    }

    // slope
    //
    if (i.getSlope ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "slope",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSlope ());
    }

    // alpha1
    //
    if (i.getAlpha1 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alpha1",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getAlpha1 ());
    }

    // alpha2
    //
    if (i.getAlpha2 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "alpha2",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getAlpha2 ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CrossSectionComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // crossSectionTable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "crossSectionTable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCrossSectionTable ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CrossSectionRoughnessComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // roughnessTable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "roughnessTable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getRoughnessTable ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BranchInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHDown ();
    }

    // ux
    //
    if (i.getUx ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ux",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUx ();
    }

    // uy
    //
    if (i.getUy ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "uy",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUy ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BranchOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydraulicStructureComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // orifice
    //
    if (i.getOrifice ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "orifice",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getOrifice ();
    }

    // weir
    //
    if (i.getWeir ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weir",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWeir ();
    }

    // pump
    //
    if (i.getPump ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "pump",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPump ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PumpComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PumpInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // HDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHDown ();
    }

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PumpOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PumpGradientComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // storageUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageUp ();
    }

    // storageDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nodeUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeUp ();
    }

    // nodeDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nodeDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNodeDown ();
    }

    // capacityCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getCapacityCharacteristics ();
    }

    // efficiencyCharacteristics
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "efficiencyCharacteristics",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getEfficiencyCharacteristics ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineCapacityCharacteristicsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // capacityTable
    //
    if (i.getCapacityTable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityTable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCapacityTable ();
    }

    // capacityEquation
    //
    if (i.getCapacityEquation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "capacityEquation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCapacityEquation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineEfficiencyCharacteristicsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // efficiencyConstant
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "efficiencyConstant",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getEfficiencyConstant ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // release
    //
    if (i.getRelease ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "release",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRelease ();
    }

    // relativeRelease
    //
    if (i.getRelativeRelease ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relativeRelease",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRelativeRelease ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TurbineOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // discharge
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "discharge",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDischarge ();
    }

    // powerProduction
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "powerProduction",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getPowerProduction ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OrificeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // width
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getWidth ());
    }

    // crestLevel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "crestLevel",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getCrestLevel ());
    }

    // contractionCoefficient
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contractionCoefficient",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getContractionCoefficient ());
    }

    // exponentGateFormula
    //
    if (i.getExponentGateFormula ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exponentGateFormula",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getExponentGateFormula ());
    }

    // exponentWeirFormula
    //
    if (i.getExponentWeirFormula ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exponentWeirFormula",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getExponentWeirFormula ());
    }

    // flowDirection
    //
    if (i.getFlowDirection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flowDirection",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlowDirection ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OrificeInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // DeltaHUp
    //
    if (i.getDeltaHUp ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeltaHUp",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeltaHUp ();
    }

    // HDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHDown ();
    }

    // DeltaHDown
    //
    if (i.getDeltaHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeltaHDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeltaHDown ();
    }

    // DConst
    //
    if (i.getDConst ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DConst",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getDConst ());
    }

    // DSeries
    //
    if (i.getDSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDSeries ();
    }

    // D
    //
    if (i.getD ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getD ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OrificeOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }

    // D
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "D",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getD ();
    }

    // flowType
    //
    if (i.getFlowType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flowType",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlowType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BranchGradientComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // storageUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageUp ();
    }

    // surfaceAreaUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceAreaUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSurfaceAreaUp ();
    }

    // storageDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "storageDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStorageDown ();
    }

    // surfaceAreaDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "surfaceAreaDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSurfaceAreaDown ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RiverWeirComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // width
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getWidth ());
    }

    // exponentWeirFormula
    //
    if (i.getExponentWeirFormula ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exponentWeirFormula",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getExponentWeirFormula ());
    }

    // submergedFlowRatio
    //
    if (i.getSubmergedFlowRatio ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "submergedFlowRatio",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSubmergedFlowRatio ());
    }

    // submergedFlowFactor
    //
    if (i.getSubmergedFlowFactor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "submergedFlowFactor",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSubmergedFlowFactor ());
    }

    // flowDirection
    //
    if (i.getFlowDirection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flowDirection",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlowDirection ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RiverWeirInputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HUp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HUp",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHUp ();
    }

    // DeltaHUp
    //
    if (i.getDeltaHUp ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeltaHUp",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeltaHUp ();
    }

    // HDown
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HDown",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getHDown ();
    }

    // DeltaHDown
    //
    if (i.getDeltaHDown ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeltaHDown",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDeltaHDown ();
    }

    // CConst
    //
    if (i.getCConst ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CConst",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getCConst ());
    }

    // CSeries
    //
    if (i.getCSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCSeries ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RiverWeirOutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Q
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQ ();
    }

    // C
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "C",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getC ();
    }

    // flowType
    //
    if (i.getFlowType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flowType",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlowType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PoolRoutingEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PoolRoutingEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PoolRoutingEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const InterpolationOptionEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InterpolationOptionEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const InterpolationOptionEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const LimiterOptionEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LimiterOptionEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LimiterOptionEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeRelativeEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimeRelativeEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimeRelativeEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CaseLangetenEnumStringType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CaseLangetenEnumStringType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CaseLangetenEnumStringType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const FlowDirectionEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const FlowDirectionEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const FlowDirectionEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const LogicalOperatorEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LogicalOperatorEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LogicalOperatorEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const RelationalOperatorEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RelationalOperatorEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RelationalOperatorEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MathematicalOperatorEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MathematicalOperatorEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MathematicalOperatorEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SpatialEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SpatialEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const SpatialEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CapacityReferenceEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CapacityReferenceEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CapacityReferenceEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputReferenceEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InputReferenceEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const InputReferenceEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BranchTypeEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const BranchTypeEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const BranchTypeEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const EquationEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const EquationEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const EquationEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MergerSplitterEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MergerSplitterEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MergerSplitterEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const HydraulicModelModeEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const HydraulicModelModeEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const HydraulicModelModeEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TransferFunctionEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TransferFunctionEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TransferFunctionEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PidComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // mode
    //
    if (i.getMode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mode",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMode ();
    }

    // settingMin
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingMin",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getSettingMin ());
    }

    // settingMax
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingMax",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getSettingMax ());
    }

    // settingMaxSpeed
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "settingMaxSpeed",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getSettingMaxSpeed ());
    }

    // kp
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kp",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getKp ());
    }

    // ki
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ki",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getKi ());
    }

    // kd
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kd",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getKd ());
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // output
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getOutput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const InputPidComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getX ();
    }

    // setpointSeries
    //
    if (i.getSetpointSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setpointSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSetpointSeries ();
    }

    // setpointValue
    //
    if (i.getSetpointValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setpointValue",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSetpointValue ());
    }

    // disturbance
    //
    if (i.getDisturbance ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "disturbance",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getDisturbance ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputPidComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getY ();
    }

    // integralPart
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "integralPart",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getIntegralPart ();
    }

    // differentialPart
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "differentialPart",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getDifferentialPart ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TriggerControllerComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LayerIDSimpleType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LayerIDSimpleType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LayerIDSimpleType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NeuronIDSimpleType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NeuronIDSimpleType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NeuronIDSimpleType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitTypeEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const UnitTypeEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const UnitTypeEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Row& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.getValue ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Y& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // selectingColumnId
    //
    if (i.getSelectingColumnId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "selectingColumnId",
          e));

      a << *i.getSelectingColumnId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MonthOfYear& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MonthOfYear& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MonthOfYear& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const QSPercentage& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // useAbsoluteAsSpillCap
    //
    if (i.getUseAbsoluteAsSpillCap ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "useAbsoluteAsSpillCap",
          e));

      a << *i.getUseAbsoluteAsSpillCap ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const QSPercentageValue& i)
  {
    e << static_cast< const ::fews::ExternalParameterSimpleType& > (i);

    // useAbsoluteAsSpillCap
    //
    if (i.getUseAbsoluteAsSpillCap ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "useAbsoluteAsSpillCap",
          e));

      a << *i.getUseAbsoluteAsSpillCap ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const External& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << i.getWeight ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Internal& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // weight
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "weight",
          e));

      a << i.getWeight ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Multiplier& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Multiplier& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Multiplier& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Property& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Property& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Property& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const X& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X1& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X11& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X2& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X12& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X21& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X3& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X4& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X5& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // factor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factor",
          e));

      a << ::xml_schema::AsDouble(i.getFactor ());
    }

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const XVector& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }

    // nStepSeriesStart
    //
    if (i.getNStepSeriesStart ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nStepSeriesStart",
          e));

      a << *i.getNStepSeriesStart ();
    }

    // nStepSeries
    //
    if (i.getNStepSeries ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nStepSeries",
          e));

      a << *i.getNStepSeries ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Y1& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // factor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factor",
          e));

      a << ::xml_schema::AsDouble(i.getFactor ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Mode& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Mode& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Mode& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const X1Series& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X1SeriesVector& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X2Series& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X2SeriesVector& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X6& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ThresholdSeries& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X1Series1& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X2Series1& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X1Series2& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X2Series2& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const QBC& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // factor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factor",
          e));

      a << ::xml_schema::AsDouble(i.getFactor ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FlowDirectionEnumStringType_member& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const FlowDirectionEnumStringType_member& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const FlowDirectionEnumStringType_member& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const FlowDirectionEnumStringType_member1& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const FlowDirectionEnumStringType_member1& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const FlowDirectionEnumStringType_member1& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Mode1& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Mode1& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Mode1& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Disturbance& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);

    // factor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "factor",
          e));

      a << ::xml_schema::AsDouble(i.getFactor ());
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

