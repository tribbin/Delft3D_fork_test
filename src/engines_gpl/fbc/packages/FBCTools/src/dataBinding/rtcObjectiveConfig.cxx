// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rtcObjectiveConfig.hxx"

namespace fews
{
  // RtcObjectiveConfigComplexType
  // 

  const RtcObjectiveConfigComplexType::VariablesOptional& RtcObjectiveConfigComplexType::
  getVariables () const
  {
    return this->variables_;
  }

  RtcObjectiveConfigComplexType::VariablesOptional& RtcObjectiveConfigComplexType::
  getVariables ()
  {
    return this->variables_;
  }

  void RtcObjectiveConfigComplexType::
  setVariables (const VariablesType& x)
  {
    this->variables_.set (x);
  }

  void RtcObjectiveConfigComplexType::
  setVariables (const VariablesOptional& x)
  {
    this->variables_ = x;
  }

  void RtcObjectiveConfigComplexType::
  setVariables (::std::auto_ptr< VariablesType > x)
  {
    this->variables_.set (x);
  }

  const RtcObjectiveConfigComplexType::ConstraintsOptional& RtcObjectiveConfigComplexType::
  getConstraints () const
  {
    return this->constraints_;
  }

  RtcObjectiveConfigComplexType::ConstraintsOptional& RtcObjectiveConfigComplexType::
  getConstraints ()
  {
    return this->constraints_;
  }

  void RtcObjectiveConfigComplexType::
  setConstraints (const ConstraintsType& x)
  {
    this->constraints_.set (x);
  }

  void RtcObjectiveConfigComplexType::
  setConstraints (const ConstraintsOptional& x)
  {
    this->constraints_ = x;
  }

  void RtcObjectiveConfigComplexType::
  setConstraints (::std::auto_ptr< ConstraintsType > x)
  {
    this->constraints_.set (x);
  }

  const RtcObjectiveConfigComplexType::TermsOptional& RtcObjectiveConfigComplexType::
  getTerms () const
  {
    return this->terms_;
  }

  RtcObjectiveConfigComplexType::TermsOptional& RtcObjectiveConfigComplexType::
  getTerms ()
  {
    return this->terms_;
  }

  void RtcObjectiveConfigComplexType::
  setTerms (const TermsType& x)
  {
    this->terms_.set (x);
  }

  void RtcObjectiveConfigComplexType::
  setTerms (const TermsOptional& x)
  {
    this->terms_ = x;
  }

  void RtcObjectiveConfigComplexType::
  setTerms (::std::auto_ptr< TermsType > x)
  {
    this->terms_.set (x);
  }

  const RtcObjectiveConfigComplexType::TermsEnsembleOptional& RtcObjectiveConfigComplexType::
  getTermsEnsemble () const
  {
    return this->termsEnsemble_;
  }

  RtcObjectiveConfigComplexType::TermsEnsembleOptional& RtcObjectiveConfigComplexType::
  getTermsEnsemble ()
  {
    return this->termsEnsemble_;
  }

  void RtcObjectiveConfigComplexType::
  setTermsEnsemble (const TermsEnsembleType& x)
  {
    this->termsEnsemble_.set (x);
  }

  void RtcObjectiveConfigComplexType::
  setTermsEnsemble (const TermsEnsembleOptional& x)
  {
    this->termsEnsemble_ = x;
  }

  void RtcObjectiveConfigComplexType::
  setTermsEnsemble (::std::auto_ptr< TermsEnsembleType > x)
  {
    this->termsEnsemble_.set (x);
  }

  const RtcObjectiveConfigComplexType::OutputOptional& RtcObjectiveConfigComplexType::
  getOutput () const
  {
    return this->output_;
  }

  RtcObjectiveConfigComplexType::OutputOptional& RtcObjectiveConfigComplexType::
  getOutput ()
  {
    return this->output_;
  }

  void RtcObjectiveConfigComplexType::
  setOutput (const OutputType& x)
  {
    this->output_.set (x);
  }

  void RtcObjectiveConfigComplexType::
  setOutput (const OutputOptional& x)
  {
    this->output_ = x;
  }

  void RtcObjectiveConfigComplexType::
  setOutput (::std::auto_ptr< OutputType > x)
  {
    this->output_.set (x);
  }


  // VariablesComplexType
  // 

  const VariablesComplexType::VariableSequence& VariablesComplexType::
  getVariable () const
  {
    return this->variable_;
  }

  VariablesComplexType::VariableSequence& VariablesComplexType::
  getVariable ()
  {
    return this->variable_;
  }

  void VariablesComplexType::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }

  const VariablesComplexType::AggregationOptional& VariablesComplexType::
  getAggregation () const
  {
    return this->aggregation_;
  }

  VariablesComplexType::AggregationOptional& VariablesComplexType::
  getAggregation ()
  {
    return this->aggregation_;
  }

  void VariablesComplexType::
  setAggregation (const AggregationType& x)
  {
    this->aggregation_.set (x);
  }

  void VariablesComplexType::
  setAggregation (const AggregationOptional& x)
  {
    this->aggregation_ = x;
  }

  void VariablesComplexType::
  setAggregation (::std::auto_ptr< AggregationType > x)
  {
    this->aggregation_.set (x);
  }


  // VariableComplexType
  // 

  const VariableComplexType::AggregationOptional& VariableComplexType::
  getAggregation () const
  {
    return this->aggregation_;
  }

  VariableComplexType::AggregationOptional& VariableComplexType::
  getAggregation ()
  {
    return this->aggregation_;
  }

  void VariableComplexType::
  setAggregation (const AggregationType& x)
  {
    this->aggregation_.set (x);
  }

  void VariableComplexType::
  setAggregation (const AggregationOptional& x)
  {
    this->aggregation_ = x;
  }

  void VariableComplexType::
  setAggregation (::std::auto_ptr< AggregationType > x)
  {
    this->aggregation_.set (x);
  }

  const VariableComplexType::IdType& VariableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  VariableComplexType::IdType& VariableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void VariableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void VariableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const VariableComplexType::TypeType& VariableComplexType::
  getType () const
  {
    return this->type_.get ();
  }

  VariableComplexType::TypeType& VariableComplexType::
  getType ()
  {
    return this->type_.get ();
  }

  void VariableComplexType::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void VariableComplexType::
  setType (::std::auto_ptr< TypeType > x)
  {
    this->type_.set (x);
  }

  const VariableComplexType::ActiveType& VariableComplexType::
  getActive () const
  {
    return this->active_.get ();
  }

  VariableComplexType::ActiveType& VariableComplexType::
  getActive ()
  {
    return this->active_.get ();
  }

  void VariableComplexType::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void VariableComplexType::
  setActive (::std::auto_ptr< ActiveType > x)
  {
    this->active_.set (x);
  }

  const VariableComplexType::ActiveType& VariableComplexType::
  getActiveDefaultValue ()
  {
    return active_default_value_;
  }

  const VariableComplexType::MinOptional& VariableComplexType::
  getMin () const
  {
    return this->min_;
  }

  VariableComplexType::MinOptional& VariableComplexType::
  getMin ()
  {
    return this->min_;
  }

  void VariableComplexType::
  setMin (const MinType& x)
  {
    this->min_.set (x);
  }

  void VariableComplexType::
  setMin (const MinOptional& x)
  {
    this->min_ = x;
  }

  void VariableComplexType::
  setMin (::std::auto_ptr< MinType > x)
  {
    this->min_.set (x);
  }

  const VariableComplexType::MaxOptional& VariableComplexType::
  getMax () const
  {
    return this->max_;
  }

  VariableComplexType::MaxOptional& VariableComplexType::
  getMax ()
  {
    return this->max_;
  }

  void VariableComplexType::
  setMax (const MaxType& x)
  {
    this->max_.set (x);
  }

  void VariableComplexType::
  setMax (const MaxOptional& x)
  {
    this->max_ = x;
  }

  void VariableComplexType::
  setMax (::std::auto_ptr< MaxType > x)
  {
    this->max_.set (x);
  }

  const VariableComplexType::ScalingFactorType& VariableComplexType::
  getScalingFactor () const
  {
    return this->scalingFactor_.get ();
  }

  VariableComplexType::ScalingFactorType& VariableComplexType::
  getScalingFactor ()
  {
    return this->scalingFactor_.get ();
  }

  void VariableComplexType::
  setScalingFactor (const ScalingFactorType& x)
  {
    this->scalingFactor_.set (x);
  }

  VariableComplexType::ScalingFactorType VariableComplexType::
  getScalingFactorDefaultValue ()
  {
    return ScalingFactorType (1.0);
  }

  const VariableComplexType::EnsembleModeType& VariableComplexType::
  getEnsembleMode () const
  {
    return this->ensembleMode_.get ();
  }

  VariableComplexType::EnsembleModeType& VariableComplexType::
  getEnsembleMode ()
  {
    return this->ensembleMode_.get ();
  }

  void VariableComplexType::
  setEnsembleMode (const EnsembleModeType& x)
  {
    this->ensembleMode_.set (x);
  }

  void VariableComplexType::
  setEnsembleMode (::std::auto_ptr< EnsembleModeType > x)
  {
    this->ensembleMode_.set (x);
  }

  const VariableComplexType::EnsembleModeType& VariableComplexType::
  getEnsembleModeDefaultValue ()
  {
    return ensembleMode_default_value_;
  }


  // AggregationComplexType
  // 

  const AggregationComplexType::ConstantOptional& AggregationComplexType::
  getConstant () const
  {
    return this->constant_;
  }

  AggregationComplexType::ConstantOptional& AggregationComplexType::
  getConstant ()
  {
    return this->constant_;
  }

  void AggregationComplexType::
  setConstant (const ConstantType& x)
  {
    this->constant_.set (x);
  }

  void AggregationComplexType::
  setConstant (const ConstantOptional& x)
  {
    this->constant_ = x;
  }

  void AggregationComplexType::
  setConstant (::std::auto_ptr< ConstantType > x)
  {
    this->constant_.set (x);
  }

  const AggregationComplexType::EquidistantOptional& AggregationComplexType::
  getEquidistant () const
  {
    return this->equidistant_;
  }

  AggregationComplexType::EquidistantOptional& AggregationComplexType::
  getEquidistant ()
  {
    return this->equidistant_;
  }

  void AggregationComplexType::
  setEquidistant (const EquidistantType& x)
  {
    this->equidistant_.set (x);
  }

  void AggregationComplexType::
  setEquidistant (const EquidistantOptional& x)
  {
    this->equidistant_ = x;
  }

  void AggregationComplexType::
  setEquidistant (::std::auto_ptr< EquidistantType > x)
  {
    this->equidistant_.set (x);
  }

  const AggregationComplexType::Non_equidistantOptional& AggregationComplexType::
  getNon_equidistant () const
  {
    return this->non_equidistant_;
  }

  AggregationComplexType::Non_equidistantOptional& AggregationComplexType::
  getNon_equidistant ()
  {
    return this->non_equidistant_;
  }

  void AggregationComplexType::
  setNon_equidistant (const Non_equidistantType& x)
  {
    this->non_equidistant_.set (x);
  }

  void AggregationComplexType::
  setNon_equidistant (const Non_equidistantOptional& x)
  {
    this->non_equidistant_ = x;
  }

  void AggregationComplexType::
  setNon_equidistant (::std::auto_ptr< Non_equidistantType > x)
  {
    this->non_equidistant_.set (x);
  }


  // AggregationEquidistantComplexType
  // 

  const AggregationEquidistantComplexType::TypeType& AggregationEquidistantComplexType::
  getType () const
  {
    return this->type_.get ();
  }

  AggregationEquidistantComplexType::TypeType& AggregationEquidistantComplexType::
  getType ()
  {
    return this->type_.get ();
  }

  void AggregationEquidistantComplexType::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void AggregationEquidistantComplexType::
  setType (::std::auto_ptr< TypeType > x)
  {
    this->type_.set (x);
  }

  const AggregationEquidistantComplexType::NAggregationStepsType& AggregationEquidistantComplexType::
  getNAggregationSteps () const
  {
    return this->nAggregationSteps_.get ();
  }

  AggregationEquidistantComplexType::NAggregationStepsType& AggregationEquidistantComplexType::
  getNAggregationSteps ()
  {
    return this->nAggregationSteps_.get ();
  }

  void AggregationEquidistantComplexType::
  setNAggregationSteps (const NAggregationStepsType& x)
  {
    this->nAggregationSteps_.set (x);
  }


  // AggregationNonEquidistantComplexType
  // 

  const AggregationNonEquidistantComplexType::TypeType& AggregationNonEquidistantComplexType::
  getType () const
  {
    return this->type_.get ();
  }

  AggregationNonEquidistantComplexType::TypeType& AggregationNonEquidistantComplexType::
  getType ()
  {
    return this->type_.get ();
  }

  void AggregationNonEquidistantComplexType::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void AggregationNonEquidistantComplexType::
  setType (::std::auto_ptr< TypeType > x)
  {
    this->type_.set (x);
  }

  const AggregationNonEquidistantComplexType::NInputStepsType& AggregationNonEquidistantComplexType::
  getNInputSteps () const
  {
    return this->nInputSteps_.get ();
  }

  AggregationNonEquidistantComplexType::NInputStepsType& AggregationNonEquidistantComplexType::
  getNInputSteps ()
  {
    return this->nInputSteps_.get ();
  }

  void AggregationNonEquidistantComplexType::
  setNInputSteps (const NInputStepsType& x)
  {
    this->nInputSteps_.set (x);
  }

  const AggregationNonEquidistantComplexType::NOutputStepsType& AggregationNonEquidistantComplexType::
  getNOutputSteps () const
  {
    return this->nOutputSteps_.get ();
  }

  AggregationNonEquidistantComplexType::NOutputStepsType& AggregationNonEquidistantComplexType::
  getNOutputSteps ()
  {
    return this->nOutputSteps_.get ();
  }

  void AggregationNonEquidistantComplexType::
  setNOutputSteps (const NOutputStepsType& x)
  {
    this->nOutputSteps_.set (x);
  }

  const AggregationNonEquidistantComplexType::StepIndexSequence& AggregationNonEquidistantComplexType::
  getStepIndex () const
  {
    return this->stepIndex_;
  }

  AggregationNonEquidistantComplexType::StepIndexSequence& AggregationNonEquidistantComplexType::
  getStepIndex ()
  {
    return this->stepIndex_;
  }

  void AggregationNonEquidistantComplexType::
  setStepIndex (const StepIndexSequence& s)
  {
    this->stepIndex_ = s;
  }


  // ConstraintsComplexType
  // 

  const ConstraintsComplexType::ConstraintSequence& ConstraintsComplexType::
  getConstraint () const
  {
    return this->constraint_;
  }

  ConstraintsComplexType::ConstraintSequence& ConstraintsComplexType::
  getConstraint ()
  {
    return this->constraint_;
  }

  void ConstraintsComplexType::
  setConstraint (const ConstraintSequence& s)
  {
    this->constraint_ = s;
  }


  // ConstraintChoiceComplexType
  // 

  const ConstraintChoiceComplexType::BoundVariableOptional& ConstraintChoiceComplexType::
  getBoundVariable () const
  {
    return this->boundVariable_;
  }

  ConstraintChoiceComplexType::BoundVariableOptional& ConstraintChoiceComplexType::
  getBoundVariable ()
  {
    return this->boundVariable_;
  }

  void ConstraintChoiceComplexType::
  setBoundVariable (const BoundVariableType& x)
  {
    this->boundVariable_.set (x);
  }

  void ConstraintChoiceComplexType::
  setBoundVariable (const BoundVariableOptional& x)
  {
    this->boundVariable_ = x;
  }

  void ConstraintChoiceComplexType::
  setBoundVariable (::std::auto_ptr< BoundVariableType > x)
  {
    this->boundVariable_.set (x);
  }

  const ConstraintChoiceComplexType::BoundVariableAverageOptional& ConstraintChoiceComplexType::
  getBoundVariableAverage () const
  {
    return this->boundVariableAverage_;
  }

  ConstraintChoiceComplexType::BoundVariableAverageOptional& ConstraintChoiceComplexType::
  getBoundVariableAverage ()
  {
    return this->boundVariableAverage_;
  }

  void ConstraintChoiceComplexType::
  setBoundVariableAverage (const BoundVariableAverageType& x)
  {
    this->boundVariableAverage_.set (x);
  }

  void ConstraintChoiceComplexType::
  setBoundVariableAverage (const BoundVariableAverageOptional& x)
  {
    this->boundVariableAverage_ = x;
  }

  void ConstraintChoiceComplexType::
  setBoundVariableAverage (::std::auto_ptr< BoundVariableAverageType > x)
  {
    this->boundVariableAverage_.set (x);
  }

  const ConstraintChoiceComplexType::BoundVariableRateOfChangeOptional& ConstraintChoiceComplexType::
  getBoundVariableRateOfChange () const
  {
    return this->boundVariableRateOfChange_;
  }

  ConstraintChoiceComplexType::BoundVariableRateOfChangeOptional& ConstraintChoiceComplexType::
  getBoundVariableRateOfChange ()
  {
    return this->boundVariableRateOfChange_;
  }

  void ConstraintChoiceComplexType::
  setBoundVariableRateOfChange (const BoundVariableRateOfChangeType& x)
  {
    this->boundVariableRateOfChange_.set (x);
  }

  void ConstraintChoiceComplexType::
  setBoundVariableRateOfChange (const BoundVariableRateOfChangeOptional& x)
  {
    this->boundVariableRateOfChange_ = x;
  }

  void ConstraintChoiceComplexType::
  setBoundVariableRateOfChange (::std::auto_ptr< BoundVariableRateOfChangeType > x)
  {
    this->boundVariableRateOfChange_.set (x);
  }

  const ConstraintChoiceComplexType::BoundStateOptional& ConstraintChoiceComplexType::
  getBoundState () const
  {
    return this->boundState_;
  }

  ConstraintChoiceComplexType::BoundStateOptional& ConstraintChoiceComplexType::
  getBoundState ()
  {
    return this->boundState_;
  }

  void ConstraintChoiceComplexType::
  setBoundState (const BoundStateType& x)
  {
    this->boundState_.set (x);
  }

  void ConstraintChoiceComplexType::
  setBoundState (const BoundStateOptional& x)
  {
    this->boundState_ = x;
  }

  void ConstraintChoiceComplexType::
  setBoundState (::std::auto_ptr< BoundStateType > x)
  {
    this->boundState_.set (x);
  }

  const ConstraintChoiceComplexType::ChanceBoundVariableOptional& ConstraintChoiceComplexType::
  getChanceBoundVariable () const
  {
    return this->chanceBoundVariable_;
  }

  ConstraintChoiceComplexType::ChanceBoundVariableOptional& ConstraintChoiceComplexType::
  getChanceBoundVariable ()
  {
    return this->chanceBoundVariable_;
  }

  void ConstraintChoiceComplexType::
  setChanceBoundVariable (const ChanceBoundVariableType& x)
  {
    this->chanceBoundVariable_.set (x);
  }

  void ConstraintChoiceComplexType::
  setChanceBoundVariable (const ChanceBoundVariableOptional& x)
  {
    this->chanceBoundVariable_ = x;
  }

  void ConstraintChoiceComplexType::
  setChanceBoundVariable (::std::auto_ptr< ChanceBoundVariableType > x)
  {
    this->chanceBoundVariable_.set (x);
  }

  const ConstraintChoiceComplexType::ActiveType& ConstraintChoiceComplexType::
  getActive () const
  {
    return this->active_.get ();
  }

  ConstraintChoiceComplexType::ActiveType& ConstraintChoiceComplexType::
  getActive ()
  {
    return this->active_.get ();
  }

  void ConstraintChoiceComplexType::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void ConstraintChoiceComplexType::
  setActive (::std::auto_ptr< ActiveType > x)
  {
    this->active_.set (x);
  }

  const ConstraintChoiceComplexType::ActiveType& ConstraintChoiceComplexType::
  getActiveDefaultValue ()
  {
    return active_default_value_;
  }


  // BoundVariableComplexType
  // 

  const BoundVariableComplexType::VariableType& BoundVariableComplexType::
  getVariable () const
  {
    return this->variable_.get ();
  }

  BoundVariableComplexType::VariableType& BoundVariableComplexType::
  getVariable ()
  {
    return this->variable_.get ();
  }

  void BoundVariableComplexType::
  setVariable (const VariableType& x)
  {
    this->variable_.set (x);
  }

  void BoundVariableComplexType::
  setVariable (::std::auto_ptr< VariableType > x)
  {
    this->variable_.set (x);
  }

  const BoundVariableComplexType::UpperBoundOptional& BoundVariableComplexType::
  getUpperBound () const
  {
    return this->upperBound_;
  }

  BoundVariableComplexType::UpperBoundOptional& BoundVariableComplexType::
  getUpperBound ()
  {
    return this->upperBound_;
  }

  void BoundVariableComplexType::
  setUpperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }

  void BoundVariableComplexType::
  setUpperBound (const UpperBoundOptional& x)
  {
    this->upperBound_ = x;
  }

  void BoundVariableComplexType::
  setUpperBound (::std::auto_ptr< UpperBoundType > x)
  {
    this->upperBound_.set (x);
  }

  const BoundVariableComplexType::UpperBoundSeriesOptional& BoundVariableComplexType::
  getUpperBoundSeries () const
  {
    return this->upperBoundSeries_;
  }

  BoundVariableComplexType::UpperBoundSeriesOptional& BoundVariableComplexType::
  getUpperBoundSeries ()
  {
    return this->upperBoundSeries_;
  }

  void BoundVariableComplexType::
  setUpperBoundSeries (const UpperBoundSeriesType& x)
  {
    this->upperBoundSeries_.set (x);
  }

  void BoundVariableComplexType::
  setUpperBoundSeries (const UpperBoundSeriesOptional& x)
  {
    this->upperBoundSeries_ = x;
  }

  void BoundVariableComplexType::
  setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > x)
  {
    this->upperBoundSeries_.set (x);
  }

  const BoundVariableComplexType::LowerBoundOptional& BoundVariableComplexType::
  getLowerBound () const
  {
    return this->lowerBound_;
  }

  BoundVariableComplexType::LowerBoundOptional& BoundVariableComplexType::
  getLowerBound ()
  {
    return this->lowerBound_;
  }

  void BoundVariableComplexType::
  setLowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  void BoundVariableComplexType::
  setLowerBound (const LowerBoundOptional& x)
  {
    this->lowerBound_ = x;
  }

  void BoundVariableComplexType::
  setLowerBound (::std::auto_ptr< LowerBoundType > x)
  {
    this->lowerBound_.set (x);
  }

  const BoundVariableComplexType::LowerBoundSeriesOptional& BoundVariableComplexType::
  getLowerBoundSeries () const
  {
    return this->lowerBoundSeries_;
  }

  BoundVariableComplexType::LowerBoundSeriesOptional& BoundVariableComplexType::
  getLowerBoundSeries ()
  {
    return this->lowerBoundSeries_;
  }

  void BoundVariableComplexType::
  setLowerBoundSeries (const LowerBoundSeriesType& x)
  {
    this->lowerBoundSeries_.set (x);
  }

  void BoundVariableComplexType::
  setLowerBoundSeries (const LowerBoundSeriesOptional& x)
  {
    this->lowerBoundSeries_ = x;
  }

  void BoundVariableComplexType::
  setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > x)
  {
    this->lowerBoundSeries_.set (x);
  }

  const BoundVariableComplexType::IdType& BoundVariableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  BoundVariableComplexType::IdType& BoundVariableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void BoundVariableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void BoundVariableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const BoundVariableComplexType::NameOptional& BoundVariableComplexType::
  getName () const
  {
    return this->name_;
  }

  BoundVariableComplexType::NameOptional& BoundVariableComplexType::
  getName ()
  {
    return this->name_;
  }

  void BoundVariableComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void BoundVariableComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void BoundVariableComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // BoundVariableRateOfChangeComplexType
  // 

  const BoundVariableRateOfChangeComplexType::VariableType& BoundVariableRateOfChangeComplexType::
  getVariable () const
  {
    return this->variable_.get ();
  }

  BoundVariableRateOfChangeComplexType::VariableType& BoundVariableRateOfChangeComplexType::
  getVariable ()
  {
    return this->variable_.get ();
  }

  void BoundVariableRateOfChangeComplexType::
  setVariable (const VariableType& x)
  {
    this->variable_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setVariable (::std::auto_ptr< VariableType > x)
  {
    this->variable_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::MultipleDelayOptional& BoundVariableRateOfChangeComplexType::
  getMultipleDelay () const
  {
    return this->multipleDelay_;
  }

  BoundVariableRateOfChangeComplexType::MultipleDelayOptional& BoundVariableRateOfChangeComplexType::
  getMultipleDelay ()
  {
    return this->multipleDelay_;
  }

  void BoundVariableRateOfChangeComplexType::
  setMultipleDelay (const MultipleDelayType& x)
  {
    this->multipleDelay_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setMultipleDelay (const MultipleDelayOptional& x)
  {
    this->multipleDelay_ = x;
  }

  void BoundVariableRateOfChangeComplexType::
  setMultipleDelay (::std::auto_ptr< MultipleDelayType > x)
  {
    this->multipleDelay_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::UpperBoundOptional& BoundVariableRateOfChangeComplexType::
  getUpperBound () const
  {
    return this->upperBound_;
  }

  BoundVariableRateOfChangeComplexType::UpperBoundOptional& BoundVariableRateOfChangeComplexType::
  getUpperBound ()
  {
    return this->upperBound_;
  }

  void BoundVariableRateOfChangeComplexType::
  setUpperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setUpperBound (const UpperBoundOptional& x)
  {
    this->upperBound_ = x;
  }

  void BoundVariableRateOfChangeComplexType::
  setUpperBound (::std::auto_ptr< UpperBoundType > x)
  {
    this->upperBound_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::UpperBoundSeriesOptional& BoundVariableRateOfChangeComplexType::
  getUpperBoundSeries () const
  {
    return this->upperBoundSeries_;
  }

  BoundVariableRateOfChangeComplexType::UpperBoundSeriesOptional& BoundVariableRateOfChangeComplexType::
  getUpperBoundSeries ()
  {
    return this->upperBoundSeries_;
  }

  void BoundVariableRateOfChangeComplexType::
  setUpperBoundSeries (const UpperBoundSeriesType& x)
  {
    this->upperBoundSeries_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setUpperBoundSeries (const UpperBoundSeriesOptional& x)
  {
    this->upperBoundSeries_ = x;
  }

  void BoundVariableRateOfChangeComplexType::
  setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > x)
  {
    this->upperBoundSeries_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::LowerBoundOptional& BoundVariableRateOfChangeComplexType::
  getLowerBound () const
  {
    return this->lowerBound_;
  }

  BoundVariableRateOfChangeComplexType::LowerBoundOptional& BoundVariableRateOfChangeComplexType::
  getLowerBound ()
  {
    return this->lowerBound_;
  }

  void BoundVariableRateOfChangeComplexType::
  setLowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setLowerBound (const LowerBoundOptional& x)
  {
    this->lowerBound_ = x;
  }

  void BoundVariableRateOfChangeComplexType::
  setLowerBound (::std::auto_ptr< LowerBoundType > x)
  {
    this->lowerBound_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::LowerBoundSeriesOptional& BoundVariableRateOfChangeComplexType::
  getLowerBoundSeries () const
  {
    return this->lowerBoundSeries_;
  }

  BoundVariableRateOfChangeComplexType::LowerBoundSeriesOptional& BoundVariableRateOfChangeComplexType::
  getLowerBoundSeries ()
  {
    return this->lowerBoundSeries_;
  }

  void BoundVariableRateOfChangeComplexType::
  setLowerBoundSeries (const LowerBoundSeriesType& x)
  {
    this->lowerBoundSeries_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setLowerBoundSeries (const LowerBoundSeriesOptional& x)
  {
    this->lowerBoundSeries_ = x;
  }

  void BoundVariableRateOfChangeComplexType::
  setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > x)
  {
    this->lowerBoundSeries_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::IdType& BoundVariableRateOfChangeComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  BoundVariableRateOfChangeComplexType::IdType& BoundVariableRateOfChangeComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void BoundVariableRateOfChangeComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const BoundVariableRateOfChangeComplexType::NameOptional& BoundVariableRateOfChangeComplexType::
  getName () const
  {
    return this->name_;
  }

  BoundVariableRateOfChangeComplexType::NameOptional& BoundVariableRateOfChangeComplexType::
  getName ()
  {
    return this->name_;
  }

  void BoundVariableRateOfChangeComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void BoundVariableRateOfChangeComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void BoundVariableRateOfChangeComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // BoundVariableAverageComplexType
  // 

  const BoundVariableAverageComplexType::VariableType& BoundVariableAverageComplexType::
  getVariable () const
  {
    return this->variable_.get ();
  }

  BoundVariableAverageComplexType::VariableType& BoundVariableAverageComplexType::
  getVariable ()
  {
    return this->variable_.get ();
  }

  void BoundVariableAverageComplexType::
  setVariable (const VariableType& x)
  {
    this->variable_.set (x);
  }

  void BoundVariableAverageComplexType::
  setVariable (::std::auto_ptr< VariableType > x)
  {
    this->variable_.set (x);
  }

  const BoundVariableAverageComplexType::AverageType& BoundVariableAverageComplexType::
  getAverage () const
  {
    return this->average_.get ();
  }

  BoundVariableAverageComplexType::AverageType& BoundVariableAverageComplexType::
  getAverage ()
  {
    return this->average_.get ();
  }

  void BoundVariableAverageComplexType::
  setAverage (const AverageType& x)
  {
    this->average_.set (x);
  }

  void BoundVariableAverageComplexType::
  setAverage (::std::auto_ptr< AverageType > x)
  {
    this->average_.set (x);
  }

  const BoundVariableAverageComplexType::UpperBoundOptional& BoundVariableAverageComplexType::
  getUpperBound () const
  {
    return this->upperBound_;
  }

  BoundVariableAverageComplexType::UpperBoundOptional& BoundVariableAverageComplexType::
  getUpperBound ()
  {
    return this->upperBound_;
  }

  void BoundVariableAverageComplexType::
  setUpperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }

  void BoundVariableAverageComplexType::
  setUpperBound (const UpperBoundOptional& x)
  {
    this->upperBound_ = x;
  }

  void BoundVariableAverageComplexType::
  setUpperBound (::std::auto_ptr< UpperBoundType > x)
  {
    this->upperBound_.set (x);
  }

  const BoundVariableAverageComplexType::UpperBoundSeriesOptional& BoundVariableAverageComplexType::
  getUpperBoundSeries () const
  {
    return this->upperBoundSeries_;
  }

  BoundVariableAverageComplexType::UpperBoundSeriesOptional& BoundVariableAverageComplexType::
  getUpperBoundSeries ()
  {
    return this->upperBoundSeries_;
  }

  void BoundVariableAverageComplexType::
  setUpperBoundSeries (const UpperBoundSeriesType& x)
  {
    this->upperBoundSeries_.set (x);
  }

  void BoundVariableAverageComplexType::
  setUpperBoundSeries (const UpperBoundSeriesOptional& x)
  {
    this->upperBoundSeries_ = x;
  }

  void BoundVariableAverageComplexType::
  setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > x)
  {
    this->upperBoundSeries_.set (x);
  }

  const BoundVariableAverageComplexType::LowerBoundOptional& BoundVariableAverageComplexType::
  getLowerBound () const
  {
    return this->lowerBound_;
  }

  BoundVariableAverageComplexType::LowerBoundOptional& BoundVariableAverageComplexType::
  getLowerBound ()
  {
    return this->lowerBound_;
  }

  void BoundVariableAverageComplexType::
  setLowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  void BoundVariableAverageComplexType::
  setLowerBound (const LowerBoundOptional& x)
  {
    this->lowerBound_ = x;
  }

  void BoundVariableAverageComplexType::
  setLowerBound (::std::auto_ptr< LowerBoundType > x)
  {
    this->lowerBound_.set (x);
  }

  const BoundVariableAverageComplexType::LowerBoundSeriesOptional& BoundVariableAverageComplexType::
  getLowerBoundSeries () const
  {
    return this->lowerBoundSeries_;
  }

  BoundVariableAverageComplexType::LowerBoundSeriesOptional& BoundVariableAverageComplexType::
  getLowerBoundSeries ()
  {
    return this->lowerBoundSeries_;
  }

  void BoundVariableAverageComplexType::
  setLowerBoundSeries (const LowerBoundSeriesType& x)
  {
    this->lowerBoundSeries_.set (x);
  }

  void BoundVariableAverageComplexType::
  setLowerBoundSeries (const LowerBoundSeriesOptional& x)
  {
    this->lowerBoundSeries_ = x;
  }

  void BoundVariableAverageComplexType::
  setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > x)
  {
    this->lowerBoundSeries_.set (x);
  }

  const BoundVariableAverageComplexType::IdType& BoundVariableAverageComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  BoundVariableAverageComplexType::IdType& BoundVariableAverageComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void BoundVariableAverageComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void BoundVariableAverageComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const BoundVariableAverageComplexType::NameOptional& BoundVariableAverageComplexType::
  getName () const
  {
    return this->name_;
  }

  BoundVariableAverageComplexType::NameOptional& BoundVariableAverageComplexType::
  getName ()
  {
    return this->name_;
  }

  void BoundVariableAverageComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void BoundVariableAverageComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void BoundVariableAverageComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // BoundAverageComplexType
  // 

  const BoundAverageComplexType::NStepOptional& BoundAverageComplexType::
  getNStep () const
  {
    return this->nStep_;
  }

  BoundAverageComplexType::NStepOptional& BoundAverageComplexType::
  getNStep ()
  {
    return this->nStep_;
  }

  void BoundAverageComplexType::
  setNStep (const NStepType& x)
  {
    this->nStep_.set (x);
  }

  void BoundAverageComplexType::
  setNStep (const NStepOptional& x)
  {
    this->nStep_ = x;
  }

  void BoundAverageComplexType::
  setNStep (::std::auto_ptr< NStepType > x)
  {
    this->nStep_.set (x);
  }

  BoundAverageComplexType::NStepType BoundAverageComplexType::
  getNStepDefaultValue ()
  {
    return NStepType (1LL);
  }

  const BoundAverageComplexType::NStepSeriesOptional& BoundAverageComplexType::
  getNStepSeries () const
  {
    return this->nStepSeries_;
  }

  BoundAverageComplexType::NStepSeriesOptional& BoundAverageComplexType::
  getNStepSeries ()
  {
    return this->nStepSeries_;
  }

  void BoundAverageComplexType::
  setNStepSeries (const NStepSeriesType& x)
  {
    this->nStepSeries_.set (x);
  }

  void BoundAverageComplexType::
  setNStepSeries (const NStepSeriesOptional& x)
  {
    this->nStepSeries_ = x;
  }

  void BoundAverageComplexType::
  setNStepSeries (::std::auto_ptr< NStepSeriesType > x)
  {
    this->nStepSeries_.set (x);
  }

  const BoundAverageComplexType::VariableDelayVectorOptional& BoundAverageComplexType::
  getVariableDelayVector () const
  {
    return this->variableDelayVector_;
  }

  BoundAverageComplexType::VariableDelayVectorOptional& BoundAverageComplexType::
  getVariableDelayVector ()
  {
    return this->variableDelayVector_;
  }

  void BoundAverageComplexType::
  setVariableDelayVector (const VariableDelayVectorType& x)
  {
    this->variableDelayVector_.set (x);
  }

  void BoundAverageComplexType::
  setVariableDelayVector (const VariableDelayVectorOptional& x)
  {
    this->variableDelayVector_ = x;
  }

  void BoundAverageComplexType::
  setVariableDelayVector (::std::auto_ptr< VariableDelayVectorType > x)
  {
    this->variableDelayVector_.set (x);
  }


  // MultipleDelayComplexType
  // 

  const MultipleDelayComplexType::VariableDelayVectorOptional& MultipleDelayComplexType::
  getVariableDelayVector () const
  {
    return this->variableDelayVector_;
  }

  MultipleDelayComplexType::VariableDelayVectorOptional& MultipleDelayComplexType::
  getVariableDelayVector ()
  {
    return this->variableDelayVector_;
  }

  void MultipleDelayComplexType::
  setVariableDelayVector (const VariableDelayVectorType& x)
  {
    this->variableDelayVector_.set (x);
  }

  void MultipleDelayComplexType::
  setVariableDelayVector (const VariableDelayVectorOptional& x)
  {
    this->variableDelayVector_ = x;
  }

  void MultipleDelayComplexType::
  setVariableDelayVector (::std::auto_ptr< VariableDelayVectorType > x)
  {
    this->variableDelayVector_.set (x);
  }

  const MultipleDelayComplexType::NStepOptional& MultipleDelayComplexType::
  getNStep () const
  {
    return this->nStep_;
  }

  MultipleDelayComplexType::NStepOptional& MultipleDelayComplexType::
  getNStep ()
  {
    return this->nStep_;
  }

  void MultipleDelayComplexType::
  setNStep (const NStepType& x)
  {
    this->nStep_.set (x);
  }

  void MultipleDelayComplexType::
  setNStep (const NStepOptional& x)
  {
    this->nStep_ = x;
  }

  void MultipleDelayComplexType::
  setNStep (::std::auto_ptr< NStepType > x)
  {
    this->nStep_.set (x);
  }

  MultipleDelayComplexType::NStepType MultipleDelayComplexType::
  getNStepDefaultValue ()
  {
    return NStepType (1LL);
  }

  const MultipleDelayComplexType::NStepSeriesOptional& MultipleDelayComplexType::
  getNStepSeries () const
  {
    return this->nStepSeries_;
  }

  MultipleDelayComplexType::NStepSeriesOptional& MultipleDelayComplexType::
  getNStepSeries ()
  {
    return this->nStepSeries_;
  }

  void MultipleDelayComplexType::
  setNStepSeries (const NStepSeriesType& x)
  {
    this->nStepSeries_.set (x);
  }

  void MultipleDelayComplexType::
  setNStepSeries (const NStepSeriesOptional& x)
  {
    this->nStepSeries_ = x;
  }

  void MultipleDelayComplexType::
  setNStepSeries (::std::auto_ptr< NStepSeriesType > x)
  {
    this->nStepSeries_.set (x);
  }

  const MultipleDelayComplexType::NStepModeOptional& MultipleDelayComplexType::
  getNStepMode () const
  {
    return this->nStepMode_;
  }

  MultipleDelayComplexType::NStepModeOptional& MultipleDelayComplexType::
  getNStepMode ()
  {
    return this->nStepMode_;
  }

  void MultipleDelayComplexType::
  setNStepMode (const NStepModeType& x)
  {
    this->nStepMode_.set (x);
  }

  void MultipleDelayComplexType::
  setNStepMode (const NStepModeOptional& x)
  {
    this->nStepMode_ = x;
  }

  void MultipleDelayComplexType::
  setNStepMode (::std::auto_ptr< NStepModeType > x)
  {
    this->nStepMode_.set (x);
  }

  const MultipleDelayComplexType::NStepModeType& MultipleDelayComplexType::
  getNStepModeDefaultValue ()
  {
    return nStepMode_default_value_;
  }

  const MultipleDelayComplexType::NStepCorrectionOptional& MultipleDelayComplexType::
  getNStepCorrection () const
  {
    return this->nStepCorrection_;
  }

  MultipleDelayComplexType::NStepCorrectionOptional& MultipleDelayComplexType::
  getNStepCorrection ()
  {
    return this->nStepCorrection_;
  }

  void MultipleDelayComplexType::
  setNStepCorrection (const NStepCorrectionType& x)
  {
    this->nStepCorrection_.set (x);
  }

  void MultipleDelayComplexType::
  setNStepCorrection (const NStepCorrectionOptional& x)
  {
    this->nStepCorrection_ = x;
  }

  MultipleDelayComplexType::NStepCorrectionType MultipleDelayComplexType::
  getNStepCorrectionDefaultValue ()
  {
    return NStepCorrectionType (false);
  }


  // BoundStateComplexType
  // 

  const BoundStateComplexType::ComponentsType& BoundStateComplexType::
  getComponents () const
  {
    return this->components_.get ();
  }

  BoundStateComplexType::ComponentsType& BoundStateComplexType::
  getComponents ()
  {
    return this->components_.get ();
  }

  void BoundStateComplexType::
  setComponents (const ComponentsType& x)
  {
    this->components_.set (x);
  }

  void BoundStateComplexType::
  setComponents (::std::auto_ptr< ComponentsType > x)
  {
    this->components_.set (x);
  }

  const BoundStateComplexType::NStepOptional& BoundStateComplexType::
  getNStep () const
  {
    return this->nStep_;
  }

  BoundStateComplexType::NStepOptional& BoundStateComplexType::
  getNStep ()
  {
    return this->nStep_;
  }

  void BoundStateComplexType::
  setNStep (const NStepType& x)
  {
    this->nStep_.set (x);
  }

  void BoundStateComplexType::
  setNStep (const NStepOptional& x)
  {
    this->nStep_ = x;
  }

  void BoundStateComplexType::
  setNStep (::std::auto_ptr< NStepType > x)
  {
    this->nStep_.set (x);
  }

  const BoundStateComplexType::StepIndicesOptional& BoundStateComplexType::
  getStepIndices () const
  {
    return this->stepIndices_;
  }

  BoundStateComplexType::StepIndicesOptional& BoundStateComplexType::
  getStepIndices ()
  {
    return this->stepIndices_;
  }

  void BoundStateComplexType::
  setStepIndices (const StepIndicesType& x)
  {
    this->stepIndices_.set (x);
  }

  void BoundStateComplexType::
  setStepIndices (const StepIndicesOptional& x)
  {
    this->stepIndices_ = x;
  }

  void BoundStateComplexType::
  setStepIndices (::std::auto_ptr< StepIndicesType > x)
  {
    this->stepIndices_.set (x);
  }

  const BoundStateComplexType::VariablesType& BoundStateComplexType::
  getVariables () const
  {
    return this->variables_.get ();
  }

  BoundStateComplexType::VariablesType& BoundStateComplexType::
  getVariables ()
  {
    return this->variables_.get ();
  }

  void BoundStateComplexType::
  setVariables (const VariablesType& x)
  {
    this->variables_.set (x);
  }

  void BoundStateComplexType::
  setVariables (::std::auto_ptr< VariablesType > x)
  {
    this->variables_.set (x);
  }

  const BoundStateComplexType::StateType& BoundStateComplexType::
  getState () const
  {
    return this->state_.get ();
  }

  BoundStateComplexType::StateType& BoundStateComplexType::
  getState ()
  {
    return this->state_.get ();
  }

  void BoundStateComplexType::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void BoundStateComplexType::
  setState (::std::auto_ptr< StateType > x)
  {
    this->state_.set (x);
  }

  const BoundStateComplexType::AverageOptional& BoundStateComplexType::
  getAverage () const
  {
    return this->average_;
  }

  BoundStateComplexType::AverageOptional& BoundStateComplexType::
  getAverage ()
  {
    return this->average_;
  }

  void BoundStateComplexType::
  setAverage (const AverageType& x)
  {
    this->average_.set (x);
  }

  void BoundStateComplexType::
  setAverage (const AverageOptional& x)
  {
    this->average_ = x;
  }

  void BoundStateComplexType::
  setAverage (::std::auto_ptr< AverageType > x)
  {
    this->average_.set (x);
  }

  const BoundStateComplexType::UpperBoundOptional& BoundStateComplexType::
  getUpperBound () const
  {
    return this->upperBound_;
  }

  BoundStateComplexType::UpperBoundOptional& BoundStateComplexType::
  getUpperBound ()
  {
    return this->upperBound_;
  }

  void BoundStateComplexType::
  setUpperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }

  void BoundStateComplexType::
  setUpperBound (const UpperBoundOptional& x)
  {
    this->upperBound_ = x;
  }

  void BoundStateComplexType::
  setUpperBound (::std::auto_ptr< UpperBoundType > x)
  {
    this->upperBound_.set (x);
  }

  const BoundStateComplexType::UpperBoundSeriesOptional& BoundStateComplexType::
  getUpperBoundSeries () const
  {
    return this->upperBoundSeries_;
  }

  BoundStateComplexType::UpperBoundSeriesOptional& BoundStateComplexType::
  getUpperBoundSeries ()
  {
    return this->upperBoundSeries_;
  }

  void BoundStateComplexType::
  setUpperBoundSeries (const UpperBoundSeriesType& x)
  {
    this->upperBoundSeries_.set (x);
  }

  void BoundStateComplexType::
  setUpperBoundSeries (const UpperBoundSeriesOptional& x)
  {
    this->upperBoundSeries_ = x;
  }

  void BoundStateComplexType::
  setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > x)
  {
    this->upperBoundSeries_.set (x);
  }

  const BoundStateComplexType::LowerBoundOptional& BoundStateComplexType::
  getLowerBound () const
  {
    return this->lowerBound_;
  }

  BoundStateComplexType::LowerBoundOptional& BoundStateComplexType::
  getLowerBound ()
  {
    return this->lowerBound_;
  }

  void BoundStateComplexType::
  setLowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  void BoundStateComplexType::
  setLowerBound (const LowerBoundOptional& x)
  {
    this->lowerBound_ = x;
  }

  void BoundStateComplexType::
  setLowerBound (::std::auto_ptr< LowerBoundType > x)
  {
    this->lowerBound_.set (x);
  }

  const BoundStateComplexType::LowerBoundSeriesOptional& BoundStateComplexType::
  getLowerBoundSeries () const
  {
    return this->lowerBoundSeries_;
  }

  BoundStateComplexType::LowerBoundSeriesOptional& BoundStateComplexType::
  getLowerBoundSeries ()
  {
    return this->lowerBoundSeries_;
  }

  void BoundStateComplexType::
  setLowerBoundSeries (const LowerBoundSeriesType& x)
  {
    this->lowerBoundSeries_.set (x);
  }

  void BoundStateComplexType::
  setLowerBoundSeries (const LowerBoundSeriesOptional& x)
  {
    this->lowerBoundSeries_ = x;
  }

  void BoundStateComplexType::
  setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > x)
  {
    this->lowerBoundSeries_.set (x);
  }

  const BoundStateComplexType::IdType& BoundStateComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  BoundStateComplexType::IdType& BoundStateComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void BoundStateComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void BoundStateComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const BoundStateComplexType::NameOptional& BoundStateComplexType::
  getName () const
  {
    return this->name_;
  }

  BoundStateComplexType::NameOptional& BoundStateComplexType::
  getName ()
  {
    return this->name_;
  }

  void BoundStateComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void BoundStateComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void BoundStateComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }

  const BoundStateComplexType::ScalingFactorType& BoundStateComplexType::
  getScalingFactor () const
  {
    return this->scalingFactor_.get ();
  }

  BoundStateComplexType::ScalingFactorType& BoundStateComplexType::
  getScalingFactor ()
  {
    return this->scalingFactor_.get ();
  }

  void BoundStateComplexType::
  setScalingFactor (const ScalingFactorType& x)
  {
    this->scalingFactor_.set (x);
  }

  BoundStateComplexType::ScalingFactorType BoundStateComplexType::
  getScalingFactorDefaultValue ()
  {
    return ScalingFactorType (1.0);
  }


  // StateAverageComplexType
  // 

  const StateAverageComplexType::NStepOptional& StateAverageComplexType::
  getNStep () const
  {
    return this->nStep_;
  }

  StateAverageComplexType::NStepOptional& StateAverageComplexType::
  getNStep ()
  {
    return this->nStep_;
  }

  void StateAverageComplexType::
  setNStep (const NStepType& x)
  {
    this->nStep_.set (x);
  }

  void StateAverageComplexType::
  setNStep (const NStepOptional& x)
  {
    this->nStep_ = x;
  }

  void StateAverageComplexType::
  setNStep (::std::auto_ptr< NStepType > x)
  {
    this->nStep_.set (x);
  }

  StateAverageComplexType::NStepType StateAverageComplexType::
  getNStepDefaultValue ()
  {
    return NStepType (1LL);
  }

  const StateAverageComplexType::NStepSeriesOptional& StateAverageComplexType::
  getNStepSeries () const
  {
    return this->nStepSeries_;
  }

  StateAverageComplexType::NStepSeriesOptional& StateAverageComplexType::
  getNStepSeries ()
  {
    return this->nStepSeries_;
  }

  void StateAverageComplexType::
  setNStepSeries (const NStepSeriesType& x)
  {
    this->nStepSeries_.set (x);
  }

  void StateAverageComplexType::
  setNStepSeries (const NStepSeriesOptional& x)
  {
    this->nStepSeries_ = x;
  }

  void StateAverageComplexType::
  setNStepSeries (::std::auto_ptr< NStepSeriesType > x)
  {
    this->nStepSeries_.set (x);
  }

  const StateAverageComplexType::StateDelayVectorType& StateAverageComplexType::
  getStateDelayVector () const
  {
    return this->stateDelayVector_.get ();
  }

  StateAverageComplexType::StateDelayVectorType& StateAverageComplexType::
  getStateDelayVector ()
  {
    return this->stateDelayVector_.get ();
  }

  void StateAverageComplexType::
  setStateDelayVector (const StateDelayVectorType& x)
  {
    this->stateDelayVector_.set (x);
  }

  void StateAverageComplexType::
  setStateDelayVector (::std::auto_ptr< StateDelayVectorType > x)
  {
    this->stateDelayVector_.set (x);
  }


  // BoundStateStepIndicesComplexType
  // 

  const BoundStateStepIndicesComplexType::StepIndexSequence& BoundStateStepIndicesComplexType::
  getStepIndex () const
  {
    return this->stepIndex_;
  }

  BoundStateStepIndicesComplexType::StepIndexSequence& BoundStateStepIndicesComplexType::
  getStepIndex ()
  {
    return this->stepIndex_;
  }

  void BoundStateStepIndicesComplexType::
  setStepIndex (const StepIndexSequence& s)
  {
    this->stepIndex_ = s;
  }


  // BoundStateComponentsComplexType
  // 

  const BoundStateComponentsComplexType::ComponentSequence& BoundStateComponentsComplexType::
  getComponent () const
  {
    return this->component_;
  }

  BoundStateComponentsComplexType::ComponentSequence& BoundStateComponentsComplexType::
  getComponent ()
  {
    return this->component_;
  }

  void BoundStateComponentsComplexType::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }


  // BoundStateVariablesComplexType
  // 

  const BoundStateVariablesComplexType::VariableSequence& BoundStateVariablesComplexType::
  getVariable () const
  {
    return this->variable_;
  }

  BoundStateVariablesComplexType::VariableSequence& BoundStateVariablesComplexType::
  getVariable ()
  {
    return this->variable_;
  }

  void BoundStateVariablesComplexType::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }


  // ChanceVariableComplexType
  // 

  const ChanceVariableComplexType::VariableType& ChanceVariableComplexType::
  getVariable () const
  {
    return this->variable_.get ();
  }

  ChanceVariableComplexType::VariableType& ChanceVariableComplexType::
  getVariable ()
  {
    return this->variable_.get ();
  }

  void ChanceVariableComplexType::
  setVariable (const VariableType& x)
  {
    this->variable_.set (x);
  }

  void ChanceVariableComplexType::
  setVariable (::std::auto_ptr< VariableType > x)
  {
    this->variable_.set (x);
  }

  const ChanceVariableComplexType::FType& ChanceVariableComplexType::
  getF () const
  {
    return this->f_.get ();
  }

  ChanceVariableComplexType::FType& ChanceVariableComplexType::
  getF ()
  {
    return this->f_.get ();
  }

  void ChanceVariableComplexType::
  setF (const FType& x)
  {
    this->f_.set (x);
  }

  const ChanceVariableComplexType::UpperBoundOptional& ChanceVariableComplexType::
  getUpperBound () const
  {
    return this->upperBound_;
  }

  ChanceVariableComplexType::UpperBoundOptional& ChanceVariableComplexType::
  getUpperBound ()
  {
    return this->upperBound_;
  }

  void ChanceVariableComplexType::
  setUpperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }

  void ChanceVariableComplexType::
  setUpperBound (const UpperBoundOptional& x)
  {
    this->upperBound_ = x;
  }

  void ChanceVariableComplexType::
  setUpperBound (::std::auto_ptr< UpperBoundType > x)
  {
    this->upperBound_.set (x);
  }

  const ChanceVariableComplexType::UpperBoundSeriesOptional& ChanceVariableComplexType::
  getUpperBoundSeries () const
  {
    return this->upperBoundSeries_;
  }

  ChanceVariableComplexType::UpperBoundSeriesOptional& ChanceVariableComplexType::
  getUpperBoundSeries ()
  {
    return this->upperBoundSeries_;
  }

  void ChanceVariableComplexType::
  setUpperBoundSeries (const UpperBoundSeriesType& x)
  {
    this->upperBoundSeries_.set (x);
  }

  void ChanceVariableComplexType::
  setUpperBoundSeries (const UpperBoundSeriesOptional& x)
  {
    this->upperBoundSeries_ = x;
  }

  void ChanceVariableComplexType::
  setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > x)
  {
    this->upperBoundSeries_.set (x);
  }

  const ChanceVariableComplexType::LowerBoundOptional& ChanceVariableComplexType::
  getLowerBound () const
  {
    return this->lowerBound_;
  }

  ChanceVariableComplexType::LowerBoundOptional& ChanceVariableComplexType::
  getLowerBound ()
  {
    return this->lowerBound_;
  }

  void ChanceVariableComplexType::
  setLowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  void ChanceVariableComplexType::
  setLowerBound (const LowerBoundOptional& x)
  {
    this->lowerBound_ = x;
  }

  void ChanceVariableComplexType::
  setLowerBound (::std::auto_ptr< LowerBoundType > x)
  {
    this->lowerBound_.set (x);
  }

  const ChanceVariableComplexType::LowerBoundSeriesOptional& ChanceVariableComplexType::
  getLowerBoundSeries () const
  {
    return this->lowerBoundSeries_;
  }

  ChanceVariableComplexType::LowerBoundSeriesOptional& ChanceVariableComplexType::
  getLowerBoundSeries ()
  {
    return this->lowerBoundSeries_;
  }

  void ChanceVariableComplexType::
  setLowerBoundSeries (const LowerBoundSeriesType& x)
  {
    this->lowerBoundSeries_.set (x);
  }

  void ChanceVariableComplexType::
  setLowerBoundSeries (const LowerBoundSeriesOptional& x)
  {
    this->lowerBoundSeries_ = x;
  }

  void ChanceVariableComplexType::
  setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > x)
  {
    this->lowerBoundSeries_.set (x);
  }

  const ChanceVariableComplexType::IdType& ChanceVariableComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ChanceVariableComplexType::IdType& ChanceVariableComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ChanceVariableComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ChanceVariableComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ChanceVariableComplexType::NameOptional& ChanceVariableComplexType::
  getName () const
  {
    return this->name_;
  }

  ChanceVariableComplexType::NameOptional& ChanceVariableComplexType::
  getName ()
  {
    return this->name_;
  }

  void ChanceVariableComplexType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ChanceVariableComplexType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ChanceVariableComplexType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // TermComplexType
  // 

  const TermComplexType::TermSequence& TermComplexType::
  getTerm () const
  {
    return this->term_;
  }

  TermComplexType::TermSequence& TermComplexType::
  getTerm ()
  {
    return this->term_;
  }

  void TermComplexType::
  setTerm (const TermSequence& s)
  {
    this->term_ = s;
  }


  // TermEnsembleComplexType
  // 

  const TermEnsembleComplexType::TermEnsembleSequence& TermEnsembleComplexType::
  getTermEnsemble () const
  {
    return this->termEnsemble_;
  }

  TermEnsembleComplexType::TermEnsembleSequence& TermEnsembleComplexType::
  getTermEnsemble ()
  {
    return this->termEnsemble_;
  }

  void TermEnsembleComplexType::
  setTermEnsemble (const TermEnsembleSequence& s)
  {
    this->termEnsemble_ = s;
  }


  // TermChoiceComplexType
  // 

  const TermChoiceComplexType::AbsoluteOptional& TermChoiceComplexType::
  getAbsolute () const
  {
    return this->absolute_;
  }

  TermChoiceComplexType::AbsoluteOptional& TermChoiceComplexType::
  getAbsolute ()
  {
    return this->absolute_;
  }

  void TermChoiceComplexType::
  setAbsolute (const AbsoluteType& x)
  {
    this->absolute_.set (x);
  }

  void TermChoiceComplexType::
  setAbsolute (const AbsoluteOptional& x)
  {
    this->absolute_ = x;
  }

  void TermChoiceComplexType::
  setAbsolute (::std::auto_ptr< AbsoluteType > x)
  {
    this->absolute_.set (x);
  }

  const TermChoiceComplexType::LinearOptional& TermChoiceComplexType::
  getLinear () const
  {
    return this->linear_;
  }

  TermChoiceComplexType::LinearOptional& TermChoiceComplexType::
  getLinear ()
  {
    return this->linear_;
  }

  void TermChoiceComplexType::
  setLinear (const LinearType& x)
  {
    this->linear_.set (x);
  }

  void TermChoiceComplexType::
  setLinear (const LinearOptional& x)
  {
    this->linear_ = x;
  }

  void TermChoiceComplexType::
  setLinear (::std::auto_ptr< LinearType > x)
  {
    this->linear_.set (x);
  }

  const TermChoiceComplexType::RateOfChangeOptional& TermChoiceComplexType::
  getRateOfChange () const
  {
    return this->rateOfChange_;
  }

  TermChoiceComplexType::RateOfChangeOptional& TermChoiceComplexType::
  getRateOfChange ()
  {
    return this->rateOfChange_;
  }

  void TermChoiceComplexType::
  setRateOfChange (const RateOfChangeType& x)
  {
    this->rateOfChange_.set (x);
  }

  void TermChoiceComplexType::
  setRateOfChange (const RateOfChangeOptional& x)
  {
    this->rateOfChange_ = x;
  }

  void TermChoiceComplexType::
  setRateOfChange (::std::auto_ptr< RateOfChangeType > x)
  {
    this->rateOfChange_.set (x);
  }

  const TermChoiceComplexType::MaxOptional& TermChoiceComplexType::
  getMax () const
  {
    return this->max_;
  }

  TermChoiceComplexType::MaxOptional& TermChoiceComplexType::
  getMax ()
  {
    return this->max_;
  }

  void TermChoiceComplexType::
  setMax (const MaxType& x)
  {
    this->max_.set (x);
  }

  void TermChoiceComplexType::
  setMax (const MaxOptional& x)
  {
    this->max_ = x;
  }

  void TermChoiceComplexType::
  setMax (::std::auto_ptr< MaxType > x)
  {
    this->max_.set (x);
  }

  const TermChoiceComplexType::MseOptional& TermChoiceComplexType::
  getMse () const
  {
    return this->mse_;
  }

  TermChoiceComplexType::MseOptional& TermChoiceComplexType::
  getMse ()
  {
    return this->mse_;
  }

  void TermChoiceComplexType::
  setMse (const MseType& x)
  {
    this->mse_.set (x);
  }

  void TermChoiceComplexType::
  setMse (const MseOptional& x)
  {
    this->mse_ = x;
  }

  void TermChoiceComplexType::
  setMse (::std::auto_ptr< MseType > x)
  {
    this->mse_.set (x);
  }

  const TermChoiceComplexType::NseOptional& TermChoiceComplexType::
  getNse () const
  {
    return this->nse_;
  }

  TermChoiceComplexType::NseOptional& TermChoiceComplexType::
  getNse ()
  {
    return this->nse_;
  }

  void TermChoiceComplexType::
  setNse (const NseType& x)
  {
    this->nse_.set (x);
  }

  void TermChoiceComplexType::
  setNse (const NseOptional& x)
  {
    this->nse_ = x;
  }

  void TermChoiceComplexType::
  setNse (::std::auto_ptr< NseType > x)
  {
    this->nse_.set (x);
  }

  const TermChoiceComplexType::RelativeVolumeOptional& TermChoiceComplexType::
  getRelativeVolume () const
  {
    return this->relativeVolume_;
  }

  TermChoiceComplexType::RelativeVolumeOptional& TermChoiceComplexType::
  getRelativeVolume ()
  {
    return this->relativeVolume_;
  }

  void TermChoiceComplexType::
  setRelativeVolume (const RelativeVolumeType& x)
  {
    this->relativeVolume_.set (x);
  }

  void TermChoiceComplexType::
  setRelativeVolume (const RelativeVolumeOptional& x)
  {
    this->relativeVolume_ = x;
  }

  void TermChoiceComplexType::
  setRelativeVolume (::std::auto_ptr< RelativeVolumeType > x)
  {
    this->relativeVolume_.set (x);
  }

  const TermChoiceComplexType::RmseOptional& TermChoiceComplexType::
  getRmse () const
  {
    return this->rmse_;
  }

  TermChoiceComplexType::RmseOptional& TermChoiceComplexType::
  getRmse ()
  {
    return this->rmse_;
  }

  void TermChoiceComplexType::
  setRmse (const RmseType& x)
  {
    this->rmse_.set (x);
  }

  void TermChoiceComplexType::
  setRmse (const RmseOptional& x)
  {
    this->rmse_ = x;
  }

  void TermChoiceComplexType::
  setRmse (::std::auto_ptr< RmseType > x)
  {
    this->rmse_.set (x);
  }

  const TermChoiceComplexType::RvOptional& TermChoiceComplexType::
  getRv () const
  {
    return this->rv_;
  }

  TermChoiceComplexType::RvOptional& TermChoiceComplexType::
  getRv ()
  {
    return this->rv_;
  }

  void TermChoiceComplexType::
  setRv (const RvType& x)
  {
    this->rv_.set (x);
  }

  void TermChoiceComplexType::
  setRv (const RvOptional& x)
  {
    this->rv_ = x;
  }

  void TermChoiceComplexType::
  setRv (::std::auto_ptr< RvType > x)
  {
    this->rv_.set (x);
  }

  const TermChoiceComplexType::SumOptional& TermChoiceComplexType::
  getSum () const
  {
    return this->sum_;
  }

  TermChoiceComplexType::SumOptional& TermChoiceComplexType::
  getSum ()
  {
    return this->sum_;
  }

  void TermChoiceComplexType::
  setSum (const SumType& x)
  {
    this->sum_.set (x);
  }

  void TermChoiceComplexType::
  setSum (const SumOptional& x)
  {
    this->sum_ = x;
  }

  void TermChoiceComplexType::
  setSum (::std::auto_ptr< SumType > x)
  {
    this->sum_.set (x);
  }

  const TermChoiceComplexType::ActiveType& TermChoiceComplexType::
  getActive () const
  {
    return this->active_.get ();
  }

  TermChoiceComplexType::ActiveType& TermChoiceComplexType::
  getActive ()
  {
    return this->active_.get ();
  }

  void TermChoiceComplexType::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void TermChoiceComplexType::
  setActive (::std::auto_ptr< ActiveType > x)
  {
    this->active_.set (x);
  }

  const TermChoiceComplexType::ActiveType& TermChoiceComplexType::
  getActiveDefaultValue ()
  {
    return active_default_value_;
  }


  // TermEnsembleChoiceComplexType
  // 

  const TermEnsembleChoiceComplexType::ChanceConstraintType& TermEnsembleChoiceComplexType::
  getChanceConstraint () const
  {
    return this->chanceConstraint_.get ();
  }

  TermEnsembleChoiceComplexType::ChanceConstraintType& TermEnsembleChoiceComplexType::
  getChanceConstraint ()
  {
    return this->chanceConstraint_.get ();
  }

  void TermEnsembleChoiceComplexType::
  setChanceConstraint (const ChanceConstraintType& x)
  {
    this->chanceConstraint_.set (x);
  }

  void TermEnsembleChoiceComplexType::
  setChanceConstraint (::std::auto_ptr< ChanceConstraintType > x)
  {
    this->chanceConstraint_.set (x);
  }

  const TermEnsembleChoiceComplexType::ActiveType& TermEnsembleChoiceComplexType::
  getActive () const
  {
    return this->active_.get ();
  }

  TermEnsembleChoiceComplexType::ActiveType& TermEnsembleChoiceComplexType::
  getActive ()
  {
    return this->active_.get ();
  }

  void TermEnsembleChoiceComplexType::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void TermEnsembleChoiceComplexType::
  setActive (::std::auto_ptr< ActiveType > x)
  {
    this->active_.set (x);
  }

  const TermEnsembleChoiceComplexType::ActiveType& TermEnsembleChoiceComplexType::
  getActiveDefaultValue ()
  {
    return active_default_value_;
  }


  // TermAbsoluteComplexType
  // 

  const TermAbsoluteComplexType::WeightingFactorSeriesOptional& TermAbsoluteComplexType::
  getWeightingFactorSeries () const
  {
    return this->weightingFactorSeries_;
  }

  TermAbsoluteComplexType::WeightingFactorSeriesOptional& TermAbsoluteComplexType::
  getWeightingFactorSeries ()
  {
    return this->weightingFactorSeries_;
  }

  void TermAbsoluteComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesType& x)
  {
    this->weightingFactorSeries_.set (x);
  }

  void TermAbsoluteComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesOptional& x)
  {
    this->weightingFactorSeries_ = x;
  }

  void TermAbsoluteComplexType::
  setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > x)
  {
    this->weightingFactorSeries_.set (x);
  }

  const TermAbsoluteComplexType::WeightingFactorSequence& TermAbsoluteComplexType::
  getWeightingFactor () const
  {
    return this->weightingFactor_;
  }

  TermAbsoluteComplexType::WeightingFactorSequence& TermAbsoluteComplexType::
  getWeightingFactor ()
  {
    return this->weightingFactor_;
  }

  void TermAbsoluteComplexType::
  setWeightingFactor (const WeightingFactorSequence& s)
  {
    this->weightingFactor_ = s;
  }

  const TermAbsoluteComplexType::WeightingFactorType& TermAbsoluteComplexType::
  getWeightingFactorDefaultValue ()
  {
    return weightingFactor_default_value_;
  }

  const TermAbsoluteComplexType::WeightingFactorFinalSequence& TermAbsoluteComplexType::
  getWeightingFactorFinal () const
  {
    return this->weightingFactorFinal_;
  }

  TermAbsoluteComplexType::WeightingFactorFinalSequence& TermAbsoluteComplexType::
  getWeightingFactorFinal ()
  {
    return this->weightingFactorFinal_;
  }

  void TermAbsoluteComplexType::
  setWeightingFactorFinal (const WeightingFactorFinalSequence& s)
  {
    this->weightingFactorFinal_ = s;
  }

  const TermAbsoluteComplexType::WeightingFactorFinalType& TermAbsoluteComplexType::
  getWeightingFactorFinalDefaultValue ()
  {
    return weightingFactorFinal_default_value_;
  }

  const TermAbsoluteComplexType::OrderType& TermAbsoluteComplexType::
  getOrder () const
  {
    return this->order_.get ();
  }

  TermAbsoluteComplexType::OrderType& TermAbsoluteComplexType::
  getOrder ()
  {
    return this->order_.get ();
  }

  void TermAbsoluteComplexType::
  setOrder (const OrderType& x)
  {
    this->order_.set (x);
  }

  TermAbsoluteComplexType::OrderType TermAbsoluteComplexType::
  getOrderDefaultValue ()
  {
    return OrderType (2.0);
  }

  const TermAbsoluteComplexType::SetPointOptional& TermAbsoluteComplexType::
  getSetPoint () const
  {
    return this->setPoint_;
  }

  TermAbsoluteComplexType::SetPointOptional& TermAbsoluteComplexType::
  getSetPoint ()
  {
    return this->setPoint_;
  }

  void TermAbsoluteComplexType::
  setSetPoint (const SetPointType& x)
  {
    this->setPoint_.set (x);
  }

  void TermAbsoluteComplexType::
  setSetPoint (const SetPointOptional& x)
  {
    this->setPoint_ = x;
  }

  void TermAbsoluteComplexType::
  setSetPoint (::std::auto_ptr< SetPointType > x)
  {
    this->setPoint_.set (x);
  }

  const TermAbsoluteComplexType::SetPointSeriesOptional& TermAbsoluteComplexType::
  getSetPointSeries () const
  {
    return this->setPointSeries_;
  }

  TermAbsoluteComplexType::SetPointSeriesOptional& TermAbsoluteComplexType::
  getSetPointSeries ()
  {
    return this->setPointSeries_;
  }

  void TermAbsoluteComplexType::
  setSetPointSeries (const SetPointSeriesType& x)
  {
    this->setPointSeries_.set (x);
  }

  void TermAbsoluteComplexType::
  setSetPointSeries (const SetPointSeriesOptional& x)
  {
    this->setPointSeries_ = x;
  }

  void TermAbsoluteComplexType::
  setSetPointSeries (::std::auto_ptr< SetPointSeriesType > x)
  {
    this->setPointSeries_.set (x);
  }

  const TermAbsoluteComplexType::UpperBranchOptional& TermAbsoluteComplexType::
  getUpperBranch () const
  {
    return this->upperBranch_;
  }

  TermAbsoluteComplexType::UpperBranchOptional& TermAbsoluteComplexType::
  getUpperBranch ()
  {
    return this->upperBranch_;
  }

  void TermAbsoluteComplexType::
  setUpperBranch (const UpperBranchType& x)
  {
    this->upperBranch_.set (x);
  }

  void TermAbsoluteComplexType::
  setUpperBranch (const UpperBranchOptional& x)
  {
    this->upperBranch_ = x;
  }

  TermAbsoluteComplexType::UpperBranchType TermAbsoluteComplexType::
  getUpperBranchDefaultValue ()
  {
    return UpperBranchType (true);
  }

  const TermAbsoluteComplexType::LowerBranchOptional& TermAbsoluteComplexType::
  getLowerBranch () const
  {
    return this->lowerBranch_;
  }

  TermAbsoluteComplexType::LowerBranchOptional& TermAbsoluteComplexType::
  getLowerBranch ()
  {
    return this->lowerBranch_;
  }

  void TermAbsoluteComplexType::
  setLowerBranch (const LowerBranchType& x)
  {
    this->lowerBranch_.set (x);
  }

  void TermAbsoluteComplexType::
  setLowerBranch (const LowerBranchOptional& x)
  {
    this->lowerBranch_ = x;
  }

  TermAbsoluteComplexType::LowerBranchType TermAbsoluteComplexType::
  getLowerBranchDefaultValue ()
  {
    return LowerBranchType (true);
  }

  const TermAbsoluteComplexType::AverageOptional& TermAbsoluteComplexType::
  getAverage () const
  {
    return this->average_;
  }

  TermAbsoluteComplexType::AverageOptional& TermAbsoluteComplexType::
  getAverage ()
  {
    return this->average_;
  }

  void TermAbsoluteComplexType::
  setAverage (const AverageType& x)
  {
    this->average_.set (x);
  }

  void TermAbsoluteComplexType::
  setAverage (const AverageOptional& x)
  {
    this->average_ = x;
  }

  void TermAbsoluteComplexType::
  setAverage (::std::auto_ptr< AverageType > x)
  {
    this->average_.set (x);
  }

  const TermAbsoluteComplexType::InputType& TermAbsoluteComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TermAbsoluteComplexType::InputType& TermAbsoluteComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TermAbsoluteComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TermAbsoluteComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TermAbsoluteComplexType::IdType& TermAbsoluteComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermAbsoluteComplexType::IdType& TermAbsoluteComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermAbsoluteComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermAbsoluteComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // ChanceConstraintComplexType
  // 

  const ChanceConstraintComplexType::WeightingFactorSeriesOptional& ChanceConstraintComplexType::
  getWeightingFactorSeries () const
  {
    return this->weightingFactorSeries_;
  }

  ChanceConstraintComplexType::WeightingFactorSeriesOptional& ChanceConstraintComplexType::
  getWeightingFactorSeries ()
  {
    return this->weightingFactorSeries_;
  }

  void ChanceConstraintComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesType& x)
  {
    this->weightingFactorSeries_.set (x);
  }

  void ChanceConstraintComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesOptional& x)
  {
    this->weightingFactorSeries_ = x;
  }

  void ChanceConstraintComplexType::
  setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > x)
  {
    this->weightingFactorSeries_.set (x);
  }

  const ChanceConstraintComplexType::WeightingFactorSequence& ChanceConstraintComplexType::
  getWeightingFactor () const
  {
    return this->weightingFactor_;
  }

  ChanceConstraintComplexType::WeightingFactorSequence& ChanceConstraintComplexType::
  getWeightingFactor ()
  {
    return this->weightingFactor_;
  }

  void ChanceConstraintComplexType::
  setWeightingFactor (const WeightingFactorSequence& s)
  {
    this->weightingFactor_ = s;
  }

  const ChanceConstraintComplexType::WeightingFactorType& ChanceConstraintComplexType::
  getWeightingFactorDefaultValue ()
  {
    return weightingFactor_default_value_;
  }

  const ChanceConstraintComplexType::WeightingFactorFinalSequence& ChanceConstraintComplexType::
  getWeightingFactorFinal () const
  {
    return this->weightingFactorFinal_;
  }

  ChanceConstraintComplexType::WeightingFactorFinalSequence& ChanceConstraintComplexType::
  getWeightingFactorFinal ()
  {
    return this->weightingFactorFinal_;
  }

  void ChanceConstraintComplexType::
  setWeightingFactorFinal (const WeightingFactorFinalSequence& s)
  {
    this->weightingFactorFinal_ = s;
  }

  const ChanceConstraintComplexType::WeightingFactorFinalType& ChanceConstraintComplexType::
  getWeightingFactorFinalDefaultValue ()
  {
    return weightingFactorFinal_default_value_;
  }

  const ChanceConstraintComplexType::OrderType& ChanceConstraintComplexType::
  getOrder () const
  {
    return this->order_.get ();
  }

  ChanceConstraintComplexType::OrderType& ChanceConstraintComplexType::
  getOrder ()
  {
    return this->order_.get ();
  }

  void ChanceConstraintComplexType::
  setOrder (const OrderType& x)
  {
    this->order_.set (x);
  }

  ChanceConstraintComplexType::OrderType ChanceConstraintComplexType::
  getOrderDefaultValue ()
  {
    return OrderType (2.0);
  }

  const ChanceConstraintComplexType::FType& ChanceConstraintComplexType::
  getF () const
  {
    return this->f_.get ();
  }

  ChanceConstraintComplexType::FType& ChanceConstraintComplexType::
  getF ()
  {
    return this->f_.get ();
  }

  void ChanceConstraintComplexType::
  setF (const FType& x)
  {
    this->f_.set (x);
  }

  ChanceConstraintComplexType::FType ChanceConstraintComplexType::
  getFDefaultValue ()
  {
    return FType (1.0);
  }

  const ChanceConstraintComplexType::UpperBoundOptional& ChanceConstraintComplexType::
  getUpperBound () const
  {
    return this->upperBound_;
  }

  ChanceConstraintComplexType::UpperBoundOptional& ChanceConstraintComplexType::
  getUpperBound ()
  {
    return this->upperBound_;
  }

  void ChanceConstraintComplexType::
  setUpperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }

  void ChanceConstraintComplexType::
  setUpperBound (const UpperBoundOptional& x)
  {
    this->upperBound_ = x;
  }

  void ChanceConstraintComplexType::
  setUpperBound (::std::auto_ptr< UpperBoundType > x)
  {
    this->upperBound_.set (x);
  }

  const ChanceConstraintComplexType::UpperBoundSeriesOptional& ChanceConstraintComplexType::
  getUpperBoundSeries () const
  {
    return this->upperBoundSeries_;
  }

  ChanceConstraintComplexType::UpperBoundSeriesOptional& ChanceConstraintComplexType::
  getUpperBoundSeries ()
  {
    return this->upperBoundSeries_;
  }

  void ChanceConstraintComplexType::
  setUpperBoundSeries (const UpperBoundSeriesType& x)
  {
    this->upperBoundSeries_.set (x);
  }

  void ChanceConstraintComplexType::
  setUpperBoundSeries (const UpperBoundSeriesOptional& x)
  {
    this->upperBoundSeries_ = x;
  }

  void ChanceConstraintComplexType::
  setUpperBoundSeries (::std::auto_ptr< UpperBoundSeriesType > x)
  {
    this->upperBoundSeries_.set (x);
  }

  const ChanceConstraintComplexType::LowerBoundOptional& ChanceConstraintComplexType::
  getLowerBound () const
  {
    return this->lowerBound_;
  }

  ChanceConstraintComplexType::LowerBoundOptional& ChanceConstraintComplexType::
  getLowerBound ()
  {
    return this->lowerBound_;
  }

  void ChanceConstraintComplexType::
  setLowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  void ChanceConstraintComplexType::
  setLowerBound (const LowerBoundOptional& x)
  {
    this->lowerBound_ = x;
  }

  void ChanceConstraintComplexType::
  setLowerBound (::std::auto_ptr< LowerBoundType > x)
  {
    this->lowerBound_.set (x);
  }

  const ChanceConstraintComplexType::LowerBoundSeriesOptional& ChanceConstraintComplexType::
  getLowerBoundSeries () const
  {
    return this->lowerBoundSeries_;
  }

  ChanceConstraintComplexType::LowerBoundSeriesOptional& ChanceConstraintComplexType::
  getLowerBoundSeries ()
  {
    return this->lowerBoundSeries_;
  }

  void ChanceConstraintComplexType::
  setLowerBoundSeries (const LowerBoundSeriesType& x)
  {
    this->lowerBoundSeries_.set (x);
  }

  void ChanceConstraintComplexType::
  setLowerBoundSeries (const LowerBoundSeriesOptional& x)
  {
    this->lowerBoundSeries_ = x;
  }

  void ChanceConstraintComplexType::
  setLowerBoundSeries (::std::auto_ptr< LowerBoundSeriesType > x)
  {
    this->lowerBoundSeries_.set (x);
  }

  const ChanceConstraintComplexType::InputType& ChanceConstraintComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  ChanceConstraintComplexType::InputType& ChanceConstraintComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void ChanceConstraintComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void ChanceConstraintComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const ChanceConstraintComplexType::IdType& ChanceConstraintComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  ChanceConstraintComplexType::IdType& ChanceConstraintComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void ChanceConstraintComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ChanceConstraintComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // AverageComplexType
  // 

  const AverageComplexType::NStepOptional& AverageComplexType::
  getNStep () const
  {
    return this->nStep_;
  }

  AverageComplexType::NStepOptional& AverageComplexType::
  getNStep ()
  {
    return this->nStep_;
  }

  void AverageComplexType::
  setNStep (const NStepType& x)
  {
    this->nStep_.set (x);
  }

  void AverageComplexType::
  setNStep (const NStepOptional& x)
  {
    this->nStep_ = x;
  }

  void AverageComplexType::
  setNStep (::std::auto_ptr< NStepType > x)
  {
    this->nStep_.set (x);
  }

  AverageComplexType::NStepType AverageComplexType::
  getNStepDefaultValue ()
  {
    return NStepType (1LL);
  }

  const AverageComplexType::NStepSeriesOptional& AverageComplexType::
  getNStepSeries () const
  {
    return this->nStepSeries_;
  }

  AverageComplexType::NStepSeriesOptional& AverageComplexType::
  getNStepSeries ()
  {
    return this->nStepSeries_;
  }

  void AverageComplexType::
  setNStepSeries (const NStepSeriesType& x)
  {
    this->nStepSeries_.set (x);
  }

  void AverageComplexType::
  setNStepSeries (const NStepSeriesOptional& x)
  {
    this->nStepSeries_ = x;
  }

  void AverageComplexType::
  setNStepSeries (::std::auto_ptr< NStepSeriesType > x)
  {
    this->nStepSeries_.set (x);
  }

  const AverageComplexType::InputDelayVectorOptional& AverageComplexType::
  getInputDelayVector () const
  {
    return this->inputDelayVector_;
  }

  AverageComplexType::InputDelayVectorOptional& AverageComplexType::
  getInputDelayVector ()
  {
    return this->inputDelayVector_;
  }

  void AverageComplexType::
  setInputDelayVector (const InputDelayVectorType& x)
  {
    this->inputDelayVector_.set (x);
  }

  void AverageComplexType::
  setInputDelayVector (const InputDelayVectorOptional& x)
  {
    this->inputDelayVector_ = x;
  }

  void AverageComplexType::
  setInputDelayVector (::std::auto_ptr< InputDelayVectorType > x)
  {
    this->inputDelayVector_.set (x);
  }


  // TermLinearComplexType
  // 

  const TermLinearComplexType::WeightingFactorSeriesOptional& TermLinearComplexType::
  getWeightingFactorSeries () const
  {
    return this->weightingFactorSeries_;
  }

  TermLinearComplexType::WeightingFactorSeriesOptional& TermLinearComplexType::
  getWeightingFactorSeries ()
  {
    return this->weightingFactorSeries_;
  }

  void TermLinearComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesType& x)
  {
    this->weightingFactorSeries_.set (x);
  }

  void TermLinearComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesOptional& x)
  {
    this->weightingFactorSeries_ = x;
  }

  void TermLinearComplexType::
  setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > x)
  {
    this->weightingFactorSeries_.set (x);
  }

  const TermLinearComplexType::WeightingFactorSequence& TermLinearComplexType::
  getWeightingFactor () const
  {
    return this->weightingFactor_;
  }

  TermLinearComplexType::WeightingFactorSequence& TermLinearComplexType::
  getWeightingFactor ()
  {
    return this->weightingFactor_;
  }

  void TermLinearComplexType::
  setWeightingFactor (const WeightingFactorSequence& s)
  {
    this->weightingFactor_ = s;
  }

  const TermLinearComplexType::WeightingFactorType& TermLinearComplexType::
  getWeightingFactorDefaultValue ()
  {
    return weightingFactor_default_value_;
  }

  const TermLinearComplexType::WeightingFactorFinalSequence& TermLinearComplexType::
  getWeightingFactorFinal () const
  {
    return this->weightingFactorFinal_;
  }

  TermLinearComplexType::WeightingFactorFinalSequence& TermLinearComplexType::
  getWeightingFactorFinal ()
  {
    return this->weightingFactorFinal_;
  }

  void TermLinearComplexType::
  setWeightingFactorFinal (const WeightingFactorFinalSequence& s)
  {
    this->weightingFactorFinal_ = s;
  }

  const TermLinearComplexType::WeightingFactorFinalType& TermLinearComplexType::
  getWeightingFactorFinalDefaultValue ()
  {
    return weightingFactorFinal_default_value_;
  }

  const TermLinearComplexType::SetPointOptional& TermLinearComplexType::
  getSetPoint () const
  {
    return this->setPoint_;
  }

  TermLinearComplexType::SetPointOptional& TermLinearComplexType::
  getSetPoint ()
  {
    return this->setPoint_;
  }

  void TermLinearComplexType::
  setSetPoint (const SetPointType& x)
  {
    this->setPoint_.set (x);
  }

  void TermLinearComplexType::
  setSetPoint (const SetPointOptional& x)
  {
    this->setPoint_ = x;
  }

  void TermLinearComplexType::
  setSetPoint (::std::auto_ptr< SetPointType > x)
  {
    this->setPoint_.set (x);
  }

  const TermLinearComplexType::SetPointSeriesOptional& TermLinearComplexType::
  getSetPointSeries () const
  {
    return this->setPointSeries_;
  }

  TermLinearComplexType::SetPointSeriesOptional& TermLinearComplexType::
  getSetPointSeries ()
  {
    return this->setPointSeries_;
  }

  void TermLinearComplexType::
  setSetPointSeries (const SetPointSeriesType& x)
  {
    this->setPointSeries_.set (x);
  }

  void TermLinearComplexType::
  setSetPointSeries (const SetPointSeriesOptional& x)
  {
    this->setPointSeries_ = x;
  }

  void TermLinearComplexType::
  setSetPointSeries (::std::auto_ptr< SetPointSeriesType > x)
  {
    this->setPointSeries_.set (x);
  }

  const TermLinearComplexType::InputType& TermLinearComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TermLinearComplexType::InputType& TermLinearComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TermLinearComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TermLinearComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TermLinearComplexType::IdType& TermLinearComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermLinearComplexType::IdType& TermLinearComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermLinearComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermLinearComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermRateOfChangeComplexType
  // 

  const TermRateOfChangeComplexType::WeightingFactorSeriesOptional& TermRateOfChangeComplexType::
  getWeightingFactorSeries () const
  {
    return this->weightingFactorSeries_;
  }

  TermRateOfChangeComplexType::WeightingFactorSeriesOptional& TermRateOfChangeComplexType::
  getWeightingFactorSeries ()
  {
    return this->weightingFactorSeries_;
  }

  void TermRateOfChangeComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesType& x)
  {
    this->weightingFactorSeries_.set (x);
  }

  void TermRateOfChangeComplexType::
  setWeightingFactorSeries (const WeightingFactorSeriesOptional& x)
  {
    this->weightingFactorSeries_ = x;
  }

  void TermRateOfChangeComplexType::
  setWeightingFactorSeries (::std::auto_ptr< WeightingFactorSeriesType > x)
  {
    this->weightingFactorSeries_.set (x);
  }

  const TermRateOfChangeComplexType::WeightingFactorSequence& TermRateOfChangeComplexType::
  getWeightingFactor () const
  {
    return this->weightingFactor_;
  }

  TermRateOfChangeComplexType::WeightingFactorSequence& TermRateOfChangeComplexType::
  getWeightingFactor ()
  {
    return this->weightingFactor_;
  }

  void TermRateOfChangeComplexType::
  setWeightingFactor (const WeightingFactorSequence& s)
  {
    this->weightingFactor_ = s;
  }

  const TermRateOfChangeComplexType::WeightingFactorType& TermRateOfChangeComplexType::
  getWeightingFactorDefaultValue ()
  {
    return weightingFactor_default_value_;
  }

  const TermRateOfChangeComplexType::OrderType& TermRateOfChangeComplexType::
  getOrder () const
  {
    return this->order_.get ();
  }

  TermRateOfChangeComplexType::OrderType& TermRateOfChangeComplexType::
  getOrder ()
  {
    return this->order_.get ();
  }

  void TermRateOfChangeComplexType::
  setOrder (const OrderType& x)
  {
    this->order_.set (x);
  }

  TermRateOfChangeComplexType::OrderType TermRateOfChangeComplexType::
  getOrderDefaultValue ()
  {
    return OrderType (2.0);
  }

  const TermRateOfChangeComplexType::SetPointOptional& TermRateOfChangeComplexType::
  getSetPoint () const
  {
    return this->setPoint_;
  }

  TermRateOfChangeComplexType::SetPointOptional& TermRateOfChangeComplexType::
  getSetPoint ()
  {
    return this->setPoint_;
  }

  void TermRateOfChangeComplexType::
  setSetPoint (const SetPointType& x)
  {
    this->setPoint_.set (x);
  }

  void TermRateOfChangeComplexType::
  setSetPoint (const SetPointOptional& x)
  {
    this->setPoint_ = x;
  }

  const TermRateOfChangeComplexType::SetPointSeriesOptional& TermRateOfChangeComplexType::
  getSetPointSeries () const
  {
    return this->setPointSeries_;
  }

  TermRateOfChangeComplexType::SetPointSeriesOptional& TermRateOfChangeComplexType::
  getSetPointSeries ()
  {
    return this->setPointSeries_;
  }

  void TermRateOfChangeComplexType::
  setSetPointSeries (const SetPointSeriesType& x)
  {
    this->setPointSeries_.set (x);
  }

  void TermRateOfChangeComplexType::
  setSetPointSeries (const SetPointSeriesOptional& x)
  {
    this->setPointSeries_ = x;
  }

  void TermRateOfChangeComplexType::
  setSetPointSeries (::std::auto_ptr< SetPointSeriesType > x)
  {
    this->setPointSeries_.set (x);
  }

  const TermRateOfChangeComplexType::MultipleDelayOptional& TermRateOfChangeComplexType::
  getMultipleDelay () const
  {
    return this->multipleDelay_;
  }

  TermRateOfChangeComplexType::MultipleDelayOptional& TermRateOfChangeComplexType::
  getMultipleDelay ()
  {
    return this->multipleDelay_;
  }

  void TermRateOfChangeComplexType::
  setMultipleDelay (const MultipleDelayType& x)
  {
    this->multipleDelay_.set (x);
  }

  void TermRateOfChangeComplexType::
  setMultipleDelay (const MultipleDelayOptional& x)
  {
    this->multipleDelay_ = x;
  }

  void TermRateOfChangeComplexType::
  setMultipleDelay (::std::auto_ptr< MultipleDelayType > x)
  {
    this->multipleDelay_.set (x);
  }

  const TermRateOfChangeComplexType::UpperBranchOptional& TermRateOfChangeComplexType::
  getUpperBranch () const
  {
    return this->upperBranch_;
  }

  TermRateOfChangeComplexType::UpperBranchOptional& TermRateOfChangeComplexType::
  getUpperBranch ()
  {
    return this->upperBranch_;
  }

  void TermRateOfChangeComplexType::
  setUpperBranch (const UpperBranchType& x)
  {
    this->upperBranch_.set (x);
  }

  void TermRateOfChangeComplexType::
  setUpperBranch (const UpperBranchOptional& x)
  {
    this->upperBranch_ = x;
  }

  TermRateOfChangeComplexType::UpperBranchType TermRateOfChangeComplexType::
  getUpperBranchDefaultValue ()
  {
    return UpperBranchType (true);
  }

  const TermRateOfChangeComplexType::LowerBranchOptional& TermRateOfChangeComplexType::
  getLowerBranch () const
  {
    return this->lowerBranch_;
  }

  TermRateOfChangeComplexType::LowerBranchOptional& TermRateOfChangeComplexType::
  getLowerBranch ()
  {
    return this->lowerBranch_;
  }

  void TermRateOfChangeComplexType::
  setLowerBranch (const LowerBranchType& x)
  {
    this->lowerBranch_.set (x);
  }

  void TermRateOfChangeComplexType::
  setLowerBranch (const LowerBranchOptional& x)
  {
    this->lowerBranch_ = x;
  }

  TermRateOfChangeComplexType::LowerBranchType TermRateOfChangeComplexType::
  getLowerBranchDefaultValue ()
  {
    return LowerBranchType (true);
  }

  const TermRateOfChangeComplexType::InputType& TermRateOfChangeComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TermRateOfChangeComplexType::InputType& TermRateOfChangeComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TermRateOfChangeComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TermRateOfChangeComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TermRateOfChangeComplexType::IdType& TermRateOfChangeComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermRateOfChangeComplexType::IdType& TermRateOfChangeComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermRateOfChangeComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermRateOfChangeComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermMaxComplexType
  // 

  const TermMaxComplexType::InputType& TermMaxComplexType::
  getInput () const
  {
    return this->input_.get ();
  }

  TermMaxComplexType::InputType& TermMaxComplexType::
  getInput ()
  {
    return this->input_.get ();
  }

  void TermMaxComplexType::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void TermMaxComplexType::
  setInput (::std::auto_ptr< InputType > x)
  {
    this->input_.set (x);
  }

  const TermMaxComplexType::IdType& TermMaxComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermMaxComplexType::IdType& TermMaxComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermMaxComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermMaxComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermMSEComplexType
  // 

  const TermMSEComplexType::FlagOptional& TermMSEComplexType::
  getFlag () const
  {
    return this->flag_;
  }

  TermMSEComplexType::FlagOptional& TermMSEComplexType::
  getFlag ()
  {
    return this->flag_;
  }

  void TermMSEComplexType::
  setFlag (const FlagType& x)
  {
    this->flag_.set (x);
  }

  void TermMSEComplexType::
  setFlag (const FlagOptional& x)
  {
    this->flag_ = x;
  }

  void TermMSEComplexType::
  setFlag (::std::auto_ptr< FlagType > x)
  {
    this->flag_.set (x);
  }

  const TermMSEComplexType::ObservationType& TermMSEComplexType::
  getObservation () const
  {
    return this->observation_.get ();
  }

  TermMSEComplexType::ObservationType& TermMSEComplexType::
  getObservation ()
  {
    return this->observation_.get ();
  }

  void TermMSEComplexType::
  setObservation (const ObservationType& x)
  {
    this->observation_.set (x);
  }

  void TermMSEComplexType::
  setObservation (::std::auto_ptr< ObservationType > x)
  {
    this->observation_.set (x);
  }

  const TermMSEComplexType::SimulationType& TermMSEComplexType::
  getSimulation () const
  {
    return this->simulation_.get ();
  }

  TermMSEComplexType::SimulationType& TermMSEComplexType::
  getSimulation ()
  {
    return this->simulation_.get ();
  }

  void TermMSEComplexType::
  setSimulation (const SimulationType& x)
  {
    this->simulation_.set (x);
  }

  void TermMSEComplexType::
  setSimulation (::std::auto_ptr< SimulationType > x)
  {
    this->simulation_.set (x);
  }

  const TermMSEComplexType::IdType& TermMSEComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermMSEComplexType::IdType& TermMSEComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermMSEComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermMSEComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermRMSEComplexType
  // 

  const TermRMSEComplexType::FlagOptional& TermRMSEComplexType::
  getFlag () const
  {
    return this->flag_;
  }

  TermRMSEComplexType::FlagOptional& TermRMSEComplexType::
  getFlag ()
  {
    return this->flag_;
  }

  void TermRMSEComplexType::
  setFlag (const FlagType& x)
  {
    this->flag_.set (x);
  }

  void TermRMSEComplexType::
  setFlag (const FlagOptional& x)
  {
    this->flag_ = x;
  }

  void TermRMSEComplexType::
  setFlag (::std::auto_ptr< FlagType > x)
  {
    this->flag_.set (x);
  }

  const TermRMSEComplexType::ObservationType& TermRMSEComplexType::
  getObservation () const
  {
    return this->observation_.get ();
  }

  TermRMSEComplexType::ObservationType& TermRMSEComplexType::
  getObservation ()
  {
    return this->observation_.get ();
  }

  void TermRMSEComplexType::
  setObservation (const ObservationType& x)
  {
    this->observation_.set (x);
  }

  void TermRMSEComplexType::
  setObservation (::std::auto_ptr< ObservationType > x)
  {
    this->observation_.set (x);
  }

  const TermRMSEComplexType::SimulationType& TermRMSEComplexType::
  getSimulation () const
  {
    return this->simulation_.get ();
  }

  TermRMSEComplexType::SimulationType& TermRMSEComplexType::
  getSimulation ()
  {
    return this->simulation_.get ();
  }

  void TermRMSEComplexType::
  setSimulation (const SimulationType& x)
  {
    this->simulation_.set (x);
  }

  void TermRMSEComplexType::
  setSimulation (::std::auto_ptr< SimulationType > x)
  {
    this->simulation_.set (x);
  }

  const TermRMSEComplexType::IdType& TermRMSEComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermRMSEComplexType::IdType& TermRMSEComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermRMSEComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermRMSEComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermNSEComplexType
  // 

  const TermNSEComplexType::FlagOptional& TermNSEComplexType::
  getFlag () const
  {
    return this->flag_;
  }

  TermNSEComplexType::FlagOptional& TermNSEComplexType::
  getFlag ()
  {
    return this->flag_;
  }

  void TermNSEComplexType::
  setFlag (const FlagType& x)
  {
    this->flag_.set (x);
  }

  void TermNSEComplexType::
  setFlag (const FlagOptional& x)
  {
    this->flag_ = x;
  }

  void TermNSEComplexType::
  setFlag (::std::auto_ptr< FlagType > x)
  {
    this->flag_.set (x);
  }

  const TermNSEComplexType::SkipNFirstStepsOptional& TermNSEComplexType::
  getSkipNFirstSteps () const
  {
    return this->skipNFirstSteps_;
  }

  TermNSEComplexType::SkipNFirstStepsOptional& TermNSEComplexType::
  getSkipNFirstSteps ()
  {
    return this->skipNFirstSteps_;
  }

  void TermNSEComplexType::
  setSkipNFirstSteps (const SkipNFirstStepsType& x)
  {
    this->skipNFirstSteps_.set (x);
  }

  void TermNSEComplexType::
  setSkipNFirstSteps (const SkipNFirstStepsOptional& x)
  {
    this->skipNFirstSteps_ = x;
  }

  const TermNSEComplexType::ObservationType& TermNSEComplexType::
  getObservation () const
  {
    return this->observation_.get ();
  }

  TermNSEComplexType::ObservationType& TermNSEComplexType::
  getObservation ()
  {
    return this->observation_.get ();
  }

  void TermNSEComplexType::
  setObservation (const ObservationType& x)
  {
    this->observation_.set (x);
  }

  void TermNSEComplexType::
  setObservation (::std::auto_ptr< ObservationType > x)
  {
    this->observation_.set (x);
  }

  const TermNSEComplexType::SimulationType& TermNSEComplexType::
  getSimulation () const
  {
    return this->simulation_.get ();
  }

  TermNSEComplexType::SimulationType& TermNSEComplexType::
  getSimulation ()
  {
    return this->simulation_.get ();
  }

  void TermNSEComplexType::
  setSimulation (const SimulationType& x)
  {
    this->simulation_.set (x);
  }

  void TermNSEComplexType::
  setSimulation (::std::auto_ptr< SimulationType > x)
  {
    this->simulation_.set (x);
  }

  const TermNSEComplexType::IdType& TermNSEComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermNSEComplexType::IdType& TermNSEComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermNSEComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermNSEComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermRelativeVolumeComplexType
  // 

  const TermRelativeVolumeComplexType::FlagOptional& TermRelativeVolumeComplexType::
  getFlag () const
  {
    return this->flag_;
  }

  TermRelativeVolumeComplexType::FlagOptional& TermRelativeVolumeComplexType::
  getFlag ()
  {
    return this->flag_;
  }

  void TermRelativeVolumeComplexType::
  setFlag (const FlagType& x)
  {
    this->flag_.set (x);
  }

  void TermRelativeVolumeComplexType::
  setFlag (const FlagOptional& x)
  {
    this->flag_ = x;
  }

  void TermRelativeVolumeComplexType::
  setFlag (::std::auto_ptr< FlagType > x)
  {
    this->flag_.set (x);
  }

  const TermRelativeVolumeComplexType::SkipNFirstStepsOptional& TermRelativeVolumeComplexType::
  getSkipNFirstSteps () const
  {
    return this->skipNFirstSteps_;
  }

  TermRelativeVolumeComplexType::SkipNFirstStepsOptional& TermRelativeVolumeComplexType::
  getSkipNFirstSteps ()
  {
    return this->skipNFirstSteps_;
  }

  void TermRelativeVolumeComplexType::
  setSkipNFirstSteps (const SkipNFirstStepsType& x)
  {
    this->skipNFirstSteps_.set (x);
  }

  void TermRelativeVolumeComplexType::
  setSkipNFirstSteps (const SkipNFirstStepsOptional& x)
  {
    this->skipNFirstSteps_ = x;
  }

  const TermRelativeVolumeComplexType::ObservationType& TermRelativeVolumeComplexType::
  getObservation () const
  {
    return this->observation_.get ();
  }

  TermRelativeVolumeComplexType::ObservationType& TermRelativeVolumeComplexType::
  getObservation ()
  {
    return this->observation_.get ();
  }

  void TermRelativeVolumeComplexType::
  setObservation (const ObservationType& x)
  {
    this->observation_.set (x);
  }

  void TermRelativeVolumeComplexType::
  setObservation (::std::auto_ptr< ObservationType > x)
  {
    this->observation_.set (x);
  }

  const TermRelativeVolumeComplexType::SimulationType& TermRelativeVolumeComplexType::
  getSimulation () const
  {
    return this->simulation_.get ();
  }

  TermRelativeVolumeComplexType::SimulationType& TermRelativeVolumeComplexType::
  getSimulation ()
  {
    return this->simulation_.get ();
  }

  void TermRelativeVolumeComplexType::
  setSimulation (const SimulationType& x)
  {
    this->simulation_.set (x);
  }

  void TermRelativeVolumeComplexType::
  setSimulation (::std::auto_ptr< SimulationType > x)
  {
    this->simulation_.set (x);
  }

  const TermRelativeVolumeComplexType::IdType& TermRelativeVolumeComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermRelativeVolumeComplexType::IdType& TermRelativeVolumeComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermRelativeVolumeComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermRelativeVolumeComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermRVComplexType
  // 

  const TermRVComplexType::FlagOptional& TermRVComplexType::
  getFlag () const
  {
    return this->flag_;
  }

  TermRVComplexType::FlagOptional& TermRVComplexType::
  getFlag ()
  {
    return this->flag_;
  }

  void TermRVComplexType::
  setFlag (const FlagType& x)
  {
    this->flag_.set (x);
  }

  void TermRVComplexType::
  setFlag (const FlagOptional& x)
  {
    this->flag_ = x;
  }

  void TermRVComplexType::
  setFlag (::std::auto_ptr< FlagType > x)
  {
    this->flag_.set (x);
  }

  const TermRVComplexType::WType& TermRVComplexType::
  getW () const
  {
    return this->w_.get ();
  }

  TermRVComplexType::WType& TermRVComplexType::
  getW ()
  {
    return this->w_.get ();
  }

  void TermRVComplexType::
  setW (const WType& x)
  {
    this->w_.set (x);
  }

  const TermRVComplexType::SkipNFirstStepsOptional& TermRVComplexType::
  getSkipNFirstSteps () const
  {
    return this->skipNFirstSteps_;
  }

  TermRVComplexType::SkipNFirstStepsOptional& TermRVComplexType::
  getSkipNFirstSteps ()
  {
    return this->skipNFirstSteps_;
  }

  void TermRVComplexType::
  setSkipNFirstSteps (const SkipNFirstStepsType& x)
  {
    this->skipNFirstSteps_.set (x);
  }

  void TermRVComplexType::
  setSkipNFirstSteps (const SkipNFirstStepsOptional& x)
  {
    this->skipNFirstSteps_ = x;
  }

  const TermRVComplexType::ObservationType& TermRVComplexType::
  getObservation () const
  {
    return this->observation_.get ();
  }

  TermRVComplexType::ObservationType& TermRVComplexType::
  getObservation ()
  {
    return this->observation_.get ();
  }

  void TermRVComplexType::
  setObservation (const ObservationType& x)
  {
    this->observation_.set (x);
  }

  void TermRVComplexType::
  setObservation (::std::auto_ptr< ObservationType > x)
  {
    this->observation_.set (x);
  }

  const TermRVComplexType::SimulationType& TermRVComplexType::
  getSimulation () const
  {
    return this->simulation_.get ();
  }

  TermRVComplexType::SimulationType& TermRVComplexType::
  getSimulation ()
  {
    return this->simulation_.get ();
  }

  void TermRVComplexType::
  setSimulation (const SimulationType& x)
  {
    this->simulation_.set (x);
  }

  void TermRVComplexType::
  setSimulation (::std::auto_ptr< SimulationType > x)
  {
    this->simulation_.set (x);
  }

  const TermRVComplexType::IdType& TermRVComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermRVComplexType::IdType& TermRVComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermRVComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermRVComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // TermSumComplexType
  // 

  const TermSumComplexType::FlagOptional& TermSumComplexType::
  getFlag () const
  {
    return this->flag_;
  }

  TermSumComplexType::FlagOptional& TermSumComplexType::
  getFlag ()
  {
    return this->flag_;
  }

  void TermSumComplexType::
  setFlag (const FlagType& x)
  {
    this->flag_.set (x);
  }

  void TermSumComplexType::
  setFlag (const FlagOptional& x)
  {
    this->flag_ = x;
  }

  void TermSumComplexType::
  setFlag (::std::auto_ptr< FlagType > x)
  {
    this->flag_.set (x);
  }

  const TermSumComplexType::SimulationType& TermSumComplexType::
  getSimulation () const
  {
    return this->simulation_.get ();
  }

  TermSumComplexType::SimulationType& TermSumComplexType::
  getSimulation ()
  {
    return this->simulation_.get ();
  }

  void TermSumComplexType::
  setSimulation (const SimulationType& x)
  {
    this->simulation_.set (x);
  }

  void TermSumComplexType::
  setSimulation (::std::auto_ptr< SimulationType > x)
  {
    this->simulation_.set (x);
  }

  const TermSumComplexType::IdType& TermSumComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  TermSumComplexType::IdType& TermSumComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void TermSumComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TermSumComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // OutputComplexType
  // 

  const OutputComplexType::JIncType& OutputComplexType::
  getJInc () const
  {
    return this->JInc_.get ();
  }

  OutputComplexType::JIncType& OutputComplexType::
  getJInc ()
  {
    return this->JInc_.get ();
  }

  void OutputComplexType::
  setJInc (const JIncType& x)
  {
    this->JInc_.set (x);
  }

  void OutputComplexType::
  setJInc (::std::auto_ptr< JIncType > x)
  {
    this->JInc_.set (x);
  }

  const OutputComplexType::JAccType& OutputComplexType::
  getJAcc () const
  {
    return this->JAcc_.get ();
  }

  OutputComplexType::JAccType& OutputComplexType::
  getJAcc ()
  {
    return this->JAcc_.get ();
  }

  void OutputComplexType::
  setJAcc (const JAccType& x)
  {
    this->JAcc_.set (x);
  }

  void OutputComplexType::
  setJAcc (::std::auto_ptr< JAccType > x)
  {
    this->JAcc_.set (x);
  }


  // NStepModeEnum
  // 

  NStepModeEnum::
  NStepModeEnum (Value v)
  : ::xml_schema::String (_xsd_NStepModeEnum_literals_[v])
  {
  }

  NStepModeEnum::
  NStepModeEnum (const char* v)
  : ::xml_schema::String (v)
  {
  }

  NStepModeEnum::
  NStepModeEnum (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  NStepModeEnum::
  NStepModeEnum (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  NStepModeEnum::
  NStepModeEnum (const NStepModeEnum& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  NStepModeEnum& NStepModeEnum::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_NStepModeEnum_literals_[v]);

    return *this;
  }


  // NStep
  // 


  // NStep1
  // 


  // NStep2
  // 


  // NStep3
  // 


  // StepIndex
  // 


  // NStep4
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace fews
{
  // RtcObjectiveConfigComplexType
  //

  RtcObjectiveConfigComplexType::
  RtcObjectiveConfigComplexType ()
  : ::xml_schema::Type (),
    variables_ (::xml_schema::Flags (), this),
    constraints_ (::xml_schema::Flags (), this),
    terms_ (::xml_schema::Flags (), this),
    termsEnsemble_ (::xml_schema::Flags (), this),
    output_ (::xml_schema::Flags (), this)
  {
  }

  RtcObjectiveConfigComplexType::
  RtcObjectiveConfigComplexType (const RtcObjectiveConfigComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variables_ (x.variables_, f, this),
    constraints_ (x.constraints_, f, this),
    terms_ (x.terms_, f, this),
    termsEnsemble_ (x.termsEnsemble_, f, this),
    output_ (x.output_, f, this)
  {
  }

  RtcObjectiveConfigComplexType::
  RtcObjectiveConfigComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variables_ (f, this),
    constraints_ (f, this),
    terms_ (f, this),
    termsEnsemble_ (f, this),
    output_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RtcObjectiveConfigComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variables
      //
      if (n.name () == "variables" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariablesType > r (
          VariablesTraits::create (i, f, this));

        if (!this->variables_)
        {
          this->variables_.set (r);
          continue;
        }
      }

      // constraints
      //
      if (n.name () == "constraints" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConstraintsType > r (
          ConstraintsTraits::create (i, f, this));

        if (!this->constraints_)
        {
          this->constraints_.set (r);
          continue;
        }
      }

      // terms
      //
      if (n.name () == "terms" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TermsType > r (
          TermsTraits::create (i, f, this));

        if (!this->terms_)
        {
          this->terms_.set (r);
          continue;
        }
      }

      // termsEnsemble
      //
      if (n.name () == "termsEnsemble" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TermsEnsembleType > r (
          TermsEnsembleTraits::create (i, f, this));

        if (!this->termsEnsemble_)
        {
          this->termsEnsemble_.set (r);
          continue;
        }
      }

      // output
      //
      if (n.name () == "output" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OutputType > r (
          OutputTraits::create (i, f, this));

        if (!this->output_)
        {
          this->output_.set (r);
          continue;
        }
      }

      break;
    }
  }

  RtcObjectiveConfigComplexType* RtcObjectiveConfigComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RtcObjectiveConfigComplexType (*this, f, c);
  }

  RtcObjectiveConfigComplexType::
  ~RtcObjectiveConfigComplexType ()
  {
  }

  // VariablesComplexType
  //

  VariablesComplexType::
  VariablesComplexType ()
  : ::xml_schema::Type (),
    variable_ (::xml_schema::Flags (), this),
    aggregation_ (::xml_schema::Flags (), this)
  {
  }

  VariablesComplexType::
  VariablesComplexType (const VariablesComplexType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this),
    aggregation_ (x.aggregation_, f, this)
  {
  }

  VariablesComplexType::
  VariablesComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (f, this),
    aggregation_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void VariablesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (r);
        continue;
      }

      // aggregation
      //
      if (n.name () == "aggregation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AggregationType > r (
          AggregationTraits::create (i, f, this));

        if (!this->aggregation_)
        {
          this->aggregation_.set (r);
          continue;
        }
      }

      break;
    }
  }

  VariablesComplexType* VariablesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VariablesComplexType (*this, f, c);
  }

  VariablesComplexType::
  ~VariablesComplexType ()
  {
  }

  // VariableComplexType
  //

  const VariableComplexType::ActiveType VariableComplexType::active_default_value_ (
    "true");

  const VariableComplexType::EnsembleModeType VariableComplexType::ensembleMode_default_value_ (
    "JOINT");

  VariableComplexType::
  VariableComplexType (const IdType& id,
                       const TypeType& type)
  : ::xml_schema::Type (),
    aggregation_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    type_ (type, ::xml_schema::Flags (), this),
    active_ (getActiveDefaultValue (), ::xml_schema::Flags (), this),
    min_ (::xml_schema::Flags (), this),
    max_ (::xml_schema::Flags (), this),
    scalingFactor_ (getScalingFactorDefaultValue (), ::xml_schema::Flags (), this),
    ensembleMode_ (getEnsembleModeDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  VariableComplexType::
  VariableComplexType (const VariableComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    aggregation_ (x.aggregation_, f, this),
    id_ (x.id_, f, this),
    type_ (x.type_, f, this),
    active_ (x.active_, f, this),
    min_ (x.min_, f, this),
    max_ (x.max_, f, this),
    scalingFactor_ (x.scalingFactor_, f, this),
    ensembleMode_ (x.ensembleMode_, f, this)
  {
  }

  VariableComplexType::
  VariableComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    aggregation_ (f, this),
    id_ (f, this),
    type_ (f, this),
    active_ (f, this),
    min_ (f, this),
    max_ (f, this),
    scalingFactor_ (f, this),
    ensembleMode_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VariableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // aggregation
      //
      if (n.name () == "aggregation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AggregationType > r (
          AggregationTraits::create (i, f, this));

        if (!this->aggregation_)
        {
          this->aggregation_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "active" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        this->active_.set (r);
        continue;
      }

      if (n.name () == "min" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MinType > r (
          MinTraits::create (i, f, this));

        this->min_.set (r);
        continue;
      }

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MaxType > r (
          MaxTraits::create (i, f, this));

        this->max_.set (r);
        continue;
      }

      if (n.name () == "scalingFactor" && n.namespace_ ().empty ())
      {
        this->scalingFactor_.set (ScalingFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ensembleMode" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< EnsembleModeType > r (
          EnsembleModeTraits::create (i, f, this));

        this->ensembleMode_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!active_.present ())
    {
      this->active_.set (getActiveDefaultValue ());
    }

    if (!scalingFactor_.present ())
    {
      this->scalingFactor_.set (getScalingFactorDefaultValue ());
    }

    if (!ensembleMode_.present ())
    {
      this->ensembleMode_.set (getEnsembleModeDefaultValue ());
    }
  }

  VariableComplexType* VariableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VariableComplexType (*this, f, c);
  }

  VariableComplexType::
  ~VariableComplexType ()
  {
  }

  // AggregationComplexType
  //

  AggregationComplexType::
  AggregationComplexType ()
  : ::xml_schema::Type (),
    constant_ (::xml_schema::Flags (), this),
    equidistant_ (::xml_schema::Flags (), this),
    non_equidistant_ (::xml_schema::Flags (), this)
  {
  }

  AggregationComplexType::
  AggregationComplexType (const AggregationComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    constant_ (x.constant_, f, this),
    equidistant_ (x.equidistant_, f, this),
    non_equidistant_ (x.non_equidistant_, f, this)
  {
  }

  AggregationComplexType::
  AggregationComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    constant_ (f, this),
    equidistant_ (f, this),
    non_equidistant_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AggregationComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConstantType > r (
          ConstantTraits::create (i, f, this));

        if (!this->constant_)
        {
          this->constant_.set (r);
          continue;
        }
      }

      // equidistant
      //
      if (n.name () == "equidistant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< EquidistantType > r (
          EquidistantTraits::create (i, f, this));

        if (!this->equidistant_)
        {
          this->equidistant_.set (r);
          continue;
        }
      }

      // non-equidistant
      //
      if (n.name () == "non-equidistant" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< Non_equidistantType > r (
          Non_equidistantTraits::create (i, f, this));

        if (!this->non_equidistant_)
        {
          this->non_equidistant_.set (r);
          continue;
        }
      }

      break;
    }
  }

  AggregationComplexType* AggregationComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AggregationComplexType (*this, f, c);
  }

  AggregationComplexType::
  ~AggregationComplexType ()
  {
  }

  // AggregationEquidistantComplexType
  //

  AggregationEquidistantComplexType::
  AggregationEquidistantComplexType (const TypeType& type,
                                     const NAggregationStepsType& nAggregationSteps)
  : ::xml_schema::Type (),
    type_ (type, ::xml_schema::Flags (), this),
    nAggregationSteps_ (nAggregationSteps, ::xml_schema::Flags (), this)
  {
  }

  AggregationEquidistantComplexType::
  AggregationEquidistantComplexType (const AggregationEquidistantComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    type_ (x.type_, f, this),
    nAggregationSteps_ (x.nAggregationSteps_, f, this)
  {
  }

  AggregationEquidistantComplexType::
  AggregationEquidistantComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    type_ (f, this),
    nAggregationSteps_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AggregationEquidistantComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // nAggregationSteps
      //
      if (n.name () == "nAggregationSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!nAggregationSteps_.present ())
        {
          this->nAggregationSteps_.set (NAggregationStepsTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.wldelft.nl/fews");
    }

    if (!nAggregationSteps_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nAggregationSteps",
        "http://www.wldelft.nl/fews");
    }
  }

  AggregationEquidistantComplexType* AggregationEquidistantComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AggregationEquidistantComplexType (*this, f, c);
  }

  AggregationEquidistantComplexType::
  ~AggregationEquidistantComplexType ()
  {
  }

  // AggregationNonEquidistantComplexType
  //

  AggregationNonEquidistantComplexType::
  AggregationNonEquidistantComplexType (const TypeType& type,
                                        const NInputStepsType& nInputSteps,
                                        const NOutputStepsType& nOutputSteps)
  : ::xml_schema::Type (),
    type_ (type, ::xml_schema::Flags (), this),
    nInputSteps_ (nInputSteps, ::xml_schema::Flags (), this),
    nOutputSteps_ (nOutputSteps, ::xml_schema::Flags (), this),
    stepIndex_ (::xml_schema::Flags (), this)
  {
  }

  AggregationNonEquidistantComplexType::
  AggregationNonEquidistantComplexType (const AggregationNonEquidistantComplexType& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    type_ (x.type_, f, this),
    nInputSteps_ (x.nInputSteps_, f, this),
    nOutputSteps_ (x.nOutputSteps_, f, this),
    stepIndex_ (x.stepIndex_, f, this)
  {
  }

  AggregationNonEquidistantComplexType::
  AggregationNonEquidistantComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    type_ (f, this),
    nInputSteps_ (f, this),
    nOutputSteps_ (f, this),
    stepIndex_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AggregationNonEquidistantComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // nInputSteps
      //
      if (n.name () == "nInputSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!nInputSteps_.present ())
        {
          this->nInputSteps_.set (NInputStepsTraits::create (i, f, this));
          continue;
        }
      }

      // nOutputSteps
      //
      if (n.name () == "nOutputSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!nOutputSteps_.present ())
        {
          this->nOutputSteps_.set (NOutputStepsTraits::create (i, f, this));
          continue;
        }
      }

      // stepIndex
      //
      if (n.name () == "stepIndex" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        this->stepIndex_.push_back (StepIndexTraits::create (i, f, this));
        continue;
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.wldelft.nl/fews");
    }

    if (!nInputSteps_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nInputSteps",
        "http://www.wldelft.nl/fews");
    }

    if (!nOutputSteps_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nOutputSteps",
        "http://www.wldelft.nl/fews");
    }
  }

  AggregationNonEquidistantComplexType* AggregationNonEquidistantComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AggregationNonEquidistantComplexType (*this, f, c);
  }

  AggregationNonEquidistantComplexType::
  ~AggregationNonEquidistantComplexType ()
  {
  }

  // ConstraintsComplexType
  //

  ConstraintsComplexType::
  ConstraintsComplexType ()
  : ::xml_schema::Type (),
    constraint_ (::xml_schema::Flags (), this)
  {
  }

  ConstraintsComplexType::
  ConstraintsComplexType (const ConstraintsComplexType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    constraint_ (x.constraint_, f, this)
  {
  }

  ConstraintsComplexType::
  ConstraintsComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    constraint_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConstraintsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // constraint
      //
      if (n.name () == "constraint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ConstraintType > r (
          ConstraintTraits::create (i, f, this));

        this->constraint_.push_back (r);
        continue;
      }

      break;
    }
  }

  ConstraintsComplexType* ConstraintsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConstraintsComplexType (*this, f, c);
  }

  ConstraintsComplexType::
  ~ConstraintsComplexType ()
  {
  }

  // ConstraintChoiceComplexType
  //

  const ConstraintChoiceComplexType::ActiveType ConstraintChoiceComplexType::active_default_value_ (
    "true");

  ConstraintChoiceComplexType::
  ConstraintChoiceComplexType ()
  : ::xml_schema::Type (),
    boundVariable_ (::xml_schema::Flags (), this),
    boundVariableAverage_ (::xml_schema::Flags (), this),
    boundVariableRateOfChange_ (::xml_schema::Flags (), this),
    boundState_ (::xml_schema::Flags (), this),
    chanceBoundVariable_ (::xml_schema::Flags (), this),
    active_ (getActiveDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  ConstraintChoiceComplexType::
  ConstraintChoiceComplexType (const ConstraintChoiceComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    boundVariable_ (x.boundVariable_, f, this),
    boundVariableAverage_ (x.boundVariableAverage_, f, this),
    boundVariableRateOfChange_ (x.boundVariableRateOfChange_, f, this),
    boundState_ (x.boundState_, f, this),
    chanceBoundVariable_ (x.chanceBoundVariable_, f, this),
    active_ (x.active_, f, this)
  {
  }

  ConstraintChoiceComplexType::
  ConstraintChoiceComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    boundVariable_ (f, this),
    boundVariableAverage_ (f, this),
    boundVariableRateOfChange_ (f, this),
    boundState_ (f, this),
    chanceBoundVariable_ (f, this),
    active_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ConstraintChoiceComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // boundVariable
      //
      if (n.name () == "boundVariable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BoundVariableType > r (
          BoundVariableTraits::create (i, f, this));

        if (!this->boundVariable_)
        {
          this->boundVariable_.set (r);
          continue;
        }
      }

      // boundVariableAverage
      //
      if (n.name () == "boundVariableAverage" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BoundVariableAverageType > r (
          BoundVariableAverageTraits::create (i, f, this));

        if (!this->boundVariableAverage_)
        {
          this->boundVariableAverage_.set (r);
          continue;
        }
      }

      // boundVariableRateOfChange
      //
      if (n.name () == "boundVariableRateOfChange" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BoundVariableRateOfChangeType > r (
          BoundVariableRateOfChangeTraits::create (i, f, this));

        if (!this->boundVariableRateOfChange_)
        {
          this->boundVariableRateOfChange_.set (r);
          continue;
        }
      }

      // boundState
      //
      if (n.name () == "boundState" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< BoundStateType > r (
          BoundStateTraits::create (i, f, this));

        if (!this->boundState_)
        {
          this->boundState_.set (r);
          continue;
        }
      }

      // chanceBoundVariable
      //
      if (n.name () == "chanceBoundVariable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ChanceBoundVariableType > r (
          ChanceBoundVariableTraits::create (i, f, this));

        if (!this->chanceBoundVariable_)
        {
          this->chanceBoundVariable_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "active" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        this->active_.set (r);
        continue;
      }
    }

    if (!active_.present ())
    {
      this->active_.set (getActiveDefaultValue ());
    }
  }

  ConstraintChoiceComplexType* ConstraintChoiceComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ConstraintChoiceComplexType (*this, f, c);
  }

  ConstraintChoiceComplexType::
  ~ConstraintChoiceComplexType ()
  {
  }

  // BoundVariableComplexType
  //

  BoundVariableComplexType::
  BoundVariableComplexType (const VariableType& variable,
                            const IdType& id)
  : ::xml_schema::Type (),
    variable_ (variable, ::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  BoundVariableComplexType::
  BoundVariableComplexType (const BoundVariableComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this),
    upperBound_ (x.upperBound_, f, this),
    upperBoundSeries_ (x.upperBoundSeries_, f, this),
    lowerBound_ (x.lowerBound_, f, this),
    lowerBoundSeries_ (x.lowerBoundSeries_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  BoundVariableComplexType::
  BoundVariableComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (f, this),
    upperBound_ (f, this),
    upperBoundSeries_ (f, this),
    lowerBound_ (f, this),
    lowerBoundSeries_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BoundVariableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        if (!variable_.present ())
        {
          this->variable_.set (r);
          continue;
        }
      }

      // upperBound
      //
      if (n.name () == "upperBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundType > r (
          UpperBoundTraits::create (i, f, this));

        if (!this->upperBound_)
        {
          this->upperBound_.set (r);
          continue;
        }
      }

      // upperBoundSeries
      //
      if (n.name () == "upperBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundSeriesType > r (
          UpperBoundSeriesTraits::create (i, f, this));

        if (!this->upperBoundSeries_)
        {
          this->upperBoundSeries_.set (r);
          continue;
        }
      }

      // lowerBound
      //
      if (n.name () == "lowerBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundType > r (
          LowerBoundTraits::create (i, f, this));

        if (!this->lowerBound_)
        {
          this->lowerBound_.set (r);
          continue;
        }
      }

      // lowerBoundSeries
      //
      if (n.name () == "lowerBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundSeriesType > r (
          LowerBoundSeriesTraits::create (i, f, this));

        if (!this->lowerBoundSeries_)
        {
          this->lowerBoundSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variable",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  BoundVariableComplexType* BoundVariableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundVariableComplexType (*this, f, c);
  }

  BoundVariableComplexType::
  ~BoundVariableComplexType ()
  {
  }

  // BoundVariableRateOfChangeComplexType
  //

  BoundVariableRateOfChangeComplexType::
  BoundVariableRateOfChangeComplexType (const VariableType& variable,
                                        const IdType& id)
  : ::xml_schema::Type (),
    variable_ (variable, ::xml_schema::Flags (), this),
    multipleDelay_ (::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  BoundVariableRateOfChangeComplexType::
  BoundVariableRateOfChangeComplexType (const BoundVariableRateOfChangeComplexType& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this),
    multipleDelay_ (x.multipleDelay_, f, this),
    upperBound_ (x.upperBound_, f, this),
    upperBoundSeries_ (x.upperBoundSeries_, f, this),
    lowerBound_ (x.lowerBound_, f, this),
    lowerBoundSeries_ (x.lowerBoundSeries_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  BoundVariableRateOfChangeComplexType::
  BoundVariableRateOfChangeComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (f, this),
    multipleDelay_ (f, this),
    upperBound_ (f, this),
    upperBoundSeries_ (f, this),
    lowerBound_ (f, this),
    lowerBoundSeries_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BoundVariableRateOfChangeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        if (!variable_.present ())
        {
          this->variable_.set (r);
          continue;
        }
      }

      // multipleDelay
      //
      if (n.name () == "multipleDelay" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MultipleDelayType > r (
          MultipleDelayTraits::create (i, f, this));

        if (!this->multipleDelay_)
        {
          this->multipleDelay_.set (r);
          continue;
        }
      }

      // upperBound
      //
      if (n.name () == "upperBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundType > r (
          UpperBoundTraits::create (i, f, this));

        if (!this->upperBound_)
        {
          this->upperBound_.set (r);
          continue;
        }
      }

      // upperBoundSeries
      //
      if (n.name () == "upperBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundSeriesType > r (
          UpperBoundSeriesTraits::create (i, f, this));

        if (!this->upperBoundSeries_)
        {
          this->upperBoundSeries_.set (r);
          continue;
        }
      }

      // lowerBound
      //
      if (n.name () == "lowerBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundType > r (
          LowerBoundTraits::create (i, f, this));

        if (!this->lowerBound_)
        {
          this->lowerBound_.set (r);
          continue;
        }
      }

      // lowerBoundSeries
      //
      if (n.name () == "lowerBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundSeriesType > r (
          LowerBoundSeriesTraits::create (i, f, this));

        if (!this->lowerBoundSeries_)
        {
          this->lowerBoundSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variable",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  BoundVariableRateOfChangeComplexType* BoundVariableRateOfChangeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundVariableRateOfChangeComplexType (*this, f, c);
  }

  BoundVariableRateOfChangeComplexType::
  ~BoundVariableRateOfChangeComplexType ()
  {
  }

  // BoundVariableAverageComplexType
  //

  BoundVariableAverageComplexType::
  BoundVariableAverageComplexType (const VariableType& variable,
                                   const AverageType& average,
                                   const IdType& id)
  : ::xml_schema::Type (),
    variable_ (variable, ::xml_schema::Flags (), this),
    average_ (average, ::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  BoundVariableAverageComplexType::
  BoundVariableAverageComplexType (const VariableType& variable,
                                   ::std::auto_ptr< AverageType >& average,
                                   const IdType& id)
  : ::xml_schema::Type (),
    variable_ (variable, ::xml_schema::Flags (), this),
    average_ (average, ::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  BoundVariableAverageComplexType::
  BoundVariableAverageComplexType (const BoundVariableAverageComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this),
    average_ (x.average_, f, this),
    upperBound_ (x.upperBound_, f, this),
    upperBoundSeries_ (x.upperBoundSeries_, f, this),
    lowerBound_ (x.lowerBound_, f, this),
    lowerBoundSeries_ (x.lowerBoundSeries_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  BoundVariableAverageComplexType::
  BoundVariableAverageComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (f, this),
    average_ (f, this),
    upperBound_ (f, this),
    upperBoundSeries_ (f, this),
    lowerBound_ (f, this),
    lowerBoundSeries_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BoundVariableAverageComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        if (!variable_.present ())
        {
          this->variable_.set (r);
          continue;
        }
      }

      // average
      //
      if (n.name () == "average" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AverageType > r (
          AverageTraits::create (i, f, this));

        if (!average_.present ())
        {
          this->average_.set (r);
          continue;
        }
      }

      // upperBound
      //
      if (n.name () == "upperBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundType > r (
          UpperBoundTraits::create (i, f, this));

        if (!this->upperBound_)
        {
          this->upperBound_.set (r);
          continue;
        }
      }

      // upperBoundSeries
      //
      if (n.name () == "upperBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundSeriesType > r (
          UpperBoundSeriesTraits::create (i, f, this));

        if (!this->upperBoundSeries_)
        {
          this->upperBoundSeries_.set (r);
          continue;
        }
      }

      // lowerBound
      //
      if (n.name () == "lowerBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundType > r (
          LowerBoundTraits::create (i, f, this));

        if (!this->lowerBound_)
        {
          this->lowerBound_.set (r);
          continue;
        }
      }

      // lowerBoundSeries
      //
      if (n.name () == "lowerBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundSeriesType > r (
          LowerBoundSeriesTraits::create (i, f, this));

        if (!this->lowerBoundSeries_)
        {
          this->lowerBoundSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variable",
        "http://www.wldelft.nl/fews");
    }

    if (!average_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "average",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  BoundVariableAverageComplexType* BoundVariableAverageComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundVariableAverageComplexType (*this, f, c);
  }

  BoundVariableAverageComplexType::
  ~BoundVariableAverageComplexType ()
  {
  }

  // BoundAverageComplexType
  //

  BoundAverageComplexType::
  BoundAverageComplexType ()
  : ::xml_schema::Type (),
    nStep_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this),
    variableDelayVector_ (::xml_schema::Flags (), this)
  {
  }

  BoundAverageComplexType::
  BoundAverageComplexType (const BoundAverageComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nStep_ (x.nStep_, f, this),
    nStepSeries_ (x.nStepSeries_, f, this),
    variableDelayVector_ (x.variableDelayVector_, f, this)
  {
  }

  BoundAverageComplexType::
  BoundAverageComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nStep_ (f, this),
    nStepSeries_ (f, this),
    variableDelayVector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BoundAverageComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nStep
      //
      if (n.name () == "nStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepType > r (
          NStepTraits::create (i, f, this));

        if (!this->nStep_)
        {
          this->nStep_.set (r);
          continue;
        }
      }

      // nStepSeries
      //
      if (n.name () == "nStepSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepSeriesType > r (
          NStepSeriesTraits::create (i, f, this));

        if (!this->nStepSeries_)
        {
          this->nStepSeries_.set (r);
          continue;
        }
      }

      // variableDelayVector
      //
      if (n.name () == "variableDelayVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableDelayVectorType > r (
          VariableDelayVectorTraits::create (i, f, this));

        if (!this->variableDelayVector_)
        {
          this->variableDelayVector_.set (r);
          continue;
        }
      }

      break;
    }
  }

  BoundAverageComplexType* BoundAverageComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundAverageComplexType (*this, f, c);
  }

  BoundAverageComplexType::
  ~BoundAverageComplexType ()
  {
  }

  // MultipleDelayComplexType
  //

  const MultipleDelayComplexType::NStepModeType MultipleDelayComplexType::nStepMode_default_value_ (
    "CONTINUOUS");

  MultipleDelayComplexType::
  MultipleDelayComplexType ()
  : ::xml_schema::Type (),
    variableDelayVector_ (::xml_schema::Flags (), this),
    nStep_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this),
    nStepMode_ (::xml_schema::Flags (), this),
    nStepCorrection_ (::xml_schema::Flags (), this)
  {
  }

  MultipleDelayComplexType::
  MultipleDelayComplexType (const MultipleDelayComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variableDelayVector_ (x.variableDelayVector_, f, this),
    nStep_ (x.nStep_, f, this),
    nStepSeries_ (x.nStepSeries_, f, this),
    nStepMode_ (x.nStepMode_, f, this),
    nStepCorrection_ (x.nStepCorrection_, f, this)
  {
  }

  MultipleDelayComplexType::
  MultipleDelayComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variableDelayVector_ (f, this),
    nStep_ (f, this),
    nStepSeries_ (f, this),
    nStepMode_ (f, this),
    nStepCorrection_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MultipleDelayComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variableDelayVector
      //
      if (n.name () == "variableDelayVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableDelayVectorType > r (
          VariableDelayVectorTraits::create (i, f, this));

        if (!this->variableDelayVector_)
        {
          this->variableDelayVector_.set (r);
          continue;
        }
      }

      // nStep
      //
      if (n.name () == "nStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepType > r (
          NStepTraits::create (i, f, this));

        if (!this->nStep_)
        {
          this->nStep_.set (r);
          continue;
        }
      }

      // nStepSeries
      //
      if (n.name () == "nStepSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepSeriesType > r (
          NStepSeriesTraits::create (i, f, this));

        if (!this->nStepSeries_)
        {
          this->nStepSeries_.set (r);
          continue;
        }
      }

      // nStepMode
      //
      if (n.name () == "nStepMode" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepModeType > r (
          NStepModeTraits::create (i, f, this));

        if (!this->nStepMode_)
        {
          this->nStepMode_.set (r);
          continue;
        }
      }

      // nStepCorrection
      //
      if (n.name () == "nStepCorrection" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->nStepCorrection_)
        {
          this->nStepCorrection_.set (NStepCorrectionTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  MultipleDelayComplexType* MultipleDelayComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MultipleDelayComplexType (*this, f, c);
  }

  MultipleDelayComplexType::
  ~MultipleDelayComplexType ()
  {
  }

  // BoundStateComplexType
  //

  BoundStateComplexType::
  BoundStateComplexType (const ComponentsType& components,
                         const VariablesType& variables,
                         const StateType& state,
                         const IdType& id)
  : ::xml_schema::Type (),
    components_ (components, ::xml_schema::Flags (), this),
    nStep_ (::xml_schema::Flags (), this),
    stepIndices_ (::xml_schema::Flags (), this),
    variables_ (variables, ::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    average_ (::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this),
    scalingFactor_ (getScalingFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  BoundStateComplexType::
  BoundStateComplexType (::std::auto_ptr< ComponentsType >& components,
                         ::std::auto_ptr< VariablesType >& variables,
                         const StateType& state,
                         const IdType& id)
  : ::xml_schema::Type (),
    components_ (components, ::xml_schema::Flags (), this),
    nStep_ (::xml_schema::Flags (), this),
    stepIndices_ (::xml_schema::Flags (), this),
    variables_ (variables, ::xml_schema::Flags (), this),
    state_ (state, ::xml_schema::Flags (), this),
    average_ (::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this),
    scalingFactor_ (getScalingFactorDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  BoundStateComplexType::
  BoundStateComplexType (const BoundStateComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    components_ (x.components_, f, this),
    nStep_ (x.nStep_, f, this),
    stepIndices_ (x.stepIndices_, f, this),
    variables_ (x.variables_, f, this),
    state_ (x.state_, f, this),
    average_ (x.average_, f, this),
    upperBound_ (x.upperBound_, f, this),
    upperBoundSeries_ (x.upperBoundSeries_, f, this),
    lowerBound_ (x.lowerBound_, f, this),
    lowerBoundSeries_ (x.lowerBoundSeries_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    scalingFactor_ (x.scalingFactor_, f, this)
  {
  }

  BoundStateComplexType::
  BoundStateComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    components_ (f, this),
    nStep_ (f, this),
    stepIndices_ (f, this),
    variables_ (f, this),
    state_ (f, this),
    average_ (f, this),
    upperBound_ (f, this),
    upperBoundSeries_ (f, this),
    lowerBound_ (f, this),
    lowerBoundSeries_ (f, this),
    id_ (f, this),
    name_ (f, this),
    scalingFactor_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BoundStateComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // components
      //
      if (n.name () == "components" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ComponentsType > r (
          ComponentsTraits::create (i, f, this));

        if (!components_.present ())
        {
          this->components_.set (r);
          continue;
        }
      }

      // nStep
      //
      if (n.name () == "nStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepType > r (
          NStepTraits::create (i, f, this));

        if (!this->nStep_)
        {
          this->nStep_.set (r);
          continue;
        }
      }

      // stepIndices
      //
      if (n.name () == "stepIndices" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StepIndicesType > r (
          StepIndicesTraits::create (i, f, this));

        if (!this->stepIndices_)
        {
          this->stepIndices_.set (r);
          continue;
        }
      }

      // variables
      //
      if (n.name () == "variables" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariablesType > r (
          VariablesTraits::create (i, f, this));

        if (!variables_.present ())
        {
          this->variables_.set (r);
          continue;
        }
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!state_.present ())
        {
          this->state_.set (r);
          continue;
        }
      }

      // average
      //
      if (n.name () == "average" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AverageType > r (
          AverageTraits::create (i, f, this));

        if (!this->average_)
        {
          this->average_.set (r);
          continue;
        }
      }

      // upperBound
      //
      if (n.name () == "upperBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundType > r (
          UpperBoundTraits::create (i, f, this));

        if (!this->upperBound_)
        {
          this->upperBound_.set (r);
          continue;
        }
      }

      // upperBoundSeries
      //
      if (n.name () == "upperBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundSeriesType > r (
          UpperBoundSeriesTraits::create (i, f, this));

        if (!this->upperBoundSeries_)
        {
          this->upperBoundSeries_.set (r);
          continue;
        }
      }

      // lowerBound
      //
      if (n.name () == "lowerBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundType > r (
          LowerBoundTraits::create (i, f, this));

        if (!this->lowerBound_)
        {
          this->lowerBound_.set (r);
          continue;
        }
      }

      // lowerBoundSeries
      //
      if (n.name () == "lowerBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundSeriesType > r (
          LowerBoundSeriesTraits::create (i, f, this));

        if (!this->lowerBoundSeries_)
        {
          this->lowerBoundSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!components_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "components",
        "http://www.wldelft.nl/fews");
    }

    if (!variables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variables",
        "http://www.wldelft.nl/fews");
    }

    if (!state_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "state",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "scalingFactor" && n.namespace_ ().empty ())
      {
        this->scalingFactor_.set (ScalingFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!scalingFactor_.present ())
    {
      this->scalingFactor_.set (getScalingFactorDefaultValue ());
    }
  }

  BoundStateComplexType* BoundStateComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundStateComplexType (*this, f, c);
  }

  BoundStateComplexType::
  ~BoundStateComplexType ()
  {
  }

  // StateAverageComplexType
  //

  StateAverageComplexType::
  StateAverageComplexType (const StateDelayVectorType& stateDelayVector)
  : ::xml_schema::Type (),
    nStep_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this),
    stateDelayVector_ (stateDelayVector, ::xml_schema::Flags (), this)
  {
  }

  StateAverageComplexType::
  StateAverageComplexType (const StateAverageComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nStep_ (x.nStep_, f, this),
    nStepSeries_ (x.nStepSeries_, f, this),
    stateDelayVector_ (x.stateDelayVector_, f, this)
  {
  }

  StateAverageComplexType::
  StateAverageComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nStep_ (f, this),
    nStepSeries_ (f, this),
    stateDelayVector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void StateAverageComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nStep
      //
      if (n.name () == "nStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepType > r (
          NStepTraits::create (i, f, this));

        if (!this->nStep_)
        {
          this->nStep_.set (r);
          continue;
        }
      }

      // nStepSeries
      //
      if (n.name () == "nStepSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepSeriesType > r (
          NStepSeriesTraits::create (i, f, this));

        if (!this->nStepSeries_)
        {
          this->nStepSeries_.set (r);
          continue;
        }
      }

      // stateDelayVector
      //
      if (n.name () == "stateDelayVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StateDelayVectorType > r (
          StateDelayVectorTraits::create (i, f, this));

        if (!stateDelayVector_.present ())
        {
          this->stateDelayVector_.set (r);
          continue;
        }
      }

      break;
    }

    if (!stateDelayVector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stateDelayVector",
        "http://www.wldelft.nl/fews");
    }
  }

  StateAverageComplexType* StateAverageComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StateAverageComplexType (*this, f, c);
  }

  StateAverageComplexType::
  ~StateAverageComplexType ()
  {
  }

  // BoundStateStepIndicesComplexType
  //

  BoundStateStepIndicesComplexType::
  BoundStateStepIndicesComplexType ()
  : ::xml_schema::Type (),
    stepIndex_ (::xml_schema::Flags (), this)
  {
  }

  BoundStateStepIndicesComplexType::
  BoundStateStepIndicesComplexType (const BoundStateStepIndicesComplexType& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    stepIndex_ (x.stepIndex_, f, this)
  {
  }

  BoundStateStepIndicesComplexType::
  BoundStateStepIndicesComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    stepIndex_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BoundStateStepIndicesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stepIndex
      //
      if (n.name () == "stepIndex" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< StepIndexType > r (
          StepIndexTraits::create (i, f, this));

        this->stepIndex_.push_back (r);
        continue;
      }

      break;
    }
  }

  BoundStateStepIndicesComplexType* BoundStateStepIndicesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundStateStepIndicesComplexType (*this, f, c);
  }

  BoundStateStepIndicesComplexType::
  ~BoundStateStepIndicesComplexType ()
  {
  }

  // BoundStateComponentsComplexType
  //

  BoundStateComponentsComplexType::
  BoundStateComponentsComplexType ()
  : ::xml_schema::Type (),
    component_ (::xml_schema::Flags (), this)
  {
  }

  BoundStateComponentsComplexType::
  BoundStateComponentsComplexType (const BoundStateComponentsComplexType& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this)
  {
  }

  BoundStateComponentsComplexType::
  BoundStateComponentsComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BoundStateComponentsComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component
      //
      if (n.name () == "component" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (r);
        continue;
      }

      break;
    }
  }

  BoundStateComponentsComplexType* BoundStateComponentsComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundStateComponentsComplexType (*this, f, c);
  }

  BoundStateComponentsComplexType::
  ~BoundStateComponentsComplexType ()
  {
  }

  // BoundStateVariablesComplexType
  //

  BoundStateVariablesComplexType::
  BoundStateVariablesComplexType ()
  : ::xml_schema::Type (),
    variable_ (::xml_schema::Flags (), this)
  {
  }

  BoundStateVariablesComplexType::
  BoundStateVariablesComplexType (const BoundStateVariablesComplexType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this)
  {
  }

  BoundStateVariablesComplexType::
  BoundStateVariablesComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BoundStateVariablesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (r);
        continue;
      }

      break;
    }
  }

  BoundStateVariablesComplexType* BoundStateVariablesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BoundStateVariablesComplexType (*this, f, c);
  }

  BoundStateVariablesComplexType::
  ~BoundStateVariablesComplexType ()
  {
  }

  // ChanceVariableComplexType
  //

  ChanceVariableComplexType::
  ChanceVariableComplexType (const VariableType& variable,
                             const FType& f,
                             const IdType& id)
  : ::xml_schema::Type (),
    variable_ (variable, ::xml_schema::Flags (), this),
    f_ (f, ::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  ChanceVariableComplexType::
  ChanceVariableComplexType (const ChanceVariableComplexType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this),
    f_ (x.f_, f, this),
    upperBound_ (x.upperBound_, f, this),
    upperBoundSeries_ (x.upperBoundSeries_, f, this),
    lowerBound_ (x.lowerBound_, f, this),
    lowerBoundSeries_ (x.lowerBoundSeries_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ChanceVariableComplexType::
  ChanceVariableComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (f, this),
    f_ (f, this),
    upperBound_ (f, this),
    upperBoundSeries_ (f, this),
    lowerBound_ (f, this),
    lowerBoundSeries_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ChanceVariableComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        if (!variable_.present ())
        {
          this->variable_.set (r);
          continue;
        }
      }

      // f
      //
      if (n.name () == "f" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!f_.present ())
        {
          this->f_.set (FTraits::create (i, f, this));
          continue;
        }
      }

      // upperBound
      //
      if (n.name () == "upperBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundType > r (
          UpperBoundTraits::create (i, f, this));

        if (!this->upperBound_)
        {
          this->upperBound_.set (r);
          continue;
        }
      }

      // upperBoundSeries
      //
      if (n.name () == "upperBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundSeriesType > r (
          UpperBoundSeriesTraits::create (i, f, this));

        if (!this->upperBoundSeries_)
        {
          this->upperBoundSeries_.set (r);
          continue;
        }
      }

      // lowerBound
      //
      if (n.name () == "lowerBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundType > r (
          LowerBoundTraits::create (i, f, this));

        if (!this->lowerBound_)
        {
          this->lowerBound_.set (r);
          continue;
        }
      }

      // lowerBoundSeries
      //
      if (n.name () == "lowerBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundSeriesType > r (
          LowerBoundSeriesTraits::create (i, f, this));

        if (!this->lowerBoundSeries_)
        {
          this->lowerBoundSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!variable_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variable",
        "http://www.wldelft.nl/fews");
    }

    if (!f_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "f",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ChanceVariableComplexType* ChanceVariableComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChanceVariableComplexType (*this, f, c);
  }

  ChanceVariableComplexType::
  ~ChanceVariableComplexType ()
  {
  }

  // TermComplexType
  //

  TermComplexType::
  TermComplexType ()
  : ::xml_schema::Type (),
    term_ (::xml_schema::Flags (), this)
  {
  }

  TermComplexType::
  TermComplexType (const TermComplexType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    term_ (x.term_, f, this)
  {
  }

  TermComplexType::
  TermComplexType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    term_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TermComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // term
      //
      if (n.name () == "term" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TermType > r (
          TermTraits::create (i, f, this));

        this->term_.push_back (r);
        continue;
      }

      break;
    }
  }

  TermComplexType* TermComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermComplexType (*this, f, c);
  }

  TermComplexType::
  ~TermComplexType ()
  {
  }

  // TermEnsembleComplexType
  //

  TermEnsembleComplexType::
  TermEnsembleComplexType ()
  : ::xml_schema::Type (),
    termEnsemble_ (::xml_schema::Flags (), this)
  {
  }

  TermEnsembleComplexType::
  TermEnsembleComplexType (const TermEnsembleComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    termEnsemble_ (x.termEnsemble_, f, this)
  {
  }

  TermEnsembleComplexType::
  TermEnsembleComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    termEnsemble_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TermEnsembleComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // termEnsemble
      //
      if (n.name () == "termEnsemble" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TermEnsembleType > r (
          TermEnsembleTraits::create (i, f, this));

        this->termEnsemble_.push_back (r);
        continue;
      }

      break;
    }
  }

  TermEnsembleComplexType* TermEnsembleComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermEnsembleComplexType (*this, f, c);
  }

  TermEnsembleComplexType::
  ~TermEnsembleComplexType ()
  {
  }

  // TermChoiceComplexType
  //

  const TermChoiceComplexType::ActiveType TermChoiceComplexType::active_default_value_ (
    "true");

  TermChoiceComplexType::
  TermChoiceComplexType ()
  : ::xml_schema::Type (),
    absolute_ (::xml_schema::Flags (), this),
    linear_ (::xml_schema::Flags (), this),
    rateOfChange_ (::xml_schema::Flags (), this),
    max_ (::xml_schema::Flags (), this),
    mse_ (::xml_schema::Flags (), this),
    nse_ (::xml_schema::Flags (), this),
    relativeVolume_ (::xml_schema::Flags (), this),
    rmse_ (::xml_schema::Flags (), this),
    rv_ (::xml_schema::Flags (), this),
    sum_ (::xml_schema::Flags (), this),
    active_ (getActiveDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  TermChoiceComplexType::
  TermChoiceComplexType (const TermChoiceComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    absolute_ (x.absolute_, f, this),
    linear_ (x.linear_, f, this),
    rateOfChange_ (x.rateOfChange_, f, this),
    max_ (x.max_, f, this),
    mse_ (x.mse_, f, this),
    nse_ (x.nse_, f, this),
    relativeVolume_ (x.relativeVolume_, f, this),
    rmse_ (x.rmse_, f, this),
    rv_ (x.rv_, f, this),
    sum_ (x.sum_, f, this),
    active_ (x.active_, f, this)
  {
  }

  TermChoiceComplexType::
  TermChoiceComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    absolute_ (f, this),
    linear_ (f, this),
    rateOfChange_ (f, this),
    max_ (f, this),
    mse_ (f, this),
    nse_ (f, this),
    relativeVolume_ (f, this),
    rmse_ (f, this),
    rv_ (f, this),
    sum_ (f, this),
    active_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermChoiceComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // absolute
      //
      if (n.name () == "absolute" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AbsoluteType > r (
          AbsoluteTraits::create (i, f, this));

        if (!this->absolute_)
        {
          this->absolute_.set (r);
          continue;
        }
      }

      // linear
      //
      if (n.name () == "linear" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LinearType > r (
          LinearTraits::create (i, f, this));

        if (!this->linear_)
        {
          this->linear_.set (r);
          continue;
        }
      }

      // rateOfChange
      //
      if (n.name () == "rateOfChange" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RateOfChangeType > r (
          RateOfChangeTraits::create (i, f, this));

        if (!this->rateOfChange_)
        {
          this->rateOfChange_.set (r);
          continue;
        }
      }

      // max
      //
      if (n.name () == "max" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MaxType > r (
          MaxTraits::create (i, f, this));

        if (!this->max_)
        {
          this->max_.set (r);
          continue;
        }
      }

      // mse
      //
      if (n.name () == "mse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MseType > r (
          MseTraits::create (i, f, this));

        if (!this->mse_)
        {
          this->mse_.set (r);
          continue;
        }
      }

      // nse
      //
      if (n.name () == "nse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NseType > r (
          NseTraits::create (i, f, this));

        if (!this->nse_)
        {
          this->nse_.set (r);
          continue;
        }
      }

      // relativeVolume
      //
      if (n.name () == "relativeVolume" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RelativeVolumeType > r (
          RelativeVolumeTraits::create (i, f, this));

        if (!this->relativeVolume_)
        {
          this->relativeVolume_.set (r);
          continue;
        }
      }

      // rmse
      //
      if (n.name () == "rmse" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RmseType > r (
          RmseTraits::create (i, f, this));

        if (!this->rmse_)
        {
          this->rmse_.set (r);
          continue;
        }
      }

      // rv
      //
      if (n.name () == "rv" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< RvType > r (
          RvTraits::create (i, f, this));

        if (!this->rv_)
        {
          this->rv_.set (r);
          continue;
        }
      }

      // sum
      //
      if (n.name () == "sum" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SumType > r (
          SumTraits::create (i, f, this));

        if (!this->sum_)
        {
          this->sum_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "active" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        this->active_.set (r);
        continue;
      }
    }

    if (!active_.present ())
    {
      this->active_.set (getActiveDefaultValue ());
    }
  }

  TermChoiceComplexType* TermChoiceComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermChoiceComplexType (*this, f, c);
  }

  TermChoiceComplexType::
  ~TermChoiceComplexType ()
  {
  }

  // TermEnsembleChoiceComplexType
  //

  const TermEnsembleChoiceComplexType::ActiveType TermEnsembleChoiceComplexType::active_default_value_ (
    "true");

  TermEnsembleChoiceComplexType::
  TermEnsembleChoiceComplexType (const ChanceConstraintType& chanceConstraint)
  : ::xml_schema::Type (),
    chanceConstraint_ (chanceConstraint, ::xml_schema::Flags (), this),
    active_ (getActiveDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  TermEnsembleChoiceComplexType::
  TermEnsembleChoiceComplexType (::std::auto_ptr< ChanceConstraintType >& chanceConstraint)
  : ::xml_schema::Type (),
    chanceConstraint_ (chanceConstraint, ::xml_schema::Flags (), this),
    active_ (getActiveDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  TermEnsembleChoiceComplexType::
  TermEnsembleChoiceComplexType (const TermEnsembleChoiceComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    chanceConstraint_ (x.chanceConstraint_, f, this),
    active_ (x.active_, f, this)
  {
  }

  TermEnsembleChoiceComplexType::
  TermEnsembleChoiceComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    chanceConstraint_ (f, this),
    active_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermEnsembleChoiceComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // chanceConstraint
      //
      if (n.name () == "chanceConstraint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ChanceConstraintType > r (
          ChanceConstraintTraits::create (i, f, this));

        if (!chanceConstraint_.present ())
        {
          this->chanceConstraint_.set (r);
          continue;
        }
      }

      break;
    }

    if (!chanceConstraint_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "chanceConstraint",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "active" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        this->active_.set (r);
        continue;
      }
    }

    if (!active_.present ())
    {
      this->active_.set (getActiveDefaultValue ());
    }
  }

  TermEnsembleChoiceComplexType* TermEnsembleChoiceComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermEnsembleChoiceComplexType (*this, f, c);
  }

  TermEnsembleChoiceComplexType::
  ~TermEnsembleChoiceComplexType ()
  {
  }

  // TermAbsoluteComplexType
  //

  const TermAbsoluteComplexType::WeightingFactorType TermAbsoluteComplexType::weightingFactor_default_value_ (
    "1.0");

  const TermAbsoluteComplexType::WeightingFactorFinalType TermAbsoluteComplexType::weightingFactorFinal_default_value_ (
    "1.0");

  TermAbsoluteComplexType::
  TermAbsoluteComplexType (const OrderType& order,
                           const InputType& input,
                           const IdType& id)
  : ::xml_schema::Type (),
    weightingFactorSeries_ (::xml_schema::Flags (), this),
    weightingFactor_ (::xml_schema::Flags (), this),
    weightingFactorFinal_ (::xml_schema::Flags (), this),
    order_ (order, ::xml_schema::Flags (), this),
    setPoint_ (::xml_schema::Flags (), this),
    setPointSeries_ (::xml_schema::Flags (), this),
    upperBranch_ (::xml_schema::Flags (), this),
    lowerBranch_ (::xml_schema::Flags (), this),
    average_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermAbsoluteComplexType::
  TermAbsoluteComplexType (const TermAbsoluteComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weightingFactorSeries_ (x.weightingFactorSeries_, f, this),
    weightingFactor_ (x.weightingFactor_, f, this),
    weightingFactorFinal_ (x.weightingFactorFinal_, f, this),
    order_ (x.order_, f, this),
    setPoint_ (x.setPoint_, f, this),
    setPointSeries_ (x.setPointSeries_, f, this),
    upperBranch_ (x.upperBranch_, f, this),
    lowerBranch_ (x.lowerBranch_, f, this),
    average_ (x.average_, f, this),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermAbsoluteComplexType::
  TermAbsoluteComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weightingFactorSeries_ (f, this),
    weightingFactor_ (f, this),
    weightingFactorFinal_ (f, this),
    order_ (f, this),
    setPoint_ (f, this),
    setPointSeries_ (f, this),
    upperBranch_ (f, this),
    lowerBranch_ (f, this),
    average_ (f, this),
    input_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermAbsoluteComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weightingFactorSeries
      //
      if (n.name () == "weightingFactorSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorSeriesType > r (
          WeightingFactorSeriesTraits::create (i, f, this));

        if (!this->weightingFactorSeries_)
        {
          this->weightingFactorSeries_.set (r);
          continue;
        }
      }

      // weightingFactor
      //
      if (n.name () == "weightingFactor" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorType > r (
          WeightingFactorTraits::create (i, f, this));

        this->weightingFactor_.push_back (r);
        continue;
      }

      // weightingFactorFinal
      //
      if (n.name () == "weightingFactorFinal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorFinalType > r (
          WeightingFactorFinalTraits::create (i, f, this));

        this->weightingFactorFinal_.push_back (r);
        continue;
      }

      // order
      //
      if (n.name () == "order" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!order_.present ())
        {
          this->order_.set (OrderTraits::create (i, f, this));
          continue;
        }
      }

      // setPoint
      //
      if (n.name () == "setPoint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetPointType > r (
          SetPointTraits::create (i, f, this));

        if (!this->setPoint_)
        {
          this->setPoint_.set (r);
          continue;
        }
      }

      // setPointSeries
      //
      if (n.name () == "setPointSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetPointSeriesType > r (
          SetPointSeriesTraits::create (i, f, this));

        if (!this->setPointSeries_)
        {
          this->setPointSeries_.set (r);
          continue;
        }
      }

      // upperBranch
      //
      if (n.name () == "upperBranch" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->upperBranch_)
        {
          this->upperBranch_.set (UpperBranchTraits::create (i, f, this));
          continue;
        }
      }

      // lowerBranch
      //
      if (n.name () == "lowerBranch" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->lowerBranch_)
        {
          this->lowerBranch_.set (LowerBranchTraits::create (i, f, this));
          continue;
        }
      }

      // average
      //
      if (n.name () == "average" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< AverageType > r (
          AverageTraits::create (i, f, this));

        if (!this->average_)
        {
          this->average_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!order_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "order",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermAbsoluteComplexType* TermAbsoluteComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermAbsoluteComplexType (*this, f, c);
  }

  TermAbsoluteComplexType::
  ~TermAbsoluteComplexType ()
  {
  }

  // ChanceConstraintComplexType
  //

  const ChanceConstraintComplexType::WeightingFactorType ChanceConstraintComplexType::weightingFactor_default_value_ (
    "1.0");

  const ChanceConstraintComplexType::WeightingFactorFinalType ChanceConstraintComplexType::weightingFactorFinal_default_value_ (
    "1.0");

  ChanceConstraintComplexType::
  ChanceConstraintComplexType (const OrderType& order,
                               const FType& f,
                               const InputType& input,
                               const IdType& id)
  : ::xml_schema::Type (),
    weightingFactorSeries_ (::xml_schema::Flags (), this),
    weightingFactor_ (::xml_schema::Flags (), this),
    weightingFactorFinal_ (::xml_schema::Flags (), this),
    order_ (order, ::xml_schema::Flags (), this),
    f_ (f, ::xml_schema::Flags (), this),
    upperBound_ (::xml_schema::Flags (), this),
    upperBoundSeries_ (::xml_schema::Flags (), this),
    lowerBound_ (::xml_schema::Flags (), this),
    lowerBoundSeries_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  ChanceConstraintComplexType::
  ChanceConstraintComplexType (const ChanceConstraintComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weightingFactorSeries_ (x.weightingFactorSeries_, f, this),
    weightingFactor_ (x.weightingFactor_, f, this),
    weightingFactorFinal_ (x.weightingFactorFinal_, f, this),
    order_ (x.order_, f, this),
    f_ (x.f_, f, this),
    upperBound_ (x.upperBound_, f, this),
    upperBoundSeries_ (x.upperBoundSeries_, f, this),
    lowerBound_ (x.lowerBound_, f, this),
    lowerBoundSeries_ (x.lowerBoundSeries_, f, this),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this)
  {
  }

  ChanceConstraintComplexType::
  ChanceConstraintComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weightingFactorSeries_ (f, this),
    weightingFactor_ (f, this),
    weightingFactorFinal_ (f, this),
    order_ (f, this),
    f_ (f, this),
    upperBound_ (f, this),
    upperBoundSeries_ (f, this),
    lowerBound_ (f, this),
    lowerBoundSeries_ (f, this),
    input_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ChanceConstraintComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weightingFactorSeries
      //
      if (n.name () == "weightingFactorSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorSeriesType > r (
          WeightingFactorSeriesTraits::create (i, f, this));

        if (!this->weightingFactorSeries_)
        {
          this->weightingFactorSeries_.set (r);
          continue;
        }
      }

      // weightingFactor
      //
      if (n.name () == "weightingFactor" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorType > r (
          WeightingFactorTraits::create (i, f, this));

        this->weightingFactor_.push_back (r);
        continue;
      }

      // weightingFactorFinal
      //
      if (n.name () == "weightingFactorFinal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorFinalType > r (
          WeightingFactorFinalTraits::create (i, f, this));

        this->weightingFactorFinal_.push_back (r);
        continue;
      }

      // order
      //
      if (n.name () == "order" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!order_.present ())
        {
          this->order_.set (OrderTraits::create (i, f, this));
          continue;
        }
      }

      // f
      //
      if (n.name () == "f" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!f_.present ())
        {
          this->f_.set (FTraits::create (i, f, this));
          continue;
        }
      }

      // upperBound
      //
      if (n.name () == "upperBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundType > r (
          UpperBoundTraits::create (i, f, this));

        if (!this->upperBound_)
        {
          this->upperBound_.set (r);
          continue;
        }
      }

      // upperBoundSeries
      //
      if (n.name () == "upperBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UpperBoundSeriesType > r (
          UpperBoundSeriesTraits::create (i, f, this));

        if (!this->upperBoundSeries_)
        {
          this->upperBoundSeries_.set (r);
          continue;
        }
      }

      // lowerBound
      //
      if (n.name () == "lowerBound" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundType > r (
          LowerBoundTraits::create (i, f, this));

        if (!this->lowerBound_)
        {
          this->lowerBound_.set (r);
          continue;
        }
      }

      // lowerBoundSeries
      //
      if (n.name () == "lowerBoundSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LowerBoundSeriesType > r (
          LowerBoundSeriesTraits::create (i, f, this));

        if (!this->lowerBoundSeries_)
        {
          this->lowerBoundSeries_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!order_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "order",
        "http://www.wldelft.nl/fews");
    }

    if (!f_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "f",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  ChanceConstraintComplexType* ChanceConstraintComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChanceConstraintComplexType (*this, f, c);
  }

  ChanceConstraintComplexType::
  ~ChanceConstraintComplexType ()
  {
  }

  // AverageComplexType
  //

  AverageComplexType::
  AverageComplexType ()
  : ::xml_schema::Type (),
    nStep_ (::xml_schema::Flags (), this),
    nStepSeries_ (::xml_schema::Flags (), this),
    inputDelayVector_ (::xml_schema::Flags (), this)
  {
  }

  AverageComplexType::
  AverageComplexType (const AverageComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nStep_ (x.nStep_, f, this),
    nStepSeries_ (x.nStepSeries_, f, this),
    inputDelayVector_ (x.inputDelayVector_, f, this)
  {
  }

  AverageComplexType::
  AverageComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nStep_ (f, this),
    nStepSeries_ (f, this),
    inputDelayVector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AverageComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nStep
      //
      if (n.name () == "nStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepType > r (
          NStepTraits::create (i, f, this));

        if (!this->nStep_)
        {
          this->nStep_.set (r);
          continue;
        }
      }

      // nStepSeries
      //
      if (n.name () == "nStepSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< NStepSeriesType > r (
          NStepSeriesTraits::create (i, f, this));

        if (!this->nStepSeries_)
        {
          this->nStepSeries_.set (r);
          continue;
        }
      }

      // inputDelayVector
      //
      if (n.name () == "inputDelayVector" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputDelayVectorType > r (
          InputDelayVectorTraits::create (i, f, this));

        if (!this->inputDelayVector_)
        {
          this->inputDelayVector_.set (r);
          continue;
        }
      }

      break;
    }
  }

  AverageComplexType* AverageComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AverageComplexType (*this, f, c);
  }

  AverageComplexType::
  ~AverageComplexType ()
  {
  }

  // TermLinearComplexType
  //

  const TermLinearComplexType::WeightingFactorType TermLinearComplexType::weightingFactor_default_value_ (
    "1.0");

  const TermLinearComplexType::WeightingFactorFinalType TermLinearComplexType::weightingFactorFinal_default_value_ (
    "1.0");

  TermLinearComplexType::
  TermLinearComplexType (const InputType& input,
                         const IdType& id)
  : ::xml_schema::Type (),
    weightingFactorSeries_ (::xml_schema::Flags (), this),
    weightingFactor_ (::xml_schema::Flags (), this),
    weightingFactorFinal_ (::xml_schema::Flags (), this),
    setPoint_ (::xml_schema::Flags (), this),
    setPointSeries_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermLinearComplexType::
  TermLinearComplexType (const TermLinearComplexType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weightingFactorSeries_ (x.weightingFactorSeries_, f, this),
    weightingFactor_ (x.weightingFactor_, f, this),
    weightingFactorFinal_ (x.weightingFactorFinal_, f, this),
    setPoint_ (x.setPoint_, f, this),
    setPointSeries_ (x.setPointSeries_, f, this),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermLinearComplexType::
  TermLinearComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weightingFactorSeries_ (f, this),
    weightingFactor_ (f, this),
    weightingFactorFinal_ (f, this),
    setPoint_ (f, this),
    setPointSeries_ (f, this),
    input_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermLinearComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weightingFactorSeries
      //
      if (n.name () == "weightingFactorSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorSeriesType > r (
          WeightingFactorSeriesTraits::create (i, f, this));

        if (!this->weightingFactorSeries_)
        {
          this->weightingFactorSeries_.set (r);
          continue;
        }
      }

      // weightingFactor
      //
      if (n.name () == "weightingFactor" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorType > r (
          WeightingFactorTraits::create (i, f, this));

        this->weightingFactor_.push_back (r);
        continue;
      }

      // weightingFactorFinal
      //
      if (n.name () == "weightingFactorFinal" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorFinalType > r (
          WeightingFactorFinalTraits::create (i, f, this));

        this->weightingFactorFinal_.push_back (r);
        continue;
      }

      // setPoint
      //
      if (n.name () == "setPoint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetPointType > r (
          SetPointTraits::create (i, f, this));

        if (!this->setPoint_)
        {
          this->setPoint_.set (r);
          continue;
        }
      }

      // setPointSeries
      //
      if (n.name () == "setPointSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetPointSeriesType > r (
          SetPointSeriesTraits::create (i, f, this));

        if (!this->setPointSeries_)
        {
          this->setPointSeries_.set (r);
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermLinearComplexType* TermLinearComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermLinearComplexType (*this, f, c);
  }

  TermLinearComplexType::
  ~TermLinearComplexType ()
  {
  }

  // TermRateOfChangeComplexType
  //

  const TermRateOfChangeComplexType::WeightingFactorType TermRateOfChangeComplexType::weightingFactor_default_value_ (
    "1.0");

  TermRateOfChangeComplexType::
  TermRateOfChangeComplexType (const OrderType& order,
                               const InputType& input,
                               const IdType& id)
  : ::xml_schema::Type (),
    weightingFactorSeries_ (::xml_schema::Flags (), this),
    weightingFactor_ (::xml_schema::Flags (), this),
    order_ (order, ::xml_schema::Flags (), this),
    setPoint_ (::xml_schema::Flags (), this),
    setPointSeries_ (::xml_schema::Flags (), this),
    multipleDelay_ (::xml_schema::Flags (), this),
    upperBranch_ (::xml_schema::Flags (), this),
    lowerBranch_ (::xml_schema::Flags (), this),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermRateOfChangeComplexType::
  TermRateOfChangeComplexType (const TermRateOfChangeComplexType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weightingFactorSeries_ (x.weightingFactorSeries_, f, this),
    weightingFactor_ (x.weightingFactor_, f, this),
    order_ (x.order_, f, this),
    setPoint_ (x.setPoint_, f, this),
    setPointSeries_ (x.setPointSeries_, f, this),
    multipleDelay_ (x.multipleDelay_, f, this),
    upperBranch_ (x.upperBranch_, f, this),
    lowerBranch_ (x.lowerBranch_, f, this),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermRateOfChangeComplexType::
  TermRateOfChangeComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weightingFactorSeries_ (f, this),
    weightingFactor_ (f, this),
    order_ (f, this),
    setPoint_ (f, this),
    setPointSeries_ (f, this),
    multipleDelay_ (f, this),
    upperBranch_ (f, this),
    lowerBranch_ (f, this),
    input_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermRateOfChangeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // weightingFactorSeries
      //
      if (n.name () == "weightingFactorSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorSeriesType > r (
          WeightingFactorSeriesTraits::create (i, f, this));

        if (!this->weightingFactorSeries_)
        {
          this->weightingFactorSeries_.set (r);
          continue;
        }
      }

      // weightingFactor
      //
      if (n.name () == "weightingFactor" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< WeightingFactorType > r (
          WeightingFactorTraits::create (i, f, this));

        this->weightingFactor_.push_back (r);
        continue;
      }

      // order
      //
      if (n.name () == "order" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!order_.present ())
        {
          this->order_.set (OrderTraits::create (i, f, this));
          continue;
        }
      }

      // setPoint
      //
      if (n.name () == "setPoint" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->setPoint_)
        {
          this->setPoint_.set (SetPointTraits::create (i, f, this));
          continue;
        }
      }

      // setPointSeries
      //
      if (n.name () == "setPointSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SetPointSeriesType > r (
          SetPointSeriesTraits::create (i, f, this));

        if (!this->setPointSeries_)
        {
          this->setPointSeries_.set (r);
          continue;
        }
      }

      // multipleDelay
      //
      if (n.name () == "multipleDelay" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< MultipleDelayType > r (
          MultipleDelayTraits::create (i, f, this));

        if (!this->multipleDelay_)
        {
          this->multipleDelay_.set (r);
          continue;
        }
      }

      // upperBranch
      //
      if (n.name () == "upperBranch" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->upperBranch_)
        {
          this->upperBranch_.set (UpperBranchTraits::create (i, f, this));
          continue;
        }
      }

      // lowerBranch
      //
      if (n.name () == "lowerBranch" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->lowerBranch_)
        {
          this->lowerBranch_.set (LowerBranchTraits::create (i, f, this));
          continue;
        }
      }

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!order_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "order",
        "http://www.wldelft.nl/fews");
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermRateOfChangeComplexType* TermRateOfChangeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermRateOfChangeComplexType (*this, f, c);
  }

  TermRateOfChangeComplexType::
  ~TermRateOfChangeComplexType ()
  {
  }

  // TermMaxComplexType
  //

  TermMaxComplexType::
  TermMaxComplexType (const InputType& input,
                      const IdType& id)
  : ::xml_schema::Type (),
    input_ (input, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermMaxComplexType::
  TermMaxComplexType (const TermMaxComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    input_ (x.input_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermMaxComplexType::
  TermMaxComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    input_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermMaxComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // input
      //
      if (n.name () == "input" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InputType > r (
          InputTraits::create (i, f, this));

        if (!input_.present ())
        {
          this->input_.set (r);
          continue;
        }
      }

      break;
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "input",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermMaxComplexType* TermMaxComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermMaxComplexType (*this, f, c);
  }

  TermMaxComplexType::
  ~TermMaxComplexType ()
  {
  }

  // TermMSEComplexType
  //

  TermMSEComplexType::
  TermMSEComplexType (const ObservationType& observation,
                      const SimulationType& simulation,
                      const IdType& id)
  : ::xml_schema::Type (),
    flag_ (::xml_schema::Flags (), this),
    observation_ (observation, ::xml_schema::Flags (), this),
    simulation_ (simulation, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermMSEComplexType::
  TermMSEComplexType (const TermMSEComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flag_ (x.flag_, f, this),
    observation_ (x.observation_, f, this),
    simulation_ (x.simulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermMSEComplexType::
  TermMSEComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flag_ (f, this),
    observation_ (f, this),
    simulation_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermMSEComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // flag
      //
      if (n.name () == "flag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlagType > r (
          FlagTraits::create (i, f, this));

        if (!this->flag_)
        {
          this->flag_.set (r);
          continue;
        }
      }

      // observation
      //
      if (n.name () == "observation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ObservationType > r (
          ObservationTraits::create (i, f, this));

        if (!observation_.present ())
        {
          this->observation_.set (r);
          continue;
        }
      }

      // simulation
      //
      if (n.name () == "simulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimulationType > r (
          SimulationTraits::create (i, f, this));

        if (!simulation_.present ())
        {
          this->simulation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!observation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "observation",
        "http://www.wldelft.nl/fews");
    }

    if (!simulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermMSEComplexType* TermMSEComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermMSEComplexType (*this, f, c);
  }

  TermMSEComplexType::
  ~TermMSEComplexType ()
  {
  }

  // TermRMSEComplexType
  //

  TermRMSEComplexType::
  TermRMSEComplexType (const ObservationType& observation,
                       const SimulationType& simulation,
                       const IdType& id)
  : ::xml_schema::Type (),
    flag_ (::xml_schema::Flags (), this),
    observation_ (observation, ::xml_schema::Flags (), this),
    simulation_ (simulation, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermRMSEComplexType::
  TermRMSEComplexType (const TermRMSEComplexType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flag_ (x.flag_, f, this),
    observation_ (x.observation_, f, this),
    simulation_ (x.simulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermRMSEComplexType::
  TermRMSEComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flag_ (f, this),
    observation_ (f, this),
    simulation_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermRMSEComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // flag
      //
      if (n.name () == "flag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlagType > r (
          FlagTraits::create (i, f, this));

        if (!this->flag_)
        {
          this->flag_.set (r);
          continue;
        }
      }

      // observation
      //
      if (n.name () == "observation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ObservationType > r (
          ObservationTraits::create (i, f, this));

        if (!observation_.present ())
        {
          this->observation_.set (r);
          continue;
        }
      }

      // simulation
      //
      if (n.name () == "simulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimulationType > r (
          SimulationTraits::create (i, f, this));

        if (!simulation_.present ())
        {
          this->simulation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!observation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "observation",
        "http://www.wldelft.nl/fews");
    }

    if (!simulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermRMSEComplexType* TermRMSEComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermRMSEComplexType (*this, f, c);
  }

  TermRMSEComplexType::
  ~TermRMSEComplexType ()
  {
  }

  // TermNSEComplexType
  //

  TermNSEComplexType::
  TermNSEComplexType (const ObservationType& observation,
                      const SimulationType& simulation,
                      const IdType& id)
  : ::xml_schema::Type (),
    flag_ (::xml_schema::Flags (), this),
    skipNFirstSteps_ (::xml_schema::Flags (), this),
    observation_ (observation, ::xml_schema::Flags (), this),
    simulation_ (simulation, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermNSEComplexType::
  TermNSEComplexType (const TermNSEComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flag_ (x.flag_, f, this),
    skipNFirstSteps_ (x.skipNFirstSteps_, f, this),
    observation_ (x.observation_, f, this),
    simulation_ (x.simulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermNSEComplexType::
  TermNSEComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flag_ (f, this),
    skipNFirstSteps_ (f, this),
    observation_ (f, this),
    simulation_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermNSEComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // flag
      //
      if (n.name () == "flag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlagType > r (
          FlagTraits::create (i, f, this));

        if (!this->flag_)
        {
          this->flag_.set (r);
          continue;
        }
      }

      // skipNFirstSteps
      //
      if (n.name () == "skipNFirstSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->skipNFirstSteps_)
        {
          this->skipNFirstSteps_.set (SkipNFirstStepsTraits::create (i, f, this));
          continue;
        }
      }

      // observation
      //
      if (n.name () == "observation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ObservationType > r (
          ObservationTraits::create (i, f, this));

        if (!observation_.present ())
        {
          this->observation_.set (r);
          continue;
        }
      }

      // simulation
      //
      if (n.name () == "simulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimulationType > r (
          SimulationTraits::create (i, f, this));

        if (!simulation_.present ())
        {
          this->simulation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!observation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "observation",
        "http://www.wldelft.nl/fews");
    }

    if (!simulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermNSEComplexType* TermNSEComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermNSEComplexType (*this, f, c);
  }

  TermNSEComplexType::
  ~TermNSEComplexType ()
  {
  }

  // TermRelativeVolumeComplexType
  //

  TermRelativeVolumeComplexType::
  TermRelativeVolumeComplexType (const ObservationType& observation,
                                 const SimulationType& simulation,
                                 const IdType& id)
  : ::xml_schema::Type (),
    flag_ (::xml_schema::Flags (), this),
    skipNFirstSteps_ (::xml_schema::Flags (), this),
    observation_ (observation, ::xml_schema::Flags (), this),
    simulation_ (simulation, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermRelativeVolumeComplexType::
  TermRelativeVolumeComplexType (const TermRelativeVolumeComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flag_ (x.flag_, f, this),
    skipNFirstSteps_ (x.skipNFirstSteps_, f, this),
    observation_ (x.observation_, f, this),
    simulation_ (x.simulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermRelativeVolumeComplexType::
  TermRelativeVolumeComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flag_ (f, this),
    skipNFirstSteps_ (f, this),
    observation_ (f, this),
    simulation_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermRelativeVolumeComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // flag
      //
      if (n.name () == "flag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlagType > r (
          FlagTraits::create (i, f, this));

        if (!this->flag_)
        {
          this->flag_.set (r);
          continue;
        }
      }

      // skipNFirstSteps
      //
      if (n.name () == "skipNFirstSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->skipNFirstSteps_)
        {
          this->skipNFirstSteps_.set (SkipNFirstStepsTraits::create (i, f, this));
          continue;
        }
      }

      // observation
      //
      if (n.name () == "observation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ObservationType > r (
          ObservationTraits::create (i, f, this));

        if (!observation_.present ())
        {
          this->observation_.set (r);
          continue;
        }
      }

      // simulation
      //
      if (n.name () == "simulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimulationType > r (
          SimulationTraits::create (i, f, this));

        if (!simulation_.present ())
        {
          this->simulation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!observation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "observation",
        "http://www.wldelft.nl/fews");
    }

    if (!simulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermRelativeVolumeComplexType* TermRelativeVolumeComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermRelativeVolumeComplexType (*this, f, c);
  }

  TermRelativeVolumeComplexType::
  ~TermRelativeVolumeComplexType ()
  {
  }

  // TermRVComplexType
  //

  TermRVComplexType::
  TermRVComplexType (const WType& w,
                     const ObservationType& observation,
                     const SimulationType& simulation,
                     const IdType& id)
  : ::xml_schema::Type (),
    flag_ (::xml_schema::Flags (), this),
    w_ (w, ::xml_schema::Flags (), this),
    skipNFirstSteps_ (::xml_schema::Flags (), this),
    observation_ (observation, ::xml_schema::Flags (), this),
    simulation_ (simulation, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermRVComplexType::
  TermRVComplexType (const TermRVComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flag_ (x.flag_, f, this),
    w_ (x.w_, f, this),
    skipNFirstSteps_ (x.skipNFirstSteps_, f, this),
    observation_ (x.observation_, f, this),
    simulation_ (x.simulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermRVComplexType::
  TermRVComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flag_ (f, this),
    w_ (f, this),
    skipNFirstSteps_ (f, this),
    observation_ (f, this),
    simulation_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermRVComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // flag
      //
      if (n.name () == "flag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlagType > r (
          FlagTraits::create (i, f, this));

        if (!this->flag_)
        {
          this->flag_.set (r);
          continue;
        }
      }

      // w
      //
      if (n.name () == "w" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!w_.present ())
        {
          this->w_.set (WTraits::create (i, f, this));
          continue;
        }
      }

      // skipNFirstSteps
      //
      if (n.name () == "skipNFirstSteps" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->skipNFirstSteps_)
        {
          this->skipNFirstSteps_.set (SkipNFirstStepsTraits::create (i, f, this));
          continue;
        }
      }

      // observation
      //
      if (n.name () == "observation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ObservationType > r (
          ObservationTraits::create (i, f, this));

        if (!observation_.present ())
        {
          this->observation_.set (r);
          continue;
        }
      }

      // simulation
      //
      if (n.name () == "simulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimulationType > r (
          SimulationTraits::create (i, f, this));

        if (!simulation_.present ())
        {
          this->simulation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!w_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "w",
        "http://www.wldelft.nl/fews");
    }

    if (!observation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "observation",
        "http://www.wldelft.nl/fews");
    }

    if (!simulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermRVComplexType* TermRVComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermRVComplexType (*this, f, c);
  }

  TermRVComplexType::
  ~TermRVComplexType ()
  {
  }

  // TermSumComplexType
  //

  TermSumComplexType::
  TermSumComplexType (const SimulationType& simulation,
                      const IdType& id)
  : ::xml_schema::Type (),
    flag_ (::xml_schema::Flags (), this),
    simulation_ (simulation, ::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this)
  {
  }

  TermSumComplexType::
  TermSumComplexType (const TermSumComplexType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    flag_ (x.flag_, f, this),
    simulation_ (x.simulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  TermSumComplexType::
  TermSumComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    flag_ (f, this),
    simulation_ (f, this),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TermSumComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // flag
      //
      if (n.name () == "flag" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< FlagType > r (
          FlagTraits::create (i, f, this));

        if (!this->flag_)
        {
          this->flag_.set (r);
          continue;
        }
      }

      // simulation
      //
      if (n.name () == "simulation" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< SimulationType > r (
          SimulationTraits::create (i, f, this));

        if (!simulation_.present ())
        {
          this->simulation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!simulation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation",
        "http://www.wldelft.nl/fews");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  TermSumComplexType* TermSumComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TermSumComplexType (*this, f, c);
  }

  TermSumComplexType::
  ~TermSumComplexType ()
  {
  }

  // OutputComplexType
  //

  OutputComplexType::
  OutputComplexType (const JIncType& JInc,
                     const JAccType& JAcc)
  : ::xml_schema::Type (),
    JInc_ (JInc, ::xml_schema::Flags (), this),
    JAcc_ (JAcc, ::xml_schema::Flags (), this)
  {
  }

  OutputComplexType::
  OutputComplexType (const OutputComplexType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    JInc_ (x.JInc_, f, this),
    JAcc_ (x.JAcc_, f, this)
  {
  }

  OutputComplexType::
  OutputComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    JInc_ (f, this),
    JAcc_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OutputComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // JInc
      //
      if (n.name () == "JInc" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< JIncType > r (
          JIncTraits::create (i, f, this));

        if (!JInc_.present ())
        {
          this->JInc_.set (r);
          continue;
        }
      }

      // JAcc
      //
      if (n.name () == "JAcc" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< JAccType > r (
          JAccTraits::create (i, f, this));

        if (!JAcc_.present ())
        {
          this->JAcc_.set (r);
          continue;
        }
      }

      break;
    }

    if (!JInc_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "JInc",
        "http://www.wldelft.nl/fews");
    }

    if (!JAcc_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "JAcc",
        "http://www.wldelft.nl/fews");
    }
  }

  OutputComplexType* OutputComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OutputComplexType (*this, f, c);
  }

  OutputComplexType::
  ~OutputComplexType ()
  {
  }

  // NStepModeEnum
  //

  NStepModeEnum::
  NStepModeEnum (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_NStepModeEnum_convert ();
  }

  NStepModeEnum::
  NStepModeEnum (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_NStepModeEnum_convert ();
  }

  NStepModeEnum::
  NStepModeEnum (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_NStepModeEnum_convert ();
  }

  NStepModeEnum* NStepModeEnum::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NStepModeEnum (*this, f, c);
  }

  NStepModeEnum::Value NStepModeEnum::
  _xsd_NStepModeEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_NStepModeEnum_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_NStepModeEnum_indexes_,
                      _xsd_NStepModeEnum_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_NStepModeEnum_indexes_ + 2 || _xsd_NStepModeEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const NStepModeEnum::
  _xsd_NStepModeEnum_literals_[2] =
  {
    "CONTINUOUS",
    "STEP"
  };

  const NStepModeEnum::Value NStepModeEnum::
  _xsd_NStepModeEnum_indexes_[2] =
  {
    ::fews::NStepModeEnum::CONTINUOUS,
    ::fews::NStepModeEnum::STEP
  };

  // NStep
  //

  NStep::
  NStep (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  NStep::
  NStep (const NStep& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  NStep::
  NStep (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  NStep::
  NStep (const ::xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  NStep::
  NStep (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  NStep* NStep::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NStep (*this, f, c);
  }

  NStep::
  ~NStep ()
  {
  }

  // NStep1
  //

  NStep1::
  NStep1 (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  NStep1::
  NStep1 (const NStep1& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  NStep1::
  NStep1 (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  NStep1::
  NStep1 (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  NStep1::
  NStep1 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  NStep1* NStep1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NStep1 (*this, f, c);
  }

  NStep1::
  ~NStep1 ()
  {
  }

  // NStep2
  //

  NStep2::
  NStep2 (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  NStep2::
  NStep2 (const NStep2& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  NStep2::
  NStep2 (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  NStep2::
  NStep2 (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  NStep2::
  NStep2 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  NStep2* NStep2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NStep2 (*this, f, c);
  }

  NStep2::
  ~NStep2 ()
  {
  }

  // NStep3
  //

  NStep3::
  NStep3 (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  NStep3::
  NStep3 (const NStep3& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  NStep3::
  NStep3 (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  NStep3::
  NStep3 (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  NStep3::
  NStep3 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  NStep3* NStep3::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NStep3 (*this, f, c);
  }

  NStep3::
  ~NStep3 ()
  {
  }

  // StepIndex
  //

  StepIndex::
  StepIndex (const ::xml_schema::Int& _xsd_Int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (_xsd_Int_base)
  {
  }

  StepIndex::
  StepIndex (const StepIndex& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  StepIndex::
  StepIndex (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  StepIndex::
  StepIndex (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  StepIndex::
  StepIndex (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  StepIndex* StepIndex::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StepIndex (*this, f, c);
  }

  StepIndex::
  ~StepIndex ()
  {
  }

  // NStep4
  //

  NStep4::
  NStep4 (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  NStep4::
  NStep4 (const NStep4& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  NStep4::
  NStep4 (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  NStep4::
  NStep4 (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  NStep4::
  NStep4 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  NStep4* NStep4::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NStep4 (*this, f, c);
  }

  NStep4::
  ~NStep4 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace fews
{
  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::std::string& u,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
      ::fews::parseRtcObjectiveConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::std::string& u,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
      ::fews::parseRtcObjectiveConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
      ::fews::parseRtcObjectiveConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcObjectiveConfig (isrc, f, p);
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcObjectiveConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcObjectiveConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcObjectiveConfig (isrc, f, p);
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcObjectiveConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcObjectiveConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xercesc::InputSource& i,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
      ::fews::parseRtcObjectiveConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xercesc::InputSource& i,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
      ::fews::parseRtcObjectiveConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
      ::fews::parseRtcObjectiveConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (const ::xercesc::DOMDocument& d,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
        ::fews::parseRtcObjectiveConfig (
          c, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "rtcObjectiveConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
        ::xsd::cxx::tree::traits< ::fews::RtcObjectiveConfigComplexType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rtcObjectiveConfig",
      "http://www.wldelft.nl/fews");
  }

  ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType >
  parseRtcObjectiveConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "rtcObjectiveConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      ::std::auto_ptr< ::fews::RtcObjectiveConfigComplexType > r (
        ::xsd::cxx::tree::traits< ::fews::RtcObjectiveConfigComplexType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rtcObjectiveConfig",
      "http://www.wldelft.nl/fews");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace fews
{
  void
  serializeRtcObjectiveConfig (::std::ostream& o,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcObjectiveConfig (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRtcObjectiveConfig (::std::ostream& o,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcObjectiveConfig (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcObjectiveConfig (::std::ostream& o,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcObjectiveConfig (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcObjectiveConfig (::xercesc::XMLFormatTarget& t,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcObjectiveConfig (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRtcObjectiveConfig (::xercesc::XMLFormatTarget& t,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcObjectiveConfig (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcObjectiveConfig (::xercesc::XMLFormatTarget& t,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcObjectiveConfig (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcObjectiveConfig (::xercesc::DOMDocument& d,
                               const ::fews::RtcObjectiveConfigComplexType& s,
                               ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "rtcObjectiveConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "rtcObjectiveConfig",
        "http://www.wldelft.nl/fews");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeRtcObjectiveConfig (const ::fews::RtcObjectiveConfigComplexType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "rtcObjectiveConfig",
        "http://www.wldelft.nl/fews",
        m, f));

    ::fews::serializeRtcObjectiveConfig (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const RtcObjectiveConfigComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variables
    //
    if (i.getVariables ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variables",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getVariables ();
    }

    // constraints
    //
    if (i.getConstraints ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constraints",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getConstraints ();
    }

    // terms
    //
    if (i.getTerms ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "terms",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTerms ();
    }

    // termsEnsemble
    //
    if (i.getTermsEnsemble ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "termsEnsemble",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTermsEnsemble ();
    }

    // output
    //
    if (i.getOutput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VariablesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    for (VariablesComplexType::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // aggregation
    //
    if (i.getAggregation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aggregation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAggregation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VariableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // aggregation
    //
    if (i.getAggregation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aggregation",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAggregation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.getType ();
    }

    // active
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "active",
          e));

      a << i.getActive ();
    }

    // min
    //
    if (i.getMin ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "min",
          e));

      a << *i.getMin ();
    }

    // max
    //
    if (i.getMax ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "max",
          e));

      a << *i.getMax ();
    }

    // scalingFactor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scalingFactor",
          e));

      a << ::xml_schema::AsDouble(i.getScalingFactor ());
    }

    // ensembleMode
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ensembleMode",
          e));

      a << i.getEnsembleMode ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AggregationComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // constant
    //
    if (i.getConstant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getConstant ();
    }

    // equidistant
    //
    if (i.getEquidistant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "equidistant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getEquidistant ();
    }

    // non-equidistant
    //
    if (i.getNon_equidistant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "non-equidistant",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNon_equidistant ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AggregationEquidistantComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getType ();
    }

    // nAggregationSteps
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nAggregationSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNAggregationSteps ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AggregationNonEquidistantComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getType ();
    }

    // nInputSteps
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nInputSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNInputSteps ();
    }

    // nOutputSteps
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nOutputSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getNOutputSteps ();
    }

    // stepIndex
    //
    for (AggregationNonEquidistantComplexType::StepIndexConstIterator
         b (i.getStepIndex ().begin ()), n (i.getStepIndex ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stepIndex",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConstraintsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // constraint
    //
    for (ConstraintsComplexType::ConstraintConstIterator
         b (i.getConstraint ().begin ()), n (i.getConstraint ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constraint",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ConstraintChoiceComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // boundVariable
    //
    if (i.getBoundVariable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundVariable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getBoundVariable ();
    }

    // boundVariableAverage
    //
    if (i.getBoundVariableAverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundVariableAverage",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getBoundVariableAverage ();
    }

    // boundVariableRateOfChange
    //
    if (i.getBoundVariableRateOfChange ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundVariableRateOfChange",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getBoundVariableRateOfChange ();
    }

    // boundState
    //
    if (i.getBoundState ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundState",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getBoundState ();
    }

    // chanceBoundVariable
    //
    if (i.getChanceBoundVariable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "chanceBoundVariable",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getChanceBoundVariable ();
    }

    // active
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "active",
          e));

      a << i.getActive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundVariableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getVariable ();
    }

    // upperBound
    //
    if (i.getUpperBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBound ();
    }

    // upperBoundSeries
    //
    if (i.getUpperBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBoundSeries ();
    }

    // lowerBound
    //
    if (i.getLowerBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBound ();
    }

    // lowerBoundSeries
    //
    if (i.getLowerBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBoundSeries ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundVariableRateOfChangeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getVariable ();
    }

    // multipleDelay
    //
    if (i.getMultipleDelay ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "multipleDelay",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMultipleDelay ();
    }

    // upperBound
    //
    if (i.getUpperBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBound ();
    }

    // upperBoundSeries
    //
    if (i.getUpperBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBoundSeries ();
    }

    // lowerBound
    //
    if (i.getLowerBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBound ();
    }

    // lowerBoundSeries
    //
    if (i.getLowerBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBoundSeries ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundVariableAverageComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getVariable ();
    }

    // average
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "average",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getAverage ();
    }

    // upperBound
    //
    if (i.getUpperBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBound ();
    }

    // upperBoundSeries
    //
    if (i.getUpperBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBoundSeries ();
    }

    // lowerBound
    //
    if (i.getLowerBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBound ();
    }

    // lowerBoundSeries
    //
    if (i.getLowerBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBoundSeries ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundAverageComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nStep
    //
    if (i.getNStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStep ();
    }

    // nStepSeries
    //
    if (i.getNStepSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStepSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStepSeries ();
    }

    // variableDelayVector
    //
    if (i.getVariableDelayVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableDelayVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getVariableDelayVector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MultipleDelayComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variableDelayVector
    //
    if (i.getVariableDelayVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variableDelayVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getVariableDelayVector ();
    }

    // nStep
    //
    if (i.getNStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStep ();
    }

    // nStepSeries
    //
    if (i.getNStepSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStepSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStepSeries ();
    }

    // nStepMode
    //
    if (i.getNStepMode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStepMode",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStepMode ();
    }

    // nStepCorrection
    //
    if (i.getNStepCorrection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStepCorrection",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStepCorrection ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundStateComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // components
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "components",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getComponents ();
    }

    // nStep
    //
    if (i.getNStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStep ();
    }

    // stepIndices
    //
    if (i.getStepIndices ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stepIndices",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getStepIndices ();
    }

    // variables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variables",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getVariables ();
    }

    // state
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getState ();
    }

    // average
    //
    if (i.getAverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "average",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAverage ();
    }

    // upperBound
    //
    if (i.getUpperBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBound ();
    }

    // upperBoundSeries
    //
    if (i.getUpperBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBoundSeries ();
    }

    // lowerBound
    //
    if (i.getLowerBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBound ();
    }

    // lowerBoundSeries
    //
    if (i.getLowerBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBoundSeries ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }

    // scalingFactor
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scalingFactor",
          e));

      a << ::xml_schema::AsDouble(i.getScalingFactor ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StateAverageComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nStep
    //
    if (i.getNStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStep ();
    }

    // nStepSeries
    //
    if (i.getNStepSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStepSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStepSeries ();
    }

    // stateDelayVector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stateDelayVector",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getStateDelayVector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundStateStepIndicesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // stepIndex
    //
    for (BoundStateStepIndicesComplexType::StepIndexConstIterator
         b (i.getStepIndex ().begin ()), n (i.getStepIndex ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stepIndex",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundStateComponentsComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // component
    //
    for (BoundStateComponentsComplexType::ComponentConstIterator
         b (i.getComponent ().begin ()), n (i.getComponent ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "component",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoundStateVariablesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    for (BoundStateVariablesComplexType::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChanceVariableComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getVariable ();
    }

    // f
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "f",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getF ());
    }

    // upperBound
    //
    if (i.getUpperBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBound ();
    }

    // upperBoundSeries
    //
    if (i.getUpperBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBoundSeries ();
    }

    // lowerBound
    //
    if (i.getLowerBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBound ();
    }

    // lowerBoundSeries
    //
    if (i.getLowerBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBoundSeries ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // term
    //
    for (TermComplexType::TermConstIterator
         b (i.getTerm ().begin ()), n (i.getTerm ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "term",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermEnsembleComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // termEnsemble
    //
    for (TermEnsembleComplexType::TermEnsembleConstIterator
         b (i.getTermEnsemble ().begin ()), n (i.getTermEnsemble ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "termEnsemble",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermChoiceComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // absolute
    //
    if (i.getAbsolute ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "absolute",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAbsolute ();
    }

    // linear
    //
    if (i.getLinear ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "linear",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLinear ();
    }

    // rateOfChange
    //
    if (i.getRateOfChange ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rateOfChange",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRateOfChange ();
    }

    // max
    //
    if (i.getMax ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "max",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMax ();
    }

    // mse
    //
    if (i.getMse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mse",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMse ();
    }

    // nse
    //
    if (i.getNse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nse",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNse ();
    }

    // relativeVolume
    //
    if (i.getRelativeVolume ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relativeVolume",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRelativeVolume ();
    }

    // rmse
    //
    if (i.getRmse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rmse",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRmse ();
    }

    // rv
    //
    if (i.getRv ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rv",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getRv ();
    }

    // sum
    //
    if (i.getSum ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sum",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSum ();
    }

    // active
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "active",
          e));

      a << i.getActive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermEnsembleChoiceComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // chanceConstraint
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "chanceConstraint",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getChanceConstraint ();
    }

    // active
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "active",
          e));

      a << i.getActive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermAbsoluteComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // weightingFactorSeries
    //
    if (i.getWeightingFactorSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWeightingFactorSeries ();
    }

    // weightingFactor
    //
    for (TermAbsoluteComplexType::WeightingFactorConstIterator
         b (i.getWeightingFactor ().begin ()), n (i.getWeightingFactor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactor",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // weightingFactorFinal
    //
    for (TermAbsoluteComplexType::WeightingFactorFinalConstIterator
         b (i.getWeightingFactorFinal ().begin ()), n (i.getWeightingFactorFinal ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorFinal",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // order
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "order",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getOrder ());
    }

    // setPoint
    //
    if (i.getSetPoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setPoint",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSetPoint ();
    }

    // setPointSeries
    //
    if (i.getSetPointSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setPointSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSetPointSeries ();
    }

    // upperBranch
    //
    if (i.getUpperBranch ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBranch",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBranch ();
    }

    // lowerBranch
    //
    if (i.getLowerBranch ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBranch",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBranch ();
    }

    // average
    //
    if (i.getAverage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "average",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAverage ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChanceConstraintComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // weightingFactorSeries
    //
    if (i.getWeightingFactorSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWeightingFactorSeries ();
    }

    // weightingFactor
    //
    for (ChanceConstraintComplexType::WeightingFactorConstIterator
         b (i.getWeightingFactor ().begin ()), n (i.getWeightingFactor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactor",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // weightingFactorFinal
    //
    for (ChanceConstraintComplexType::WeightingFactorFinalConstIterator
         b (i.getWeightingFactorFinal ().begin ()), n (i.getWeightingFactorFinal ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorFinal",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // order
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "order",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getOrder ());
    }

    // f
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "f",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getF ());
    }

    // upperBound
    //
    if (i.getUpperBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBound ();
    }

    // upperBoundSeries
    //
    if (i.getUpperBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBoundSeries ();
    }

    // lowerBound
    //
    if (i.getLowerBound ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBound",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBound ();
    }

    // lowerBoundSeries
    //
    if (i.getLowerBoundSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBoundSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBoundSeries ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AverageComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // nStep
    //
    if (i.getNStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStep ();
    }

    // nStepSeries
    //
    if (i.getNStepSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nStepSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getNStepSeries ();
    }

    // inputDelayVector
    //
    if (i.getInputDelayVector ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inputDelayVector",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInputDelayVector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermLinearComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // weightingFactorSeries
    //
    if (i.getWeightingFactorSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWeightingFactorSeries ();
    }

    // weightingFactor
    //
    for (TermLinearComplexType::WeightingFactorConstIterator
         b (i.getWeightingFactor ().begin ()), n (i.getWeightingFactor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactor",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // weightingFactorFinal
    //
    for (TermLinearComplexType::WeightingFactorFinalConstIterator
         b (i.getWeightingFactorFinal ().begin ()), n (i.getWeightingFactorFinal ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorFinal",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // setPoint
    //
    if (i.getSetPoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setPoint",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSetPoint ();
    }

    // setPointSeries
    //
    if (i.getSetPointSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setPointSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSetPointSeries ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermRateOfChangeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // weightingFactorSeries
    //
    if (i.getWeightingFactorSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactorSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getWeightingFactorSeries ();
    }

    // weightingFactor
    //
    for (TermRateOfChangeComplexType::WeightingFactorConstIterator
         b (i.getWeightingFactor ().begin ()), n (i.getWeightingFactor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "weightingFactor",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // order
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "order",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getOrder ());
    }

    // setPoint
    //
    if (i.getSetPoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setPoint",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(*i.getSetPoint ());
    }

    // setPointSeries
    //
    if (i.getSetPointSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "setPointSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSetPointSeries ();
    }

    // multipleDelay
    //
    if (i.getMultipleDelay ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "multipleDelay",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getMultipleDelay ();
    }

    // upperBranch
    //
    if (i.getUpperBranch ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upperBranch",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUpperBranch ();
    }

    // lowerBranch
    //
    if (i.getLowerBranch ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "lowerBranch",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getLowerBranch ();
    }

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermMaxComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // input
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getInput ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermMSEComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flag
    //
    if (i.getFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlag ();
    }

    // observation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "observation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getObservation ();
    }

    // simulation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSimulation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermRMSEComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flag
    //
    if (i.getFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlag ();
    }

    // observation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "observation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getObservation ();
    }

    // simulation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSimulation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermNSEComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flag
    //
    if (i.getFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlag ();
    }

    // skipNFirstSteps
    //
    if (i.getSkipNFirstSteps ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "skipNFirstSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSkipNFirstSteps ();
    }

    // observation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "observation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getObservation ();
    }

    // simulation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSimulation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermRelativeVolumeComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flag
    //
    if (i.getFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlag ();
    }

    // skipNFirstSteps
    //
    if (i.getSkipNFirstSteps ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "skipNFirstSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSkipNFirstSteps ();
    }

    // observation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "observation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getObservation ();
    }

    // simulation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSimulation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermRVComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flag
    //
    if (i.getFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlag ();
    }

    // w
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "w",
          "http://www.wldelft.nl/fews",
          e));

      s << ::xml_schema::AsDouble(i.getW ());
    }

    // skipNFirstSteps
    //
    if (i.getSkipNFirstSteps ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "skipNFirstSteps",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getSkipNFirstSteps ();
    }

    // observation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "observation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getObservation ();
    }

    // simulation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSimulation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TermSumComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // flag
    //
    if (i.getFlag ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flag",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getFlag ();
    }

    // simulation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getSimulation ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OutputComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // JInc
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "JInc",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getJInc ();
    }

    // JAcc
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "JAcc",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getJAcc ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NStepModeEnum& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NStepModeEnum& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NStepModeEnum& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NStep& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NStep& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NStep& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NStep1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NStep1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NStep1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NStep2& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NStep2& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NStep2& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NStep3& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NStep3& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NStep3& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const StepIndex& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const StepIndex& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const StepIndex& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const NStep4& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const NStep4& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const NStep4& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

