// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "treeVector.hxx"

namespace openda
{
  // TreeVectorFileXML
  // 

  const TreeVectorFileXML::TimeStampOptional& TreeVectorFileXML::
  getTimeStamp () const
  {
    return this->timeStamp_;
  }

  TreeVectorFileXML::TimeStampOptional& TreeVectorFileXML::
  getTimeStamp ()
  {
    return this->timeStamp_;
  }

  void TreeVectorFileXML::
  setTimeStamp (const TimeStampType& x)
  {
    this->timeStamp_.set (x);
  }

  void TreeVectorFileXML::
  setTimeStamp (const TimeStampOptional& x)
  {
    this->timeStamp_ = x;
  }

  void TreeVectorFileXML::
  setTimeStamp (::std::auto_ptr< TimeStampType > x)
  {
    this->timeStamp_.set (x);
  }

  const TreeVectorFileXML::TreeVectorType& TreeVectorFileXML::
  getTreeVector () const
  {
    return this->treeVector_.get ();
  }

  TreeVectorFileXML::TreeVectorType& TreeVectorFileXML::
  getTreeVector ()
  {
    return this->treeVector_.get ();
  }

  void TreeVectorFileXML::
  setTreeVector (const TreeVectorType& x)
  {
    this->treeVector_.set (x);
  }

  void TreeVectorFileXML::
  setTreeVector (::std::auto_ptr< TreeVectorType > x)
  {
    this->treeVector_.set (x);
  }


  // TreeVectorXML
  // 

  const TreeVectorXML::DescriptionOptional& TreeVectorXML::
  getDescription () const
  {
    return this->description_;
  }

  TreeVectorXML::DescriptionOptional& TreeVectorXML::
  getDescription ()
  {
    return this->description_;
  }

  void TreeVectorXML::
  setDescription (const DescriptionType& x)
  {
    this->description_.set (x);
  }

  void TreeVectorXML::
  setDescription (const DescriptionOptional& x)
  {
    this->description_ = x;
  }

  void TreeVectorXML::
  setDescription (::std::auto_ptr< DescriptionType > x)
  {
    this->description_.set (x);
  }

  const TreeVectorXML::TreeVectorLeafSequence& TreeVectorXML::
  getTreeVectorLeaf () const
  {
    return this->treeVectorLeaf_;
  }

  TreeVectorXML::TreeVectorLeafSequence& TreeVectorXML::
  getTreeVectorLeaf ()
  {
    return this->treeVectorLeaf_;
  }

  void TreeVectorXML::
  setTreeVectorLeaf (const TreeVectorLeafSequence& s)
  {
    this->treeVectorLeaf_ = s;
  }

  const TreeVectorXML::SubTreeVectorSequence& TreeVectorXML::
  getSubTreeVector () const
  {
    return this->subTreeVector_;
  }

  TreeVectorXML::SubTreeVectorSequence& TreeVectorXML::
  getSubTreeVector ()
  {
    return this->subTreeVector_;
  }

  void TreeVectorXML::
  setSubTreeVector (const SubTreeVectorSequence& s)
  {
    this->subTreeVector_ = s;
  }

  const TreeVectorXML::IdOptional& TreeVectorXML::
  getId () const
  {
    return this->id_;
  }

  TreeVectorXML::IdOptional& TreeVectorXML::
  getId ()
  {
    return this->id_;
  }

  void TreeVectorXML::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TreeVectorXML::
  setId (const IdOptional& x)
  {
    this->id_ = x;
  }

  void TreeVectorXML::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const TreeVectorXML::CaptionOptional& TreeVectorXML::
  getCaption () const
  {
    return this->caption_;
  }

  TreeVectorXML::CaptionOptional& TreeVectorXML::
  getCaption ()
  {
    return this->caption_;
  }

  void TreeVectorXML::
  setCaption (const CaptionType& x)
  {
    this->caption_.set (x);
  }

  void TreeVectorXML::
  setCaption (const CaptionOptional& x)
  {
    this->caption_ = x;
  }

  void TreeVectorXML::
  setCaption (::std::auto_ptr< CaptionType > x)
  {
    this->caption_.set (x);
  }

  const TreeVectorXML::ExcludeFromVectorOptional& TreeVectorXML::
  getExcludeFromVector () const
  {
    return this->excludeFromVector_;
  }

  TreeVectorXML::ExcludeFromVectorOptional& TreeVectorXML::
  getExcludeFromVector ()
  {
    return this->excludeFromVector_;
  }

  void TreeVectorXML::
  setExcludeFromVector (const ExcludeFromVectorType& x)
  {
    this->excludeFromVector_.set (x);
  }

  void TreeVectorXML::
  setExcludeFromVector (const ExcludeFromVectorOptional& x)
  {
    this->excludeFromVector_ = x;
  }

  const TreeVectorXML::ClassNameOptional& TreeVectorXML::
  getClassName () const
  {
    return this->className_;
  }

  TreeVectorXML::ClassNameOptional& TreeVectorXML::
  getClassName ()
  {
    return this->className_;
  }

  void TreeVectorXML::
  setClassName (const ClassNameType& x)
  {
    this->className_.set (x);
  }

  void TreeVectorXML::
  setClassName (const ClassNameOptional& x)
  {
    this->className_ = x;
  }

  void TreeVectorXML::
  setClassName (::std::auto_ptr< ClassNameType > x)
  {
    this->className_.set (x);
  }


  // TreeVectorLeafXML
  // 

  const TreeVectorLeafXML::UnitOptional& TreeVectorLeafXML::
  getUnit () const
  {
    return this->unit_;
  }

  TreeVectorLeafXML::UnitOptional& TreeVectorLeafXML::
  getUnit ()
  {
    return this->unit_;
  }

  void TreeVectorLeafXML::
  setUnit (const UnitType& x)
  {
    this->unit_.set (x);
  }

  void TreeVectorLeafXML::
  setUnit (const UnitOptional& x)
  {
    this->unit_ = x;
  }

  void TreeVectorLeafXML::
  setUnit (::std::auto_ptr< UnitType > x)
  {
    this->unit_.set (x);
  }

  const TreeVectorLeafXML::MissingValueOptional& TreeVectorLeafXML::
  getMissingValue () const
  {
    return this->missingValue_;
  }

  TreeVectorLeafXML::MissingValueOptional& TreeVectorLeafXML::
  getMissingValue ()
  {
    return this->missingValue_;
  }

  void TreeVectorLeafXML::
  setMissingValue (const MissingValueType& x)
  {
    this->missingValue_.set (x);
  }

  void TreeVectorLeafXML::
  setMissingValue (const MissingValueOptional& x)
  {
    this->missingValue_ = x;
  }

  const TreeVectorLeafXML::DimensionsOptional& TreeVectorLeafXML::
  getDimensions () const
  {
    return this->dimensions_;
  }

  TreeVectorLeafXML::DimensionsOptional& TreeVectorLeafXML::
  getDimensions ()
  {
    return this->dimensions_;
  }

  void TreeVectorLeafXML::
  setDimensions (const DimensionsType& x)
  {
    this->dimensions_.set (x);
  }

  void TreeVectorLeafXML::
  setDimensions (const DimensionsOptional& x)
  {
    this->dimensions_ = x;
  }

  void TreeVectorLeafXML::
  setDimensions (::std::auto_ptr< DimensionsType > x)
  {
    this->dimensions_.set (x);
  }

  const TreeVectorLeafXML::GridOptional& TreeVectorLeafXML::
  getGrid () const
  {
    return this->grid_;
  }

  TreeVectorLeafXML::GridOptional& TreeVectorLeafXML::
  getGrid ()
  {
    return this->grid_;
  }

  void TreeVectorLeafXML::
  setGrid (const GridType& x)
  {
    this->grid_.set (x);
  }

  void TreeVectorLeafXML::
  setGrid (const GridOptional& x)
  {
    this->grid_ = x;
  }

  void TreeVectorLeafXML::
  setGrid (::std::auto_ptr< GridType > x)
  {
    this->grid_.set (x);
  }

  const TreeVectorLeafXML::VectorType& TreeVectorLeafXML::
  getVector () const
  {
    return this->vector_.get ();
  }

  TreeVectorLeafXML::VectorType& TreeVectorLeafXML::
  getVector ()
  {
    return this->vector_.get ();
  }

  void TreeVectorLeafXML::
  setVector (const VectorType& x)
  {
    this->vector_.set (x);
  }

  void TreeVectorLeafXML::
  setVector (::std::auto_ptr< VectorType > x)
  {
    this->vector_.set (x);
  }

  const TreeVectorLeafXML::IdOptional& TreeVectorLeafXML::
  getId () const
  {
    return this->id_;
  }

  TreeVectorLeafXML::IdOptional& TreeVectorLeafXML::
  getId ()
  {
    return this->id_;
  }

  void TreeVectorLeafXML::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void TreeVectorLeafXML::
  setId (const IdOptional& x)
  {
    this->id_ = x;
  }

  void TreeVectorLeafXML::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const TreeVectorLeafXML::CaptionOptional& TreeVectorLeafXML::
  getCaption () const
  {
    return this->caption_;
  }

  TreeVectorLeafXML::CaptionOptional& TreeVectorLeafXML::
  getCaption ()
  {
    return this->caption_;
  }

  void TreeVectorLeafXML::
  setCaption (const CaptionType& x)
  {
    this->caption_.set (x);
  }

  void TreeVectorLeafXML::
  setCaption (const CaptionOptional& x)
  {
    this->caption_ = x;
  }

  void TreeVectorLeafXML::
  setCaption (::std::auto_ptr< CaptionType > x)
  {
    this->caption_.set (x);
  }

  const TreeVectorLeafXML::ExcludeFromVectorOptional& TreeVectorLeafXML::
  getExcludeFromVector () const
  {
    return this->excludeFromVector_;
  }

  TreeVectorLeafXML::ExcludeFromVectorOptional& TreeVectorLeafXML::
  getExcludeFromVector ()
  {
    return this->excludeFromVector_;
  }

  void TreeVectorLeafXML::
  setExcludeFromVector (const ExcludeFromVectorType& x)
  {
    this->excludeFromVector_.set (x);
  }

  void TreeVectorLeafXML::
  setExcludeFromVector (const ExcludeFromVectorOptional& x)
  {
    this->excludeFromVector_ = x;
  }

  const TreeVectorLeafXML::ClassNameOptional& TreeVectorLeafXML::
  getClassName () const
  {
    return this->className_;
  }

  TreeVectorLeafXML::ClassNameOptional& TreeVectorLeafXML::
  getClassName ()
  {
    return this->className_;
  }

  void TreeVectorLeafXML::
  setClassName (const ClassNameType& x)
  {
    this->className_.set (x);
  }

  void TreeVectorLeafXML::
  setClassName (const ClassNameOptional& x)
  {
    this->className_ = x;
  }

  void TreeVectorLeafXML::
  setClassName (::std::auto_ptr< ClassNameType > x)
  {
    this->className_.set (x);
  }


  // DimensionsXML
  // 

  const DimensionsXML::DimSize1Type& DimensionsXML::
  getDimSize1 () const
  {
    return this->dimSize1_.get ();
  }

  DimensionsXML::DimSize1Type& DimensionsXML::
  getDimSize1 ()
  {
    return this->dimSize1_.get ();
  }

  void DimensionsXML::
  setDimSize1 (const DimSize1Type& x)
  {
    this->dimSize1_.set (x);
  }

  void DimensionsXML::
  setDimSize1 (::std::auto_ptr< DimSize1Type > x)
  {
    this->dimSize1_.set (x);
  }

  const DimensionsXML::DimSize2Optional& DimensionsXML::
  getDimSize2 () const
  {
    return this->dimSize2_;
  }

  DimensionsXML::DimSize2Optional& DimensionsXML::
  getDimSize2 ()
  {
    return this->dimSize2_;
  }

  void DimensionsXML::
  setDimSize2 (const DimSize2Type& x)
  {
    this->dimSize2_.set (x);
  }

  void DimensionsXML::
  setDimSize2 (const DimSize2Optional& x)
  {
    this->dimSize2_ = x;
  }

  void DimensionsXML::
  setDimSize2 (::std::auto_ptr< DimSize2Type > x)
  {
    this->dimSize2_.set (x);
  }

  const DimensionsXML::DimSize3Optional& DimensionsXML::
  getDimSize3 () const
  {
    return this->dimSize3_;
  }

  DimensionsXML::DimSize3Optional& DimensionsXML::
  getDimSize3 ()
  {
    return this->dimSize3_;
  }

  void DimensionsXML::
  setDimSize3 (const DimSize3Type& x)
  {
    this->dimSize3_.set (x);
  }

  void DimensionsXML::
  setDimSize3 (const DimSize3Optional& x)
  {
    this->dimSize3_ = x;
  }

  void DimensionsXML::
  setDimSize3 (::std::auto_ptr< DimSize3Type > x)
  {
    this->dimSize3_.set (x);
  }


  // GridXML
  // 

  const GridXML::ComputationalSpaceType& GridXML::
  getComputationalSpace () const
  {
    return this->computationalSpace_.get ();
  }

  GridXML::ComputationalSpaceType& GridXML::
  getComputationalSpace ()
  {
    return this->computationalSpace_.get ();
  }

  void GridXML::
  setComputationalSpace (const ComputationalSpaceType& x)
  {
    this->computationalSpace_.set (x);
  }

  void GridXML::
  setComputationalSpace (::std::auto_ptr< ComputationalSpaceType > x)
  {
    this->computationalSpace_.set (x);
  }

  const GridXML::PhysicalSpaceOptional& GridXML::
  getPhysicalSpace () const
  {
    return this->physicalSpace_;
  }

  GridXML::PhysicalSpaceOptional& GridXML::
  getPhysicalSpace ()
  {
    return this->physicalSpace_;
  }

  void GridXML::
  setPhysicalSpace (const PhysicalSpaceType& x)
  {
    this->physicalSpace_.set (x);
  }

  void GridXML::
  setPhysicalSpace (const PhysicalSpaceOptional& x)
  {
    this->physicalSpace_ = x;
  }

  void GridXML::
  setPhysicalSpace (::std::auto_ptr< PhysicalSpaceType > x)
  {
    this->physicalSpace_.set (x);
  }


  // ComputationalSpaceXML
  // 

  const ComputationalSpaceXML::DimensionSequence& ComputationalSpaceXML::
  getDimension () const
  {
    return this->dimension_;
  }

  ComputationalSpaceXML::DimensionSequence& ComputationalSpaceXML::
  getDimension ()
  {
    return this->dimension_;
  }

  void ComputationalSpaceXML::
  setDimension (const DimensionSequence& s)
  {
    this->dimension_ = s;
  }


  // ComputationalDimensionXML
  // 

  const ComputationalDimensionXML::IdType& ComputationalDimensionXML::
  getId () const
  {
    return this->id_.get ();
  }

  ComputationalDimensionXML::IdType& ComputationalDimensionXML::
  getId ()
  {
    return this->id_.get ();
  }

  void ComputationalDimensionXML::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void ComputationalDimensionXML::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const ComputationalDimensionXML::LengthType& ComputationalDimensionXML::
  getLength () const
  {
    return this->length_.get ();
  }

  ComputationalDimensionXML::LengthType& ComputationalDimensionXML::
  getLength ()
  {
    return this->length_.get ();
  }

  void ComputationalDimensionXML::
  setLength (const LengthType& x)
  {
    this->length_.set (x);
  }


  // PhysicalSpaceXML
  // 

  const PhysicalSpaceXML::DimensionSequence& PhysicalSpaceXML::
  getDimension () const
  {
    return this->dimension_;
  }

  PhysicalSpaceXML::DimensionSequence& PhysicalSpaceXML::
  getDimension ()
  {
    return this->dimension_;
  }

  void PhysicalSpaceXML::
  setDimension (const DimensionSequence& s)
  {
    this->dimension_ = s;
  }


  // PhysicalDimensionXML
  // 

  const PhysicalDimensionXML::IdType& PhysicalDimensionXML::
  getId () const
  {
    return this->id_.get ();
  }

  PhysicalDimensionXML::IdType& PhysicalDimensionXML::
  getId ()
  {
    return this->id_.get ();
  }

  void PhysicalDimensionXML::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void PhysicalDimensionXML::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const PhysicalDimensionXML::AxesType& PhysicalDimensionXML::
  getAxes () const
  {
    return this->axes_.get ();
  }

  PhysicalDimensionXML::AxesType& PhysicalDimensionXML::
  getAxes ()
  {
    return this->axes_.get ();
  }

  void PhysicalDimensionXML::
  setAxes (const AxesType& x)
  {
    this->axes_.set (x);
  }

  void PhysicalDimensionXML::
  setAxes (::std::auto_ptr< AxesType > x)
  {
    this->axes_.set (x);
  }

  const PhysicalDimensionXML::RefType& PhysicalDimensionXML::
  getRef () const
  {
    return this->ref_.get ();
  }

  PhysicalDimensionXML::RefType& PhysicalDimensionXML::
  getRef ()
  {
    return this->ref_.get ();
  }

  void PhysicalDimensionXML::
  setRef (const RefType& x)
  {
    this->ref_.set (x);
  }

  void PhysicalDimensionXML::
  setRef (::std::auto_ptr< RefType > x)
  {
    this->ref_.set (x);
  }


  // MetaInfoXML
  // 

  const MetaInfoXML::IdOptional& MetaInfoXML::
  getId () const
  {
    return this->id_;
  }

  MetaInfoXML::IdOptional& MetaInfoXML::
  getId ()
  {
    return this->id_;
  }

  void MetaInfoXML::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void MetaInfoXML::
  setId (const IdOptional& x)
  {
    this->id_ = x;
  }

  void MetaInfoXML::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // DateTimeXML
  // 

  const DateTimeXML::DateType& DateTimeXML::
  getDate () const
  {
    return this->date_.get ();
  }

  DateTimeXML::DateType& DateTimeXML::
  getDate ()
  {
    return this->date_.get ();
  }

  void DateTimeXML::
  setDate (const DateType& x)
  {
    this->date_.set (x);
  }

  void DateTimeXML::
  setDate (::std::auto_ptr< DateType > x)
  {
    this->date_.set (x);
  }

  const DateTimeXML::TimeType& DateTimeXML::
  getTime () const
  {
    return this->time_.get ();
  }

  DateTimeXML::TimeType& DateTimeXML::
  getTime ()
  {
    return this->time_.get ();
  }

  void DateTimeXML::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void DateTimeXML::
  setTime (::std::auto_ptr< TimeType > x)
  {
    this->time_.set (x);
  }

  const DateTimeXML::TimeZoneOptional& DateTimeXML::
  getTimeZone () const
  {
    return this->timeZone_;
  }

  DateTimeXML::TimeZoneOptional& DateTimeXML::
  getTimeZone ()
  {
    return this->timeZone_;
  }

  void DateTimeXML::
  setTimeZone (const TimeZoneType& x)
  {
    this->timeZone_.set (x);
  }

  void DateTimeXML::
  setTimeZone (const TimeZoneOptional& x)
  {
    this->timeZone_ = x;
  }

  void DateTimeXML::
  setTimeZone (::std::auto_ptr< TimeZoneType > x)
  {
    this->timeZone_.set (x);
  }


  // DateXML
  // 


  // TimeXML
  // 


  // VectorXML
  // 


  // TimeZoneXML
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace openda
{
  // TreeVectorFileXML
  //

  TreeVectorFileXML::
  TreeVectorFileXML (const TreeVectorType& treeVector)
  : ::xml_schema::Type (),
    timeStamp_ (::xml_schema::Flags (), this),
    treeVector_ (treeVector, ::xml_schema::Flags (), this)
  {
  }

  TreeVectorFileXML::
  TreeVectorFileXML (::std::auto_ptr< TreeVectorType >& treeVector)
  : ::xml_schema::Type (),
    timeStamp_ (::xml_schema::Flags (), this),
    treeVector_ (treeVector, ::xml_schema::Flags (), this)
  {
  }

  TreeVectorFileXML::
  TreeVectorFileXML (const TreeVectorFileXML& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timeStamp_ (x.timeStamp_, f, this),
    treeVector_ (x.treeVector_, f, this)
  {
  }

  TreeVectorFileXML::
  TreeVectorFileXML (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timeStamp_ (f, this),
    treeVector_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TreeVectorFileXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timeStamp
      //
      if (n.name () == "timeStamp" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< TimeStampType > r (
          TimeStampTraits::create (i, f, this));

        if (!this->timeStamp_)
        {
          this->timeStamp_.set (r);
          continue;
        }
      }

      // treeVector
      //
      if (n.name () == "treeVector" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< TreeVectorType > r (
          TreeVectorTraits::create (i, f, this));

        if (!treeVector_.present ())
        {
          this->treeVector_.set (r);
          continue;
        }
      }

      break;
    }

    if (!treeVector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treeVector",
        "http://www.openda.org");
    }
  }

  TreeVectorFileXML* TreeVectorFileXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TreeVectorFileXML (*this, f, c);
  }

  TreeVectorFileXML::
  ~TreeVectorFileXML ()
  {
  }

  // TreeVectorXML
  //

  TreeVectorXML::
  TreeVectorXML ()
  : ::xml_schema::Type (),
    description_ (::xml_schema::Flags (), this),
    treeVectorLeaf_ (::xml_schema::Flags (), this),
    subTreeVector_ (::xml_schema::Flags (), this),
    id_ (::xml_schema::Flags (), this),
    caption_ (::xml_schema::Flags (), this),
    excludeFromVector_ (::xml_schema::Flags (), this),
    className_ (::xml_schema::Flags (), this)
  {
  }

  TreeVectorXML::
  TreeVectorXML (const TreeVectorXML& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    description_ (x.description_, f, this),
    treeVectorLeaf_ (x.treeVectorLeaf_, f, this),
    subTreeVector_ (x.subTreeVector_, f, this),
    id_ (x.id_, f, this),
    caption_ (x.caption_, f, this),
    excludeFromVector_ (x.excludeFromVector_, f, this),
    className_ (x.className_, f, this)
  {
  }

  TreeVectorXML::
  TreeVectorXML (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    description_ (f, this),
    treeVectorLeaf_ (f, this),
    subTreeVector_ (f, this),
    id_ (f, this),
    caption_ (f, this),
    excludeFromVector_ (f, this),
    className_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TreeVectorXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< DescriptionType > r (
          DescriptionTraits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (r);
          continue;
        }
      }

      // treeVectorLeaf
      //
      if (n.name () == "treeVectorLeaf" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< TreeVectorLeafType > r (
          TreeVectorLeafTraits::create (i, f, this));

        this->treeVectorLeaf_.push_back (r);
        continue;
      }

      // subTreeVector
      //
      if (n.name () == "subTreeVector" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< SubTreeVectorType > r (
          SubTreeVectorTraits::create (i, f, this));

        this->subTreeVector_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "caption" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CaptionType > r (
          CaptionTraits::create (i, f, this));

        this->caption_.set (r);
        continue;
      }

      if (n.name () == "excludeFromVector" && n.namespace_ ().empty ())
      {
        this->excludeFromVector_.set (ExcludeFromVectorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "className" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ClassNameType > r (
          ClassNameTraits::create (i, f, this));

        this->className_.set (r);
        continue;
      }
    }
  }

  TreeVectorXML* TreeVectorXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TreeVectorXML (*this, f, c);
  }

  TreeVectorXML::
  ~TreeVectorXML ()
  {
  }

  // TreeVectorLeafXML
  //

  TreeVectorLeafXML::
  TreeVectorLeafXML (const VectorType& vector)
  : ::xml_schema::Type (),
    unit_ (::xml_schema::Flags (), this),
    missingValue_ (::xml_schema::Flags (), this),
    dimensions_ (::xml_schema::Flags (), this),
    grid_ (::xml_schema::Flags (), this),
    vector_ (vector, ::xml_schema::Flags (), this),
    id_ (::xml_schema::Flags (), this),
    caption_ (::xml_schema::Flags (), this),
    excludeFromVector_ (::xml_schema::Flags (), this),
    className_ (::xml_schema::Flags (), this)
  {
  }

  TreeVectorLeafXML::
  TreeVectorLeafXML (const TreeVectorLeafXML& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    unit_ (x.unit_, f, this),
    missingValue_ (x.missingValue_, f, this),
    dimensions_ (x.dimensions_, f, this),
    grid_ (x.grid_, f, this),
    vector_ (x.vector_, f, this),
    id_ (x.id_, f, this),
    caption_ (x.caption_, f, this),
    excludeFromVector_ (x.excludeFromVector_, f, this),
    className_ (x.className_, f, this)
  {
  }

  TreeVectorLeafXML::
  TreeVectorLeafXML (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    unit_ (f, this),
    missingValue_ (f, this),
    dimensions_ (f, this),
    grid_ (f, this),
    vector_ (f, this),
    id_ (f, this),
    caption_ (f, this),
    excludeFromVector_ (f, this),
    className_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TreeVectorLeafXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // unit
      //
      if (n.name () == "unit" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< UnitType > r (
          UnitTraits::create (i, f, this));

        if (!this->unit_)
        {
          this->unit_.set (r);
          continue;
        }
      }

      // missingValue
      //
      if (n.name () == "missingValue" && n.namespace_ () == "http://www.openda.org")
      {
        if (!this->missingValue_)
        {
          this->missingValue_.set (MissingValueTraits::create (i, f, this));
          continue;
        }
      }

      // dimensions
      //
      if (n.name () == "dimensions" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< DimensionsType > r (
          DimensionsTraits::create (i, f, this));

        if (!this->dimensions_)
        {
          this->dimensions_.set (r);
          continue;
        }
      }

      // grid
      //
      if (n.name () == "grid" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< GridType > r (
          GridTraits::create (i, f, this));

        if (!this->grid_)
        {
          this->grid_.set (r);
          continue;
        }
      }

      // vector
      //
      if (n.name () == "vector" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< VectorType > r (
          VectorTraits::create (i, f, this));

        if (!vector_.present ())
        {
          this->vector_.set (r);
          continue;
        }
      }

      break;
    }

    if (!vector_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vector",
        "http://www.openda.org");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "caption" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CaptionType > r (
          CaptionTraits::create (i, f, this));

        this->caption_.set (r);
        continue;
      }

      if (n.name () == "excludeFromVector" && n.namespace_ ().empty ())
      {
        this->excludeFromVector_.set (ExcludeFromVectorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "className" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ClassNameType > r (
          ClassNameTraits::create (i, f, this));

        this->className_.set (r);
        continue;
      }
    }
  }

  TreeVectorLeafXML* TreeVectorLeafXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TreeVectorLeafXML (*this, f, c);
  }

  TreeVectorLeafXML::
  ~TreeVectorLeafXML ()
  {
  }

  // DimensionsXML
  //

  DimensionsXML::
  DimensionsXML (const DimSize1Type& dimSize1)
  : ::xml_schema::Type (),
    dimSize1_ (dimSize1, ::xml_schema::Flags (), this),
    dimSize2_ (::xml_schema::Flags (), this),
    dimSize3_ (::xml_schema::Flags (), this)
  {
  }

  DimensionsXML::
  DimensionsXML (const DimensionsXML& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dimSize1_ (x.dimSize1_, f, this),
    dimSize2_ (x.dimSize2_, f, this),
    dimSize3_ (x.dimSize3_, f, this)
  {
  }

  DimensionsXML::
  DimensionsXML (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dimSize1_ (f, this),
    dimSize2_ (f, this),
    dimSize3_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void DimensionsXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dimSize1" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DimSize1Type > r (
          DimSize1Traits::create (i, f, this));

        this->dimSize1_.set (r);
        continue;
      }

      if (n.name () == "dimSize2" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DimSize2Type > r (
          DimSize2Traits::create (i, f, this));

        this->dimSize2_.set (r);
        continue;
      }

      if (n.name () == "dimSize3" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DimSize3Type > r (
          DimSize3Traits::create (i, f, this));

        this->dimSize3_.set (r);
        continue;
      }
    }

    if (!dimSize1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dimSize1",
        "");
    }
  }

  DimensionsXML* DimensionsXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DimensionsXML (*this, f, c);
  }

  DimensionsXML::
  ~DimensionsXML ()
  {
  }

  // GridXML
  //

  GridXML::
  GridXML (const ComputationalSpaceType& computationalSpace)
  : ::xml_schema::Type (),
    computationalSpace_ (computationalSpace, ::xml_schema::Flags (), this),
    physicalSpace_ (::xml_schema::Flags (), this)
  {
  }

  GridXML::
  GridXML (::std::auto_ptr< ComputationalSpaceType >& computationalSpace)
  : ::xml_schema::Type (),
    computationalSpace_ (computationalSpace, ::xml_schema::Flags (), this),
    physicalSpace_ (::xml_schema::Flags (), this)
  {
  }

  GridXML::
  GridXML (const GridXML& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    computationalSpace_ (x.computationalSpace_, f, this),
    physicalSpace_ (x.physicalSpace_, f, this)
  {
  }

  GridXML::
  GridXML (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    computationalSpace_ (f, this),
    physicalSpace_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GridXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // computationalSpace
      //
      if (n.name () == "computationalSpace" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< ComputationalSpaceType > r (
          ComputationalSpaceTraits::create (i, f, this));

        if (!computationalSpace_.present ())
        {
          this->computationalSpace_.set (r);
          continue;
        }
      }

      // physicalSpace
      //
      if (n.name () == "physicalSpace" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< PhysicalSpaceType > r (
          PhysicalSpaceTraits::create (i, f, this));

        if (!this->physicalSpace_)
        {
          this->physicalSpace_.set (r);
          continue;
        }
      }

      break;
    }

    if (!computationalSpace_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "computationalSpace",
        "http://www.openda.org");
    }
  }

  GridXML* GridXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GridXML (*this, f, c);
  }

  GridXML::
  ~GridXML ()
  {
  }

  // ComputationalSpaceXML
  //

  ComputationalSpaceXML::
  ComputationalSpaceXML ()
  : ::xml_schema::Type (),
    dimension_ (::xml_schema::Flags (), this)
  {
  }

  ComputationalSpaceXML::
  ComputationalSpaceXML (const ComputationalSpaceXML& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dimension_ (x.dimension_, f, this)
  {
  }

  ComputationalSpaceXML::
  ComputationalSpaceXML (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dimension_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ComputationalSpaceXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dimension
      //
      if (n.name () == "dimension" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< DimensionType > r (
          DimensionTraits::create (i, f, this));

        this->dimension_.push_back (r);
        continue;
      }

      break;
    }
  }

  ComputationalSpaceXML* ComputationalSpaceXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComputationalSpaceXML (*this, f, c);
  }

  ComputationalSpaceXML::
  ~ComputationalSpaceXML ()
  {
  }

  // ComputationalDimensionXML
  //

  ComputationalDimensionXML::
  ComputationalDimensionXML (const IdType& id,
                             const LengthType& length)
  : ::xml_schema::Type (),
    id_ (id, ::xml_schema::Flags (), this),
    length_ (length, ::xml_schema::Flags (), this)
  {
  }

  ComputationalDimensionXML::
  ComputationalDimensionXML (const ComputationalDimensionXML& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this),
    length_ (x.length_, f, this)
  {
  }

  ComputationalDimensionXML::
  ComputationalDimensionXML (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (f, this),
    length_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ComputationalDimensionXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "length" && n.namespace_ ().empty ())
      {
        this->length_.set (LengthTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!length_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "length",
        "");
    }
  }

  ComputationalDimensionXML* ComputationalDimensionXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComputationalDimensionXML (*this, f, c);
  }

  ComputationalDimensionXML::
  ~ComputationalDimensionXML ()
  {
  }

  // PhysicalSpaceXML
  //

  PhysicalSpaceXML::
  PhysicalSpaceXML ()
  : ::xml_schema::Type (),
    dimension_ (::xml_schema::Flags (), this)
  {
  }

  PhysicalSpaceXML::
  PhysicalSpaceXML (const PhysicalSpaceXML& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dimension_ (x.dimension_, f, this)
  {
  }

  PhysicalSpaceXML::
  PhysicalSpaceXML (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dimension_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PhysicalSpaceXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dimension
      //
      if (n.name () == "dimension" && n.namespace_ () == "http://www.openda.org")
      {
        ::std::auto_ptr< DimensionType > r (
          DimensionTraits::create (i, f, this));

        this->dimension_.push_back (r);
        continue;
      }

      break;
    }
  }

  PhysicalSpaceXML* PhysicalSpaceXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PhysicalSpaceXML (*this, f, c);
  }

  PhysicalSpaceXML::
  ~PhysicalSpaceXML ()
  {
  }

  // PhysicalDimensionXML
  //

  PhysicalDimensionXML::
  PhysicalDimensionXML (const IdType& id,
                        const AxesType& axes,
                        const RefType& ref)
  : ::xml_schema::Type (),
    id_ (id, ::xml_schema::Flags (), this),
    axes_ (axes, ::xml_schema::Flags (), this),
    ref_ (ref, ::xml_schema::Flags (), this)
  {
  }

  PhysicalDimensionXML::
  PhysicalDimensionXML (const PhysicalDimensionXML& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this),
    axes_ (x.axes_, f, this),
    ref_ (x.ref_, f, this)
  {
  }

  PhysicalDimensionXML::
  PhysicalDimensionXML (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (f, this),
    axes_ (f, this),
    ref_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void PhysicalDimensionXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "axes" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AxesType > r (
          AxesTraits::create (i, f, this));

        this->axes_.set (r);
        continue;
      }

      if (n.name () == "ref" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RefType > r (
          RefTraits::create (i, f, this));

        this->ref_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!axes_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "axes",
        "");
    }

    if (!ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  PhysicalDimensionXML* PhysicalDimensionXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PhysicalDimensionXML (*this, f, c);
  }

  PhysicalDimensionXML::
  ~PhysicalDimensionXML ()
  {
  }

  // MetaInfoXML
  //

  MetaInfoXML::
  MetaInfoXML ()
  : ::xml_schema::Type (),
    id_ (::xml_schema::Flags (), this)
  {
  }

  MetaInfoXML::
  MetaInfoXML (const MetaInfoXML& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  MetaInfoXML::
  MetaInfoXML (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MetaInfoXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }
    }
  }

  MetaInfoXML* MetaInfoXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetaInfoXML (*this, f, c);
  }

  MetaInfoXML::
  ~MetaInfoXML ()
  {
  }

  // DateTimeXML
  //

  DateTimeXML::
  DateTimeXML (const DateType& date,
               const TimeType& time)
  : ::xml_schema::Type (),
    date_ (date, ::xml_schema::Flags (), this),
    time_ (time, ::xml_schema::Flags (), this),
    timeZone_ (::xml_schema::Flags (), this)
  {
  }

  DateTimeXML::
  DateTimeXML (const DateTimeXML& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    date_ (x.date_, f, this),
    time_ (x.time_, f, this),
    timeZone_ (x.timeZone_, f, this)
  {
  }

  DateTimeXML::
  DateTimeXML (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    date_ (f, this),
    time_ (f, this),
    timeZone_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void DateTimeXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "date" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DateType > r (
          DateTraits::create (i, f, this));

        this->date_.set (r);
        continue;
      }

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TimeType > r (
          TimeTraits::create (i, f, this));

        this->time_.set (r);
        continue;
      }

      if (n.name () == "timeZone" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TimeZoneType > r (
          TimeZoneTraits::create (i, f, this));

        this->timeZone_.set (r);
        continue;
      }
    }

    if (!date_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "date",
        "");
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  DateTimeXML* DateTimeXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateTimeXML (*this, f, c);
  }

  DateTimeXML::
  ~DateTimeXML ()
  {
  }

  // DateXML
  //

  DateXML::
  DateXML (const ::xml_schema::Date& _xsd_Date_base)
  : ::xml_schema::Date (_xsd_Date_base)
  {
  }

  DateXML::
  DateXML (const DateXML& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Date (x, f, c)
  {
  }

  DateXML::
  DateXML (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Date (e, f, c)
  {
  }

  DateXML::
  DateXML (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Date (a, f, c)
  {
  }

  DateXML::
  DateXML (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Date (s, e, f, c)
  {
  }

  DateXML* DateXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateXML (*this, f, c);
  }

  DateXML::
  ~DateXML ()
  {
  }

  // TimeXML
  //

  TimeXML::
  TimeXML (const ::xml_schema::Time& _xsd_Time_base)
  : ::xml_schema::Time (_xsd_Time_base)
  {
  }

  TimeXML::
  TimeXML (const TimeXML& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Time (x, f, c)
  {
  }

  TimeXML::
  TimeXML (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Time (e, f, c)
  {
  }

  TimeXML::
  TimeXML (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Time (a, f, c)
  {
  }

  TimeXML::
  TimeXML (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Time (s, e, f, c)
  {
  }

  TimeXML* TimeXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeXML (*this, f, c);
  }

  TimeXML::
  ~TimeXML ()
  {
  }

  // VectorXML
  //

  VectorXML::
  VectorXML ()
  : ::xml_schema::String ()
  {
  }

  VectorXML::
  VectorXML (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VectorXML::
  VectorXML (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VectorXML::
  VectorXML (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VectorXML::
  VectorXML (const VectorXML& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  VectorXML::
  VectorXML (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  VectorXML::
  VectorXML (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  VectorXML::
  VectorXML (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  VectorXML* VectorXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorXML (*this, f, c);
  }

  VectorXML::
  ~VectorXML ()
  {
  }

  // TimeZoneXML
  //

  TimeZoneXML::
  TimeZoneXML ()
  : ::xml_schema::String ()
  {
  }

  TimeZoneXML::
  TimeZoneXML (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZoneXML::
  TimeZoneXML (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZoneXML::
  TimeZoneXML (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZoneXML::
  TimeZoneXML (const TimeZoneXML& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  TimeZoneXML::
  TimeZoneXML (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  TimeZoneXML::
  TimeZoneXML (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  TimeZoneXML::
  TimeZoneXML (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  TimeZoneXML* TimeZoneXML::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeZoneXML (*this, f, c);
  }

  TimeZoneXML::
  ~TimeZoneXML ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace openda
{
  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::std::string& u,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
      ::openda::parseTreeVectorFile (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::std::string& u,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
      ::openda::parseTreeVectorFile (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
      ::openda::parseTreeVectorFile (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::openda::parseTreeVectorFile (isrc, f, p);
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::openda::parseTreeVectorFile (isrc, h, f, p);
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::openda::parseTreeVectorFile (isrc, h, f, p);
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::openda::parseTreeVectorFile (isrc, f, p);
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::openda::parseTreeVectorFile (isrc, h, f, p);
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::openda::parseTreeVectorFile (isrc, h, f, p);
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xercesc::InputSource& i,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
      ::openda::parseTreeVectorFile (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xercesc::InputSource& i,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
      ::openda::parseTreeVectorFile (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
      ::openda::parseTreeVectorFile (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (const ::xercesc::DOMDocument& d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
        ::openda::parseTreeVectorFile (
          c, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "treeVectorFile" &&
        n.namespace_ () == "http://www.openda.org")
    {
      ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
        ::xsd::cxx::tree::traits< ::openda::TreeVectorFileXML, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "treeVectorFile",
      "http://www.openda.org");
  }

  ::std::auto_ptr< ::openda::TreeVectorFileXML >
  parseTreeVectorFile (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "treeVectorFile" &&
        n.namespace_ () == "http://www.openda.org")
    {
      ::std::auto_ptr< ::openda::TreeVectorFileXML > r (
        ::xsd::cxx::tree::traits< ::openda::TreeVectorFileXML, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "treeVectorFile",
      "http://www.openda.org");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace openda
{
  void
  serializeTreeVectorFile (::std::ostream& o,
                           const ::openda::TreeVectorFileXML& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::openda::serializeTreeVectorFile (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeTreeVectorFile (::std::ostream& o,
                           const ::openda::TreeVectorFileXML& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::openda::serializeTreeVectorFile (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeTreeVectorFile (::std::ostream& o,
                           const ::openda::TreeVectorFileXML& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::openda::serializeTreeVectorFile (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeTreeVectorFile (::xercesc::XMLFormatTarget& t,
                           const ::openda::TreeVectorFileXML& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::openda::serializeTreeVectorFile (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeTreeVectorFile (::xercesc::XMLFormatTarget& t,
                           const ::openda::TreeVectorFileXML& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::openda::serializeTreeVectorFile (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeTreeVectorFile (::xercesc::XMLFormatTarget& t,
                           const ::openda::TreeVectorFileXML& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::openda::serializeTreeVectorFile (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeTreeVectorFile (::xercesc::DOMDocument& d,
                           const ::openda::TreeVectorFileXML& s,
                           ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "treeVectorFile" &&
        n.namespace_ () == "http://www.openda.org")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "treeVectorFile",
        "http://www.openda.org");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeTreeVectorFile (const ::openda::TreeVectorFileXML& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "treeVectorFile",
        "http://www.openda.org",
        m, f));

    ::openda::serializeTreeVectorFile (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const TreeVectorFileXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // timeStamp
    //
    if (i.getTimeStamp ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeStamp",
          "http://www.openda.org",
          e));

      s << *i.getTimeStamp ();
    }

    // treeVector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "treeVector",
          "http://www.openda.org",
          e));

      s << i.getTreeVector ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TreeVectorXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // description
    //
    if (i.getDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "http://www.openda.org",
          e));

      s << *i.getDescription ();
    }

    // treeVectorLeaf
    //
    for (TreeVectorXML::TreeVectorLeafConstIterator
         b (i.getTreeVectorLeaf ().begin ()), n (i.getTreeVectorLeaf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "treeVectorLeaf",
          "http://www.openda.org",
          e));

      s << *b;
    }

    // subTreeVector
    //
    for (TreeVectorXML::SubTreeVectorConstIterator
         b (i.getSubTreeVector ().begin ()), n (i.getSubTreeVector ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subTreeVector",
          "http://www.openda.org",
          e));

      s << *b;
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }

    // caption
    //
    if (i.getCaption ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "caption",
          e));

      a << *i.getCaption ();
    }

    // excludeFromVector
    //
    if (i.getExcludeFromVector ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "excludeFromVector",
          e));

      a << *i.getExcludeFromVector ();
    }

    // className
    //
    if (i.getClassName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "className",
          e));

      a << *i.getClassName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TreeVectorLeafXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // unit
    //
    if (i.getUnit ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unit",
          "http://www.openda.org",
          e));

      s << *i.getUnit ();
    }

    // missingValue
    //
    if (i.getMissingValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "missingValue",
          "http://www.openda.org",
          e));

      s << ::xml_schema::AsDouble(*i.getMissingValue ());
    }

    // dimensions
    //
    if (i.getDimensions ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dimensions",
          "http://www.openda.org",
          e));

      s << *i.getDimensions ();
    }

    // grid
    //
    if (i.getGrid ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "grid",
          "http://www.openda.org",
          e));

      s << *i.getGrid ();
    }

    // vector
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vector",
          "http://www.openda.org",
          e));

      s << i.getVector ();
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }

    // caption
    //
    if (i.getCaption ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "caption",
          e));

      a << *i.getCaption ();
    }

    // excludeFromVector
    //
    if (i.getExcludeFromVector ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "excludeFromVector",
          e));

      a << *i.getExcludeFromVector ();
    }

    // className
    //
    if (i.getClassName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "className",
          e));

      a << *i.getClassName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DimensionsXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // dimSize1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimSize1",
          e));

      a << i.getDimSize1 ();
    }

    // dimSize2
    //
    if (i.getDimSize2 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimSize2",
          e));

      a << *i.getDimSize2 ();
    }

    // dimSize3
    //
    if (i.getDimSize3 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dimSize3",
          e));

      a << *i.getDimSize3 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GridXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // computationalSpace
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "computationalSpace",
          "http://www.openda.org",
          e));

      s << i.getComputationalSpace ();
    }

    // physicalSpace
    //
    if (i.getPhysicalSpace ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "physicalSpace",
          "http://www.openda.org",
          e));

      s << *i.getPhysicalSpace ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComputationalSpaceXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // dimension
    //
    for (ComputationalSpaceXML::DimensionConstIterator
         b (i.getDimension ().begin ()), n (i.getDimension ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dimension",
          "http://www.openda.org",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComputationalDimensionXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // length
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "length",
          e));

      a << i.getLength ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PhysicalSpaceXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // dimension
    //
    for (PhysicalSpaceXML::DimensionConstIterator
         b (i.getDimension ().begin ()), n (i.getDimension ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dimension",
          "http://www.openda.org",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PhysicalDimensionXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // axes
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "axes",
          e));

      a << i.getAxes ();
    }

    // ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ref",
          e));

      a << i.getRef ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MetaInfoXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateTimeXML& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // date
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "date",
          e));

      a << i.getDate ();
    }

    // time
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "time",
          e));

      a << i.getTime ();
    }

    // timeZone
    //
    if (i.getTimeZone ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "timeZone",
          e));

      a << *i.getTimeZone ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateXML& i)
  {
    e << static_cast< const ::xml_schema::Date& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DateXML& i)
  {
    a << static_cast< const ::xml_schema::Date& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DateXML& i)
  {
    l << static_cast< const ::xml_schema::Date& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeXML& i)
  {
    e << static_cast< const ::xml_schema::Time& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimeXML& i)
  {
    a << static_cast< const ::xml_schema::Time& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimeXML& i)
  {
    l << static_cast< const ::xml_schema::Time& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VectorXML& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VectorXML& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VectorXML& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeZoneXML& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimeZoneXML& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimeZoneXML& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

