// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from rtcToolsConfig.xsd.
 */

#ifndef RTC_TOOLS_CONFIG_HXX
#define RTC_TOOLS_CONFIG_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace fews
{
  class RtcToolsConfigComplexType;
  class GeneralModuleConfigComplexType;
  class ComponentsComplexType;
  class ComponentComplexType;
  class AllocationTableComplexType;
  class ATableComplexType;
  class InputATableComplexType;
  class OutputATableComplexType;
  class HydrologicalModelComplexType;
  class SubmodelComplexType;
  class ReleaseTotalComplexType;
  class ParameterReleaseTotalComplexType;
  class InputReleaseTotalComplexType;
  class EvaporationPotentialComplexType;
  class ParameterEvaporationPotentialComplexType;
  class InputEvaporationPotentialComplexType;
  class OutputEvaporationPotentialComplexType;
  class TypicalProfileComplexType;
  class DataTypicalProfileComplexType;
  class SnowRainJunctionComplexType;
  class ParameterSnowRainJunctionComplexType;
  class InputSnowRainJunctionComplexType;
  class OutputSnowRainJunctionComplexType;
  class StorageSystemComplexType;
  class StorageSystemSettingsComplexType;
  class OutputStorageSystemComplexType;
  class NodeStorageSystemComplexType;
  class InputNodeStorageSystemComplexType;
  class LinkStorageSystemComplexType;
  class OutputLinkStorageSystemComplexType;
  class MeltRefreezingStorageSystemComplexType;
  class ParameterMeltRefreezingStorageSystemComplexType;
  class ReleaseWaterContentStorageSystemComplexType;
  class ParameterReleaseWaterContentStorageSystemComplexType;
  class EvaporationInterceptionStorageSystemComplexType;
  class InputEvaporationInterceptionStorageSystemComplexType;
  class ParameterEvaporationInterceptionStorageSystemComplexType;
  class ReleaseAboveThresholdStorageSystemComplexType;
  class ParameterReleaseAboveThresholdStorageSystemComplexType;
  class InputReleaseAboveThresholdStorageSystemComplexType;
  class IrrigationStorageSystemComplexType;
  class ParameterIrrigationStorageSystemComplexType;
  class WaterDistributionConstantStorageSystemComplexType;
  class ParameterWaterDistributionConstantStorageSystemComplexType;
  class InputWaterDistributionConstantStorageSystemComplexType;
  class WaterDistributionVariableStorageSystemComplexType;
  class ParameterWaterDistributionVariableStorageSystemComplexType;
  class InputWaterDistributionVariableStorageSystemComplexType;
  class GroundwaterFlowStorageSystemComplexType;
  class InputGroundwaterFlowStorageSystemComplexType;
  class ParametergroundwaterFlowStorageSystemComplexType;
  class EvaporationActualStorageSystemComplexType;
  class InputEvaporationActualStorageSystemComplexType;
  class ParameterEvaporationActualStorageSystemComplexType;
  class SoilRunoffStorageSystemComplexType;
  class InputSoilRunoffStorageSystemComplexType;
  class ParameterSoilRunoffStorageSystemComplexType;
  class CapillaryFlowStorageSystemComplexType;
  class InputCapillaryFlowStorageSystemComplexType;
  class ParameterCapillaryFlowStorageSystemComplexType;
  class ResponseStorageSystemComplexType;
  class ParameterResponseStorageSystemComplexType;
  class InputResponseStorageSystemComplexType;
  class PercolationStorageSystemComplexType;
  class ParameterPercolationStorageSystemComplexType;
  class InputPercolationStorageSystemComplexType;
  class ArmaComplexType;
  class ArmaInputComplexType;
  class ArmaOutputComplexType;
  class AccumulationComplexType;
  class AccumulationInputComplexType;
  class AccumulationOutputComplexType;
  class GradientComplexType;
  class GradientInputComplexType;
  class GradientOutputComplexType;
  class LorentGeversComplexType;
  class LorentGeversParameterSoilComplexType;
  class LorentGeversParameterResponseComplexType;
  class LorentGeversInputComplexType;
  class LorentGeversStateComplexType;
  class LorentGeversStateUpdateComplexType;
  class LorentGeversOutputComplexType;
  class HBVComplexType;
  class HBVParameterInputComplexType;
  class HBVParameterSnowComplexType;
  class HBVParameterInterceptionComplexType;
  class HBVParameterSoilComplexType;
  class HBVParameterResponseComplexType;
  class HBVInputComplexType;
  class HBVLinkComplexType;
  class HBVStateComplexType;
  class HBVStateUpdateComplexType;
  class HBVOutputComplexType;
  class SRMComplexType;
  class SRMParameterComplexType;
  class SRMParameterZoneComplexType;
  class SRMInputComplexType;
  class SRMStateComplexType;
  class SRMOutputComplexType;
  class UnitDelayComplexType;
  class UnitDelayInputComplexType;
  class UnitDelayOutputComplexType;
  class UnitHydrographComplexType;
  class UnitHydrographWeightComplexType;
  class UnitHydrographWeightTriangularComplexType;
  class UnitHydrographWeightCustomComplexType;
  class UnitHydrographInputComplexType;
  class UnitHydrographOutputComplexType;
  class ReservoirCompactComplexType;
  class LevelStorageEquationComplexType;
  class TailwaterEquationComplexType;
  class TailwaterTidalEquationComplexType;
  class TurbineEfficiencyTableComplexType;
  class ColumnsComplexType;
  class RowComplexType;
  class MaxFlowsComplexType;
  class ReservoirCompactInputComplexType;
  class ReservoirCompactOutputComplexType;
  class ReservoirComplexType;
  class RoutingComplexType;
  class NeuralNetworkComplexType;
  class LayerComplexType;
  class NeuronComplexType;
  class NeuronInputComplexType;
  class NeuronOutputComplexType;
  class HydraulicModelComplexType;
  class HydraulicModelSequentialImplicitComplexType;
  class HydraulicModelSimultaneousComplexType;
  class HydraulicModelOutputComplexType;
  class ConnectionInputComplexType;
  class ConnectionOutputComplexType;
  class RoutingOutputComplexType;
  class ReservoirRoutingComplexType;
  class SimpleReservoirComplexType;
  class ConnectionCoefficientsComplexType;
  class RulesComplexType;
  class RuleComplexType;
  class ThunerseeRuleComplexType;
  class ReservoirThunerseeRuleComplexType;
  class WeirThunerseeRuleComplexType;
  class TunnelThunerseeRuleComplexType;
  class ThunerseeRuleInputComplexType;
  class ThunerseeRuleOutputComplexType;
  class AebiRuleComplexType;
  class AebiRuleInputComplexType;
  class AebiRuleOutputComplexType;
  class LookupTableComplexType;
  class TableLookupTableComplexType;
  class Lookup2DTableComplexType;
  class Table2DLookupTableComplexType;
  class XDimComplexType;
  class YDimComplexType;
  class ValueArrayComplexType;
  class IntervalComplexType;
  class IntervalInputComplexType;
  class IntervalOutputComplexType;
  class DateLookupTableComplexType;
  class InterpolationOptionsComplexType;
  class DateRecord2ComplexType;
  class DateRecord2DataComplexType;
  class DateLookupTableInputComplexType;
  class DateLookupTableOutputComplexType;
  class LookupTableInputComplexType;
  class LookupTableOutputComplexType;
  class Lookup2DTableInputComplexType;
  class Lookup2DTableOutputComplexType;
  class PolygonLookupComplexType;
  class PolygonsComplexType;
  class PolygonComplexType;
  class EdgesComplexType;
  class EdgeComplexType;
  class PolygonLookupInputComplexType;
  class PolygonLookupOutputComplexType;
  class SpreadsheetComplexType;
  class ValidPeriodsComplexType;
  class ValidPeriodComplexType;
  class DateComplexType;
  class SpreadsheetTablesComplexType;
  class SpreadsheetTableComplexType;
  class SpreadsheetRecordComplexType;
  class SpreadsheetInputComplexType;
  class SpreadsheetOutputComplexType;
  class MergerComplexType;
  class MergerInputComplexType;
  class MergerOutputComplexType;
  class MergerSplitterComplexType;
  class MergerSplitterInputComplexType;
  class MergerSplitterOutputComplexType;
  class TimeAbsoluteComplexType;
  class TimeAbsoluteInputComplexType;
  class TimeAbsoluteOutputComplexType;
  class TimeRelativeComplexType;
  class TimeRelativeControlTableComplexType;
  class TimeRelativeControlTableRecordComplexType;
  class TimeRelativeInputComplexType;
  class TimeRelativeOutputComplexType;
  class ExpressionComplexType;
  class DeadBandValueComplexType;
  class DeadBandValueInputComplexType;
  class DeadBandTimeComplexType;
  class DeadBandTimeDiscreteComplexType;
  class DeadBandTimeInputComplexType;
  class DeadBandTimeOutputComplexType;
  class LimiterComplexType;
  class LimiterInputComplexType;
  class TriggersComplexType;
  class TriggerComplexType;
  class EifelRurRuleComplexType;
  class GuideBandRuleComplexType;
  class GuideBandRuleInputComplexType;
  class GuideBandRuleOutputComplexType;
  class ConstantRuleComplexType;
  class ConstantRuleOutputComplexType;
  class MinSimpleRuleComplexType;
  class StorageCharacteristicsComplexType;
  class CapacityCharacteristicsComplexType;
  class TurbineCharacteristicsComplexType;
  class TurbineOutputCharacteristicsComplexType;
  class ElevationTableComplexType;
  class TailwaterComplexType;
  class TailwaterOutputComplexType;
  class ElevationRecordComplexType;
  class ControlledOutletComplexType;
  class UncontrolledOutletComplexType;
  class UOutletInputComplexType;
  class EquationsComplexType;
  class EquationComplexType;
  class ZonesComplexType;
  class ZoneComplexType;
  class DateTableComplexType;
  class DateRecordComplexType;
  class ReservoirInputComplexType;
  class ReservoirOutputComplexType;
  class ReservoirGradientComplexType;
  class NodeGradientComplexType;
  class OutletInputComplexType;
  class OutletOutputComplexType;
  class DeadBandTriggerComplexType;
  class TriggerInputComplexType;
  class TriggerOutputComplexType;
  class StandardTriggerComplexType;
  class RelationalConditionComplexType;
  class SetTriggerComplexType;
  class RuleTriggerComplexType;
  class ResultComplexType;
  class ConditionComplexType;
  class RuleStateTriggerComplexType;
  class InflowComplexType;
  class NodeComplexType;
  class NodeInputComplexType;
  class NodeOutputComplexType;
  class BranchComplexType;
  class CrossSectionComplexType;
  class CrossSectionRoughnessComplexType;
  class BranchInputComplexType;
  class BranchOutputComplexType;
  class HydraulicStructureComplexType;
  class PumpComplexType;
  class PumpInputComplexType;
  class PumpOutputComplexType;
  class PumpGradientComplexType;
  class TurbineComplexType;
  class TurbineCapacityCharacteristicsComplexType;
  class TurbineEfficiencyCharacteristicsComplexType;
  class TurbineInputComplexType;
  class TurbineOutputComplexType;
  class OrificeComplexType;
  class OrificeInputComplexType;
  class OrificeOutputComplexType;
  class BranchGradientComplexType;
  class RiverWeirComplexType;
  class RiverWeirInputComplexType;
  class RiverWeirOutputComplexType;
  class PoolRoutingEnumStringType;
  class InterpolationOptionEnumStringType;
  class LimiterOptionEnumStringType;
  class TimeRelativeEnumStringType;
  class CaseLangetenEnumStringType;
  class FlowDirectionEnumStringType;
  class LogicalOperatorEnumStringType;
  class RelationalOperatorEnumStringType;
  class MathematicalOperatorEnumStringType;
  class SpatialEnumStringType;
  class CapacityReferenceEnumStringType;
  class InputReferenceEnumStringType;
  class BranchTypeEnumStringType;
  class EquationEnumStringType;
  class MergerSplitterEnumStringType;
  class HydraulicModelModeEnumStringType;
  class TransferFunctionEnumStringType;
  class PidComplexType;
  class InputPidComplexType;
  class OutputPidComplexType;
  class TriggerControllerComplexType;
  class LayerIDSimpleType;
  class NeuronIDSimpleType;
  class UnitTypeEnumStringType;
  class Row;
  class Y;
  class MonthOfYear;
  class QSPercentage;
  class QSPercentageValue;
  class External;
  class Internal;
  class Multiplier;
  class Property;
  class X;
  class X1;
  class X11;
  class X2;
  class X12;
  class X21;
  class X3;
  class X4;
  class X5;
  class XVector;
  class Y1;
  class Mode;
  class X1Series;
  class X1SeriesVector;
  class X2Series;
  class X2SeriesVector;
  class X6;
  class ThresholdSeries;
  class X1Series1;
  class X2Series1;
  class X1Series2;
  class X2Series2;
  class QBC;
  class FlowDirectionEnumStringType_member;
  class FlowDirectionEnumStringType_member1;
  class Mode1;
  class Disturbance;
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-lcp.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "rtcSharedTypes.hxx"

/**
 * @brief C++ namespace for the %http://www.wldelft.nl/fews
 * schema namespace.
 */
namespace fews
{
  /**
   * @brief Class corresponding to the %RtcToolsConfigComplexType schema type.
   *
   * @nosubgrouping
   */
  class RtcToolsConfigComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name general
     *
     * @brief Accessor and modifier functions for the %general
     * optional element.
     *
     * OBSOLETE. Still here for backwards compatibility. Remove after next
     * release.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GeneralModuleConfigComplexType GeneralType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GeneralType > GeneralOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GeneralType, char > GeneralTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GeneralOptional&
    getGeneral () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GeneralOptional&
    getGeneral ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGeneral (const GeneralType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGeneral (const GeneralOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGeneral (::std::auto_ptr< GeneralType > p);

    //@}

    /**
     * @name components
     *
     * @brief Accessor and modifier functions for the %components
     * optional element.
     *
     * The components section includes all simulation components.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ComponentsComplexType ComponentsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ComponentsType > ComponentsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentsType, char > ComponentsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ComponentsOptional&
    getComponents () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ComponentsOptional&
    getComponents ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComponents (const ComponentsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setComponents (const ComponentsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setComponents (::std::auto_ptr< ComponentsType > p);

    //@}

    /**
     * @name rules
     *
     * @brief Accessor and modifier functions for the %rules
     * optional element.
     *
     * The rules section includes operating rules or controllers for defining
     * the release of reservoir, structural settings of gates etc.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RulesComplexType RulesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RulesType > RulesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RulesType, char > RulesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RulesOptional&
    getRules () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RulesOptional&
    getRules ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRules (const RulesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRules (const RulesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRules (::std::auto_ptr< RulesType > p);

    //@}

    /**
     * @name triggers
     *
     * @brief Accessor and modifier functions for the %triggers
     * optional element.
     *
     * Triggers may activate or deactivate rules defined in the section
    above. */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggersComplexType TriggersType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TriggersType > TriggersOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TriggersType, char > TriggersTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TriggersOptional&
    getTriggers () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TriggersOptional&
    getTriggers ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTriggers (const TriggersType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTriggers (const TriggersOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTriggers (::std::auto_ptr< TriggersType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RtcToolsConfigComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RtcToolsConfigComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RtcToolsConfigComplexType (const RtcToolsConfigComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RtcToolsConfigComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RtcToolsConfigComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GeneralOptional general_;
    ComponentsOptional components_;
    RulesOptional rules_;
    TriggersOptional triggers_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GeneralModuleConfigComplexType schema type.
   *
   * DEPRICATED
   *
   * @nosubgrouping
   */
  class GeneralModuleConfigComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * optional element.
     *
     * DEPRICATED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String DescriptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DescriptionType > DescriptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DescriptionOptional&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DescriptionOptional&
    getDescription ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDescription (const DescriptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDescription (const DescriptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDescription (::std::auto_ptr< DescriptionType > p);

    //@}

    /**
     * @name poolRoutingScheme
     *
     * @brief Accessor and modifier functions for the %poolRoutingScheme
     * required element.
     *
     * DEPRICATED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PoolRoutingEnumStringType PoolRoutingSchemeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PoolRoutingSchemeType, char > PoolRoutingSchemeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PoolRoutingSchemeType&
    getPoolRoutingScheme () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PoolRoutingSchemeType&
    getPoolRoutingScheme ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPoolRoutingScheme (const PoolRoutingSchemeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPoolRoutingScheme (::std::auto_ptr< PoolRoutingSchemeType > p);

    //@}

    /**
     * @name theta
     *
     * @brief Accessor and modifier functions for the %theta
     * required element.
     *
     * DEPRICATED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ThetaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThetaType, char, ::xsd::cxx::tree::schema_type::double_ > ThetaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ThetaType&
    getTheta () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ThetaType&
    getTheta ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTheta (const ThetaType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GeneralModuleConfigComplexType (const PoolRoutingSchemeType&,
                                    const ThetaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GeneralModuleConfigComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GeneralModuleConfigComplexType (const GeneralModuleConfigComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GeneralModuleConfigComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GeneralModuleConfigComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DescriptionOptional description_;
    ::xsd::cxx::tree::one< PoolRoutingSchemeType > poolRoutingScheme_;
    ::xsd::cxx::tree::one< ThetaType > theta_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ComponentsComplexType schema type.
   *
   * @nosubgrouping
   */
  class ComponentsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ComponentComplexType ComponentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ComponentType > ComponentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ComponentSequence::iterator ComponentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ComponentSequence::const_iterator ComponentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ComponentSequence&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ComponentSequence&
    getComponent ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setComponent (const ComponentSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ComponentsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComponentsComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComponentsComplexType (const ComponentsComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ComponentsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ComponentsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ComponentSequence component_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ComponentComplexType schema type.
   *
   * @nosubgrouping
   */
  class ComponentComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name accumulation
     *
     * @brief Accessor and modifier functions for the %accumulation
     * optional element.
     *
     * Accumulation of a time series over time
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AccumulationComplexType AccumulationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AccumulationType > AccumulationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AccumulationType, char > AccumulationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AccumulationOptional&
    getAccumulation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AccumulationOptional&
    getAccumulation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAccumulation (const AccumulationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAccumulation (const AccumulationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAccumulation (::std::auto_ptr< AccumulationType > p);

    //@}

    /**
     * @name allocationTable
     *
     * @brief Accessor and modifier functions for the %allocationTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AllocationTableComplexType AllocationTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AllocationTableType > AllocationTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AllocationTableType, char > AllocationTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AllocationTableOptional&
    getAllocationTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AllocationTableOptional&
    getAllocationTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAllocationTable (const AllocationTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAllocationTable (const AllocationTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAllocationTable (::std::auto_ptr< AllocationTableType > p);

    //@}

    /**
     * @name arma
     *
     * @brief Accessor and modifier functions for the %arma
     * optional element.
     *
     * Arma error correction model
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ArmaComplexType ArmaType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ArmaType > ArmaOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ArmaType, char > ArmaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ArmaOptional&
    getArma () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ArmaOptional&
    getArma ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setArma (const ArmaType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setArma (const ArmaOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setArma (::std::auto_ptr< ArmaType > p);

    //@}

    /**
     * @name expression
     *
     * @brief Accessor and modifier functions for the %expression
     * optional element.
     *
     * Mathematical expression
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExpressionComplexType ExpressionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExpressionType > ExpressionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExpressionType, char > ExpressionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExpressionOptional&
    getExpression () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExpressionOptional&
    getExpression ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpression (const ExpressionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpression (const ExpressionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExpression (::std::auto_ptr< ExpressionType > p);

    //@}

    /**
     * @name gradient
     *
     * @brief Accessor and modifier functions for the %gradient
     * optional element.
     *
     * Post processing for computing gradients of simulated values
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GradientComplexType GradientType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GradientType > GradientOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GradientType, char > GradientTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GradientOptional&
    getGradient () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GradientOptional&
    getGradient ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGradient (const GradientType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGradient (const GradientOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGradient (::std::auto_ptr< GradientType > p);

    //@}

    /**
     * @name hbv
     *
     * @brief Accessor and modifier functions for the %hbv
     * optional element.
     *
     * This is an implementation of the HBV-96 hydrological model. Note that
     * the unit hydrograph is not included, but available separately.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVComplexType HbvType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HbvType > HbvOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HbvType, char > HbvTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HbvOptional&
    getHbv () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HbvOptional&
    getHbv ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHbv (const HbvType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHbv (const HbvOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHbv (::std::auto_ptr< HbvType > p);

    //@}

    /**
     * @name hydraulicModel
     *
     * @brief Accessor and modifier functions for the %hydraulicModel
     * optional element.
     *
     * Simplifications of the full dynamic, one-dimensional hydraulic model
     * according to the kinematic wave, diffusive wave and inertial
     * assumptions.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydraulicModelComplexType HydraulicModelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HydraulicModelType > HydraulicModelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HydraulicModelType, char > HydraulicModelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HydraulicModelOptional&
    getHydraulicModel () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HydraulicModelOptional&
    getHydraulicModel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHydraulicModel (const HydraulicModelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHydraulicModel (const HydraulicModelOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHydraulicModel (::std::auto_ptr< HydraulicModelType > p);

    //@}

    /**
     * @name hydrologicalModel
     *
     * @brief Accessor and modifier functions for the %hydrologicalModel
     * optional element.
     *
     * Modular, conceptual hydrological model with implicit time stepping
     * scheme.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydrologicalModelComplexType HydrologicalModelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HydrologicalModelType > HydrologicalModelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HydrologicalModelType, char > HydrologicalModelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HydrologicalModelOptional&
    getHydrologicalModel () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HydrologicalModelOptional&
    getHydrologicalModel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHydrologicalModel (const HydrologicalModelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHydrologicalModel (const HydrologicalModelOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHydrologicalModel (::std::auto_ptr< HydrologicalModelType > p);

    //@}

    /**
     * @name lookupTable
     *
     * @brief Accessor and modifier functions for the %lookupTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LookupTableComplexType LookupTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LookupTableType > LookupTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LookupTableType, char > LookupTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LookupTableOptional&
    getLookupTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LookupTableOptional&
    getLookupTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLookupTable (const LookupTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLookupTable (const LookupTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLookupTable (::std::auto_ptr< LookupTableType > p);

    //@}

    /**
     * @name lookup2DTable
     *
     * @brief Accessor and modifier functions for the %lookup2DTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Lookup2DTableComplexType Lookup2DTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Lookup2DTableType > Lookup2DTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Lookup2DTableType, char > Lookup2DTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Lookup2DTableOptional&
    getLookup2DTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Lookup2DTableOptional&
    getLookup2DTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLookup2DTable (const Lookup2DTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLookup2DTable (const Lookup2DTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLookup2DTable (::std::auto_ptr< Lookup2DTableType > p);

    //@}

    /**
     * @name merger
     *
     * @brief Accessor and modifier functions for the %merger
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerComplexType MergerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MergerType > MergerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MergerType, char > MergerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MergerOptional&
    getMerger () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MergerOptional&
    getMerger ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMerger (const MergerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMerger (const MergerOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMerger (::std::auto_ptr< MergerType > p);

    //@}

    /**
     * @name mergerSplitter
     *
     * @brief Accessor and modifier functions for the %mergerSplitter
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerSplitterComplexType MergerSplitterType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MergerSplitterType > MergerSplitterOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MergerSplitterType, char > MergerSplitterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MergerSplitterOptional&
    getMergerSplitter () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MergerSplitterOptional&
    getMergerSplitter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMergerSplitter (const MergerSplitterType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMergerSplitter (const MergerSplitterOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMergerSplitter (::std::auto_ptr< MergerSplitterType > p);

    //@}

    /**
     * @name neuralNetwork
     *
     * @brief Accessor and modifier functions for the %neuralNetwork
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NeuralNetworkComplexType NeuralNetworkType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NeuralNetworkType > NeuralNetworkOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NeuralNetworkType, char > NeuralNetworkTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NeuralNetworkOptional&
    getNeuralNetwork () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NeuralNetworkOptional&
    getNeuralNetwork ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNeuralNetwork (const NeuralNetworkType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNeuralNetwork (const NeuralNetworkOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNeuralNetwork (::std::auto_ptr< NeuralNetworkType > p);

    //@}

    /**
     * @name reservoir
     *
     * @brief Accessor and modifier functions for the %reservoir
     * optional element.
     *
     * Reservoir with arbitrary number of inlets and outlets.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirComplexType ReservoirType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReservoirType > ReservoirOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReservoirType, char > ReservoirTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReservoirOptional&
    getReservoir () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReservoirOptional&
    getReservoir ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReservoir (const ReservoirType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReservoir (const ReservoirOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReservoir (::std::auto_ptr< ReservoirType > p);

    //@}

    /**
     * @name reservoirCompact
     *
     * @brief Accessor and modifier functions for the %reservoirCompact
     * optional element.
     *
     * Test implementation of a compact reservoir class for simultaneous and
     * sequential optimization mode
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirCompactComplexType ReservoirCompactType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReservoirCompactType > ReservoirCompactOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReservoirCompactType, char > ReservoirCompactTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReservoirCompactOptional&
    getReservoirCompact () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReservoirCompactOptional&
    getReservoirCompact ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReservoirCompact (const ReservoirCompactType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReservoirCompact (const ReservoirCompactOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReservoirCompact (::std::auto_ptr< ReservoirCompactType > p);

    //@}

    /**
     * @name lorentGevers
     *
     * @brief Accessor and modifier functions for the %lorentGevers
     * optional element.
     *
     * Lorent/Gevers hydrological model
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversComplexType LorentGeversType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LorentGeversType > LorentGeversOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LorentGeversType, char > LorentGeversTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LorentGeversOptional&
    getLorentGevers () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LorentGeversOptional&
    getLorentGevers ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLorentGevers (const LorentGeversType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLorentGevers (const LorentGeversOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLorentGevers (::std::auto_ptr< LorentGeversType > p);

    //@}

    /**
     * @name routing
     *
     * @brief Accessor and modifier functions for the %routing
     * optional element.
     *
     * not implemented yet
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RoutingComplexType RoutingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RoutingType > RoutingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RoutingType, char > RoutingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RoutingOptional&
    getRouting () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RoutingOptional&
    getRouting ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRouting (const RoutingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRouting (const RoutingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRouting (::std::auto_ptr< RoutingType > p);

    //@}

    /**
     * @name srm
     *
     * @brief Accessor and modifier functions for the %srm
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SRMComplexType SrmType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SrmType > SrmOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SrmType, char > SrmTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SrmOptional&
    getSrm () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SrmOptional&
    getSrm ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSrm (const SrmType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSrm (const SrmOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSrm (::std::auto_ptr< SrmType > p);

    //@}

    /**
     * @name unitDelay
     *
     * @brief Accessor and modifier functions for the %unitDelay
     * optional element.
     *
     * Unit delay operator for  delaying a value by n times the time step of
     * the model.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitDelayComplexType UnitDelayType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnitDelayType > UnitDelayOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitDelayType, char > UnitDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnitDelayOptional&
    getUnitDelay () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UnitDelayOptional&
    getUnitDelay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUnitDelay (const UnitDelayType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUnitDelay (const UnitDelayOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnitDelay (::std::auto_ptr< UnitDelayType > p);

    //@}

    /**
     * @name unitHydrograph
     *
     * @brief Accessor and modifier functions for the %unitHydrograph
     * optional element.
     *
     * Unit hydrograph
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitHydrographComplexType UnitHydrographType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnitHydrographType > UnitHydrographOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitHydrographType, char > UnitHydrographTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnitHydrographOptional&
    getUnitHydrograph () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UnitHydrographOptional&
    getUnitHydrograph ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUnitHydrograph (const UnitHydrographType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUnitHydrograph (const UnitHydrographOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnitHydrograph (::std::auto_ptr< UnitHydrographType > p);

    //@}

    /**
     * @name template
     *
     * @brief Accessor and modifier functions for the %template
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TemplateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TemplateType > TemplateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TemplateType, char > TemplateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TemplateOptional&
    getTemplate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TemplateOptional&
    getTemplate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTemplate (const TemplateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setTemplate (const TemplateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTemplate (::std::auto_ptr< TemplateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ComponentComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComponentComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComponentComplexType (const ComponentComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ComponentComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ComponentComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AccumulationOptional accumulation_;
    AllocationTableOptional allocationTable_;
    ArmaOptional arma_;
    ExpressionOptional expression_;
    GradientOptional gradient_;
    HbvOptional hbv_;
    HydraulicModelOptional hydraulicModel_;
    HydrologicalModelOptional hydrologicalModel_;
    LookupTableOptional lookupTable_;
    Lookup2DTableOptional lookup2DTable_;
    MergerOptional merger_;
    MergerSplitterOptional mergerSplitter_;
    NeuralNetworkOptional neuralNetwork_;
    ReservoirOptional reservoir_;
    ReservoirCompactOptional reservoirCompact_;
    LorentGeversOptional lorentGevers_;
    RoutingOptional routing_;
    SrmOptional srm_;
    UnitDelayOptional unitDelay_;
    UnitHydrographOptional unitHydrograph_;
    TemplateOptional template__;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AllocationTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class AllocationTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name table
     *
     * @brief Accessor and modifier functions for the %table
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ATableComplexType TableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TableType > TableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TableType, char > TableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TableOptional&
    getTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TableOptional&
    getTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTable (const TableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTable (const TableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTable (::std::auto_ptr< TableType > p);

    //@}

    /**
     * @name tableExternal
     *
     * @brief Accessor and modifier functions for the %tableExternal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String TableExternalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TableExternalType > TableExternalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TableExternalType, char > TableExternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TableExternalOptional&
    getTableExternal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TableExternalOptional&
    getTableExternal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTableExternal (const TableExternalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTableExternal (const TableExternalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTableExternal (::std::auto_ptr< TableExternalType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputATableComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputATableComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AllocationTableComplexType (const InputType&,
                                const OutputType&,
                                const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AllocationTableComplexType (::std::auto_ptr< InputType >&,
                                ::std::auto_ptr< OutputType >&,
                                const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AllocationTableComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AllocationTableComplexType (const AllocationTableComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AllocationTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AllocationTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TableOptional table_;
    TableExternalOptional tableExternal_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ATableComplexType schema type.
   *
   * @nosubgrouping
   */
  class ATableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name row
     *
     * @brief Accessor and modifier functions for the %row
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Row RowType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RowType > RowSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RowSequence::iterator RowIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RowSequence::const_iterator RowConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RowType, char > RowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RowSequence&
    getRow () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RowSequence&
    getRow ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRow (const RowSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ATableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ATableComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ATableComplexType (const ATableComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ATableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ATableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RowSequence row_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputATableComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputATableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name valueSelection
     *
     * @brief Accessor and modifier functions for the %valueSelection
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ValueSelectionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ValueSelectionType > ValueSelectionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueSelectionType, char > ValueSelectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ValueSelectionOptional&
    getValueSelection () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ValueSelectionOptional&
    getValueSelection ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValueSelection (const ValueSelectionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setValueSelection (const ValueSelectionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setValueSelection (::std::auto_ptr< ValueSelectionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputATableComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputATableComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputATableComplexType (const InputATableComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputATableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputATableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ValueSelectionOptional valueSelection_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputATableComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputATableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Y YType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< YType > YSequence;

    /**
     * @brief Element iterator type.
     */
    typedef YSequence::iterator YIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef YSequence::const_iterator YConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const YSequence&
    getY () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    YSequence&
    getY ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setY (const YSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputATableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputATableComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputATableComplexType (const OutputATableComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputATableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputATableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    YSequence y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HydrologicalModelComplexType schema type.
   *
   * @nosubgrouping
   */
  class HydrologicalModelComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name submodel
     *
     * @brief Accessor and modifier functions for the %submodel
     * sequence element.
     *
     * sub-models for the modular setup of the hydrological model, the
     * storage system contains a set of storage nodes and links and is solved
     * with an implicit time stepping scheme
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SubmodelComplexType SubmodelType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SubmodelType > SubmodelSequence;

    /**
     * @brief Element iterator type.
     */
    typedef SubmodelSequence::iterator SubmodelIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SubmodelSequence::const_iterator SubmodelConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SubmodelType, char > SubmodelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SubmodelSequence&
    getSubmodel () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SubmodelSequence&
    getSubmodel ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSubmodel (const SubmodelSequence& s);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HydrologicalModelComplexType (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydrologicalModelComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydrologicalModelComplexType (const HydrologicalModelComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydrologicalModelComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HydrologicalModelComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SubmodelSequence submodel_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SubmodelComplexType schema type.
   *
   * @nosubgrouping
   */
  class SubmodelComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name typicalProfile
     *
     * @brief Accessor and modifier functions for the %typicalProfile
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TypicalProfileComplexType TypicalProfileType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypicalProfileType > TypicalProfileOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypicalProfileType, char > TypicalProfileTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypicalProfileOptional&
    getTypicalProfile () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TypicalProfileOptional&
    getTypicalProfile ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTypicalProfile (const TypicalProfileType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTypicalProfile (const TypicalProfileOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTypicalProfile (::std::auto_ptr< TypicalProfileType > p);

    //@}

    /**
     * @name snowRainJunction
     *
     * @brief Accessor and modifier functions for the %snowRainJunction
     * optional element.
     *
     * separates precipitation into snow and rainfall
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SnowRainJunctionComplexType SnowRainJunctionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SnowRainJunctionType > SnowRainJunctionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SnowRainJunctionType, char > SnowRainJunctionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SnowRainJunctionOptional&
    getSnowRainJunction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SnowRainJunctionOptional&
    getSnowRainJunction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSnowRainJunction (const SnowRainJunctionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSnowRainJunction (const SnowRainJunctionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSnowRainJunction (::std::auto_ptr< SnowRainJunctionType > p);

    //@}

    /**
     * @name evaporationPotential
     *
     * @brief Accessor and modifier functions for the %evaporationPotential
     * optional element.
     *
     * potential evaporation
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EvaporationPotentialComplexType EvaporationPotentialType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EvaporationPotentialType > EvaporationPotentialOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EvaporationPotentialType, char > EvaporationPotentialTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EvaporationPotentialOptional&
    getEvaporationPotential () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EvaporationPotentialOptional&
    getEvaporationPotential ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEvaporationPotential (const EvaporationPotentialType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEvaporationPotential (const EvaporationPotentialOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEvaporationPotential (::std::auto_ptr< EvaporationPotentialType > p);

    //@}

    /**
     * @name storageSystem
     *
     * @brief Accessor and modifier functions for the %storageSystem
     * optional element.
     *
     * storage systems with storage nodes and links for setting up bucket
     * models
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StorageSystemComplexType StorageSystemType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StorageSystemType > StorageSystemOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageSystemType, char > StorageSystemTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StorageSystemOptional&
    getStorageSystem () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StorageSystemOptional&
    getStorageSystem ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageSystem (const StorageSystemType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStorageSystem (const StorageSystemOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStorageSystem (::std::auto_ptr< StorageSystemType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SubmodelComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SubmodelComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SubmodelComplexType (const SubmodelComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SubmodelComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SubmodelComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TypicalProfileOptional typicalProfile_;
    SnowRainJunctionOptional snowRainJunction_;
    EvaporationPotentialOptional evaporationPotential_;
    StorageSystemOptional storageSystem_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReleaseTotalComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReleaseTotalComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputReleaseTotalComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     *
     * total discharge [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReleaseTotalComplexType (const InputType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReleaseTotalComplexType (::std::auto_ptr< InputType >&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReleaseTotalComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReleaseTotalComplexType (const ReleaseTotalComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReleaseTotalComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReleaseTotalComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterReleaseTotalComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterReleaseTotalComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * required element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AREAType&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AREAType&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterReleaseTotalComplexType (const AREAType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterReleaseTotalComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterReleaseTotalComplexType (const ParameterReleaseTotalComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterReleaseTotalComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterReleaseTotalComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AREAType > AREA_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputReleaseTotalComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputReleaseTotalComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name discharge
     *
     * @brief Accessor and modifier functions for the %discharge
     * sequence element.
     *
     * discharges from different storage nodes [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DischargeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DischargeType > DischargeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DischargeSequence::iterator DischargeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DischargeSequence::const_iterator DischargeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeType, char > DischargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DischargeSequence&
    getDischarge () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DischargeSequence&
    getDischarge ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDischarge (const DischargeSequence& s);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const DischargeType&
    getDischargeDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputReleaseTotalComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputReleaseTotalComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputReleaseTotalComplexType (const InputReleaseTotalComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputReleaseTotalComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputReleaseTotalComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DischargeSequence discharge_;
    static const DischargeType discharge_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EvaporationPotentialComplexType schema type.
   *
   * @nosubgrouping
   */
  class EvaporationPotentialComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterEvaporationPotentialComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputEvaporationPotentialComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputEvaporationPotentialComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EvaporationPotentialComplexType (const ParameterType&,
                                     const InputType&,
                                     const OutputType&,
                                     const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    EvaporationPotentialComplexType (::std::auto_ptr< ParameterType >&,
                                     ::std::auto_ptr< InputType >&,
                                     ::std::auto_ptr< OutputType >&,
                                     const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EvaporationPotentialComplexType (const EvaporationPotentialComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EvaporationPotentialComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EvaporationPotentialComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterEvaporationPotentialComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterEvaporationPotentialComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ECORR
     *
     * @brief Accessor and modifier functions for the %ECORR
     * optional element.
     *
     * evaporation correction factor, default = 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ECORRType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ECORRType > ECORROptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ECORRType, char > ECORRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ECORROptional&
    getECORR () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ECORROptional&
    getECORR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setECORR (const ECORRType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setECORR (const ECORROptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setECORR (::std::auto_ptr< ECORRType > p);

    //@}

    /**
     * @name ETF
     *
     * @brief Accessor and modifier functions for the %ETF
     * required element.
     *
     * temperature correction factor
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ETFType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ETFType, char > ETFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ETFType&
    getETF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ETFType&
    getETF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setETF (const ETFType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setETF (::std::auto_ptr< ETFType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterEvaporationPotentialComplexType (const ETFType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterEvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterEvaporationPotentialComplexType (const ParameterEvaporationPotentialComplexType& x,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterEvaporationPotentialComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterEvaporationPotentialComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ECORROptional ECORR_;
    ::xsd::cxx::tree::one< ETFType > ETF_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputEvaporationPotentialComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputEvaporationPotentialComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name EPM
     *
     * @brief Accessor and modifier functions for the %EPM
     * required element.
     *
     * monthly mean value of potential evaporation [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPMType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPMType, char > EPMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPMType&
    getEPM () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPMType&
    getEPM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEPM (const EPMType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEPM (::std::auto_ptr< EPMType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const EPMType&
    getEPMDefaultValue ();

    //@}

    /**
     * @name TM
     *
     * @brief Accessor and modifier functions for the %TM
     * required element.
     *
     * monthly mean temperature [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TMType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TMType, char > TMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TMType&
    getTM () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TMType&
    getTM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTM (const TMType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTM (::std::auto_ptr< TMType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const TMType&
    getTMDefaultValue ();

    //@}

    /**
     * @name T
     *
     * @brief Accessor and modifier functions for the %T
     * required element.
     *
     * instantaneous temperature [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TType, char > TTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TType&
    getT () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TType&
    getT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setT (const TType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setT (::std::auto_ptr< TType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const TType&
    getTDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputEvaporationPotentialComplexType (const EPMType&,
                                          const TMType&,
                                          const TType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputEvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputEvaporationPotentialComplexType (const InputEvaporationPotentialComplexType& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputEvaporationPotentialComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputEvaporationPotentialComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EPMType > EPM_;
    static const EPMType EPM_default_value_;
    ::xsd::cxx::tree::one< TMType > TM_;
    static const TMType TM_default_value_;
    ::xsd::cxx::tree::one< TType > T_;
    static const TType T_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputEvaporationPotentialComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputEvaporationPotentialComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name EP
     *
     * @brief Accessor and modifier functions for the %EP
     * required element.
     *
     * instantaneous potential evaporation [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPType, char > EPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPType&
    getEP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPType&
    getEP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEP (const EPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEP (::std::auto_ptr< EPType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const EPType&
    getEPDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputEvaporationPotentialComplexType (const EPType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputEvaporationPotentialComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputEvaporationPotentialComplexType (const OutputEvaporationPotentialComplexType& x,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputEvaporationPotentialComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputEvaporationPotentialComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EPType > EP_;
    static const EPType EP_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TypicalProfileComplexType schema type.
   *
   * @nosubgrouping
   */
  class TypicalProfileComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name data
     *
     * @brief Accessor and modifier functions for the %data
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DataTypicalProfileComplexType DataType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DataType > DataSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DataSequence::iterator DataIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DataSequence::const_iterator DataConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DataType, char > DataTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DataSequence&
    getData () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DataSequence&
    getData ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setData (const DataSequence& s);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TypicalProfileComplexType (const OutputType&,
                               const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TypicalProfileComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TypicalProfileComplexType (const TypicalProfileComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TypicalProfileComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TypicalProfileComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DataSequence data_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DataTypicalProfileComplexType schema type.
   *
   * @nosubgrouping
   */
  class DataTypicalProfileComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name monthOfYear
     *
     * @brief Accessor and modifier functions for the %monthOfYear
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::MonthOfYear MonthOfYearType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MonthOfYearType, char > MonthOfYearTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MonthOfYearType&
    getMonthOfYear () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MonthOfYearType&
    getMonthOfYear ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMonthOfYear (const MonthOfYearType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMonthOfYear (::std::auto_ptr< MonthOfYearType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DataTypicalProfileComplexType (const MonthOfYearType&,
                                   const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DataTypicalProfileComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DataTypicalProfileComplexType (const DataTypicalProfileComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DataTypicalProfileComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DataTypicalProfileComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MonthOfYearType > monthOfYear_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SnowRainJunctionComplexType schema type.
   *
   * @nosubgrouping
   */
  class SnowRainJunctionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterSnowRainJunctionComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputSnowRainJunctionComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputSnowRainJunctionComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SnowRainJunctionComplexType (const ParameterType&,
                                 const InputType&,
                                 const OutputType&,
                                 const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SnowRainJunctionComplexType (::std::auto_ptr< ParameterType >&,
                                 ::std::auto_ptr< InputType >&,
                                 ::std::auto_ptr< OutputType >&,
                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SnowRainJunctionComplexType (const SnowRainJunctionComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SnowRainJunctionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SnowRainJunctionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterSnowRainJunctionComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterSnowRainJunctionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * optional element.
     *
     * smoothing parameter for switching between a linear ramp (D=0.0) and a
     * sigmoid function (D=1.0)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType DType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DType > DOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DOptional&
    getD () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DOptional&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setD (const DOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name RFCF
     *
     * @brief Accessor and modifier functions for the %RFCF
     * optional element.
     *
     * rainfall correction factor [-], default is 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType RFCFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RFCFType > RFCFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RFCFType, char > RFCFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RFCFOptional&
    getRFCF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RFCFOptional&
    getRFCF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRFCF (const RFCFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRFCF (const RFCFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRFCF (::std::auto_ptr< RFCFType > p);

    //@}

    /**
     * @name SFCF
     *
     * @brief Accessor and modifier functions for the %SFCF
     * optional element.
     *
     * snowfall correction factor [-], default is 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType SFCFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SFCFType > SFCFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SFCFType, char > SFCFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SFCFOptional&
    getSFCF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SFCFOptional&
    getSFCF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSFCF (const SFCFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSFCF (const SFCFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSFCF (::std::auto_ptr< SFCFType > p);

    //@}

    /**
     * @name TT
     *
     * @brief Accessor and modifier functions for the %TT
     * required element.
     *
     * temperature limit for snow and rainfall [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TTType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TTType, char > TTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TTType&
    getTT () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TTType&
    getTT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTT (const TTType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTT (::std::auto_ptr< TTType > p);

    //@}

    /**
     * @name TTI
     *
     * @brief Accessor and modifier functions for the %TTI
     * required element.
     *
     * temperature interval with a mixture of snow and rainfall [K]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TTIType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TTIType, char > TTITraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TTIType&
    getTTI () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TTIType&
    getTTI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTTI (const TTIType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTTI (::std::auto_ptr< TTIType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterSnowRainJunctionComplexType (const TTType&,
                                          const TTIType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterSnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterSnowRainJunctionComplexType (const ParameterSnowRainJunctionComplexType& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterSnowRainJunctionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterSnowRainJunctionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DOptional D_;
    RFCFOptional RFCF_;
    SFCFOptional SFCF_;
    ::xsd::cxx::tree::one< TTType > TT_;
    ::xsd::cxx::tree::one< TTIType > TTI_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputSnowRainJunctionComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputSnowRainJunctionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name P
     *
     * @brief Accessor and modifier functions for the %P
     * required element.
     *
     * precipitation [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PType&
    getP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PType&
    getP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setP (const PType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setP (::std::auto_ptr< PType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const PType&
    getPDefaultValue ();

    //@}

    /**
     * @name T
     *
     * @brief Accessor and modifier functions for the %T
     * required element.
     *
     * temperature [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TType, char > TTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TType&
    getT () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TType&
    getT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setT (const TType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setT (::std::auto_ptr< TType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const TType&
    getTDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputSnowRainJunctionComplexType (const PType&,
                                      const TType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputSnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputSnowRainJunctionComplexType (const InputSnowRainJunctionComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputSnowRainJunctionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputSnowRainJunctionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PType > P_;
    static const PType P_default_value_;
    ::xsd::cxx::tree::one< TType > T_;
    static const TType T_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputSnowRainJunctionComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputSnowRainJunctionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name RF
     *
     * @brief Accessor and modifier functions for the %RF
     * required element.
     *
     * rainfall [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RFType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RFType, char > RFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RFType&
    getRF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RFType&
    getRF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRF (const RFType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRF (::std::auto_ptr< RFType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const RFType&
    getRFDefaultValue ();

    //@}

    /**
     * @name SF
     *
     * @brief Accessor and modifier functions for the %SF
     * required element.
     *
     * snowfall [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SFType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SFType, char > SFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SFType&
    getSF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SFType&
    getSF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSF (const SFType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSF (::std::auto_ptr< SFType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const SFType&
    getSFDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputSnowRainJunctionComplexType (const RFType&,
                                       const SFType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputSnowRainJunctionComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputSnowRainJunctionComplexType (const OutputSnowRainJunctionComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputSnowRainJunctionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputSnowRainJunctionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RFType > RF_;
    static const RFType RF_default_value_;
    ::xsd::cxx::tree::one< SFType > SF_;
    static const SFType SF_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class StorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name settings
     *
     * @brief Accessor and modifier functions for the %settings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StorageSystemSettingsComplexType SettingsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SettingsType > SettingsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingsType, char > SettingsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SettingsOptional&
    getSettings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SettingsOptional&
    getSettings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettings (const SettingsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSettings (const SettingsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSettings (::std::auto_ptr< SettingsType > p);

    //@}

    /**
     * @name storageNode
     *
     * @brief Accessor and modifier functions for the %storageNode
     * sequence element.
     *
     * storage node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NodeStorageSystemComplexType StorageNodeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< StorageNodeType > StorageNodeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef StorageNodeSequence::iterator StorageNodeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef StorageNodeSequence::const_iterator StorageNodeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageNodeType, char > StorageNodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const StorageNodeSequence&
    getStorageNode () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    StorageNodeSequence&
    getStorageNode ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setStorageNode (const StorageNodeSequence& s);

    //@}

    /**
     * @name link
     *
     * @brief Accessor and modifier functions for the %link
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LinkStorageSystemComplexType LinkType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< LinkType > LinkSequence;

    /**
     * @brief Element iterator type.
     */
    typedef LinkSequence::iterator LinkIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef LinkSequence::const_iterator LinkConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LinkType, char > LinkTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const LinkSequence&
    getLink () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    LinkSequence&
    getLink ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setLink (const LinkSequence& s);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputStorageSystemComplexType OutputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OutputType > OutputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OutputOptional&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OutputOptional&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOutput (const OutputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StorageSystemComplexType (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StorageSystemComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StorageSystemComplexType (const StorageSystemComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SettingsOptional settings_;
    StorageNodeSequence storageNode_;
    LinkSequence link_;
    OutputOptional output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StorageSystemSettingsComplexType schema type.
   *
   * @nosubgrouping
   */
  class StorageSystemSettingsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name convergenceThreshold
     *
     * @brief Accessor and modifier functions for the %convergenceThreshold
     * required element.
     *
     * iteration stops after reaching this threshold
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ConvergenceThresholdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConvergenceThresholdType, char, ::xsd::cxx::tree::schema_type::double_ > ConvergenceThresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ConvergenceThresholdType&
    getConvergenceThreshold () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ConvergenceThresholdType&
    getConvergenceThreshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConvergenceThreshold (const ConvergenceThresholdType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ConvergenceThresholdType
    getConvergenceThresholdDefaultValue ();

    //@}

    /**
     * @name acceptableConvergenceThreshold
     *
     * @brief Accessor and modifier functions for the %acceptableConvergenceThreshold
     * optional element.
     *
     * optional threshold after reaching the maximum number of iterations,
     * writes a warning if reached, writes error otherwise
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double AcceptableConvergenceThresholdType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AcceptableConvergenceThresholdType > AcceptableConvergenceThresholdOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AcceptableConvergenceThresholdType, char, ::xsd::cxx::tree::schema_type::double_ > AcceptableConvergenceThresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AcceptableConvergenceThresholdOptional&
    getAcceptableConvergenceThreshold () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AcceptableConvergenceThresholdOptional&
    getAcceptableConvergenceThreshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAcceptableConvergenceThreshold (const AcceptableConvergenceThresholdType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAcceptableConvergenceThreshold (const AcceptableConvergenceThresholdOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static AcceptableConvergenceThresholdType
    getAcceptableConvergenceThresholdDefaultValue ();

    //@}

    /**
     * @name treatNonConvergenceAsError
     *
     * @brief Accessor and modifier functions for the %treatNonConvergenceAsError
     * required element.
     *
     * treat non-convergence related to the thresholds as error or not
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean TreatNonConvergenceAsErrorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatNonConvergenceAsErrorType, char > TreatNonConvergenceAsErrorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreatNonConvergenceAsErrorType&
    getTreatNonConvergenceAsError () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreatNonConvergenceAsErrorType&
    getTreatNonConvergenceAsError ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatNonConvergenceAsError (const TreatNonConvergenceAsErrorType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static TreatNonConvergenceAsErrorType
    getTreatNonConvergenceAsErrorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StorageSystemSettingsComplexType (const ConvergenceThresholdType&,
                                      const TreatNonConvergenceAsErrorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StorageSystemSettingsComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StorageSystemSettingsComplexType (const StorageSystemSettingsComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StorageSystemSettingsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StorageSystemSettingsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConvergenceThresholdType > convergenceThreshold_;
    AcceptableConvergenceThresholdOptional acceptableConvergenceThreshold_;
    ::xsd::cxx::tree::one< TreatNonConvergenceAsErrorType > treatNonConvergenceAsError_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nJac
     *
     * @brief Accessor and modifier functions for the %nJac
     * required element.
     *
     * number of evaluations of the Jacobian
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NJacType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NJacType, char > NJacTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NJacType&
    getNJac () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NJacType&
    getNJac ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNJac (const NJacType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNJac (::std::auto_ptr< NJacType > p);

    //@}

    /**
     * @name nFun
     *
     * @brief Accessor and modifier functions for the %nFun
     * required element.
     *
     * number of function evaluations
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NFunType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NFunType, char > NFunTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NFunType&
    getNFun () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NFunType&
    getNFun ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNFun (const NFunType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNFun (::std::auto_ptr< NFunType > p);

    //@}

    /**
     * @name res
     *
     * @brief Accessor and modifier functions for the %res
     * required element.
     *
     * residuum at last iteration step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ResType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResType, char > ResTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ResType&
    getRes () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ResType&
    getRes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRes (const ResType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRes (::std::auto_ptr< ResType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputStorageSystemComplexType (const NJacType&,
                                    const NFunType&,
                                    const ResType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputStorageSystemComplexType (const OutputStorageSystemComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NJacType > nJac_;
    ::xsd::cxx::tree::one< NFunType > nFun_;
    ::xsd::cxx::tree::one< ResType > res_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NodeStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class NodeStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * constant area [km2], default is 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name stateMin
     *
     * @brief Accessor and modifier functions for the %stateMin
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType StateMinType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateMinType > StateMinOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateMinType, char > StateMinTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateMinOptional&
    getStateMin () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateMinOptional&
    getStateMin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateMin (const StateMinType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStateMin (const StateMinOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateMin (::std::auto_ptr< StateMinType > p);

    //@}

    /**
     * @name stateMax
     *
     * @brief Accessor and modifier functions for the %stateMax
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType StateMaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateMaxType > StateMaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateMaxType, char > StateMaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateMaxOptional&
    getStateMax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateMaxOptional&
    getStateMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateMax (const StateMaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStateMax (const StateMaxOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateMax (::std::auto_ptr< StateMaxType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputNodeStorageSystemComplexType InputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InputType > InputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InputOptional&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InputOptional&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInput (const InputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name state
     *
     * @brief Accessor and modifier functions for the %state
     * required element.
     *
     * unit volume [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StateType&
    getState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StateType&
    getState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setState (::std::auto_ptr< StateType > p);

    //@}

    /**
     * @name residuum
     *
     * @brief Accessor and modifier functions for the %residuum
     * required element.
     *
     * residuum [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ResiduumType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResiduumType, char > ResiduumTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ResiduumType&
    getResiduum () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ResiduumType&
    getResiduum ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setResiduum (const ResiduumType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setResiduum (::std::auto_ptr< ResiduumType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NodeStorageSystemComplexType (const StateType&,
                                  const ResiduumType&,
                                  const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NodeStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NodeStorageSystemComplexType (const NodeStorageSystemComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NodeStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NodeStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    StateMinOptional stateMin_;
    StateMaxOptional stateMax_;
    InputOptional input_;
    ::xsd::cxx::tree::one< StateType > state_;
    ::xsd::cxx::tree::one< ResiduumType > residuum_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputNodeStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputNodeStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name discharge
     *
     * @brief Accessor and modifier functions for the %discharge
     * sequence element.
     *
     * inflow as discharge [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DischargeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DischargeType > DischargeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DischargeSequence::iterator DischargeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DischargeSequence::const_iterator DischargeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeType, char > DischargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DischargeSequence&
    getDischarge () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DischargeSequence&
    getDischarge ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDischarge (const DischargeSequence& s);

    //@}

    /**
     * @name unitVolume
     *
     * @brief Accessor and modifier functions for the %unitVolume
     * sequence element.
     *
     * inflow as unit Volume [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UnitVolumeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< UnitVolumeType > UnitVolumeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef UnitVolumeSequence::iterator UnitVolumeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef UnitVolumeSequence::const_iterator UnitVolumeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitVolumeType, char > UnitVolumeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const UnitVolumeSequence&
    getUnitVolume () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    UnitVolumeSequence&
    getUnitVolume ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setUnitVolume (const UnitVolumeSequence& s);

    //@}

    /**
     * @name state
     *
     * @brief Accessor and modifier functions for the %state
     * optional element.
     *
     * unit volume [mm], replaces the computes state
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateType > StateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateOptional&
    getState () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateOptional&
    getState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setState (const StateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setState (::std::auto_ptr< StateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputNodeStorageSystemComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputNodeStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputNodeStorageSystemComplexType (const InputNodeStorageSystemComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputNodeStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputNodeStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DischargeSequence discharge_;
    UnitVolumeSequence unitVolume_;
    StateOptional state_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LinkStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class LinkStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name capillaryFlow
     *
     * @brief Accessor and modifier functions for the %capillaryFlow
     * optional element.
     *
     * capillary flow, typically from GW (saturated upper zone - ground
     * water) to UZ (unsaturated zone)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CapillaryFlowStorageSystemComplexType CapillaryFlowType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapillaryFlowType > CapillaryFlowOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapillaryFlowType, char > CapillaryFlowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapillaryFlowOptional&
    getCapillaryFlow () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapillaryFlowOptional&
    getCapillaryFlow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapillaryFlow (const CapillaryFlowType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapillaryFlow (const CapillaryFlowOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapillaryFlow (::std::auto_ptr< CapillaryFlowType > p);

    //@}

    /**
     * @name evaporationActual
     *
     * @brief Accessor and modifier functions for the %evaporationActual
     * optional element.
     *
     * actual evaporation from unsaturated zone storage node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EvaporationActualStorageSystemComplexType EvaporationActualType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EvaporationActualType > EvaporationActualOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EvaporationActualType, char > EvaporationActualTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EvaporationActualOptional&
    getEvaporationActual () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EvaporationActualOptional&
    getEvaporationActual ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEvaporationActual (const EvaporationActualType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEvaporationActual (const EvaporationActualOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEvaporationActual (::std::auto_ptr< EvaporationActualType > p);

    //@}

    /**
     * @name evaporationInterception
     *
     * @brief Accessor and modifier functions for the %evaporationInterception
     * optional element.
     *
     * evaporation from interception storage node, typically VEG/P/UP
     * (vegeration/paved interception)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EvaporationInterceptionStorageSystemComplexType EvaporationInterceptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EvaporationInterceptionType > EvaporationInterceptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EvaporationInterceptionType, char > EvaporationInterceptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EvaporationInterceptionOptional&
    getEvaporationInterception () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EvaporationInterceptionOptional&
    getEvaporationInterception ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEvaporationInterception (const EvaporationInterceptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEvaporationInterception (const EvaporationInterceptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEvaporationInterception (::std::auto_ptr< EvaporationInterceptionType > p);

    //@}

    /**
     * @name groundwaterFlow
     *
     * @brief Accessor and modifier functions for the %groundwaterFlow
     * optional element.
     *
     * GW Groundwater interaction with SW Surface water
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GroundwaterFlowStorageSystemComplexType GroundwaterFlowType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GroundwaterFlowType > GroundwaterFlowOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GroundwaterFlowType, char > GroundwaterFlowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GroundwaterFlowOptional&
    getGroundwaterFlow () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GroundwaterFlowOptional&
    getGroundwaterFlow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGroundwaterFlow (const GroundwaterFlowType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGroundwaterFlow (const GroundwaterFlowOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGroundwaterFlow (::std::auto_ptr< GroundwaterFlowType > p);

    //@}

    /**
     * @name percolation
     *
     * @brief Accessor and modifier functions for the %percolation
     * optional element.
     *
     * percolation, typically from GW upper zone to GW lower zone), or from
     * UP unpaved surface to UZ unsaturated zone
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PercolationStorageSystemComplexType PercolationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PercolationType > PercolationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PercolationType, char > PercolationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PercolationOptional&
    getPercolation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PercolationOptional&
    getPercolation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPercolation (const PercolationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPercolation (const PercolationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPercolation (::std::auto_ptr< PercolationType > p);

    //@}

    /**
     * @name releaseInterception
     *
     * @brief Accessor and modifier functions for the %releaseInterception
     * optional element.
     *
     * release above threshold from interception storage node, typically
     * VEG/P/UP (uses relese above threshold link)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReleaseAboveThresholdStorageSystemComplexType ReleaseInterceptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReleaseInterceptionType > ReleaseInterceptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseInterceptionType, char > ReleaseInterceptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReleaseInterceptionOptional&
    getReleaseInterception () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReleaseInterceptionOptional&
    getReleaseInterception ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReleaseInterception (const ReleaseInterceptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReleaseInterception (const ReleaseInterceptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReleaseInterception (::std::auto_ptr< ReleaseInterceptionType > p);

    //@}

    /**
     * @name response
     *
     * @brief Accessor and modifier functions for the %response
     * optional element.
     *
     * response from storage node, typically GW upper and GW lower zone
     * storage nodes
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ResponseStorageSystemComplexType ResponseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ResponseType > ResponseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResponseType, char > ResponseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ResponseOptional&
    getResponse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ResponseOptional&
    getResponse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setResponse (const ResponseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setResponse (const ResponseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setResponse (::std::auto_ptr< ResponseType > p);

    //@}

    /**
     * @name sewerOverflow
     *
     * @brief Accessor and modifier functions for the %sewerOverflow
     * optional element.
     *
     * sewer overflow (uses relese above threshold link)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReleaseAboveThresholdStorageSystemComplexType SewerOverflowType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SewerOverflowType > SewerOverflowOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SewerOverflowType, char > SewerOverflowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SewerOverflowOptional&
    getSewerOverflow () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SewerOverflowOptional&
    getSewerOverflow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSewerOverflow (const SewerOverflowType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSewerOverflow (const SewerOverflowOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSewerOverflow (::std::auto_ptr< SewerOverflowType > p);

    //@}

    /**
     * @name soilRunoff
     *
     * @brief Accessor and modifier functions for the %soilRunoff
     * optional element.
     *
     * soil runoff from UZ unsaturated zone to GW upper zone storage node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SoilRunoffStorageSystemComplexType SoilRunoffType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SoilRunoffType > SoilRunoffOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SoilRunoffType, char > SoilRunoffTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SoilRunoffOptional&
    getSoilRunoff () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SoilRunoffOptional&
    getSoilRunoff ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSoilRunoff (const SoilRunoffType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSoilRunoff (const SoilRunoffOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSoilRunoff (::std::auto_ptr< SoilRunoffType > p);

    //@}

    /**
     * @name wasteWaterTreatmentPlant
     *
     * @brief Accessor and modifier functions for the %wasteWaterTreatmentPlant
     * optional element.
     *
     * water treated via the WWTP, flows at a max rate of a constant max pump
     * capacity. Uses water distribution constant link
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::WaterDistributionConstantStorageSystemComplexType WasteWaterTreatmentPlantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WasteWaterTreatmentPlantType > WasteWaterTreatmentPlantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WasteWaterTreatmentPlantType, char > WasteWaterTreatmentPlantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WasteWaterTreatmentPlantOptional&
    getWasteWaterTreatmentPlant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WasteWaterTreatmentPlantOptional&
    getWasteWaterTreatmentPlant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWasteWaterTreatmentPlant (const WasteWaterTreatmentPlantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWasteWaterTreatmentPlant (const WasteWaterTreatmentPlantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWasteWaterTreatmentPlant (::std::auto_ptr< WasteWaterTreatmentPlantType > p);

    //@}

    /**
     * @name waterDistributionConstant
     *
     * @brief Accessor and modifier functions for the %waterDistributionConstant
     * optional element.
     *
     * water abstraction/distribution/consumption referenced to a constant
     * demand (e.i. maxpump capacity). Uses water distribution constant link
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::WaterDistributionConstantStorageSystemComplexType WaterDistributionConstantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WaterDistributionConstantType > WaterDistributionConstantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WaterDistributionConstantType, char > WaterDistributionConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WaterDistributionConstantOptional&
    getWaterDistributionConstant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WaterDistributionConstantOptional&
    getWaterDistributionConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWaterDistributionConstant (const WaterDistributionConstantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWaterDistributionConstant (const WaterDistributionConstantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWaterDistributionConstant (::std::auto_ptr< WaterDistributionConstantType > p);

    //@}

    /**
     * @name waterDistributionVariable
     *
     * @brief Accessor and modifier functions for the %waterDistributionVariable
     * optional element.
     *
     * water abstraction/distribution/consumption referenced to a variable
     * demand (e.i. domestic or industrial water demands). Uses water
     * distribution variable link)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::WaterDistributionVariableStorageSystemComplexType WaterDistributionVariableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WaterDistributionVariableType > WaterDistributionVariableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WaterDistributionVariableType, char > WaterDistributionVariableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WaterDistributionVariableOptional&
    getWaterDistributionVariable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WaterDistributionVariableOptional&
    getWaterDistributionVariable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWaterDistributionVariable (const WaterDistributionVariableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWaterDistributionVariable (const WaterDistributionVariableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWaterDistributionVariable (::std::auto_ptr< WaterDistributionVariableType > p);

    //@}

    /**
     * @name meltRefreezing
     *
     * @brief Accessor and modifier functions for the %meltRefreezing
     * optional element.
     *
     * NOT REFACTORED. melting and refreezing, typically used between SP
     * (snow pack) and WC (water content) nodes
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MeltRefreezingStorageSystemComplexType MeltRefreezingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MeltRefreezingType > MeltRefreezingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeltRefreezingType, char > MeltRefreezingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MeltRefreezingOptional&
    getMeltRefreezing () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MeltRefreezingOptional&
    getMeltRefreezing ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMeltRefreezing (const MeltRefreezingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMeltRefreezing (const MeltRefreezingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMeltRefreezing (::std::auto_ptr< MeltRefreezingType > p);

    //@}

    /**
     * @name releaseWaterContent
     *
     * @brief Accessor and modifier functions for the %releaseWaterContent
     * optional element.
     *
     * NOT REFACTORED. release from water content storage node (typically WC)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReleaseWaterContentStorageSystemComplexType ReleaseWaterContentType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReleaseWaterContentType > ReleaseWaterContentOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseWaterContentType, char > ReleaseWaterContentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReleaseWaterContentOptional&
    getReleaseWaterContent () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReleaseWaterContentOptional&
    getReleaseWaterContent ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReleaseWaterContent (const ReleaseWaterContentType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReleaseWaterContent (const ReleaseWaterContentOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReleaseWaterContent (::std::auto_ptr< ReleaseWaterContentType > p);

    //@}

    /**
     * @name irrigation
     *
     * @brief Accessor and modifier functions for the %irrigation
     * optional element.
     *
     * NOT REFACTORED. water consumption by domestic irrigation due to dry
     * soil
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IrrigationStorageSystemComplexType IrrigationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IrrigationType > IrrigationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IrrigationType, char > IrrigationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IrrigationOptional&
    getIrrigation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IrrigationOptional&
    getIrrigation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIrrigation (const IrrigationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIrrigation (const IrrigationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIrrigation (::std::auto_ptr< IrrigationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LinkStorageSystemComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LinkStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LinkStorageSystemComplexType (const LinkStorageSystemComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LinkStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LinkStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapillaryFlowOptional capillaryFlow_;
    EvaporationActualOptional evaporationActual_;
    EvaporationInterceptionOptional evaporationInterception_;
    GroundwaterFlowOptional groundwaterFlow_;
    PercolationOptional percolation_;
    ReleaseInterceptionOptional releaseInterception_;
    ResponseOptional response_;
    SewerOverflowOptional sewerOverflow_;
    SoilRunoffOptional soilRunoff_;
    WasteWaterTreatmentPlantOptional wasteWaterTreatmentPlant_;
    WaterDistributionConstantOptional waterDistributionConstant_;
    WaterDistributionVariableOptional waterDistributionVariable_;
    MeltRefreezingOptional meltRefreezing_;
    ReleaseWaterContentOptional releaseWaterContent_;
    IrrigationOptional irrigation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputLinkStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputLinkStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name H
     *
     * @brief Accessor and modifier functions for the %H
     * required element.
     *
     * Discharge as unit volume [mm/timestep]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HType, char > HTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HType&
    getH () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HType&
    getH ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setH (const HType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setH (::std::auto_ptr< HType > p);

    //@}

    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     *
     * Discharge [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputLinkStorageSystemComplexType (const HType&,
                                        const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputLinkStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputLinkStorageSystemComplexType (const OutputLinkStorageSystemComplexType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputLinkStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputLinkStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HType > H_;
    ::xsd::cxx::tree::one< QType > Q_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %meltRefreezingStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class MeltRefreezingStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterMeltRefreezingStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name nodeU
     *
     * @brief Accessor and modifier functions for the %nodeU
     * required element.
     *
     * upstream node, typically SP (snow pack)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeUType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeUType, char > NodeUTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeUType&
    getNodeU () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeUType&
    getNodeU ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeU (const NodeUType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeU (::std::auto_ptr< NodeUType > p);

    //@}

    /**
     * @name nodeD
     *
     * @brief Accessor and modifier functions for the %nodeD
     * required element.
     *
     * downstream node, typically WC (water content)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeDType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeDType, char > NodeDTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeDType&
    getNodeD () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeDType&
    getNodeD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeD (const NodeDType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeD (::std::auto_ptr< NodeDType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     *
     * instanteneous temperature [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MeltRefreezingStorageSystemComplexType (const ParameterType&,
                                            const NodeUType&,
                                            const NodeDType&,
                                            const InputType&,
                                            const OutputType&,
                                            const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    MeltRefreezingStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                            const NodeUType&,
                                            const NodeDType&,
                                            const InputType&,
                                            ::std::auto_ptr< OutputType >&,
                                            const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MeltRefreezingStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MeltRefreezingStorageSystemComplexType (const MeltRefreezingStorageSystemComplexType& x,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MeltRefreezingStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MeltRefreezingStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< NodeUType > nodeU_;
    ::xsd::cxx::tree::one< NodeDType > nodeD_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterMeltRefreezingStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterMeltRefreezingStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name CFMAX
     *
     * @brief Accessor and modifier functions for the %CFMAX
     * required element.
     *
     * degree day factor [mm/day]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CFMAXType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFMAXType, char > CFMAXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFMAXType&
    getCFMAX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFMAXType&
    getCFMAX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFMAX (const CFMAXType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFMAX (::std::auto_ptr< CFMAXType > p);

    //@}

    /**
     * @name CFR
     *
     * @brief Accessor and modifier functions for the %CFR
     * required element.
     *
     * refreezing factor [-]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CFRType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFRType, char > CFRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFRType&
    getCFR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFRType&
    getCFR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFR (const CFRType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFR (::std::auto_ptr< CFRType > p);

    //@}

    /**
     * @name M
     *
     * @brief Accessor and modifier functions for the %M
     * optional element.
     *
     * smoothing factor, default = 0.05, more smoothing for higher value and
     * vice versa
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MType > MOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MType, char > MTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MOptional&
    getM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MOptional&
    getM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setM (const MType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setM (const MOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setM (::std::auto_ptr< MType > p);

    //@}

    /**
     * @name TTM
     *
     * @brief Accessor and modifier functions for the %TTM
     * required element.
     *
     * temperature limit for melting [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TTMType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TTMType, char > TTMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TTMType&
    getTTM () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TTMType&
    getTTM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTTM (const TTMType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTTM (::std::auto_ptr< TTMType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterMeltRefreezingStorageSystemComplexType (const CFMAXType&,
                                                     const CFRType&,
                                                     const TTMType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterMeltRefreezingStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f = 0,
                                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterMeltRefreezingStorageSystemComplexType (const ParameterMeltRefreezingStorageSystemComplexType& x,
                                                     ::xml_schema::Flags f = 0,
                                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterMeltRefreezingStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterMeltRefreezingStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< CFMAXType > CFMAX_;
    ::xsd::cxx::tree::one< CFRType > CFR_;
    MOptional M_;
    ::xsd::cxx::tree::one< TTMType > TTM_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %releaseWaterContentStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReleaseWaterContentStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterReleaseWaterContentStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name nodeU
     *
     * @brief Accessor and modifier functions for the %nodeU
     * required element.
     *
     * upstream node, typically WC (water content)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeUType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeUType, char > NodeUTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeUType&
    getNodeU () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeUType&
    getNodeU ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeU (const NodeUType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeU (::std::auto_ptr< NodeUType > p);

    //@}

    /**
     * @name nodeA
     *
     * @brief Accessor and modifier functions for the %nodeA
     * required element.
     *
     * auxiliary node with snow pack, typically SP (snow pack)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeAType, char > NodeATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeAType&
    getNodeA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeAType&
    getNodeA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeA (const NodeAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeA (::std::auto_ptr< NodeAType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReleaseWaterContentStorageSystemComplexType (const ParameterType&,
                                                 const NodeUType&,
                                                 const NodeAType&,
                                                 const OutputType&,
                                                 const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReleaseWaterContentStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                                 const NodeUType&,
                                                 const NodeAType&,
                                                 ::std::auto_ptr< OutputType >&,
                                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReleaseWaterContentStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReleaseWaterContentStorageSystemComplexType (const ReleaseWaterContentStorageSystemComplexType& x,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReleaseWaterContentStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReleaseWaterContentStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< NodeUType > nodeU_;
    ::xsd::cxx::tree::one< NodeAType > nodeA_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterReleaseWaterContentStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterReleaseWaterContentStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name WHC
     *
     * @brief Accessor and modifier functions for the %WHC
     * required element.
     *
     * water holding capacity [-]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType WHCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WHCType, char > WHCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WHCType&
    getWHC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WHCType&
    getWHC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWHC (const WHCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWHC (::std::auto_ptr< WHCType > p);

    //@}

    /**
     * @name M
     *
     * @brief Accessor and modifier functions for the %M
     * optional element.
     *
     * smoothing coefficient
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MType > MOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MType, char > MTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MOptional&
    getM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MOptional&
    getM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setM (const MType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setM (const MOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setM (::std::auto_ptr< MType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterReleaseWaterContentStorageSystemComplexType (const WHCType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterReleaseWaterContentStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::Flags f = 0,
                                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterReleaseWaterContentStorageSystemComplexType (const ParameterReleaseWaterContentStorageSystemComplexType& x,
                                                          ::xml_schema::Flags f = 0,
                                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterReleaseWaterContentStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterReleaseWaterContentStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< WHCType > WHC_;
    MOptional M_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %evaporationInterceptionStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class EvaporationInterceptionStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterEvaporationInterceptionStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputEvaporationInterceptionStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EvaporationInterceptionStorageSystemComplexType (const ParameterType&,
                                                     const InputType&,
                                                     const OutputType&,
                                                     const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    EvaporationInterceptionStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                                     ::std::auto_ptr< InputType >&,
                                                     ::std::auto_ptr< OutputType >&,
                                                     const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EvaporationInterceptionStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f = 0,
                                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EvaporationInterceptionStorageSystemComplexType (const EvaporationInterceptionStorageSystemComplexType& x,
                                                     ::xml_schema::Flags f = 0,
                                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EvaporationInterceptionStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EvaporationInterceptionStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputEvaporationInterceptionStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputEvaporationInterceptionStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, typically IC (interception)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name EP
     *
     * @brief Accessor and modifier functions for the %EP
     * required element.
     *
     * potential evaporation [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPType, char > EPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPType&
    getEP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPType&
    getEP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEP (const EPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEP (::std::auto_ptr< EPType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputEvaporationInterceptionStorageSystemComplexType (const HUpType&,
                                                          const EPType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputEvaporationInterceptionStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::Flags f = 0,
                                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputEvaporationInterceptionStorageSystemComplexType (const InputEvaporationInterceptionStorageSystemComplexType& x,
                                                          ::xml_schema::Flags f = 0,
                                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputEvaporationInterceptionStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputEvaporationInterceptionStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    ::xsd::cxx::tree::one< EPType > EP_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterEvaporationInterceptionStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterEvaporationInterceptionStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterEvaporationInterceptionStorageSystemComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterEvaporationInterceptionStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                              ::xml_schema::Flags f = 0,
                                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterEvaporationInterceptionStorageSystemComplexType (const ParameterEvaporationInterceptionStorageSystemComplexType& x,
                                                              ::xml_schema::Flags f = 0,
                                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterEvaporationInterceptionStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterEvaporationInterceptionStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %releaseAboveThresholdStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReleaseAboveThresholdStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterReleaseAboveThresholdStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputReleaseAboveThresholdStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReleaseAboveThresholdStorageSystemComplexType (const ParameterType&,
                                                   const InputType&,
                                                   const OutputType&,
                                                   const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReleaseAboveThresholdStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                                   ::std::auto_ptr< InputType >&,
                                                   ::std::auto_ptr< OutputType >&,
                                                   const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReleaseAboveThresholdStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::Flags f = 0,
                                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReleaseAboveThresholdStorageSystemComplexType (const ReleaseAboveThresholdStorageSystemComplexType& x,
                                                   ::xml_schema::Flags f = 0,
                                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReleaseAboveThresholdStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReleaseAboveThresholdStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterReleaseAboveThresholdStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterReleaseAboveThresholdStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2], default = 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name FRAC
     *
     * @brief Accessor and modifier functions for the %FRAC
     * optional element.
     *
     * percentage of the flow which flows towards the bucket of interest. The
     * permitted range is between 0 and 100
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType FRACType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FRACType > FRACOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FRACType, char > FRACTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FRACOptional&
    getFRAC () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FRACOptional&
    getFRAC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFRAC (const FRACType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFRAC (const FRACOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFRAC (::std::auto_ptr< FRACType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const FRACType&
    getFRACDefaultValue ();

    //@}

    /**
     * @name LIC
     *
     * @brief Accessor and modifier functions for the %LIC
     * required element.
     *
     * upper limit of (interception) storage node [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LICType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LICType, char > LICTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LICType&
    getLIC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LICType&
    getLIC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLIC (const LICType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLIC (::std::auto_ptr< LICType > p);

    //@}

    /**
     * @name M
     *
     * @brief Accessor and modifier functions for the %M
     * optional element.
     *
     * smoothing factor
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MType > MOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MType, char > MTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MOptional&
    getM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MOptional&
    getM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setM (const MType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setM (const MOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setM (::std::auto_ptr< MType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterReleaseAboveThresholdStorageSystemComplexType (const LICType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterReleaseAboveThresholdStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::Flags f = 0,
                                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterReleaseAboveThresholdStorageSystemComplexType (const ParameterReleaseAboveThresholdStorageSystemComplexType& x,
                                                            ::xml_schema::Flags f = 0,
                                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterReleaseAboveThresholdStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterReleaseAboveThresholdStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    FRACOptional FRAC_;
    static const FRACType FRAC_default_value_;
    ::xsd::cxx::tree::one< LICType > LIC_;
    MOptional M_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputReleaseAboveThresholdStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputReleaseAboveThresholdStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * optional element.
     *
     * downstream node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HDownType > HDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HDownOptional&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HDownOptional&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHDown (const HDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputReleaseAboveThresholdStorageSystemComplexType (const HUpType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputReleaseAboveThresholdStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::Flags f = 0,
                                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputReleaseAboveThresholdStorageSystemComplexType (const InputReleaseAboveThresholdStorageSystemComplexType& x,
                                                        ::xml_schema::Flags f = 0,
                                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputReleaseAboveThresholdStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputReleaseAboveThresholdStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    HDownOptional HDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %irrigationStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class IrrigationStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterIrrigationStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name nodeU
     *
     * @brief Accessor and modifier functions for the %nodeU
     * required element.
     *
     * upstream node, source of water usually the drinking water treatment
     * plant
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeUType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeUType, char > NodeUTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeUType&
    getNodeU () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeUType&
    getNodeU ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeU (const NodeUType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeU (::std::auto_ptr< NodeUType > p);

    //@}

    /**
     * @name nodeD
     *
     * @brief Accessor and modifier functions for the %nodeD
     * required element.
     *
     * downstream node which recieves the irrigation water
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeDType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeDType, char > NodeDTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeDType&
    getNodeD () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeDType&
    getNodeD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeD (const NodeDType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeD (::std::auto_ptr< NodeDType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IrrigationStorageSystemComplexType (const ParameterType&,
                                        const NodeUType&,
                                        const NodeDType&,
                                        const OutputType&,
                                        const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    IrrigationStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                        const NodeUType&,
                                        const NodeDType&,
                                        ::std::auto_ptr< OutputType >&,
                                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IrrigationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IrrigationStorageSystemComplexType (const IrrigationStorageSystemComplexType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IrrigationStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IrrigationStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< NodeUType > nodeU_;
    ::xsd::cxx::tree::one< NodeDType > nodeD_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterIrrigationStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterIrrigationStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2], default = 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name IRR_CONST
     *
     * @brief Accessor and modifier functions for the %IRR_CONST
     * optional element.
     *
     * costant irrigation flux [mm/d]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType IRR_CONSTType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IRR_CONSTType > IRR_CONSTOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IRR_CONSTType, char > IRR_CONSTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IRR_CONSTOptional&
    getIRR_CONST () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IRR_CONSTOptional&
    getIRR_CONST ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIRR_CONST (const IRR_CONSTType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIRR_CONST (const IRR_CONSTOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIRR_CONST (::std::auto_ptr< IRR_CONSTType > p);

    //@}

    /**
     * @name IRR_THR
     *
     * @brief Accessor and modifier functions for the %IRR_THR
     * required element.
     *
     * Threshold of the downstream node under which irrigation is needed [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType IRR_THRType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IRR_THRType, char > IRR_THRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const IRR_THRType&
    getIRR_THR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    IRR_THRType&
    getIRR_THR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIRR_THR (const IRR_THRType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setIRR_THR (::std::auto_ptr< IRR_THRType > p);

    //@}

    /**
     * @name M
     *
     * @brief Accessor and modifier functions for the %M
     * optional element.
     *
     * smoothing factor
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MType > MOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MType, char > MTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MOptional&
    getM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MOptional&
    getM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setM (const MType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setM (const MOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setM (::std::auto_ptr< MType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterIrrigationStorageSystemComplexType (const IRR_THRType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterIrrigationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterIrrigationStorageSystemComplexType (const ParameterIrrigationStorageSystemComplexType& x,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterIrrigationStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterIrrigationStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    IRR_CONSTOptional IRR_CONST_;
    ::xsd::cxx::tree::one< IRR_THRType > IRR_THR_;
    MOptional M_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %waterDistributionConstantStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class WaterDistributionConstantStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterWaterDistributionConstantStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputWaterDistributionConstantStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    WaterDistributionConstantStorageSystemComplexType (const ParameterType&,
                                                       const InputType&,
                                                       const OutputType&,
                                                       const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    WaterDistributionConstantStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                                       ::std::auto_ptr< InputType >&,
                                                       ::std::auto_ptr< OutputType >&,
                                                       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    WaterDistributionConstantStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::Flags f = 0,
                                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WaterDistributionConstantStorageSystemComplexType (const WaterDistributionConstantStorageSystemComplexType& x,
                                                       ::xml_schema::Flags f = 0,
                                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual WaterDistributionConstantStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~WaterDistributionConstantStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterWaterDistributionConstantStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterWaterDistributionConstantStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2], default = 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * required element.
     *
     * capacity of demand/abstraction [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType DType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DType&
    getD () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DType&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name MIN_UP
     *
     * @brief Accessor and modifier functions for the %MIN_UP
     * optional element.
     *
     * minimum abstraction level upstream [mm]. Default 0, till empty.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MIN_UPType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MIN_UPType > MIN_UPOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MIN_UPType, char > MIN_UPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MIN_UPOptional&
    getMIN_UP () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MIN_UPOptional&
    getMIN_UP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMIN_UP (const MIN_UPType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMIN_UP (const MIN_UPOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMIN_UP (::std::auto_ptr< MIN_UPType > p);

    //@}

    /**
     * @name M
     *
     * @brief Accessor and modifier functions for the %M
     * optional element.
     *
     * smoothing factor
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MType > MOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MType, char > MTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MOptional&
    getM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MOptional&
    getM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setM (const MType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setM (const MOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setM (::std::auto_ptr< MType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterWaterDistributionConstantStorageSystemComplexType (const DType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterWaterDistributionConstantStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::Flags f = 0,
                                                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterWaterDistributionConstantStorageSystemComplexType (const ParameterWaterDistributionConstantStorageSystemComplexType& x,
                                                                ::xml_schema::Flags f = 0,
                                                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterWaterDistributionConstantStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterWaterDistributionConstantStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< DType > D_;
    MIN_UPOptional MIN_UP_;
    MOptional M_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputWaterDistributionConstantStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputWaterDistributionConstantStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, source of water abstraction/distribution (i.e. surface
     * water/groundwater/sewerage)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * optional element.
     *
     * downstream node collector of abstracted water. For instance drinking
     * water treatment plant
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HDownType > HDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HDownOptional&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HDownOptional&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHDown (const HDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputWaterDistributionConstantStorageSystemComplexType (const HUpType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputWaterDistributionConstantStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::Flags f = 0,
                                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputWaterDistributionConstantStorageSystemComplexType (const InputWaterDistributionConstantStorageSystemComplexType& x,
                                                            ::xml_schema::Flags f = 0,
                                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputWaterDistributionConstantStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputWaterDistributionConstantStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    HDownOptional HDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %waterDistributionVariableStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class WaterDistributionVariableStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterWaterDistributionVariableStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputWaterDistributionVariableStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    WaterDistributionVariableStorageSystemComplexType (const ParameterType&,
                                                       const InputType&,
                                                       const OutputType&,
                                                       const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    WaterDistributionVariableStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                                       ::std::auto_ptr< InputType >&,
                                                       ::std::auto_ptr< OutputType >&,
                                                       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    WaterDistributionVariableStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::Flags f = 0,
                                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WaterDistributionVariableStorageSystemComplexType (const WaterDistributionVariableStorageSystemComplexType& x,
                                                       ::xml_schema::Flags f = 0,
                                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual WaterDistributionVariableStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~WaterDistributionVariableStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterWaterDistributionVariableStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterWaterDistributionVariableStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2], default = 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name MIN_UP
     *
     * @brief Accessor and modifier functions for the %MIN_UP
     * optional element.
     *
     * minimum abstraction level upstream [mm]. Default 0, till empty.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MIN_UPType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MIN_UPType > MIN_UPOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MIN_UPType, char > MIN_UPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MIN_UPOptional&
    getMIN_UP () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MIN_UPOptional&
    getMIN_UP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMIN_UP (const MIN_UPType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMIN_UP (const MIN_UPOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMIN_UP (::std::auto_ptr< MIN_UPType > p);

    //@}

    /**
     * @name M
     *
     * @brief Accessor and modifier functions for the %M
     * optional element.
     *
     * smoothing factor
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MType > MOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MType, char > MTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MOptional&
    getM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MOptional&
    getM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setM (const MType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setM (const MOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setM (::std::auto_ptr< MType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterWaterDistributionVariableStorageSystemComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterWaterDistributionVariableStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                                ::xml_schema::Flags f = 0,
                                                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterWaterDistributionVariableStorageSystemComplexType (const ParameterWaterDistributionVariableStorageSystemComplexType& x,
                                                                ::xml_schema::Flags f = 0,
                                                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterWaterDistributionVariableStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterWaterDistributionVariableStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    MIN_UPOptional MIN_UP_;
    MOptional M_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputWaterDistributionVariableStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputWaterDistributionVariableStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, source of water abstraction/distribution (i.e. surface
     * water/groundwater/sewerage)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * optional element.
     *
     * downstream node collector of abstracted water. For instance drinking
     * water treatment plant
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HDownType > HDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HDownOptional&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HDownOptional&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHDown (const HDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * required element.
     *
     * series of industrial or domestic water demands/abstractions [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DType&
    getD () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DType&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputWaterDistributionVariableStorageSystemComplexType (const HUpType&,
                                                            const DType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputWaterDistributionVariableStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                            ::xml_schema::Flags f = 0,
                                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputWaterDistributionVariableStorageSystemComplexType (const InputWaterDistributionVariableStorageSystemComplexType& x,
                                                            ::xml_schema::Flags f = 0,
                                                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputWaterDistributionVariableStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputWaterDistributionVariableStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    HDownOptional HDown_;
    ::xsd::cxx::tree::one< DType > D_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %groundwaterFlowStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class GroundwaterFlowStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParametergroundwaterFlowStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputGroundwaterFlowStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GroundwaterFlowStorageSystemComplexType (const ParameterType&,
                                             const InputType&,
                                             const OutputType&,
                                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GroundwaterFlowStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                             ::std::auto_ptr< InputType >&,
                                             ::std::auto_ptr< OutputType >&,
                                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GroundwaterFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GroundwaterFlowStorageSystemComplexType (const GroundwaterFlowStorageSystemComplexType& x,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GroundwaterFlowStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GroundwaterFlowStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputGroundwaterFlowStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputGroundwaterFlowStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, can be GW groundwater or SW surface water
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * required element.
     *
     * downstream node, can be GW groundwater or SW surface water
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HDownType&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HDownType&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputGroundwaterFlowStorageSystemComplexType (const HUpType&,
                                                  const HDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputGroundwaterFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputGroundwaterFlowStorageSystemComplexType (const InputGroundwaterFlowStorageSystemComplexType& x,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputGroundwaterFlowStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputGroundwaterFlowStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    ::xsd::cxx::tree::one< HDownType > HDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParametergroundwaterFlowStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParametergroundwaterFlowStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ALPHA
     *
     * @brief Accessor and modifier functions for the %ALPHA
     * required element.
     *
     * Ground water reaction coefficient
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ALPHAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ALPHAType, char > ALPHATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ALPHAType&
    getALPHA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ALPHAType&
    getALPHA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setALPHA (const ALPHAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setALPHA (::std::auto_ptr< ALPHAType > p);

    //@}

    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name K
     *
     * @brief Accessor and modifier functions for the %K
     * required element.
     *
     * Ground water Conductivity [1/d]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType KType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KType, char > KTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KType&
    getK () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KType&
    getK ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setK (const KType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setK (::std::auto_ptr< KType > p);

    //@}

    /**
     * @name MAX_GFLOW
     *
     * @brief Accessor and modifier functions for the %MAX_GFLOW
     * required element.
     *
     * Maximum groundwater flow [mm/d]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType MAX_GFLOWType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MAX_GFLOWType, char > MAX_GFLOWTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MAX_GFLOWType&
    getMAX_GFLOW () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MAX_GFLOWType&
    getMAX_GFLOW ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMAX_GFLOW (const MAX_GFLOWType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMAX_GFLOW (::std::auto_ptr< MAX_GFLOWType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParametergroundwaterFlowStorageSystemComplexType (const ALPHAType&,
                                                      const KType&,
                                                      const MAX_GFLOWType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParametergroundwaterFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::Flags f = 0,
                                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParametergroundwaterFlowStorageSystemComplexType (const ParametergroundwaterFlowStorageSystemComplexType& x,
                                                      ::xml_schema::Flags f = 0,
                                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParametergroundwaterFlowStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParametergroundwaterFlowStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ALPHAType > ALPHA_;
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< KType > K_;
    ::xsd::cxx::tree::one< MAX_GFLOWType > MAX_GFLOW_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %evaporationActualStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class EvaporationActualStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterEvaporationActualStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputEvaporationActualStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EvaporationActualStorageSystemComplexType (const ParameterType&,
                                               const InputType&,
                                               const OutputType&,
                                               const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    EvaporationActualStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                               ::std::auto_ptr< InputType >&,
                                               ::std::auto_ptr< OutputType >&,
                                               const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EvaporationActualStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EvaporationActualStorageSystemComplexType (const EvaporationActualStorageSystemComplexType& x,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EvaporationActualStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EvaporationActualStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputEvaporationActualStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputEvaporationActualStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, typically SM (soil moisture)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name EP
     *
     * @brief Accessor and modifier functions for the %EP
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPType, char > EPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPType&
    getEP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPType&
    getEP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEP (const EPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEP (::std::auto_ptr< EPType > p);

    //@}

    /**
     * @name EI
     *
     * @brief Accessor and modifier functions for the %EI
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EIType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EIType > EIOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EIType, char > EITraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EIOptional&
    getEI () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EIOptional&
    getEI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEI (const EIType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEI (const EIOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEI (::std::auto_ptr< EIType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputEvaporationActualStorageSystemComplexType (const HUpType&,
                                                    const EPType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputEvaporationActualStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f = 0,
                                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputEvaporationActualStorageSystemComplexType (const InputEvaporationActualStorageSystemComplexType& x,
                                                    ::xml_schema::Flags f = 0,
                                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputEvaporationActualStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputEvaporationActualStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    ::xsd::cxx::tree::one< EPType > EP_;
    EIOptional EI_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterEvaporationActualStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterEvaporationActualStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [1000 m2], default = 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * optional element.
     *
     * distance measure for smoothing the transitions [-]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType DType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DType > DOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DOptional&
    getD () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DOptional&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setD (const DOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name FC
     *
     * @brief Accessor and modifier functions for the %FC
     * required element.
     *
     * field capacity [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType FCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FCType, char > FCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FCType&
    getFC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FCType&
    getFC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFC (const FCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFC (::std::auto_ptr< FCType > p);

    //@}

    /**
     * @name LP
     *
     * @brief Accessor and modifier functions for the %LP
     * required element.
     *
     * limit for potential evaporation [-]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LPType, char > LPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LPType&
    getLP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LPType&
    getLP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLP (const LPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLP (::std::auto_ptr< LPType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterEvaporationActualStorageSystemComplexType (const FCType&,
                                                        const LPType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterEvaporationActualStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::Flags f = 0,
                                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterEvaporationActualStorageSystemComplexType (const ParameterEvaporationActualStorageSystemComplexType& x,
                                                        ::xml_schema::Flags f = 0,
                                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterEvaporationActualStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterEvaporationActualStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    DOptional D_;
    ::xsd::cxx::tree::one< FCType > FC_;
    ::xsd::cxx::tree::one< LPType > LP_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SoilRunoffStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class SoilRunoffStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterSoilRunoffStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputSoilRunoffStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SoilRunoffStorageSystemComplexType (const ParameterType&,
                                        const InputType&,
                                        const OutputType&,
                                        const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SoilRunoffStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                        ::std::auto_ptr< InputType >&,
                                        ::std::auto_ptr< OutputType >&,
                                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SoilRunoffStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SoilRunoffStorageSystemComplexType (const SoilRunoffStorageSystemComplexType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SoilRunoffStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SoilRunoffStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputSoilRunoffStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputSoilRunoffStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, typically unsaturated zone (SM soil moisture)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * optional element.
     *
     * optional downstream node, typically uper saturated zones (UZ upper
     * zone storage). Required if capillary flow is used and SM and UZ are
     * present in one storage system
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HDownType > HDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HDownOptional&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HDownOptional&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHDown (const HDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name INF
     *
     * @brief Accessor and modifier functions for the %INF
     * sequence element.
     *
     * infiltation into the unsaturated zone (fluzex into SM  [m3/s])
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType INFType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< INFType > INFSequence;

    /**
     * @brief Element iterator type.
     */
    typedef INFSequence::iterator INFIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef INFSequence::const_iterator INFConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< INFType, char > INFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const INFSequence&
    getINF () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    INFSequence&
    getINF ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setINF (const INFSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputSoilRunoffStorageSystemComplexType (const HUpType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputSoilRunoffStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputSoilRunoffStorageSystemComplexType (const InputSoilRunoffStorageSystemComplexType& x,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputSoilRunoffStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputSoilRunoffStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    HDownOptional HDown_;
    INFSequence INF_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterSoilRunoffStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterSoilRunoffStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name BETA
     *
     * @brief Accessor and modifier functions for the %BETA
     * required element.
     *
     * parameter in soil routine [-]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BETAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BETAType, char > BETATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BETAType&
    getBETA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BETAType&
    getBETA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBETA (const BETAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBETA (::std::auto_ptr< BETAType > p);

    //@}

    /**
     * @name FC
     *
     * @brief Accessor and modifier functions for the %FC
     * required element.
     *
     * field capacity [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType FCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FCType, char > FCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FCType&
    getFC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FCType&
    getFC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFC (const FCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFC (::std::auto_ptr< FCType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterSoilRunoffStorageSystemComplexType (const BETAType&,
                                                 const FCType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterSoilRunoffStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterSoilRunoffStorageSystemComplexType (const ParameterSoilRunoffStorageSystemComplexType& x,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterSoilRunoffStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterSoilRunoffStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< BETAType > BETA_;
    ::xsd::cxx::tree::one< FCType > FC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CapillaryFlowStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class CapillaryFlowStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterCapillaryFlowStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputCapillaryFlowStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CapillaryFlowStorageSystemComplexType (const ParameterType&,
                                           const InputType&,
                                           const OutputType&,
                                           const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    CapillaryFlowStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                           ::std::auto_ptr< InputType >&,
                                           ::std::auto_ptr< OutputType >&,
                                           const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CapillaryFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CapillaryFlowStorageSystemComplexType (const CapillaryFlowStorageSystemComplexType& x,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CapillaryFlowStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CapillaryFlowStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputCapillaryFlowStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputCapillaryFlowStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, typically GW upper zone
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * required element.
     *
     * downstream node, typically UZ unsaturted zone
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HDownType&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HDownType&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputCapillaryFlowStorageSystemComplexType (const HUpType&,
                                                const HDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputCapillaryFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::Flags f = 0,
                                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputCapillaryFlowStorageSystemComplexType (const InputCapillaryFlowStorageSystemComplexType& x,
                                                ::xml_schema::Flags f = 0,
                                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputCapillaryFlowStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputCapillaryFlowStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    ::xsd::cxx::tree::one< HDownType > HDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterCapillaryFlowStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterCapillaryFlowStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name CFLUX
     *
     * @brief Accessor and modifier functions for the %CFLUX
     * required element.
     *
     * maximum value of capillary flow [mm/d]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CFLUXType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFLUXType, char > CFLUXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFLUXType&
    getCFLUX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFLUXType&
    getCFLUX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFLUX (const CFLUXType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFLUX (::std::auto_ptr< CFLUXType > p);

    //@}

    /**
     * @name FC
     *
     * @brief Accessor and modifier functions for the %FC
     * required element.
     *
     * field capacity [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType FCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FCType, char > FCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FCType&
    getFC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FCType&
    getFC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFC (const FCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFC (::std::auto_ptr< FCType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterCapillaryFlowStorageSystemComplexType (const CFLUXType&,
                                                    const FCType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterCapillaryFlowStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f = 0,
                                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterCapillaryFlowStorageSystemComplexType (const ParameterCapillaryFlowStorageSystemComplexType& x,
                                                    ::xml_schema::Flags f = 0,
                                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterCapillaryFlowStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterCapillaryFlowStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< CFLUXType > CFLUX_;
    ::xsd::cxx::tree::one< FCType > FC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ResponseStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ResponseStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterResponseStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputResponseStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ResponseStorageSystemComplexType (const ParameterType&,
                                      const InputType&,
                                      const OutputType&,
                                      const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ResponseStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                      ::std::auto_ptr< InputType >&,
                                      ::std::auto_ptr< OutputType >&,
                                      const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ResponseStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ResponseStorageSystemComplexType (const ResponseStorageSystemComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ResponseStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ResponseStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterResponseStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterResponseStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name K
     *
     * @brief Accessor and modifier functions for the %K
     * required element.
     *
     * recession coefficient [1/d]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType KType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KType, char > KTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KType&
    getK () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KType&
    getK ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setK (const KType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setK (::std::auto_ptr< KType > p);

    //@}

    /**
     * @name ALPHA
     *
     * @brief Accessor and modifier functions for the %ALPHA
     * optional element.
     *
     * response box parameter [-], default = 0.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ALPHAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ALPHAType > ALPHAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ALPHAType, char > ALPHATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ALPHAOptional&
    getALPHA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ALPHAOptional&
    getALPHA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setALPHA (const ALPHAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setALPHA (const ALPHAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setALPHA (::std::auto_ptr< ALPHAType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterResponseStorageSystemComplexType (const KType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterResponseStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterResponseStorageSystemComplexType (const ParameterResponseStorageSystemComplexType& x,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterResponseStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterResponseStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< KType > K_;
    ALPHAOptional ALPHA_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputResponseStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputResponseStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream (release) node, typically UZ and/or LZ (upper/lower zone
     * storages)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputResponseStorageSystemComplexType (const HUpType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputResponseStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputResponseStorageSystemComplexType (const InputResponseStorageSystemComplexType& x,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputResponseStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputResponseStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PercolationStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class PercolationStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ParameterPercolationStorageSystemComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputPercolationStorageSystemComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputLinkStorageSystemComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PercolationStorageSystemComplexType (const ParameterType&,
                                         const InputType&,
                                         const OutputType&,
                                         const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PercolationStorageSystemComplexType (::std::auto_ptr< ParameterType >&,
                                         ::std::auto_ptr< InputType >&,
                                         ::std::auto_ptr< OutputType >&,
                                         const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PercolationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PercolationStorageSystemComplexType (const PercolationStorageSystemComplexType& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PercolationStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PercolationStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParameterPercolationStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class ParameterPercolationStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * optional element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AREAType > AREAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AREAOptional&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AREAOptional&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAREA (const AREAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name PERC
     *
     * @brief Accessor and modifier functions for the %PERC
     * required element.
     *
     * percolation [mm/d]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType PERCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PERCType, char > PERCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PERCType&
    getPERC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PERCType&
    getPERC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPERC (const PERCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPERC (::std::auto_ptr< PERCType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParameterPercolationStorageSystemComplexType (const PERCType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParameterPercolationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParameterPercolationStorageSystemComplexType (const ParameterPercolationStorageSystemComplexType& x,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParameterPercolationStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParameterPercolationStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AREAOptional AREA_;
    ::xsd::cxx::tree::one< PERCType > PERC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputPercolationStorageSystemComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputPercolationStorageSystemComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * upstream node, typically UZ (upper zone storage)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * optional element.
     *
     * downstream node, typically LZ (lower zone storage)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HDownType > HDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HDownOptional&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HDownOptional&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHDown (const HDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputPercolationStorageSystemComplexType (const HUpType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputPercolationStorageSystemComplexType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputPercolationStorageSystemComplexType (const InputPercolationStorageSystemComplexType& x,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputPercolationStorageSystemComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputPercolationStorageSystemComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    HDownOptional HDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ArmaComplexType schema type.
   *
   * @nosubgrouping
   */
  class ArmaComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name arCoef
     *
     * @brief Accessor and modifier functions for the %arCoef
     * required element.
     *
     * autoregression coefficient related to prior time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ArCoefType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ArCoefType, char, ::xsd::cxx::tree::schema_type::double_ > ArCoefTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ArCoefType&
    getArCoef () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ArCoefType&
    getArCoef ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setArCoef (const ArCoefType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ArCoefType
    getArCoefDefaultValue ();

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ArmaInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ArmaOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ArmaComplexType (const ArCoefType&,
                     const InputType&,
                     const OutputType&,
                     const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ArmaComplexType (const ArCoefType&,
                     ::std::auto_ptr< InputType >&,
                     ::std::auto_ptr< OutputType >&,
                     const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ArmaComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ArmaComplexType (const ArmaComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ArmaComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ArmaComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ArCoefType > arCoef_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ArmaInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ArmaInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name obs
     *
     * @brief Accessor and modifier functions for the %obs
     * required element.
     *
     * observed data
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ObsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ObsType, char > ObsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ObsType&
    getObs () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ObsType&
    getObs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setObs (const ObsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setObs (::std::auto_ptr< ObsType > p);

    //@}

    /**
     * @name sim
     *
     * @brief Accessor and modifier functions for the %sim
     * required element.
     *
     * simulated data
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SimType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimType, char > SimTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SimType&
    getSim () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SimType&
    getSim ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSim (const SimType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSim (::std::auto_ptr< SimType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ArmaInputComplexType (const ObsType&,
                          const SimType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ArmaInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ArmaInputComplexType (const ArmaInputComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ArmaInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ArmaInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ObsType > obs_;
    ::xsd::cxx::tree::one< SimType > sim_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ArmaOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ArmaOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name arma
     *
     * @brief Accessor and modifier functions for the %arma
     * required element.
     *
     * output-corrected data
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ArmaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ArmaType, char > ArmaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ArmaType&
    getArma () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ArmaType&
    getArma ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setArma (const ArmaType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setArma (::std::auto_ptr< ArmaType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ArmaOutputComplexType (const ArmaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ArmaOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ArmaOutputComplexType (const ArmaOutputComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ArmaOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ArmaOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ArmaType > arma_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AccumulationComplexType schema type.
   *
   * @nosubgrouping
   */
  class AccumulationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name multiplier
     *
     * @brief Accessor and modifier functions for the %multiplier
     * optional element.
     *
     * optional multiplier
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double MultiplierType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MultiplierType > MultiplierOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultiplierType, char, ::xsd::cxx::tree::schema_type::double_ > MultiplierTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MultiplierOptional&
    getMultiplier () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MultiplierOptional&
    getMultiplier ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMultiplier (const MultiplierType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMultiplier (const MultiplierOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static MultiplierType
    getMultiplierDefaultValue ();

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     *
     * input variable
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AccumulationInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AccumulationOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AccumulationComplexType (const InputType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AccumulationComplexType (::std::auto_ptr< InputType >&,
                             ::std::auto_ptr< OutputType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AccumulationComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AccumulationComplexType (const AccumulationComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AccumulationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AccumulationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MultiplierOptional multiplier_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AccumulationInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class AccumulationInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AccumulationInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AccumulationInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AccumulationInputComplexType (const AccumulationInputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AccumulationInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AccumulationInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AccumulationOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class AccumulationOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AccumulationOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AccumulationOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AccumulationOutputComplexType (const AccumulationOutputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AccumulationOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AccumulationOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GradientComplexType schema type.
   *
   * @nosubgrouping
   */
  class GradientComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name multiplier
     *
     * @brief Accessor and modifier functions for the %multiplier
     * optional element.
     *
     * optional multiplier
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double MultiplierType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MultiplierType > MultiplierOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultiplierType, char, ::xsd::cxx::tree::schema_type::double_ > MultiplierTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MultiplierOptional&
    getMultiplier () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MultiplierOptional&
    getMultiplier ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMultiplier (const MultiplierType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMultiplier (const MultiplierOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static MultiplierType
    getMultiplierDefaultValue ();

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     *
     * input variable
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GradientInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     *
     * gradient, dx = multiplier*(xNew-xOld)/dt
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GradientOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GradientComplexType (const InputType&,
                         const OutputType&,
                         const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GradientComplexType (::std::auto_ptr< InputType >&,
                         ::std::auto_ptr< OutputType >&,
                         const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GradientComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GradientComplexType (const GradientComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GradientComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GradientComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MultiplierOptional multiplier_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GradientInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class GradientInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GradientInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GradientInputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GradientInputComplexType (const GradientInputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GradientInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GradientInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GradientOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class GradientOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name dx
     *
     * @brief Accessor and modifier functions for the %dx
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DxType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DxType, char > DxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DxType&
    getDx () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DxType&
    getDx ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDx (const DxType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDx (::std::auto_ptr< DxType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GradientOutputComplexType (const DxType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GradientOutputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GradientOutputComplexType (const GradientOutputComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GradientOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GradientOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DxType > dx_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameterSoil
     *
     * @brief Accessor and modifier functions for the %parameterSoil
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversParameterSoilComplexType ParameterSoilType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterSoilType, char > ParameterSoilTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterSoilType&
    getParameterSoil () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterSoilType&
    getParameterSoil ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterSoil (const ParameterSoilType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterSoil (::std::auto_ptr< ParameterSoilType > p);

    //@}

    /**
     * @name parameterResponse
     *
     * @brief Accessor and modifier functions for the %parameterResponse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversParameterResponseComplexType ParameterResponseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterResponseType, char > ParameterResponseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterResponseType&
    getParameterResponse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterResponseType&
    getParameterResponse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterResponse (const ParameterResponseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterResponse (::std::auto_ptr< ParameterResponseType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name state
     *
     * @brief Accessor and modifier functions for the %state
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversStateComplexType StateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StateType&
    getState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StateType&
    getState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setState (::std::auto_ptr< StateType > p);

    //@}

    /**
     * @name stateUpdate
     *
     * @brief Accessor and modifier functions for the %stateUpdate
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversStateUpdateComplexType StateUpdateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateUpdateType > StateUpdateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateUpdateType, char > StateUpdateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateUpdateOptional&
    getStateUpdate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateUpdateOptional&
    getStateUpdate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateUpdate (const StateUpdateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStateUpdate (const StateUpdateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateUpdate (::std::auto_ptr< StateUpdateType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LorentGeversOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversComplexType (const ParameterSoilType&,
                             const ParameterResponseType&,
                             const InputType&,
                             const StateType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LorentGeversComplexType (::std::auto_ptr< ParameterSoilType >&,
                             ::std::auto_ptr< ParameterResponseType >&,
                             ::std::auto_ptr< InputType >&,
                             ::std::auto_ptr< StateType >&,
                             ::std::auto_ptr< OutputType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversComplexType (const LorentGeversComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterSoilType > parameterSoil_;
    ::xsd::cxx::tree::one< ParameterResponseType > parameterResponse_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< StateType > state_;
    StateUpdateOptional stateUpdate_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversParameterSoilComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversParameterSoilComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name BETA
     *
     * @brief Accessor and modifier functions for the %BETA
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BETAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BETAType, char > BETATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BETAType&
    getBETA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BETAType&
    getBETA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBETA (const BETAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBETA (::std::auto_ptr< BETAType > p);

    //@}

    /**
     * @name PMAX
     *
     * @brief Accessor and modifier functions for the %PMAX
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType PMAXType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PMAXType, char > PMAXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PMAXType&
    getPMAX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PMAXType&
    getPMAX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPMAX (const PMAXType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPMAX (::std::auto_ptr< PMAXType > p);

    //@}

    /**
     * @name SMAX
     *
     * @brief Accessor and modifier functions for the %SMAX
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType SMAXType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SMAXType, char > SMAXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SMAXType&
    getSMAX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SMAXType&
    getSMAX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSMAX (const SMAXType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSMAX (::std::auto_ptr< SMAXType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversParameterSoilComplexType (const BETAType&,
                                          const PMAXType&,
                                          const SMAXType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversParameterSoilComplexType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversParameterSoilComplexType (const LorentGeversParameterSoilComplexType& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversParameterSoilComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversParameterSoilComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BETAType > BETA_;
    ::xsd::cxx::tree::one< PMAXType > PMAX_;
    ::xsd::cxx::tree::one< SMAXType > SMAX_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversParameterResponseComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversParameterResponseComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AREAType&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AREAType&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name KS
     *
     * @brief Accessor and modifier functions for the %KS
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType KSType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KSType, char > KSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KSType&
    getKS () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KSType&
    getKS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setKS (const KSType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setKS (::std::auto_ptr< KSType > p);

    //@}

    /**
     * @name TS1
     *
     * @brief Accessor and modifier functions for the %TS1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TS1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TS1Type, char > TS1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TS1Type&
    getTS1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TS1Type&
    getTS1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTS1 (const TS1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTS1 (::std::auto_ptr< TS1Type > p);

    //@}

    /**
     * @name TS2
     *
     * @brief Accessor and modifier functions for the %TS2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TS2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TS2Type, char > TS2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TS2Type&
    getTS2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TS2Type&
    getTS2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTS2 (const TS2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTS2 (::std::auto_ptr< TS2Type > p);

    //@}

    /**
     * @name KB
     *
     * @brief Accessor and modifier functions for the %KB
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType KBType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KBType, char > KBTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KBType&
    getKB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KBType&
    getKB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setKB (const KBType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setKB (::std::auto_ptr< KBType > p);

    //@}

    /**
     * @name TB1
     *
     * @brief Accessor and modifier functions for the %TB1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TB1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TB1Type, char > TB1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TB1Type&
    getTB1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TB1Type&
    getTB1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTB1 (const TB1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTB1 (::std::auto_ptr< TB1Type > p);

    //@}

    /**
     * @name TB2
     *
     * @brief Accessor and modifier functions for the %TB2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TB2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TB2Type, char > TB2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TB2Type&
    getTB2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TB2Type&
    getTB2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTB2 (const TB2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTB2 (::std::auto_ptr< TB2Type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversParameterResponseComplexType (const AREAType&,
                                              const KSType&,
                                              const TS1Type&,
                                              const TS2Type&,
                                              const KBType&,
                                              const TB1Type&,
                                              const TB2Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversParameterResponseComplexType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversParameterResponseComplexType (const LorentGeversParameterResponseComplexType& x,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversParameterResponseComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversParameterResponseComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AREAType > AREA_;
    ::xsd::cxx::tree::one< KSType > KS_;
    ::xsd::cxx::tree::one< TS1Type > TS1_;
    ::xsd::cxx::tree::one< TS2Type > TS2_;
    ::xsd::cxx::tree::one< KBType > KB_;
    ::xsd::cxx::tree::one< TB1Type > TB1_;
    ::xsd::cxx::tree::one< TB2Type > TB2_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name EP
     *
     * @brief Accessor and modifier functions for the %EP
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPType, char > EPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPType&
    getEP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPType&
    getEP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEP (const EPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEP (::std::auto_ptr< EPType > p);

    //@}

    /**
     * @name P
     *
     * @brief Accessor and modifier functions for the %P
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PType&
    getP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PType&
    getP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setP (const PType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setP (::std::auto_ptr< PType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversInputComplexType (const EPType&,
                                  const PType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversInputComplexType (const LorentGeversInputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EPType > EP_;
    ::xsd::cxx::tree::one< PType > P_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversStateComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversStateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name S
     *
     * @brief Accessor and modifier functions for the %S
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SType, char > STraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SType&
    getS () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SType&
    getS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setS (const SType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setS (::std::auto_ptr< SType > p);

    //@}

    /**
     * @name QS1
     *
     * @brief Accessor and modifier functions for the %QS1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QS1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QS1Type, char > QS1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QS1Type&
    getQS1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QS1Type&
    getQS1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQS1 (const QS1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQS1 (::std::auto_ptr< QS1Type > p);

    //@}

    /**
     * @name QS2
     *
     * @brief Accessor and modifier functions for the %QS2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QS2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QS2Type, char > QS2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QS2Type&
    getQS2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QS2Type&
    getQS2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQS2 (const QS2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQS2 (::std::auto_ptr< QS2Type > p);

    //@}

    /**
     * @name QB1
     *
     * @brief Accessor and modifier functions for the %QB1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QB1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QB1Type, char > QB1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QB1Type&
    getQB1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QB1Type&
    getQB1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQB1 (const QB1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQB1 (::std::auto_ptr< QB1Type > p);

    //@}

    /**
     * @name QB2
     *
     * @brief Accessor and modifier functions for the %QB2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QB2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QB2Type, char > QB2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QB2Type&
    getQB2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QB2Type&
    getQB2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQB2 (const QB2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQB2 (::std::auto_ptr< QB2Type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversStateComplexType (const SType&,
                                  const QS1Type&,
                                  const QS2Type&,
                                  const QB1Type&,
                                  const QB2Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversStateComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversStateComplexType (const LorentGeversStateComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversStateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversStateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SType > S_;
    ::xsd::cxx::tree::one< QS1Type > QS1_;
    ::xsd::cxx::tree::one< QS2Type > QS2_;
    ::xsd::cxx::tree::one< QB1Type > QB1_;
    ::xsd::cxx::tree::one< QB2Type > QB2_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversStateUpdateComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversStateUpdateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name S
     *
     * @brief Accessor and modifier functions for the %S
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SType, char > STraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SType&
    getS () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SType&
    getS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setS (const SType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setS (::std::auto_ptr< SType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversStateUpdateComplexType (const SType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversStateUpdateComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversStateUpdateComplexType (const LorentGeversStateUpdateComplexType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversStateUpdateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversStateUpdateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SType > S_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LorentGeversOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class LorentGeversOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LorentGeversOutputComplexType (const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LorentGeversOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LorentGeversOutputComplexType (const LorentGeversOutputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LorentGeversOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LorentGeversOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QType > Q_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameterInput
     *
     * @brief Accessor and modifier functions for the %parameterInput
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVParameterInputComplexType ParameterInputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterInputType, char > ParameterInputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterInputType&
    getParameterInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterInputType&
    getParameterInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterInput (const ParameterInputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterInput (::std::auto_ptr< ParameterInputType > p);

    //@}

    /**
     * @name parameterSnow
     *
     * @brief Accessor and modifier functions for the %parameterSnow
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVParameterSnowComplexType ParameterSnowType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterSnowType, char > ParameterSnowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterSnowType&
    getParameterSnow () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterSnowType&
    getParameterSnow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterSnow (const ParameterSnowType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterSnow (::std::auto_ptr< ParameterSnowType > p);

    //@}

    /**
     * @name parameterInterception
     *
     * @brief Accessor and modifier functions for the %parameterInterception
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVParameterInterceptionComplexType ParameterInterceptionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterInterceptionType, char > ParameterInterceptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterInterceptionType&
    getParameterInterception () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterInterceptionType&
    getParameterInterception ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterInterception (const ParameterInterceptionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterInterception (::std::auto_ptr< ParameterInterceptionType > p);

    //@}

    /**
     * @name parameterSoil
     *
     * @brief Accessor and modifier functions for the %parameterSoil
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVParameterSoilComplexType ParameterSoilType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterSoilType, char > ParameterSoilTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterSoilType&
    getParameterSoil () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterSoilType&
    getParameterSoil ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterSoil (const ParameterSoilType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterSoil (::std::auto_ptr< ParameterSoilType > p);

    //@}

    /**
     * @name parameterResponse
     *
     * @brief Accessor and modifier functions for the %parameterResponse
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVParameterResponseComplexType ParameterResponseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterResponseType, char > ParameterResponseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterResponseType&
    getParameterResponse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterResponseType&
    getParameterResponse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameterResponse (const ParameterResponseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameterResponse (::std::auto_ptr< ParameterResponseType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name link
     *
     * @brief Accessor and modifier functions for the %link
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVLinkComplexType LinkType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LinkType > LinkOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LinkType, char > LinkTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LinkOptional&
    getLink () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LinkOptional&
    getLink ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLink (const LinkType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLink (const LinkOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLink (::std::auto_ptr< LinkType > p);

    //@}

    /**
     * @name state
     *
     * @brief Accessor and modifier functions for the %state
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVStateComplexType StateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StateType&
    getState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StateType&
    getState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setState (::std::auto_ptr< StateType > p);

    //@}

    /**
     * @name stateUpdate
     *
     * @brief Accessor and modifier functions for the %stateUpdate
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVStateUpdateComplexType StateUpdateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateUpdateType > StateUpdateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateUpdateType, char > StateUpdateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateUpdateOptional&
    getStateUpdate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StateUpdateOptional&
    getStateUpdate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStateUpdate (const StateUpdateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStateUpdate (const StateUpdateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateUpdate (::std::auto_ptr< StateUpdateType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HBVOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVComplexType (const ParameterInputType&,
                    const ParameterSnowType&,
                    const ParameterInterceptionType&,
                    const ParameterSoilType&,
                    const ParameterResponseType&,
                    const InputType&,
                    const StateType&,
                    const OutputType&,
                    const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HBVComplexType (::std::auto_ptr< ParameterInputType >&,
                    ::std::auto_ptr< ParameterSnowType >&,
                    ::std::auto_ptr< ParameterInterceptionType >&,
                    ::std::auto_ptr< ParameterSoilType >&,
                    ::std::auto_ptr< ParameterResponseType >&,
                    ::std::auto_ptr< InputType >&,
                    ::std::auto_ptr< StateType >&,
                    ::std::auto_ptr< OutputType >&,
                    const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVComplexType (const HBVComplexType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterInputType > parameterInput_;
    ::xsd::cxx::tree::one< ParameterSnowType > parameterSnow_;
    ::xsd::cxx::tree::one< ParameterInterceptionType > parameterInterception_;
    ::xsd::cxx::tree::one< ParameterSoilType > parameterSoil_;
    ::xsd::cxx::tree::one< ParameterResponseType > parameterResponse_;
    ::xsd::cxx::tree::one< InputType > input_;
    LinkOptional link_;
    ::xsd::cxx::tree::one< StateType > state_;
    StateUpdateOptional stateUpdate_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVParameterInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVParameterInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ECORR
     *
     * @brief Accessor and modifier functions for the %ECORR
     * optional element.
     *
     * correction factor for EP
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ECORRType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ECORRType > ECORROptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ECORRType, char > ECORRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ECORROptional&
    getECORR () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ECORROptional&
    getECORR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setECORR (const ECORRType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setECORR (const ECORROptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setECORR (::std::auto_ptr< ECORRType > p);

    //@}

    /**
     * @name RFCF
     *
     * @brief Accessor and modifier functions for the %RFCF
     * optional element.
     *
     * correction factor for rainfall
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType RFCFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RFCFType > RFCFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RFCFType, char > RFCFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RFCFOptional&
    getRFCF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RFCFOptional&
    getRFCF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRFCF (const RFCFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRFCF (const RFCFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRFCF (::std::auto_ptr< RFCFType > p);

    //@}

    /**
     * @name SFCF
     *
     * @brief Accessor and modifier functions for the %SFCF
     * optional element.
     *
     * correction factor for snow
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType SFCFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SFCFType > SFCFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SFCFType, char > SFCFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SFCFOptional&
    getSFCF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SFCFOptional&
    getSFCF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSFCF (const SFCFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSFCF (const SFCFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSFCF (::std::auto_ptr< SFCFType > p);

    //@}

    /**
     * @name TT
     *
     * @brief Accessor and modifier functions for the %TT
     * required element.
     *
     * temperature limit for snow / rain [oC], normally close to 0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TTType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TTType, char > TTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TTType&
    getTT () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TTType&
    getTT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTT (const TTType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTT (::std::auto_ptr< TTType > p);

    //@}

    /**
     * @name TTI
     *
     * @brief Accessor and modifier functions for the %TTI
     * required element.
     *
     * temperature interval with a mixture of snow / rain [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TTIType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TTIType, char > TTITraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TTIType&
    getTTI () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TTIType&
    getTTI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTTI (const TTIType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTTI (::std::auto_ptr< TTIType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVParameterInputComplexType (const TTType&,
                                  const TTIType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVParameterInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVParameterInputComplexType (const HBVParameterInputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVParameterInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVParameterInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ECORROptional ECORR_;
    RFCFOptional RFCF_;
    SFCFOptional SFCF_;
    ::xsd::cxx::tree::one< TTType > TT_;
    ::xsd::cxx::tree::one< TTIType > TTI_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVParameterSnowComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVParameterSnowComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name CFMAX
     *
     * @brief Accessor and modifier functions for the %CFMAX
     * required element.
     *
     * degree day factor [mm/(oC*day)], varies normally between 1.5 and 4, 2
     * and 3.5 can be used in forested and open
     * landscape respectively
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CFMAXType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFMAXType, char > CFMAXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFMAXType&
    getCFMAX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFMAXType&
    getCFMAX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFMAX (const CFMAXType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFMAX (::std::auto_ptr< CFMAXType > p);

    //@}

    /**
     * @name CFR
     *
     * @brief Accessor and modifier functions for the %CFR
     * required element.
     *
     * refreezing factor [-], about 0.05
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CFRType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFRType, char > CFRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFRType&
    getCFR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFRType&
    getCFR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFR (const CFRType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFR (::std::auto_ptr< CFRType > p);

    //@}

    /**
     * @name CWH
     *
     * @brief Accessor and modifier functions for the %CWH
     * required element.
     *
     * water holding capacity [-], usually 0.1
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CWHType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CWHType, char > CWHTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CWHType&
    getCWH () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CWHType&
    getCWH ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCWH (const CWHType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCWH (::std::auto_ptr< CWHType > p);

    //@}

    /**
     * @name TTM
     *
     * @brief Accessor and modifier functions for the %TTM
     * required element.
     *
     * temperature limit for melting [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TTMType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TTMType, char > TTMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TTMType&
    getTTM () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TTMType&
    getTTM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTTM (const TTMType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTTM (::std::auto_ptr< TTMType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVParameterSnowComplexType (const CFMAXType&,
                                 const CFRType&,
                                 const CWHType&,
                                 const TTMType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVParameterSnowComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVParameterSnowComplexType (const HBVParameterSnowComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVParameterSnowComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVParameterSnowComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CFMAXType > CFMAX_;
    ::xsd::cxx::tree::one< CFRType > CFR_;
    ::xsd::cxx::tree::one< CWHType > CWH_;
    ::xsd::cxx::tree::one< TTMType > TTM_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVParameterInterceptionComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVParameterInterceptionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name LIC
     *
     * @brief Accessor and modifier functions for the %LIC
     * required element.
     *
     * maximum interception storage
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LICType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LICType, char > LICTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LICType&
    getLIC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LICType&
    getLIC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLIC (const LICType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLIC (::std::auto_ptr< LICType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVParameterInterceptionComplexType (const LICType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVParameterInterceptionComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVParameterInterceptionComplexType (const HBVParameterInterceptionComplexType& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVParameterInterceptionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVParameterInterceptionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LICType > LIC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVParameterSoilComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVParameterSoilComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name BETA
     *
     * @brief Accessor and modifier functions for the %BETA
     * required element.
     *
     * parameter in soil routine [-], usually between 1 and 6
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BETAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BETAType, char > BETATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BETAType&
    getBETA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BETAType&
    getBETA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBETA (const BETAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBETA (::std::auto_ptr< BETAType > p);

    //@}

    /**
     * @name CFLUX
     *
     * @brief Accessor and modifier functions for the %CFLUX
     * required element.
     *
     * maximum value of CF
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CFLUXType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFLUXType, char > CFLUXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFLUXType&
    getCFLUX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFLUXType&
    getCFLUX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFLUX (const CFLUXType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFLUX (::std::auto_ptr< CFLUXType > p);

    //@}

    /**
     * @name ETF
     *
     * @brief Accessor and modifier functions for the %ETF
     * required element.
     *
     * temperature correction factor
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ETFType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ETFType, char > ETFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ETFType&
    getETF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ETFType&
    getETF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setETF (const ETFType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setETF (::std::auto_ptr< ETFType > p);

    //@}

    /**
     * @name FC
     *
     * @brief Accessor and modifier functions for the %FC
     * required element.
     *
     * field capacity [mm], between 50 and 500
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType FCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FCType, char > FCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FCType&
    getFC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FCType&
    getFC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFC (const FCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFC (::std::auto_ptr< FCType > p);

    //@}

    /**
     * @name LP
     *
     * @brief Accessor and modifier functions for the %LP
     * required element.
     *
     * limit for potential evapotranspiration [-], in the range between 0.3
     * and 1
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType LPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LPType, char > LPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LPType&
    getLP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LPType&
    getLP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLP (const LPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLP (::std::auto_ptr< LPType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVParameterSoilComplexType (const BETAType&,
                                 const CFLUXType&,
                                 const ETFType&,
                                 const FCType&,
                                 const LPType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVParameterSoilComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVParameterSoilComplexType (const HBVParameterSoilComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVParameterSoilComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVParameterSoilComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BETAType > BETA_;
    ::xsd::cxx::tree::one< CFLUXType > CFLUX_;
    ::xsd::cxx::tree::one< ETFType > ETF_;
    ::xsd::cxx::tree::one< FCType > FC_;
    ::xsd::cxx::tree::one< LPType > LP_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVParameterResponseComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVParameterResponseComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ALPHA
     *
     * @brief Accessor and modifier functions for the %ALPHA
     * required element.
     *
     * response box parameter [-], usually between 1.0 and 2.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType ALPHAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ALPHAType, char > ALPHATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ALPHAType&
    getALPHA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ALPHAType&
    getALPHA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setALPHA (const ALPHAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setALPHA (::std::auto_ptr< ALPHAType > p);

    //@}

    /**
     * @name AREA
     *
     * @brief Accessor and modifier functions for the %AREA
     * required element.
     *
     * catchment area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AREAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AREAType, char > AREATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AREAType&
    getAREA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AREAType&
    getAREA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAREA (const AREAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAREA (::std::auto_ptr< AREAType > p);

    //@}

    /**
     * @name K
     *
     * @brief Accessor and modifier functions for the %K
     * required element.
     *
     * recession coefficient
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType KType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KType, char > KTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KType&
    getK () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KType&
    getK ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setK (const KType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setK (::std::auto_ptr< KType > p);

    //@}

    /**
     * @name K1
     *
     * @brief Accessor and modifier functions for the %K1
     * required element.
     *
     * recession coefficient [1/day]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType K1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< K1Type, char > K1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const K1Type&
    getK1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    K1Type&
    getK1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setK1 (const K1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setK1 (::std::auto_ptr< K1Type > p);

    //@}

    /**
     * @name PERC
     *
     * @brief Accessor and modifier functions for the %PERC
     * required element.
     *
     * percolation from upper to lower response box [mm/day], usually between
     * 0 and 6
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType PERCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PERCType, char > PERCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PERCType&
    getPERC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PERCType&
    getPERC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPERC (const PERCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPERC (::std::auto_ptr< PERCType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVParameterResponseComplexType (const ALPHAType&,
                                     const AREAType&,
                                     const KType&,
                                     const K1Type&,
                                     const PERCType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVParameterResponseComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVParameterResponseComplexType (const HBVParameterResponseComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVParameterResponseComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVParameterResponseComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ALPHAType > ALPHA_;
    ::xsd::cxx::tree::one< AREAType > AREA_;
    ::xsd::cxx::tree::one< KType > K_;
    ::xsd::cxx::tree::one< K1Type > K1_;
    ::xsd::cxx::tree::one< PERCType > PERC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name EP
     *
     * @brief Accessor and modifier functions for the %EP
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPType, char > EPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPType&
    getEP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPType&
    getEP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEP (const EPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEP (::std::auto_ptr< EPType > p);

    //@}

    /**
     * @name P
     *
     * @brief Accessor and modifier functions for the %P
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PType&
    getP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PType&
    getP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setP (const PType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setP (::std::auto_ptr< PType > p);

    //@}

    /**
     * @name T
     *
     * @brief Accessor and modifier functions for the %T
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TType, char > TTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TType&
    getT () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TType&
    getT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setT (const TType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setT (::std::auto_ptr< TType > p);

    //@}

    /**
     * @name TM
     *
     * @brief Accessor and modifier functions for the %TM
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TMType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TMType, char > TMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TMType&
    getTM () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TMType&
    getTM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTM (const TMType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTM (::std::auto_ptr< TMType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVInputComplexType (const EPType&,
                         const PType&,
                         const TType&,
                         const TMType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVInputComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVInputComplexType (const HBVInputComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EPType > EP_;
    ::xsd::cxx::tree::one< PType > P_;
    ::xsd::cxx::tree::one< TType > T_;
    ::xsd::cxx::tree::one< TMType > TM_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVLinkComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVLinkComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name CF
     *
     * @brief Accessor and modifier functions for the %CF
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType CFType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFType, char > CFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFType&
    getCF () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFType&
    getCF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCF (const CFType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCF (::std::auto_ptr< CFType > p);

    //@}

    /**
     * @name EA
     *
     * @brief Accessor and modifier functions for the %EA
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EAType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EAType, char > EATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EAType&
    getEA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EAType&
    getEA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEA (const EAType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEA (::std::auto_ptr< EAType > p);

    //@}

    /**
     * @name EI
     *
     * @brief Accessor and modifier functions for the %EI
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EIType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EIType, char > EITraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EIType&
    getEI () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EIType&
    getEI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEI (const EIType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEI (::std::auto_ptr< EIType > p);

    //@}

    /**
     * @name EP
     *
     * @brief Accessor and modifier functions for the %EP
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EPType, char > EPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EPType&
    getEP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EPType&
    getEP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEP (const EPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEP (::std::auto_ptr< EPType > p);

    //@}

    /**
     * @name IN
     *
     * @brief Accessor and modifier functions for the %IN
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType INType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< INType, char > INTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const INType&
    getIN () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    INType&
    getIN ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIN (const INType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setIN (::std::auto_ptr< INType > p);

    //@}

    /**
     * @name INI
     *
     * @brief Accessor and modifier functions for the %INI
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType INIType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< INIType, char > INITraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const INIType&
    getINI () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    INIType&
    getINI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setINI (const INIType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setINI (::std::auto_ptr< INIType > p);

    //@}

    /**
     * @name PERC
     *
     * @brief Accessor and modifier functions for the %PERC
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PERCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PERCType, char > PERCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PERCType&
    getPERC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PERCType&
    getPERC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPERC (const PERCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPERC (::std::auto_ptr< PERCType > p);

    //@}

    /**
     * @name R
     *
     * @brief Accessor and modifier functions for the %R
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RType, char > RTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RType&
    getR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RType&
    getR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setR (const RType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setR (::std::auto_ptr< RType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVLinkComplexType (const CFType&,
                        const EAType&,
                        const EIType&,
                        const EPType&,
                        const INType&,
                        const INIType&,
                        const PERCType&,
                        const RType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVLinkComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVLinkComplexType (const HBVLinkComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVLinkComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVLinkComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CFType > CF_;
    ::xsd::cxx::tree::one< EAType > EA_;
    ::xsd::cxx::tree::one< EIType > EI_;
    ::xsd::cxx::tree::one< EPType > EP_;
    ::xsd::cxx::tree::one< INType > IN_;
    ::xsd::cxx::tree::one< INIType > INI_;
    ::xsd::cxx::tree::one< PERCType > PERC_;
    ::xsd::cxx::tree::one< RType > R_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVStateComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVStateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name IC
     *
     * @brief Accessor and modifier functions for the %IC
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ICType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ICType, char > ICTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ICType&
    getIC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ICType&
    getIC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIC (const ICType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setIC (::std::auto_ptr< ICType > p);

    //@}

    /**
     * @name LZ
     *
     * @brief Accessor and modifier functions for the %LZ
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LZType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LZType, char > LZTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LZType&
    getLZ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LZType&
    getLZ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLZ (const LZType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLZ (::std::auto_ptr< LZType > p);

    //@}

    /**
     * @name SM
     *
     * @brief Accessor and modifier functions for the %SM
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SMType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SMType, char > SMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SMType&
    getSM () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SMType&
    getSM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSM (const SMType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSM (::std::auto_ptr< SMType > p);

    //@}

    /**
     * @name SP
     *
     * @brief Accessor and modifier functions for the %SP
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SPType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SPType, char > SPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SPType&
    getSP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SPType&
    getSP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSP (const SPType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSP (::std::auto_ptr< SPType > p);

    //@}

    /**
     * @name UZ
     *
     * @brief Accessor and modifier functions for the %UZ
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UZType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UZType, char > UZTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const UZType&
    getUZ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    UZType&
    getUZ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUZ (const UZType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setUZ (::std::auto_ptr< UZType > p);

    //@}

    /**
     * @name WC
     *
     * @brief Accessor and modifier functions for the %WC
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType WCType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WCType, char > WCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WCType&
    getWC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WCType&
    getWC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWC (const WCType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWC (::std::auto_ptr< WCType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVStateComplexType (const ICType&,
                         const LZType&,
                         const SMType&,
                         const SPType&,
                         const UZType&,
                         const WCType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVStateComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVStateComplexType (const HBVStateComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVStateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVStateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ICType > IC_;
    ::xsd::cxx::tree::one< LZType > LZ_;
    ::xsd::cxx::tree::one< SMType > SM_;
    ::xsd::cxx::tree::one< SPType > SP_;
    ::xsd::cxx::tree::one< UZType > UZ_;
    ::xsd::cxx::tree::one< WCType > WC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVStateUpdateComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVStateUpdateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name IC
     *
     * @brief Accessor and modifier functions for the %IC
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ICType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ICType > ICOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ICType, char > ICTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ICOptional&
    getIC () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ICOptional&
    getIC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIC (const ICType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIC (const ICOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIC (::std::auto_ptr< ICType > p);

    //@}

    /**
     * @name LZ
     *
     * @brief Accessor and modifier functions for the %LZ
     * optional element.
     *
     * increment on lower zone storage [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LZType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LZType > LZOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LZType, char > LZTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LZOptional&
    getLZ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LZOptional&
    getLZ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLZ (const LZType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLZ (const LZOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLZ (::std::auto_ptr< LZType > p);

    //@}

    /**
     * @name SM
     *
     * @brief Accessor and modifier functions for the %SM
     * optional element.
     *
     * STILL NOT IMPLEMENTED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SMType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SMType > SMOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SMType, char > SMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SMOptional&
    getSM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SMOptional&
    getSM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSM (const SMType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSM (const SMOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSM (::std::auto_ptr< SMType > p);

    //@}

    /**
     * @name SP
     *
     * @brief Accessor and modifier functions for the %SP
     * optional element.
     *
     * STILL NOT IMPLEMENTED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SPType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SPType > SPOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SPType, char > SPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SPOptional&
    getSP () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SPOptional&
    getSP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSP (const SPType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSP (const SPOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSP (::std::auto_ptr< SPType > p);

    //@}

    /**
     * @name UZ
     *
     * @brief Accessor and modifier functions for the %UZ
     * optional element.
     *
     * STILL NOT IMPLEMENTED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UZType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UZType > UZOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UZType, char > UZTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UZOptional&
    getUZ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UZOptional&
    getUZ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUZ (const UZType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUZ (const UZOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUZ (::std::auto_ptr< UZType > p);

    //@}

    /**
     * @name WC
     *
     * @brief Accessor and modifier functions for the %WC
     * optional element.
     *
     * STILL NOT IMPLEMENTED
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType WCType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WCType > WCOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WCType, char > WCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WCOptional&
    getWC () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WCOptional&
    getWC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWC (const WCType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWC (const WCOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWC (::std::auto_ptr< WCType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVStateUpdateComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVStateUpdateComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVStateUpdateComplexType (const HBVStateUpdateComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVStateUpdateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVStateUpdateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ICOptional IC_;
    LZOptional LZ_;
    SMOptional SM_;
    SPOptional SP_;
    UZOptional UZ_;
    WCOptional WC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HBVOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class HBVOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name SMPercentage
     *
     * @brief Accessor and modifier functions for the %SMPercentage
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SMPercentageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SMPercentageType > SMPercentageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SMPercentageType, char > SMPercentageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SMPercentageOptional&
    getSMPercentage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SMPercentageOptional&
    getSMPercentage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSMPercentage (const SMPercentageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSMPercentage (const SMPercentageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSMPercentage (::std::auto_ptr< SMPercentageType > p);

    //@}

    /**
     * @name SWE
     *
     * @brief Accessor and modifier functions for the %SWE
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SWEType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SWEType > SWEOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SWEType, char > SWETraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SWEOptional&
    getSWE () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SWEOptional&
    getSWE ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSWE (const SWEType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSWE (const SWEOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSWE (::std::auto_ptr< SWEType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HBVOutputComplexType (const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HBVOutputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HBVOutputComplexType (const HBVOutputComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HBVOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HBVOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QType > Q_;
    SMPercentageOptional SMPercentage_;
    SWEOptional SWE_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SRMComplexType schema type.
   *
   * @nosubgrouping
   */
  class SRMComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SRMParameterComplexType ParameterType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParameterType&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParameterType&
    getParameter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameter (const ParameterType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameter (::std::auto_ptr< ParameterType > p);

    //@}

    /**
     * @name parameterZone
     *
     * @brief Accessor and modifier functions for the %parameterZone
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SRMParameterZoneComplexType ParameterZoneType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ParameterZoneType > ParameterZoneSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ParameterZoneSequence::iterator ParameterZoneIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ParameterZoneSequence::const_iterator ParameterZoneConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterZoneType, char > ParameterZoneTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ParameterZoneSequence&
    getParameterZone () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ParameterZoneSequence&
    getParameterZone ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setParameterZone (const ParameterZoneSequence& s);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SRMInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name state
     *
     * @brief Accessor and modifier functions for the %state
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SRMStateComplexType StateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StateType&
    getState () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StateType&
    getState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setState (::std::auto_ptr< StateType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SRMOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SRMComplexType (const ParameterType&,
                    const InputType&,
                    const StateType&,
                    const OutputType&,
                    const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SRMComplexType (::std::auto_ptr< ParameterType >&,
                    ::std::auto_ptr< InputType >&,
                    ::std::auto_ptr< StateType >&,
                    ::std::auto_ptr< OutputType >&,
                    const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SRMComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SRMComplexType (const SRMComplexType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SRMComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SRMComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ParameterType > parameter_;
    ParameterZoneSequence parameterZone_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< StateType > state_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SRMParameterComplexType schema type.
   *
   * @nosubgrouping
   */
  class SRMParameterComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Pt
     *
     * @brief Accessor and modifier functions for the %Pt
     * required element.
     *
     * precipitation threshold [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType PtType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PtType, char > PtTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PtType&
    getPt () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PtType&
    getPt ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPt (const PtType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPt (::std::auto_ptr< PtType > p);

    //@}

    /**
     * @name TLag
     *
     * @brief Accessor and modifier functions for the %TLag
     * required element.
     *
     * Time lag of input data [h]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TLagType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TLagType, char > TLagTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TLagType&
    getTLag () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TLagType&
    getTLag ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTLag (const TLagType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTLag (::std::auto_ptr< TLagType > p);

    //@}

    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     *
     * recession coefficient 1
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     *
     * recession coefficient 2
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SRMParameterComplexType (const PtType&,
                             const TLagType&,
                             const XType&,
                             const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SRMParameterComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SRMParameterComplexType (const SRMParameterComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SRMParameterComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SRMParameterComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PtType > Pt_;
    ::xsd::cxx::tree::one< TLagType > TLag_;
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SRMParameterZoneComplexType schema type.
   *
   * @nosubgrouping
   */
  class SRMParameterZoneComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required element.
     *
     * degree day factor [mm/(oC*day)]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AType&
    getA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA (const AType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setA (::std::auto_ptr< AType > p);

    //@}

    /**
     * @name area
     *
     * @brief Accessor and modifier functions for the %area
     * required element.
     *
     * area [km2]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AreaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AreaType, char > AreaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AreaType&
    getArea () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AreaType&
    getArea ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setArea (const AreaType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setArea (::std::auto_ptr< AreaType > p);

    //@}

    /**
     * @name Tcr1
     *
     * @brief Accessor and modifier functions for the %Tcr1
     * required element.
     *
     * critical temperature (???) [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Tcr1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Tcr1Type, char > Tcr1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const Tcr1Type&
    getTcr1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    Tcr1Type&
    getTcr1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTcr1 (const Tcr1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTcr1 (::std::auto_ptr< Tcr1Type > p);

    //@}

    /**
     * @name Tcr2
     *
     * @brief Accessor and modifier functions for the %Tcr2
     * required element.
     *
     * critical temperature (???) [oC]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType Tcr2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Tcr2Type, char > Tcr2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const Tcr2Type&
    getTcr2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    Tcr2Type&
    getTcr2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTcr2 (const Tcr2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTcr2 (::std::auto_ptr< Tcr2Type > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdOptional&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    IdOptional&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setId (const IdOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SRMParameterZoneComplexType (const AType&,
                                 const AreaType&,
                                 const Tcr1Type&,
                                 const Tcr2Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SRMParameterZoneComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SRMParameterZoneComplexType (const SRMParameterZoneComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SRMParameterZoneComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SRMParameterZoneComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AType > a_;
    ::xsd::cxx::tree::one< AreaType > area_;
    ::xsd::cxx::tree::one< Tcr1Type > Tcr1_;
    ::xsd::cxx::tree::one< Tcr2Type > Tcr2_;
    IdOptional id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SRMInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class SRMInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name P
     *
     * @brief Accessor and modifier functions for the %P
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PType > POptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const POptional&
    getP () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    POptional&
    getP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setP (const PType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setP (const POptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setP (::std::auto_ptr< PType > p);

    //@}

    /**
     * @name P-Vector
     *
     * @brief Accessor and modifier functions for the %P-Vector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType P_VectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< P_VectorType > P_VectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< P_VectorType, char > P_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const P_VectorOptional&
    getP_Vector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    P_VectorOptional&
    getP_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setP_Vector (const P_VectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setP_Vector (const P_VectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setP_Vector (::std::auto_ptr< P_VectorType > p);

    //@}

    /**
     * @name T
     *
     * @brief Accessor and modifier functions for the %T
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TType > TOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TType, char > TTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TOptional&
    getT () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TOptional&
    getT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setT (const TType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setT (const TOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setT (::std::auto_ptr< TType > p);

    //@}

    /**
     * @name T-Vector
     *
     * @brief Accessor and modifier functions for the %T-Vector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType T_VectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< T_VectorType > T_VectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< T_VectorType, char > T_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const T_VectorOptional&
    getT_Vector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    T_VectorOptional&
    getT_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setT_Vector (const T_VectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setT_Vector (const T_VectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setT_Vector (::std::auto_ptr< T_VectorType > p);

    //@}

    /**
     * @name SCA
     *
     * @brief Accessor and modifier functions for the %SCA
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SCAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SCAType > SCAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SCAType, char > SCATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SCAOptional&
    getSCA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SCAOptional&
    getSCA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSCA (const SCAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSCA (const SCAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSCA (::std::auto_ptr< SCAType > p);

    //@}

    /**
     * @name SCA-Vector
     *
     * @brief Accessor and modifier functions for the %SCA-Vector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SCA_VectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SCA_VectorType > SCA_VectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SCA_VectorType, char > SCA_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SCA_VectorOptional&
    getSCA_Vector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SCA_VectorOptional&
    getSCA_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSCA_Vector (const SCA_VectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSCA_Vector (const SCA_VectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSCA_Vector (::std::auto_ptr< SCA_VectorType > p);

    //@}

    /**
     * @name RCA
     *
     * @brief Accessor and modifier functions for the %RCA
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RCAType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RCAType > RCAOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RCAType, char > RCATraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RCAOptional&
    getRCA () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RCAOptional&
    getRCA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRCA (const RCAType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRCA (const RCAOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRCA (::std::auto_ptr< RCAType > p);

    //@}

    /**
     * @name RCA-Vector
     *
     * @brief Accessor and modifier functions for the %RCA-Vector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RCA_VectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RCA_VectorType > RCA_VectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RCA_VectorType, char > RCA_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RCA_VectorOptional&
    getRCA_Vector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RCA_VectorOptional&
    getRCA_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRCA_Vector (const RCA_VectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRCA_Vector (const RCA_VectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRCA_Vector (::std::auto_ptr< RCA_VectorType > p);

    //@}

    /**
     * @name cr
     *
     * @brief Accessor and modifier functions for the %cr
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType CrType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CrType > CrOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CrType, char > CrTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CrOptional&
    getCr () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CrOptional&
    getCr ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCr (const CrType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCr (const CrOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCr (::std::auto_ptr< CrType > p);

    //@}

    /**
     * @name cr-Vector
     *
     * @brief Accessor and modifier functions for the %cr-Vector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType Cr_VectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Cr_VectorType > Cr_VectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Cr_VectorType, char > Cr_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Cr_VectorOptional&
    getCr_Vector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Cr_VectorOptional&
    getCr_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCr_Vector (const Cr_VectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCr_Vector (const Cr_VectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCr_Vector (::std::auto_ptr< Cr_VectorType > p);

    //@}

    /**
     * @name cs
     *
     * @brief Accessor and modifier functions for the %cs
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType CsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CsType > CsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CsType, char > CsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CsOptional&
    getCs () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CsOptional&
    getCs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCs (const CsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCs (const CsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCs (::std::auto_ptr< CsType > p);

    //@}

    /**
     * @name cs-Vector
     *
     * @brief Accessor and modifier functions for the %cs-Vector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType Cs_VectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Cs_VectorType > Cs_VectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Cs_VectorType, char > Cs_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Cs_VectorOptional&
    getCs_Vector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Cs_VectorOptional&
    getCs_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCs_Vector (const Cs_VectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCs_Vector (const Cs_VectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCs_Vector (::std::auto_ptr< Cs_VectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SRMInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SRMInputComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SRMInputComplexType (const SRMInputComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SRMInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SRMInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    POptional P_;
    P_VectorOptional P_Vector_;
    TOptional T_;
    T_VectorOptional T_Vector_;
    SCAOptional SCA_;
    SCA_VectorOptional SCA_Vector_;
    RCAOptional RCA_;
    RCA_VectorOptional RCA_Vector_;
    CrOptional cr_;
    Cr_VectorOptional cr_Vector_;
    CsOptional cs_;
    Cs_VectorOptional cs_Vector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SRMStateComplexType schema type.
   *
   * @nosubgrouping
   */
  class SRMStateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name PStorage-Vector
     *
     * @brief Accessor and modifier functions for the %PStorage-Vector
     * required element.
     *
     * snow storage of non-snow-covered areas [mm]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PStorage_VectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PStorage_VectorType, char > PStorage_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PStorage_VectorType&
    getPStorage_Vector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PStorage_VectorType&
    getPStorage_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPStorage_Vector (const PStorage_VectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPStorage_Vector (::std::auto_ptr< PStorage_VectorType > p);

    //@}

    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     *
     * discharge [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SRMStateComplexType (const PStorage_VectorType&,
                         const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SRMStateComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SRMStateComplexType (const SRMStateComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SRMStateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SRMStateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PStorage_VectorType > PStorage_Vector_;
    ::xsd::cxx::tree::one< QType > Q_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SRMOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class SRMOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name QRain-Vector
     *
     * @brief Accessor and modifier functions for the %QRain-Vector
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QRain_VectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QRain_VectorType, char > QRain_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QRain_VectorType&
    getQRain_Vector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QRain_VectorType&
    getQRain_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQRain_Vector (const QRain_VectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQRain_Vector (::std::auto_ptr< QRain_VectorType > p);

    //@}

    /**
     * @name QSnow-Vector
     *
     * @brief Accessor and modifier functions for the %QSnow-Vector
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QSnow_VectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSnow_VectorType, char > QSnow_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QSnow_VectorType&
    getQSnow_Vector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QSnow_VectorType&
    getQSnow_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQSnow_Vector (const QSnow_VectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQSnow_Vector (::std::auto_ptr< QSnow_VectorType > p);

    //@}

    /**
     * @name QStorage-Vector
     *
     * @brief Accessor and modifier functions for the %QStorage-Vector
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QStorage_VectorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QStorage_VectorType, char > QStorage_VectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QStorage_VectorType&
    getQStorage_Vector () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QStorage_VectorType&
    getQStorage_Vector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQStorage_Vector (const QStorage_VectorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQStorage_Vector (::std::auto_ptr< QStorage_VectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SRMOutputComplexType (const QRain_VectorType&,
                          const QSnow_VectorType&,
                          const QStorage_VectorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SRMOutputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SRMOutputComplexType (const SRMOutputComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SRMOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SRMOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QRain_VectorType > QRain_Vector_;
    ::xsd::cxx::tree::one< QSnow_VectorType > QSnow_Vector_;
    ::xsd::cxx::tree::one< QStorage_VectorType > QStorage_Vector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitDelayComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitDelayComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nStep
     *
     * @brief Accessor and modifier functions for the %nStep
     * optional element.
     *
     * nStep optionally provides a delay with an arbitrary numer of time
     * steps or sub time step, i.e. 1.5 time steps, if being used also
     * specify the yFinal tag in the output options
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType NStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepType > NStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepType, char > NStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepOptional&
    getNStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NStepOptional&
    getNStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNStep (const NStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNStep (const NStepOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStep (::std::auto_ptr< NStepType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitDelayInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     *
     * The configuration of a multiple unit delay requires the configuration
     * of a time series for each delay time step
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitDelayOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitDelayComplexType (const InputType&,
                          const OutputType&,
                          const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    UnitDelayComplexType (::std::auto_ptr< InputType >&,
                          ::std::auto_ptr< OutputType >&,
                          const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitDelayComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitDelayComplexType (const UnitDelayComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitDelayComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitDelayComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NStepOptional nStep_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitDelayInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitDelayInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitDelayInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitDelayInputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitDelayInputComplexType (const UnitDelayInputComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitDelayInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitDelayInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitDelayOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitDelayOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< YType > YSequence;

    /**
     * @brief Element iterator type.
     */
    typedef YSequence::iterator YIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef YSequence::const_iterator YConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const YSequence&
    getY () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    YSequence&
    getY ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setY (const YSequence& s);

    //@}

    /**
     * @name yVector
     *
     * @brief Accessor and modifier functions for the %yVector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YVectorType > YVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YVectorType, char > YVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YVectorOptional&
    getYVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YVectorOptional&
    getYVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYVector (const YVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYVector (const YVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYVector (::std::auto_ptr< YVectorType > p);

    //@}

    /**
     * @name yFinal
     *
     * @brief Accessor and modifier functions for the %yFinal
     * optional element.
     *
     * optional result of the delay operator, identical to yVector[end] if
     * the delay is a multiple of the time step, required in case of sub time
     * steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YFinalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YFinalType > YFinalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YFinalType, char > YFinalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YFinalOptional&
    getYFinal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YFinalOptional&
    getYFinal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYFinal (const YFinalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYFinal (const YFinalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYFinal (::std::auto_ptr< YFinalType > p);

    //@}

    /**
     * @name yMin
     *
     * @brief Accessor and modifier functions for the %yMin
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YMinType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMinType > YMinOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMinType, char > YMinTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMinOptional&
    getYMin () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMinOptional&
    getYMin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMin (const YMinType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMin (const YMinOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYMin (::std::auto_ptr< YMinType > p);

    //@}

    /**
     * @name yMean
     *
     * @brief Accessor and modifier functions for the %yMean
     * optional element.
     *
     * optional mean of input and outputs
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YMeanType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMeanType > YMeanOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMeanType, char > YMeanTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMeanOptional&
    getYMean () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMeanOptional&
    getYMean ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMean (const YMeanType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMean (const YMeanOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYMean (::std::auto_ptr< YMeanType > p);

    //@}

    /**
     * @name yMax
     *
     * @brief Accessor and modifier functions for the %yMax
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YMaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMaxType > YMaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMaxType, char > YMaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMaxOptional&
    getYMax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMaxOptional&
    getYMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMax (const YMaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMax (const YMaxOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYMax (::std::auto_ptr< YMaxType > p);

    //@}

    /**
     * @name ySum
     *
     * @brief Accessor and modifier functions for the %ySum
     * optional element.
     *
     * optional sum of input and outputs
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YSumType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YSumType > YSumOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YSumType, char > YSumTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YSumOptional&
    getYSum () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YSumOptional&
    getYSum ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYSum (const YSumType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYSum (const YSumOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYSum (::std::auto_ptr< YSumType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitDelayOutputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitDelayOutputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitDelayOutputComplexType (const UnitDelayOutputComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitDelayOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitDelayOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    YSequence y_;
    YVectorOptional yVector_;
    YFinalOptional yFinal_;
    YMinOptional yMin_;
    YMeanOptional yMean_;
    YMaxOptional yMax_;
    YSumOptional ySum_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitHydrographComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitHydrographComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name weights
     *
     * @brief Accessor and modifier functions for the %weights
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitHydrographWeightComplexType WeightsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightsType, char > WeightsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WeightsType&
    getWeights () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WeightsType&
    getWeights ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeights (const WeightsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWeights (::std::auto_ptr< WeightsType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitHydrographInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitHydrographOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitHydrographComplexType (const WeightsType&,
                               const InputType&,
                               const OutputType&,
                               const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    UnitHydrographComplexType (::std::auto_ptr< WeightsType >&,
                               ::std::auto_ptr< InputType >&,
                               ::std::auto_ptr< OutputType >&,
                               const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitHydrographComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitHydrographComplexType (const UnitHydrographComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitHydrographComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitHydrographComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< WeightsType > weights_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitHydrographWeightComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitHydrographWeightComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name triangular
     *
     * @brief Accessor and modifier functions for the %triangular
     * optional element.
     *
     * weights with triangular shape
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitHydrographWeightTriangularComplexType TriangularType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TriangularType > TriangularOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TriangularType, char > TriangularTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TriangularOptional&
    getTriangular () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TriangularOptional&
    getTriangular ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTriangular (const TriangularType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTriangular (const TriangularOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTriangular (::std::auto_ptr< TriangularType > p);

    //@}

    /**
     * @name custom
     *
     * @brief Accessor and modifier functions for the %custom
     * optional element.
     *
     * user-defined weights
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitHydrographWeightCustomComplexType CustomType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CustomType > CustomOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CustomType, char > CustomTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CustomOptional&
    getCustom () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CustomOptional&
    getCustom ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCustom (const CustomType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCustom (const CustomOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCustom (::std::auto_ptr< CustomType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitHydrographWeightComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitHydrographWeightComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitHydrographWeightComplexType (const UnitHydrographWeightComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitHydrographWeightComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitHydrographWeightComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TriangularOptional triangular_;
    CustomOptional custom_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitHydrographWeightTriangularComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitHydrographWeightTriangularComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nSteps
     *
     * @brief Accessor and modifier functions for the %nSteps
     * required element.
     *
     * number of time steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType NStepsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepsType, char > NStepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NStepsType&
    getNSteps () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NStepsType&
    getNSteps ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNSteps (const NStepsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNSteps (::std::auto_ptr< NStepsType > p);

    //@}

    /**
     * @name factor
     *
     * @brief Accessor and modifier functions for the %factor
     * optional element.
     *
     * sum of all weight, if not equal to 1.0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double FactorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FactorType > FactorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorType, char, ::xsd::cxx::tree::schema_type::double_ > FactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FactorOptional&
    getFactor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FactorOptional&
    getFactor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFactor (const FactorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFactor (const FactorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static FactorType
    getFactorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitHydrographWeightTriangularComplexType (const NStepsType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitHydrographWeightTriangularComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitHydrographWeightTriangularComplexType (const UnitHydrographWeightTriangularComplexType& x,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitHydrographWeightTriangularComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitHydrographWeightTriangularComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NStepsType > nSteps_;
    FactorOptional factor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitHydrographWeightCustomComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitHydrographWeightCustomComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * sequence element.
     *
     * user defined weights
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double WeightType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WeightType > WeightSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WeightSequence::iterator WeightIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WeightSequence::const_iterator WeightConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightType, char, ::xsd::cxx::tree::schema_type::double_ > WeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WeightSequence&
    getWeight () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WeightSequence&
    getWeight ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWeight (const WeightSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitHydrographWeightCustomComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitHydrographWeightCustomComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitHydrographWeightCustomComplexType (const UnitHydrographWeightCustomComplexType& x,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitHydrographWeightCustomComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitHydrographWeightCustomComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WeightSequence weight_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitHydrographInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitHydrographInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitHydrographInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitHydrographInputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitHydrographInputComplexType (const UnitHydrographInputComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitHydrographInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitHydrographInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UnitHydrographOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class UnitHydrographOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name xDelay
     *
     * @brief Accessor and modifier functions for the %xDelay
     * sequence element.
     *
     * definition of individual time series for vector with delays, configure
     * one element less than weights defined above
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XDelayType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< XDelayType > XDelaySequence;

    /**
     * @brief Element iterator type.
     */
    typedef XDelaySequence::iterator XDelayIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef XDelaySequence::const_iterator XDelayConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XDelayType, char > XDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const XDelaySequence&
    getXDelay () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    XDelaySequence&
    getXDelay ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setXDelay (const XDelaySequence& s);

    //@}

    /**
     * @name xDelayVector
     *
     * @brief Accessor and modifier functions for the %xDelayVector
     * optional element.
     *
     * definition of delay vector, configure one element less than weights
     * defined above
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XDelayVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< XDelayVectorType > XDelayVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XDelayVectorType, char > XDelayVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const XDelayVectorOptional&
    getXDelayVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    XDelayVectorOptional&
    getXDelayVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setXDelayVector (const XDelayVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setXDelayVector (const XDelayVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setXDelayVector (::std::auto_ptr< XDelayVectorType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     *
     * result of unit hydrograph
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UnitHydrographOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitHydrographOutputComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitHydrographOutputComplexType (const UnitHydrographOutputComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitHydrographOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UnitHydrographOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    XDelaySequence xDelay_;
    XDelayVectorOptional xDelayVector_;
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirCompactComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirCompactComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name units
     *
     * @brief Accessor and modifier functions for the %units
     * optional element.
     *
     * "SI" or "Imperial" units
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitTypeEnumStringType UnitsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnitsType > UnitsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitsType, char > UnitsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnitsOptional&
    getUnits () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UnitsOptional&
    getUnits ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUnits (const UnitsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUnits (const UnitsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnits (::std::auto_ptr< UnitsType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const UnitsType&
    getUnitsDefaultValue ();

    //@}

    /**
     * @name levelStorageTable
     *
     * @brief Accessor and modifier functions for the %levelStorageTable
     * optional element.
     *
     * level-storage relation of the reservoir, level in [m] or [ft], storage
     * in [m3] or [KCFS-hrs]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType LevelStorageTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LevelStorageTableType > LevelStorageTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelStorageTableType, char > LevelStorageTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LevelStorageTableOptional&
    getLevelStorageTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LevelStorageTableOptional&
    getLevelStorageTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevelStorageTable (const LevelStorageTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLevelStorageTable (const LevelStorageTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLevelStorageTable (::std::auto_ptr< LevelStorageTableType > p);

    //@}

    /**
     * @name levelStorageTableExternal
     *
     * @brief Accessor and modifier functions for the %levelStorageTableExternal
     * optional element.
     *
     * externalizes the level storage table to a parameter file, requires the
     * two columns "level" and "storage"
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String LevelStorageTableExternalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LevelStorageTableExternalType > LevelStorageTableExternalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelStorageTableExternalType, char > LevelStorageTableExternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LevelStorageTableExternalOptional&
    getLevelStorageTableExternal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LevelStorageTableExternalOptional&
    getLevelStorageTableExternal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevelStorageTableExternal (const LevelStorageTableExternalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLevelStorageTableExternal (const LevelStorageTableExternalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLevelStorageTableExternal (::std::auto_ptr< LevelStorageTableExternalType > p);

    //@}

    /**
     * @name levelStorageEquation
     *
     * @brief Accessor and modifier functions for the %levelStorageEquation
     * optional element.
     *
     * level storage equation according to S = A0 + A1*FB ( + A2*FB^2 + ...)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LevelStorageEquationComplexType LevelStorageEquationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LevelStorageEquationType > LevelStorageEquationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelStorageEquationType, char > LevelStorageEquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LevelStorageEquationOptional&
    getLevelStorageEquation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LevelStorageEquationOptional&
    getLevelStorageEquation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevelStorageEquation (const LevelStorageEquationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLevelStorageEquation (const LevelStorageEquationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLevelStorageEquation (::std::auto_ptr< LevelStorageEquationType > p);

    //@}

    /**
     * @name tailwaterTable
     *
     * @brief Accessor and modifier functions for the %tailwaterTable
     * optional element.
     *
     * tailwater as a function of the reservoir release only
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType TailwaterTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterTableType > TailwaterTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterTableType, char > TailwaterTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterTableOptional&
    getTailwaterTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterTableOptional&
    getTailwaterTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwaterTable (const TailwaterTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwaterTable (const TailwaterTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwaterTable (::std::auto_ptr< TailwaterTableType > p);

    //@}

    /**
     * @name tailwaterEquation
     *
     * @brief Accessor and modifier functions for the %tailwaterEquation
     * optional element.
     *
     * tailwater equation according to TW = A + B*FB_downstream(t-1) +
     * C*Q(t)^D, D is equal 1.0 by default if not provided
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TailwaterEquationComplexType TailwaterEquationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterEquationType > TailwaterEquationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterEquationType, char > TailwaterEquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterEquationOptional&
    getTailwaterEquation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterEquationOptional&
    getTailwaterEquation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwaterEquation (const TailwaterEquationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwaterEquation (const TailwaterEquationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwaterEquation (::std::auto_ptr< TailwaterEquationType > p);

    //@}

    /**
     * @name tailwaterTidalEquation
     *
     * @brief Accessor and modifier functions for the %tailwaterTidalEquation
     * optional element.
     *
     * tidal influenced tailwater equation (works only in hindcast mode, use
     * tailwater external with appropiate forecast of the tailwater in
     * operational forecasting), TW = TWObs + A*(Q-QObs)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TailwaterTidalEquationComplexType TailwaterTidalEquationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterTidalEquationType > TailwaterTidalEquationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterTidalEquationType, char > TailwaterTidalEquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterTidalEquationOptional&
    getTailwaterTidalEquation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterTidalEquationOptional&
    getTailwaterTidalEquation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwaterTidalEquation (const TailwaterTidalEquationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwaterTidalEquation (const TailwaterTidalEquationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwaterTidalEquation (::std::auto_ptr< TailwaterTidalEquationType > p);

    //@}

    /**
     * @name tailwaterExternalTable
     *
     * @brief Accessor and modifier functions for the %tailwaterExternalTable
     * optional element.
     *
     * external tailwater table
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String TailwaterExternalTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterExternalTableType > TailwaterExternalTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterExternalTableType, char > TailwaterExternalTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterExternalTableOptional&
    getTailwaterExternalTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterExternalTableOptional&
    getTailwaterExternalTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwaterExternalTable (const TailwaterExternalTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwaterExternalTable (const TailwaterExternalTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwaterExternalTable (::std::auto_ptr< TailwaterExternalTableType > p);

    //@}

    /**
     * @name tailwaterExternalTimeSeries
     *
     * @brief Accessor and modifier functions for the %tailwaterExternalTimeSeries
     * optional element.
     *
     * external tailwater elevation from an external source or a previous
     * calculation OUTSIDE of the reservoirCompact components
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TailwaterExternalTimeSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterExternalTimeSeriesType > TailwaterExternalTimeSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterExternalTimeSeriesType, char > TailwaterExternalTimeSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterExternalTimeSeriesOptional&
    getTailwaterExternalTimeSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterExternalTimeSeriesOptional&
    getTailwaterExternalTimeSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwaterExternalTimeSeries (const TailwaterExternalTimeSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwaterExternalTimeSeries (const TailwaterExternalTimeSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwaterExternalTimeSeries (::std::auto_ptr< TailwaterExternalTimeSeriesType > p);

    //@}

    /**
     * @name tailwaterConstant
     *
     * @brief Accessor and modifier functions for the %tailwaterConstant
     * optional element.
     *
     * constant value for tailwater elevation
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TailwaterConstantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterConstantType > TailwaterConstantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterConstantType, char > TailwaterConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterConstantOptional&
    getTailwaterConstant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterConstantOptional&
    getTailwaterConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwaterConstant (const TailwaterConstantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwaterConstant (const TailwaterConstantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwaterConstant (::std::auto_ptr< TailwaterConstantType > p);

    //@}

    /**
     * @name turbineEfficiencyConstant
     *
     * @brief Accessor and modifier functions for the %turbineEfficiencyConstant
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType TurbineEfficiencyConstantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TurbineEfficiencyConstantType > TurbineEfficiencyConstantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TurbineEfficiencyConstantType, char > TurbineEfficiencyConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TurbineEfficiencyConstantOptional&
    getTurbineEfficiencyConstant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TurbineEfficiencyConstantOptional&
    getTurbineEfficiencyConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTurbineEfficiencyConstant (const TurbineEfficiencyConstantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTurbineEfficiencyConstant (const TurbineEfficiencyConstantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTurbineEfficiencyConstant (::std::auto_ptr< TurbineEfficiencyConstantType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const TurbineEfficiencyConstantType&
    getTurbineEfficiencyConstantDefaultValue ();

    //@}

    /**
     * @name turbineEfficiencyTable
     *
     * @brief Accessor and modifier functions for the %turbineEfficiencyTable
     * optional element.
     *
     * old formulation, will be removed in the future
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType TurbineEfficiencyTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TurbineEfficiencyTableType > TurbineEfficiencyTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TurbineEfficiencyTableType, char > TurbineEfficiencyTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TurbineEfficiencyTableOptional&
    getTurbineEfficiencyTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TurbineEfficiencyTableOptional&
    getTurbineEfficiencyTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTurbineEfficiencyTable (const TurbineEfficiencyTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTurbineEfficiencyTable (const TurbineEfficiencyTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTurbineEfficiencyTable (::std::auto_ptr< TurbineEfficiencyTableType > p);

    //@}

    /**
     * @name turbineEfficiencyTableExternal
     *
     * @brief Accessor and modifier functions for the %turbineEfficiencyTableExternal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String TurbineEfficiencyTableExternalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TurbineEfficiencyTableExternalType > TurbineEfficiencyTableExternalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TurbineEfficiencyTableExternalType, char > TurbineEfficiencyTableExternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TurbineEfficiencyTableExternalOptional&
    getTurbineEfficiencyTableExternal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TurbineEfficiencyTableExternalOptional&
    getTurbineEfficiencyTableExternal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTurbineEfficiencyTableExternal (const TurbineEfficiencyTableExternalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTurbineEfficiencyTableExternal (const TurbineEfficiencyTableExternalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTurbineEfficiencyTableExternal (::std::auto_ptr< TurbineEfficiencyTableExternalType > p);

    //@}

    /**
     * @name turbineEfficiencyTable2D
     *
     * @brief Accessor and modifier functions for the %turbineEfficiencyTable2D
     * optional element.
     *
     * new formulation, turbine effiency depends on head and turbine release,
     * computation by 2D lookup
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineEfficiencyTableComplexType TurbineEfficiencyTable2DType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TurbineEfficiencyTable2DType > TurbineEfficiencyTable2DOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TurbineEfficiencyTable2DType, char > TurbineEfficiencyTable2DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TurbineEfficiencyTable2DOptional&
    getTurbineEfficiencyTable2D () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TurbineEfficiencyTable2DOptional&
    getTurbineEfficiencyTable2D ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTurbineEfficiencyTable2D (const TurbineEfficiencyTable2DType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTurbineEfficiencyTable2D (const TurbineEfficiencyTable2DOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTurbineEfficiencyTable2D (::std::auto_ptr< TurbineEfficiencyTable2DType > p);

    //@}

    /**
     * @name turbineEfficiencyTable2DExternal
     *
     * @brief Accessor and modifier functions for the %turbineEfficiencyTable2DExternal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String TurbineEfficiencyTable2DExternalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TurbineEfficiencyTable2DExternalType > TurbineEfficiencyTable2DExternalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TurbineEfficiencyTable2DExternalType, char > TurbineEfficiencyTable2DExternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TurbineEfficiencyTable2DExternalOptional&
    getTurbineEfficiencyTable2DExternal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TurbineEfficiencyTable2DExternalOptional&
    getTurbineEfficiencyTable2DExternal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTurbineEfficiencyTable2DExternal (const TurbineEfficiencyTable2DExternalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTurbineEfficiencyTable2DExternal (const TurbineEfficiencyTable2DExternalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTurbineEfficiencyTable2DExternal (::std::auto_ptr< TurbineEfficiencyTable2DExternalType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     *
     * input time series
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirCompactInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     *
     * output time series
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirCompactOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirCompactComplexType (const InputType&,
                                 const OutputType&,
                                 const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReservoirCompactComplexType (::std::auto_ptr< InputType >&,
                                 ::std::auto_ptr< OutputType >&,
                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirCompactComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirCompactComplexType (const ReservoirCompactComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirCompactComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirCompactComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UnitsOptional units_;
    static const UnitsType units_default_value_;
    LevelStorageTableOptional levelStorageTable_;
    LevelStorageTableExternalOptional levelStorageTableExternal_;
    LevelStorageEquationOptional levelStorageEquation_;
    TailwaterTableOptional tailwaterTable_;
    TailwaterEquationOptional tailwaterEquation_;
    TailwaterTidalEquationOptional tailwaterTidalEquation_;
    TailwaterExternalTableOptional tailwaterExternalTable_;
    TailwaterExternalTimeSeriesOptional tailwaterExternalTimeSeries_;
    TailwaterConstantOptional tailwaterConstant_;
    TurbineEfficiencyConstantOptional turbineEfficiencyConstant_;
    static const TurbineEfficiencyConstantType turbineEfficiencyConstant_default_value_;
    TurbineEfficiencyTableOptional turbineEfficiencyTable_;
    TurbineEfficiencyTableExternalOptional turbineEfficiencyTableExternal_;
    TurbineEfficiencyTable2DOptional turbineEfficiencyTable2D_;
    TurbineEfficiencyTable2DExternalOptional turbineEfficiencyTable2DExternal_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LevelStorageEquationComplexType schema type.
   *
   * @nosubgrouping
   */
  class LevelStorageEquationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name A0
     *
     * @brief Accessor and modifier functions for the %A0
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double A0Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< A0Type, char, ::xsd::cxx::tree::schema_type::double_ > A0Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const A0Type&
    getA0 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    A0Type&
    getA0 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA0 (const A0Type& x);

    //@}

    /**
     * @name A1
     *
     * @brief Accessor and modifier functions for the %A1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double A1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< A1Type, char, ::xsd::cxx::tree::schema_type::double_ > A1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const A1Type&
    getA1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    A1Type&
    getA1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA1 (const A1Type& x);

    //@}

    /**
     * @name A2
     *
     * @brief Accessor and modifier functions for the %A2
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double A2Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< A2Type > A2Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< A2Type, char, ::xsd::cxx::tree::schema_type::double_ > A2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const A2Optional&
    getA2 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    A2Optional&
    getA2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA2 (const A2Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setA2 (const A2Optional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static A2Type
    getA2DefaultValue ();

    //@}

    /**
     * @name A3
     *
     * @brief Accessor and modifier functions for the %A3
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double A3Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< A3Type > A3Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< A3Type, char, ::xsd::cxx::tree::schema_type::double_ > A3Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const A3Optional&
    getA3 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    A3Optional&
    getA3 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA3 (const A3Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setA3 (const A3Optional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static A3Type
    getA3DefaultValue ();

    //@}

    /**
     * @name A4
     *
     * @brief Accessor and modifier functions for the %A4
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double A4Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< A4Type > A4Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< A4Type, char, ::xsd::cxx::tree::schema_type::double_ > A4Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const A4Optional&
    getA4 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    A4Optional&
    getA4 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA4 (const A4Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setA4 (const A4Optional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static A4Type
    getA4DefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LevelStorageEquationComplexType (const A0Type&,
                                     const A1Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LevelStorageEquationComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LevelStorageEquationComplexType (const LevelStorageEquationComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LevelStorageEquationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LevelStorageEquationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< A0Type > A0_;
    ::xsd::cxx::tree::one< A1Type > A1_;
    A2Optional A2_;
    A3Optional A3_;
    A4Optional A4_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TailwaterEquationComplexType schema type.
   *
   * @nosubgrouping
   */
  class TailwaterEquationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name A
     *
     * @brief Accessor and modifier functions for the %A
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AType&
    getA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA (const AType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setA (::std::auto_ptr< AType > p);

    //@}

    /**
     * @name B
     *
     * @brief Accessor and modifier functions for the %B
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BType, char > BTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BType&
    getB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BType&
    getB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setB (const BType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setB (::std::auto_ptr< BType > p);

    //@}

    /**
     * @name C
     *
     * @brief Accessor and modifier functions for the %C
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CType&
    getC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CType&
    getC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setC (const CType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setC (::std::auto_ptr< CType > p);

    //@}

    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType DType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DType > DOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DOptional&
    getD () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DOptional&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setD (const DOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const DType&
    getDDefaultValue ();

    //@}

    /**
     * @name FBDown
     *
     * @brief Accessor and modifier functions for the %FBDown
     * optional element.
     *
     * time series reference to forebay elevation of the downstream project,
     * only required if B is non-zero
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FBDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FBDownType > FBDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FBDownType, char > FBDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FBDownOptional&
    getFBDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FBDownOptional&
    getFBDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFBDown (const FBDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFBDown (const FBDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFBDown (::std::auto_ptr< FBDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TailwaterEquationComplexType (const AType&,
                                  const BType&,
                                  const CType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TailwaterEquationComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TailwaterEquationComplexType (const TailwaterEquationComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TailwaterEquationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TailwaterEquationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AType > A_;
    ::xsd::cxx::tree::one< BType > B_;
    ::xsd::cxx::tree::one< CType > C_;
    DOptional D_;
    static const DType D_default_value_;
    FBDownOptional FBDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TailwaterTidalEquationComplexType schema type.
   *
   * @nosubgrouping
   */
  class TailwaterTidalEquationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name A
     *
     * @brief Accessor and modifier functions for the %A
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AType&
    getA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA (const AType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setA (::std::auto_ptr< AType > p);

    //@}

    /**
     * @name TWObs
     *
     * @brief Accessor and modifier functions for the %TWObs
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TWObsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TWObsType, char > TWObsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TWObsType&
    getTWObs () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TWObsType&
    getTWObs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTWObs (const TWObsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTWObs (::std::auto_ptr< TWObsType > p);

    //@}

    /**
     * @name QObs
     *
     * @brief Accessor and modifier functions for the %QObs
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QObsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QObsType, char > QObsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QObsType&
    getQObs () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QObsType&
    getQObs ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQObs (const QObsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQObs (::std::auto_ptr< QObsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TailwaterTidalEquationComplexType (const AType&,
                                       const TWObsType&,
                                       const QObsType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TailwaterTidalEquationComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TailwaterTidalEquationComplexType (const TailwaterTidalEquationComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TailwaterTidalEquationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TailwaterTidalEquationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AType > A_;
    ::xsd::cxx::tree::one< TWObsType > TWObs_;
    ::xsd::cxx::tree::one< QObsType > QObs_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineEfficiencyTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineEfficiencyTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name columns
     *
     * @brief Accessor and modifier functions for the %columns
     * required element.
     *
     * column Ids refering to the head [m] of each column
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ColumnsComplexType ColumnsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ColumnsType, char > ColumnsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ColumnsType&
    getColumns () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ColumnsType&
    getColumns ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setColumns (const ColumnsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setColumns (::std::auto_ptr< ColumnsType > p);

    //@}

    /**
     * @name row
     *
     * @brief Accessor and modifier functions for the %row
     * sequence element.
     *
     * rows with turbine efficiency (related to the head coloumn) for a given
     * flow
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RowComplexType RowType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RowType > RowSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RowSequence::iterator RowIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RowSequence::const_iterator RowConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RowType, char > RowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RowSequence&
    getRow () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RowSequence&
    getRow ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRow (const RowSequence& s);

    //@}

    /**
     * @name maxFlows
     *
     * @brief Accessor and modifier functions for the %maxFlows
     * required element.
     *
     * maximum flow for a given head (provided above)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MaxFlowsComplexType MaxFlowsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlowsType, char > MaxFlowsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MaxFlowsType&
    getMaxFlows () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MaxFlowsType&
    getMaxFlows ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMaxFlows (const MaxFlowsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMaxFlows (::std::auto_ptr< MaxFlowsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineEfficiencyTableComplexType (const ColumnsType&,
                                       const MaxFlowsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TurbineEfficiencyTableComplexType (::std::auto_ptr< ColumnsType >&,
                                       ::std::auto_ptr< MaxFlowsType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineEfficiencyTableComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineEfficiencyTableComplexType (const TurbineEfficiencyTableComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineEfficiencyTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineEfficiencyTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ColumnsType > columns_;
    RowSequence row_;
    ::xsd::cxx::tree::one< MaxFlowsType > maxFlows_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ColumnsComplexType schema type.
   *
   * @nosubgrouping
   */
  class ColumnsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name head01
     *
     * @brief Accessor and modifier functions for the %head01
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head01Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head01Type, char, ::xsd::cxx::tree::schema_type::double_ > Head01Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Head01Type&
    getHead01 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Head01Type&
    getHead01 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead01 (const Head01Type& x);

    //@}

    /**
     * @name head02
     *
     * @brief Accessor and modifier functions for the %head02
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head02Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head02Type, char, ::xsd::cxx::tree::schema_type::double_ > Head02Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Head02Type&
    getHead02 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Head02Type&
    getHead02 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead02 (const Head02Type& x);

    //@}

    /**
     * @name head03
     *
     * @brief Accessor and modifier functions for the %head03
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head03Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head03Type > Head03Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head03Type, char, ::xsd::cxx::tree::schema_type::double_ > Head03Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head03Optional&
    getHead03 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head03Optional&
    getHead03 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead03 (const Head03Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead03 (const Head03Optional& x);

    //@}

    /**
     * @name head04
     *
     * @brief Accessor and modifier functions for the %head04
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head04Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head04Type > Head04Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head04Type, char, ::xsd::cxx::tree::schema_type::double_ > Head04Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head04Optional&
    getHead04 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head04Optional&
    getHead04 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead04 (const Head04Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead04 (const Head04Optional& x);

    //@}

    /**
     * @name head05
     *
     * @brief Accessor and modifier functions for the %head05
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head05Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head05Type > Head05Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head05Type, char, ::xsd::cxx::tree::schema_type::double_ > Head05Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head05Optional&
    getHead05 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head05Optional&
    getHead05 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead05 (const Head05Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead05 (const Head05Optional& x);

    //@}

    /**
     * @name head06
     *
     * @brief Accessor and modifier functions for the %head06
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head06Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head06Type > Head06Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head06Type, char, ::xsd::cxx::tree::schema_type::double_ > Head06Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head06Optional&
    getHead06 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head06Optional&
    getHead06 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead06 (const Head06Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead06 (const Head06Optional& x);

    //@}

    /**
     * @name head07
     *
     * @brief Accessor and modifier functions for the %head07
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head07Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head07Type > Head07Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head07Type, char, ::xsd::cxx::tree::schema_type::double_ > Head07Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head07Optional&
    getHead07 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head07Optional&
    getHead07 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead07 (const Head07Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead07 (const Head07Optional& x);

    //@}

    /**
     * @name head08
     *
     * @brief Accessor and modifier functions for the %head08
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head08Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head08Type > Head08Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head08Type, char, ::xsd::cxx::tree::schema_type::double_ > Head08Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head08Optional&
    getHead08 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head08Optional&
    getHead08 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead08 (const Head08Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead08 (const Head08Optional& x);

    //@}

    /**
     * @name head09
     *
     * @brief Accessor and modifier functions for the %head09
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head09Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head09Type > Head09Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head09Type, char, ::xsd::cxx::tree::schema_type::double_ > Head09Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head09Optional&
    getHead09 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head09Optional&
    getHead09 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead09 (const Head09Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead09 (const Head09Optional& x);

    //@}

    /**
     * @name head10
     *
     * @brief Accessor and modifier functions for the %head10
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head10Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head10Type > Head10Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head10Type, char, ::xsd::cxx::tree::schema_type::double_ > Head10Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head10Optional&
    getHead10 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head10Optional&
    getHead10 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead10 (const Head10Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead10 (const Head10Optional& x);

    //@}

    /**
     * @name head11
     *
     * @brief Accessor and modifier functions for the %head11
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head11Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head11Type > Head11Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head11Type, char, ::xsd::cxx::tree::schema_type::double_ > Head11Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head11Optional&
    getHead11 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head11Optional&
    getHead11 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead11 (const Head11Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead11 (const Head11Optional& x);

    //@}

    /**
     * @name head12
     *
     * @brief Accessor and modifier functions for the %head12
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head12Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head12Type > Head12Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head12Type, char, ::xsd::cxx::tree::schema_type::double_ > Head12Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head12Optional&
    getHead12 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head12Optional&
    getHead12 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead12 (const Head12Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead12 (const Head12Optional& x);

    //@}

    /**
     * @name head13
     *
     * @brief Accessor and modifier functions for the %head13
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head13Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head13Type > Head13Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head13Type, char, ::xsd::cxx::tree::schema_type::double_ > Head13Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head13Optional&
    getHead13 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head13Optional&
    getHead13 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead13 (const Head13Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead13 (const Head13Optional& x);

    //@}

    /**
     * @name head14
     *
     * @brief Accessor and modifier functions for the %head14
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head14Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head14Type > Head14Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head14Type, char, ::xsd::cxx::tree::schema_type::double_ > Head14Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head14Optional&
    getHead14 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head14Optional&
    getHead14 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead14 (const Head14Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead14 (const Head14Optional& x);

    //@}

    /**
     * @name head15
     *
     * @brief Accessor and modifier functions for the %head15
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head15Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head15Type > Head15Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head15Type, char, ::xsd::cxx::tree::schema_type::double_ > Head15Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head15Optional&
    getHead15 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head15Optional&
    getHead15 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead15 (const Head15Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead15 (const Head15Optional& x);

    //@}

    /**
     * @name head16
     *
     * @brief Accessor and modifier functions for the %head16
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head16Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head16Type > Head16Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head16Type, char, ::xsd::cxx::tree::schema_type::double_ > Head16Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head16Optional&
    getHead16 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head16Optional&
    getHead16 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead16 (const Head16Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead16 (const Head16Optional& x);

    //@}

    /**
     * @name head17
     *
     * @brief Accessor and modifier functions for the %head17
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head17Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head17Type > Head17Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head17Type, char, ::xsd::cxx::tree::schema_type::double_ > Head17Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head17Optional&
    getHead17 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head17Optional&
    getHead17 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead17 (const Head17Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead17 (const Head17Optional& x);

    //@}

    /**
     * @name head18
     *
     * @brief Accessor and modifier functions for the %head18
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head18Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head18Type > Head18Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head18Type, char, ::xsd::cxx::tree::schema_type::double_ > Head18Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head18Optional&
    getHead18 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head18Optional&
    getHead18 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead18 (const Head18Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead18 (const Head18Optional& x);

    //@}

    /**
     * @name head19
     *
     * @brief Accessor and modifier functions for the %head19
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head19Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head19Type > Head19Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head19Type, char, ::xsd::cxx::tree::schema_type::double_ > Head19Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head19Optional&
    getHead19 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head19Optional&
    getHead19 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead19 (const Head19Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead19 (const Head19Optional& x);

    //@}

    /**
     * @name head20
     *
     * @brief Accessor and modifier functions for the %head20
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Head20Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Head20Type > Head20Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Head20Type, char, ::xsd::cxx::tree::schema_type::double_ > Head20Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Head20Optional&
    getHead20 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Head20Optional&
    getHead20 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHead20 (const Head20Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHead20 (const Head20Optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ColumnsComplexType (const Head01Type&,
                        const Head02Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ColumnsComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ColumnsComplexType (const ColumnsComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ColumnsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ColumnsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Head01Type > head01_;
    ::xsd::cxx::tree::one< Head02Type > head02_;
    Head03Optional head03_;
    Head04Optional head04_;
    Head05Optional head05_;
    Head06Optional head06_;
    Head07Optional head07_;
    Head08Optional head08_;
    Head09Optional head09_;
    Head10Optional head10_;
    Head11Optional head11_;
    Head12Optional head12_;
    Head13Optional head13_;
    Head14Optional head14_;
    Head15Optional head15_;
    Head16Optional head16_;
    Head17Optional head17_;
    Head18Optional head18_;
    Head19Optional head19_;
    Head20Optional head20_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RowComplexType schema type.
   *
   * @nosubgrouping
   */
  class RowComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name flow
     *
     * @brief Accessor and modifier functions for the %flow
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FlowType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlowType, char, ::xsd::cxx::tree::schema_type::double_ > FlowTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FlowType&
    getFlow () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FlowType&
    getFlow ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFlow (const FlowType& x);

    //@}

    /**
     * @name eta_head01
     *
     * @brief Accessor and modifier functions for the %eta_head01
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head01Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head01Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head01Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Eta_head01Type&
    getEta_head01 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Eta_head01Type&
    getEta_head01 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head01 (const Eta_head01Type& x);

    //@}

    /**
     * @name eta_head02
     *
     * @brief Accessor and modifier functions for the %eta_head02
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head02Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head02Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head02Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Eta_head02Type&
    getEta_head02 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Eta_head02Type&
    getEta_head02 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head02 (const Eta_head02Type& x);

    //@}

    /**
     * @name eta_head03
     *
     * @brief Accessor and modifier functions for the %eta_head03
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head03Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head03Type > Eta_head03Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head03Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head03Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head03Optional&
    getEta_head03 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head03Optional&
    getEta_head03 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head03 (const Eta_head03Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head03 (const Eta_head03Optional& x);

    //@}

    /**
     * @name eta_head04
     *
     * @brief Accessor and modifier functions for the %eta_head04
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head04Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head04Type > Eta_head04Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head04Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head04Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head04Optional&
    getEta_head04 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head04Optional&
    getEta_head04 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head04 (const Eta_head04Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head04 (const Eta_head04Optional& x);

    //@}

    /**
     * @name eta_head05
     *
     * @brief Accessor and modifier functions for the %eta_head05
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head05Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head05Type > Eta_head05Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head05Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head05Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head05Optional&
    getEta_head05 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head05Optional&
    getEta_head05 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head05 (const Eta_head05Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head05 (const Eta_head05Optional& x);

    //@}

    /**
     * @name eta_head06
     *
     * @brief Accessor and modifier functions for the %eta_head06
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head06Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head06Type > Eta_head06Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head06Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head06Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head06Optional&
    getEta_head06 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head06Optional&
    getEta_head06 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head06 (const Eta_head06Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head06 (const Eta_head06Optional& x);

    //@}

    /**
     * @name eta_head07
     *
     * @brief Accessor and modifier functions for the %eta_head07
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head07Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head07Type > Eta_head07Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head07Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head07Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head07Optional&
    getEta_head07 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head07Optional&
    getEta_head07 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head07 (const Eta_head07Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head07 (const Eta_head07Optional& x);

    //@}

    /**
     * @name eta_head08
     *
     * @brief Accessor and modifier functions for the %eta_head08
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head08Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head08Type > Eta_head08Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head08Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head08Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head08Optional&
    getEta_head08 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head08Optional&
    getEta_head08 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head08 (const Eta_head08Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head08 (const Eta_head08Optional& x);

    //@}

    /**
     * @name eta_head09
     *
     * @brief Accessor and modifier functions for the %eta_head09
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head09Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head09Type > Eta_head09Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head09Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head09Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head09Optional&
    getEta_head09 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head09Optional&
    getEta_head09 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head09 (const Eta_head09Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head09 (const Eta_head09Optional& x);

    //@}

    /**
     * @name eta_head10
     *
     * @brief Accessor and modifier functions for the %eta_head10
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head10Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head10Type > Eta_head10Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head10Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head10Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head10Optional&
    getEta_head10 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head10Optional&
    getEta_head10 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head10 (const Eta_head10Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head10 (const Eta_head10Optional& x);

    //@}

    /**
     * @name eta_head11
     *
     * @brief Accessor and modifier functions for the %eta_head11
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head11Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head11Type > Eta_head11Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head11Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head11Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head11Optional&
    getEta_head11 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head11Optional&
    getEta_head11 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head11 (const Eta_head11Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head11 (const Eta_head11Optional& x);

    //@}

    /**
     * @name eta_head12
     *
     * @brief Accessor and modifier functions for the %eta_head12
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head12Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head12Type > Eta_head12Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head12Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head12Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head12Optional&
    getEta_head12 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head12Optional&
    getEta_head12 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head12 (const Eta_head12Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head12 (const Eta_head12Optional& x);

    //@}

    /**
     * @name eta_head13
     *
     * @brief Accessor and modifier functions for the %eta_head13
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head13Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head13Type > Eta_head13Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head13Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head13Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head13Optional&
    getEta_head13 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head13Optional&
    getEta_head13 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head13 (const Eta_head13Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head13 (const Eta_head13Optional& x);

    //@}

    /**
     * @name eta_head14
     *
     * @brief Accessor and modifier functions for the %eta_head14
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head14Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head14Type > Eta_head14Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head14Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head14Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head14Optional&
    getEta_head14 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head14Optional&
    getEta_head14 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head14 (const Eta_head14Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head14 (const Eta_head14Optional& x);

    //@}

    /**
     * @name eta_head15
     *
     * @brief Accessor and modifier functions for the %eta_head15
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head15Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head15Type > Eta_head15Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head15Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head15Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head15Optional&
    getEta_head15 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head15Optional&
    getEta_head15 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head15 (const Eta_head15Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head15 (const Eta_head15Optional& x);

    //@}

    /**
     * @name eta_head16
     *
     * @brief Accessor and modifier functions for the %eta_head16
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head16Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head16Type > Eta_head16Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head16Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head16Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head16Optional&
    getEta_head16 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head16Optional&
    getEta_head16 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head16 (const Eta_head16Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head16 (const Eta_head16Optional& x);

    //@}

    /**
     * @name eta_head17
     *
     * @brief Accessor and modifier functions for the %eta_head17
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head17Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head17Type > Eta_head17Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head17Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head17Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head17Optional&
    getEta_head17 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head17Optional&
    getEta_head17 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head17 (const Eta_head17Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head17 (const Eta_head17Optional& x);

    //@}

    /**
     * @name eta_head18
     *
     * @brief Accessor and modifier functions for the %eta_head18
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head18Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head18Type > Eta_head18Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head18Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head18Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head18Optional&
    getEta_head18 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head18Optional&
    getEta_head18 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head18 (const Eta_head18Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head18 (const Eta_head18Optional& x);

    //@}

    /**
     * @name eta_head19
     *
     * @brief Accessor and modifier functions for the %eta_head19
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head19Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head19Type > Eta_head19Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head19Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head19Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head19Optional&
    getEta_head19 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head19Optional&
    getEta_head19 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head19 (const Eta_head19Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head19 (const Eta_head19Optional& x);

    //@}

    /**
     * @name eta_head20
     *
     * @brief Accessor and modifier functions for the %eta_head20
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Eta_head20Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Eta_head20Type > Eta_head20Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Eta_head20Type, char, ::xsd::cxx::tree::schema_type::double_ > Eta_head20Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Eta_head20Optional&
    getEta_head20 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Eta_head20Optional&
    getEta_head20 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEta_head20 (const Eta_head20Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEta_head20 (const Eta_head20Optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RowComplexType (const FlowType&,
                    const Eta_head01Type&,
                    const Eta_head02Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RowComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RowComplexType (const RowComplexType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RowComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RowComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FlowType > flow_;
    ::xsd::cxx::tree::one< Eta_head01Type > eta_head01_;
    ::xsd::cxx::tree::one< Eta_head02Type > eta_head02_;
    Eta_head03Optional eta_head03_;
    Eta_head04Optional eta_head04_;
    Eta_head05Optional eta_head05_;
    Eta_head06Optional eta_head06_;
    Eta_head07Optional eta_head07_;
    Eta_head08Optional eta_head08_;
    Eta_head09Optional eta_head09_;
    Eta_head10Optional eta_head10_;
    Eta_head11Optional eta_head11_;
    Eta_head12Optional eta_head12_;
    Eta_head13Optional eta_head13_;
    Eta_head14Optional eta_head14_;
    Eta_head15Optional eta_head15_;
    Eta_head16Optional eta_head16_;
    Eta_head17Optional eta_head17_;
    Eta_head18Optional eta_head18_;
    Eta_head19Optional eta_head19_;
    Eta_head20Optional eta_head20_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MaxFlowsComplexType schema type.
   *
   * @nosubgrouping
   */
  class MaxFlowsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name maxFlow_head01
     *
     * @brief Accessor and modifier functions for the %maxFlow_head01
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head01Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head01Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head01Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MaxFlow_head01Type&
    getMaxFlow_head01 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MaxFlow_head01Type&
    getMaxFlow_head01 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head01 (const MaxFlow_head01Type& x);

    //@}

    /**
     * @name maxFlow_head02
     *
     * @brief Accessor and modifier functions for the %maxFlow_head02
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head02Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head02Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head02Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MaxFlow_head02Type&
    getMaxFlow_head02 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MaxFlow_head02Type&
    getMaxFlow_head02 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head02 (const MaxFlow_head02Type& x);

    //@}

    /**
     * @name maxFlow_head03
     *
     * @brief Accessor and modifier functions for the %maxFlow_head03
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head03Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head03Type > MaxFlow_head03Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head03Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head03Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head03Optional&
    getMaxFlow_head03 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head03Optional&
    getMaxFlow_head03 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head03 (const MaxFlow_head03Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head03 (const MaxFlow_head03Optional& x);

    //@}

    /**
     * @name maxFlow_head04
     *
     * @brief Accessor and modifier functions for the %maxFlow_head04
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head04Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head04Type > MaxFlow_head04Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head04Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head04Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head04Optional&
    getMaxFlow_head04 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head04Optional&
    getMaxFlow_head04 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head04 (const MaxFlow_head04Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head04 (const MaxFlow_head04Optional& x);

    //@}

    /**
     * @name maxFlow_head05
     *
     * @brief Accessor and modifier functions for the %maxFlow_head05
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head05Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head05Type > MaxFlow_head05Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head05Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head05Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head05Optional&
    getMaxFlow_head05 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head05Optional&
    getMaxFlow_head05 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head05 (const MaxFlow_head05Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head05 (const MaxFlow_head05Optional& x);

    //@}

    /**
     * @name maxFlow_head06
     *
     * @brief Accessor and modifier functions for the %maxFlow_head06
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head06Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head06Type > MaxFlow_head06Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head06Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head06Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head06Optional&
    getMaxFlow_head06 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head06Optional&
    getMaxFlow_head06 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head06 (const MaxFlow_head06Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head06 (const MaxFlow_head06Optional& x);

    //@}

    /**
     * @name maxFlow_head07
     *
     * @brief Accessor and modifier functions for the %maxFlow_head07
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head07Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head07Type > MaxFlow_head07Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head07Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head07Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head07Optional&
    getMaxFlow_head07 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head07Optional&
    getMaxFlow_head07 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head07 (const MaxFlow_head07Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head07 (const MaxFlow_head07Optional& x);

    //@}

    /**
     * @name maxFlow_head08
     *
     * @brief Accessor and modifier functions for the %maxFlow_head08
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head08Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head08Type > MaxFlow_head08Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head08Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head08Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head08Optional&
    getMaxFlow_head08 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head08Optional&
    getMaxFlow_head08 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head08 (const MaxFlow_head08Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head08 (const MaxFlow_head08Optional& x);

    //@}

    /**
     * @name maxFlow_head09
     *
     * @brief Accessor and modifier functions for the %maxFlow_head09
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head09Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head09Type > MaxFlow_head09Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head09Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head09Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head09Optional&
    getMaxFlow_head09 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head09Optional&
    getMaxFlow_head09 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head09 (const MaxFlow_head09Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head09 (const MaxFlow_head09Optional& x);

    //@}

    /**
     * @name maxFlow_head10
     *
     * @brief Accessor and modifier functions for the %maxFlow_head10
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head10Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head10Type > MaxFlow_head10Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head10Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head10Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head10Optional&
    getMaxFlow_head10 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head10Optional&
    getMaxFlow_head10 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head10 (const MaxFlow_head10Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head10 (const MaxFlow_head10Optional& x);

    //@}

    /**
     * @name maxFlow_head11
     *
     * @brief Accessor and modifier functions for the %maxFlow_head11
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head11Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head11Type > MaxFlow_head11Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head11Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head11Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head11Optional&
    getMaxFlow_head11 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head11Optional&
    getMaxFlow_head11 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head11 (const MaxFlow_head11Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head11 (const MaxFlow_head11Optional& x);

    //@}

    /**
     * @name maxFlow_head12
     *
     * @brief Accessor and modifier functions for the %maxFlow_head12
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head12Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head12Type > MaxFlow_head12Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head12Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head12Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head12Optional&
    getMaxFlow_head12 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head12Optional&
    getMaxFlow_head12 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head12 (const MaxFlow_head12Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head12 (const MaxFlow_head12Optional& x);

    //@}

    /**
     * @name maxFlow_head13
     *
     * @brief Accessor and modifier functions for the %maxFlow_head13
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head13Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head13Type > MaxFlow_head13Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head13Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head13Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head13Optional&
    getMaxFlow_head13 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head13Optional&
    getMaxFlow_head13 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head13 (const MaxFlow_head13Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head13 (const MaxFlow_head13Optional& x);

    //@}

    /**
     * @name maxFlow_head14
     *
     * @brief Accessor and modifier functions for the %maxFlow_head14
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head14Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head14Type > MaxFlow_head14Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head14Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head14Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head14Optional&
    getMaxFlow_head14 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head14Optional&
    getMaxFlow_head14 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head14 (const MaxFlow_head14Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head14 (const MaxFlow_head14Optional& x);

    //@}

    /**
     * @name maxFlow_head15
     *
     * @brief Accessor and modifier functions for the %maxFlow_head15
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head15Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head15Type > MaxFlow_head15Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head15Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head15Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head15Optional&
    getMaxFlow_head15 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head15Optional&
    getMaxFlow_head15 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head15 (const MaxFlow_head15Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head15 (const MaxFlow_head15Optional& x);

    //@}

    /**
     * @name maxFlow_head16
     *
     * @brief Accessor and modifier functions for the %maxFlow_head16
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head16Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head16Type > MaxFlow_head16Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head16Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head16Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head16Optional&
    getMaxFlow_head16 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head16Optional&
    getMaxFlow_head16 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head16 (const MaxFlow_head16Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head16 (const MaxFlow_head16Optional& x);

    //@}

    /**
     * @name maxFlow_head17
     *
     * @brief Accessor and modifier functions for the %maxFlow_head17
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head17Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head17Type > MaxFlow_head17Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head17Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head17Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head17Optional&
    getMaxFlow_head17 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head17Optional&
    getMaxFlow_head17 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head17 (const MaxFlow_head17Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head17 (const MaxFlow_head17Optional& x);

    //@}

    /**
     * @name maxFlow_head18
     *
     * @brief Accessor and modifier functions for the %maxFlow_head18
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head18Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head18Type > MaxFlow_head18Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head18Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head18Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head18Optional&
    getMaxFlow_head18 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head18Optional&
    getMaxFlow_head18 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head18 (const MaxFlow_head18Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head18 (const MaxFlow_head18Optional& x);

    //@}

    /**
     * @name maxFlow_head19
     *
     * @brief Accessor and modifier functions for the %maxFlow_head19
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head19Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head19Type > MaxFlow_head19Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head19Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head19Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head19Optional&
    getMaxFlow_head19 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head19Optional&
    getMaxFlow_head19 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head19 (const MaxFlow_head19Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head19 (const MaxFlow_head19Optional& x);

    //@}

    /**
     * @name maxFlow_head20
     *
     * @brief Accessor and modifier functions for the %maxFlow_head20
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxFlow_head20Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxFlow_head20Type > MaxFlow_head20Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxFlow_head20Type, char, ::xsd::cxx::tree::schema_type::double_ > MaxFlow_head20Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxFlow_head20Optional&
    getMaxFlow_head20 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxFlow_head20Optional&
    getMaxFlow_head20 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxFlow_head20 (const MaxFlow_head20Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxFlow_head20 (const MaxFlow_head20Optional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MaxFlowsComplexType (const MaxFlow_head01Type&,
                         const MaxFlow_head02Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MaxFlowsComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MaxFlowsComplexType (const MaxFlowsComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MaxFlowsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MaxFlowsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MaxFlow_head01Type > maxFlow_head01_;
    ::xsd::cxx::tree::one< MaxFlow_head02Type > maxFlow_head02_;
    MaxFlow_head03Optional maxFlow_head03_;
    MaxFlow_head04Optional maxFlow_head04_;
    MaxFlow_head05Optional maxFlow_head05_;
    MaxFlow_head06Optional maxFlow_head06_;
    MaxFlow_head07Optional maxFlow_head07_;
    MaxFlow_head08Optional maxFlow_head08_;
    MaxFlow_head09Optional maxFlow_head09_;
    MaxFlow_head10Optional maxFlow_head10_;
    MaxFlow_head11Optional maxFlow_head11_;
    MaxFlow_head12Optional maxFlow_head12_;
    MaxFlow_head13Optional maxFlow_head13_;
    MaxFlow_head14Optional maxFlow_head14_;
    MaxFlow_head15Optional maxFlow_head15_;
    MaxFlow_head16Optional maxFlow_head16_;
    MaxFlow_head17Optional maxFlow_head17_;
    MaxFlow_head18Optional maxFlow_head18_;
    MaxFlow_head19Optional maxFlow_head19_;
    MaxFlow_head20Optional maxFlow_head20_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirCompactInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirCompactInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name FB
     *
     * @brief Accessor and modifier functions for the %FB
     * required element.
     *
     * forebay elevation [m above reference level] or [ft above sea level]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FBType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FBType, char > FBTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FBType&
    getFB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FBType&
    getFB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFB (const FBType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFB (::std::auto_ptr< FBType > p);

    //@}

    /**
     * @name QI
     *
     * @brief Accessor and modifier functions for the %QI
     * sequence element.
     *
     * single or multiple inflow time series into the reservoir [m3/s] or
     * [KCFS], data is expected to be complete and valid if provided
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QIType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< QIType > QISequence;

    /**
     * @brief Element iterator type.
     */
    typedef QISequence::iterator QIIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef QISequence::const_iterator QIConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QIType, char > QITraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const QISequence&
    getQI () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    QISequence&
    getQI ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setQI (const QISequence& s);

    //@}

    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     *
     * reservoir outflow [m3/s] or [KCFS], data is expected to be complete
     * and valid
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name QSPercentage
     *
     * @brief Accessor and modifier functions for the %QSPercentage
     * optional element.
     *
     * relative spill target as a percentage [0..100] of the total flow Q
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::QSPercentage QSPercentageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QSPercentageType > QSPercentageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSPercentageType, char > QSPercentageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QSPercentageOptional&
    getQSPercentage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QSPercentageOptional&
    getQSPercentage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQSPercentage (const QSPercentageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQSPercentage (const QSPercentageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQSPercentage (::std::auto_ptr< QSPercentageType > p);

    //@}

    /**
     * @name QSPercentageValue
     *
     * @brief Accessor and modifier functions for the %QSPercentageValue
     * optional element.
     *
     * relative spill target as a percentage [0..100] of the total flow Q
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::QSPercentageValue QSPercentageValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QSPercentageValueType > QSPercentageValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSPercentageValueType, char > QSPercentageValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QSPercentageValueOptional&
    getQSPercentageValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QSPercentageValueOptional&
    getQSPercentageValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQSPercentageValue (const QSPercentageValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQSPercentageValue (const QSPercentageValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQSPercentageValue (::std::auto_ptr< QSPercentageValueType > p);

    //@}

    /**
     * @name QS
     *
     * @brief Accessor and modifier functions for the %QS
     * optional element.
     *
     * absolute spill target [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QSType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QSType > QSOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSType, char > QSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QSOptional&
    getQS () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QSOptional&
    getQS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQS (const QSType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQS (const QSOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQS (::std::auto_ptr< QSType > p);

    //@}

    /**
     * @name QSValue
     *
     * @brief Accessor and modifier functions for the %QSValue
     * optional element.
     *
     * absolute spill target [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType QSValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QSValueType > QSValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSValueType, char > QSValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QSValueOptional&
    getQSValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QSValueOptional&
    getQSValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQSValue (const QSValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQSValue (const QSValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQSValue (::std::auto_ptr< QSValueType > p);

    //@}

    /**
     * @name QMISC
     *
     * @brief Accessor and modifier functions for the %QMISC
     * optional element.
     *
     * optional miscellaneous flow (uncontrolled), will be zero by default
     * [m3/s] or [KCFS] if no time series is supplied or if the time series
     * includes NaN values
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QMISCType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QMISCType > QMISCOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QMISCType, char > QMISCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QMISCOptional&
    getQMISC () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QMISCOptional&
    getQMISC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQMISC (const QMISCType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQMISC (const QMISCOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQMISC (::std::auto_ptr< QMISCType > p);

    //@}

    /**
     * @name PM
     *
     * @brief Accessor and modifier functions for the %PM
     * optional element.
     *
     * minimum generation constraint on aggregated turbine level [MW],
     * primarly used as operational constraint
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PMType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PMType > PMOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PMType, char > PMTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PMOptional&
    getPM () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PMOptional&
    getPM ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPM (const PMType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPM (const PMOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPM (::std::auto_ptr< PMType > p);

    //@}

    /**
     * @name PMValue
     *
     * @brief Accessor and modifier functions for the %PMValue
     * optional element.
     *
     * fixed minimum generation constraint on aggregated turbine level [MW],
     * primarily used as physical constraint
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType PMValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PMValueType > PMValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PMValueType, char > PMValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PMValueOptional&
    getPMValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PMValueOptional&
    getPMValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPMValue (const PMValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPMValue (const PMValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPMValue (::std::auto_ptr< PMValueType > p);

    //@}

    /**
     * @name PX
     *
     * @brief Accessor and modifier functions for the %PX
     * optional element.
     *
     * maximum generation constraint on aggregated turbine level [MW],
     * primarly used as operational constraint
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PXType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PXType > PXOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PXType, char > PXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PXOptional&
    getPX () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PXOptional&
    getPX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPX (const PXType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPX (const PXOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPX (::std::auto_ptr< PXType > p);

    //@}

    /**
     * @name PXValue
     *
     * @brief Accessor and modifier functions for the %PXValue
     * optional element.
     *
     * fixed maximum generation constraint on aggregated turbine level [MW],
     * primarly used as physical constraint
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType PXValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PXValueType > PXValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PXValueType, char > PXValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PXValueOptional&
    getPXValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PXValueOptional&
    getPXValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPXValue (const PXValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPXValue (const PXValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPXValue (::std::auto_ptr< PXValueType > p);

    //@}

    /**
     * @name QTX
     *
     * @brief Accessor and modifier functions for the %QTX
     * optional element.
     *
     * maximum generation constraint on aggregated turbine level [m3/s] or
     * [KCFS], primarily used as operational constraint
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QTXType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QTXType > QTXOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QTXType, char > QTXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QTXOptional&
    getQTX () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QTXOptional&
    getQTX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQTX (const QTXType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQTX (const QTXOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQTX (::std::auto_ptr< QTXType > p);

    //@}

    /**
     * @name QTXValue
     *
     * @brief Accessor and modifier functions for the %QTXValue
     * optional element.
     *
     * fixed maximum generation constraint on aggregated turbine level [m3/s]
     * or [KCFS], primarily used as physical constraint
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType QTXValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QTXValueType > QTXValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QTXValueType, char > QTXValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QTXValueOptional&
    getQTXValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QTXValueOptional&
    getQTXValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQTXValue (const QTXValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQTXValue (const QTXValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQTXValue (::std::auto_ptr< QTXValueType > p);

    //@}

    /**
     * @name OF
     *
     * @brief Accessor and modifier functions for the %OF
     * optional element.
     *
     * optional time series with the unit outage factor [0-1], it reduces the
     * (physical) constraints PXValue and QTXValue (NO impact on PX, QTX)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType OFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OFType > OFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OFType, char > OFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OFOptional&
    getOF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OFOptional&
    getOF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOF (const OFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOF (const OFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOF (::std::auto_ptr< OFType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirCompactInputComplexType (const FBType&,
                                      const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirCompactInputComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirCompactInputComplexType (const ReservoirCompactInputComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirCompactInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirCompactInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FBType > FB_;
    QISequence QI_;
    ::xsd::cxx::tree::one< QType > Q_;
    QSPercentageOptional QSPercentage_;
    QSPercentageValueOptional QSPercentageValue_;
    QSOptional QS_;
    QSValueOptional QSValue_;
    QMISCOptional QMISC_;
    PMOptional PM_;
    PMValueOptional PMValue_;
    PXOptional PX_;
    PXValueOptional PXValue_;
    QTXOptional QTX_;
    QTXValueOptional QTXValue_;
    OFOptional OF_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirCompactOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirCompactOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name S
     *
     * @brief Accessor and modifier functions for the %S
     * required element.
     *
     * storage [m3] or [KCFS-hrs], this is the system state needed in the
     * state file
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SType, char > STraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SType&
    getS () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SType&
    getS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setS (const SType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setS (::std::auto_ptr< SType > p);

    //@}

    /**
     * @name FB
     *
     * @brief Accessor and modifier functions for the %FB
     * required element.
     *
     * forebay elevation [m above reference level] or [ft above sea level]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FBType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FBType, char > FBTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FBType&
    getFB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FBType&
    getFB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFB (const FBType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFB (::std::auto_ptr< FBType > p);

    //@}

    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     *
     * reservoir outflow [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name QI
     *
     * @brief Accessor and modifier functions for the %QI
     * required element.
     *
     * reservoir inflow [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QIType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QIType, char > QITraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QIType&
    getQI () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QIType&
    getQI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQI (const QIType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQI (::std::auto_ptr< QIType > p);

    //@}

    /**
     * @name QT
     *
     * @brief Accessor and modifier functions for the %QT
     * required element.
     *
     * turbine flow [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QTType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QTType, char > QTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QTType&
    getQT () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QTType&
    getQT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQT (const QTType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQT (::std::auto_ptr< QTType > p);

    //@}

    /**
     * @name QTX
     *
     * @brief Accessor and modifier functions for the %QTX
     * optional element.
     *
     * maximum turbine flow [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QTXType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QTXType > QTXOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QTXType, char > QTXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QTXOptional&
    getQTX () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QTXOptional&
    getQTX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQTX (const QTXType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQTX (const QTXOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQTX (::std::auto_ptr< QTXType > p);

    //@}

    /**
     * @name QS
     *
     * @brief Accessor and modifier functions for the %QS
     * required element.
     *
     * spillage [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QSType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSType, char > QSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QSType&
    getQS () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QSType&
    getQS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQS (const QSType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQS (::std::auto_ptr< QSType > p);

    //@}

    /**
     * @name QSPercentage
     *
     * @brief Accessor and modifier functions for the %QSPercentage
     * optional element.
     *
     * relative spillage [0..100]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QSPercentageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QSPercentageType > QSPercentageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QSPercentageType, char > QSPercentageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QSPercentageOptional&
    getQSPercentage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QSPercentageOptional&
    getQSPercentage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQSPercentage (const QSPercentageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQSPercentage (const QSPercentageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQSPercentage (::std::auto_ptr< QSPercentageType > p);

    //@}

    /**
     * @name QMISC
     *
     * @brief Accessor and modifier functions for the %QMISC
     * optional element.
     *
     * miscellaneous flow [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QMISCType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QMISCType > QMISCOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QMISCType, char > QMISCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QMISCOptional&
    getQMISC () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QMISCOptional&
    getQMISC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQMISC (const QMISCType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQMISC (const QMISCOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQMISC (::std::auto_ptr< QMISCType > p);

    //@}

    /**
     * @name DQ
     *
     * @brief Accessor and modifier functions for the %DQ
     * required element.
     *
     * deviation from spill target [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DQType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DQType, char > DQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DQType&
    getDQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DQType&
    getDQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDQ (const DQType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDQ (::std::auto_ptr< DQType > p);

    //@}

    /**
     * @name TW
     *
     * @brief Accessor and modifier functions for the %TW
     * required element.
     *
     * tailwater elevation [m above reference level] or [ft above sea level]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TWType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TWType, char > TWTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TWType&
    getTW () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TWType&
    getTW ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTW (const TWType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTW (::std::auto_ptr< TWType > p);

    //@}

    /**
     * @name H
     *
     * @brief Accessor and modifier functions for the %H
     * required element.
     *
     * head [m] or [ft]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HType, char > HTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HType&
    getH () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HType&
    getH ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setH (const HType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setH (::std::auto_ptr< HType > p);

    //@}

    /**
     * @name P
     *
     * @brief Accessor and modifier functions for the %P
     * required element.
     *
     * power generation [MW]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PType&
    getP () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PType&
    getP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setP (const PType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setP (::std::auto_ptr< PType > p);

    //@}

    /**
     * @name PX
     *
     * @brief Accessor and modifier functions for the %PX
     * optional element.
     *
     * maximum power generation [MW]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PXType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PXType > PXOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PXType, char > PXTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PXOptional&
    getPX () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PXOptional&
    getPX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPX (const PXType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPX (const PXOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPX (::std::auto_ptr< PXType > p);

    //@}

    /**
     * @name R
     *
     * @brief Accessor and modifier functions for the %R
     * required element.
     *
     * residuum of mass balance (in simultaneous mode) [m3/s] or [KCFS]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RType, char > RTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RType&
    getR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RType&
    getR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setR (const RType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setR (::std::auto_ptr< RType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirCompactOutputComplexType (const SType&,
                                       const FBType&,
                                       const QType&,
                                       const QIType&,
                                       const QTType&,
                                       const QSType&,
                                       const DQType&,
                                       const TWType&,
                                       const HType&,
                                       const PType&,
                                       const RType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirCompactOutputComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirCompactOutputComplexType (const ReservoirCompactOutputComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirCompactOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirCompactOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SType > S_;
    ::xsd::cxx::tree::one< FBType > FB_;
    ::xsd::cxx::tree::one< QType > Q_;
    ::xsd::cxx::tree::one< QIType > QI_;
    ::xsd::cxx::tree::one< QTType > QT_;
    QTXOptional QTX_;
    ::xsd::cxx::tree::one< QSType > QS_;
    QSPercentageOptional QSPercentage_;
    QMISCOptional QMISC_;
    ::xsd::cxx::tree::one< DQType > DQ_;
    ::xsd::cxx::tree::one< TWType > TW_;
    ::xsd::cxx::tree::one< HType > H_;
    ::xsd::cxx::tree::one< PType > P_;
    PXOptional PX_;
    ::xsd::cxx::tree::one< RType > R_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * required element.
     *
     * Time integration scheme for the network components
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PoolRoutingEnumStringType ModeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ModeType&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ModeType&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    //@}

    /**
     * @name theta
     *
     * @brief Accessor and modifier functions for the %theta
     * required element.
     *
     * Time weighting coefficient for the semi-implicit theta schema: 0 is
     * equal to a full weight on the old time step, 1 represents a full
     * weight on new time step. The coefficient is not used in the fully
     * explicit or implicit schemas. The permitted range is between 0.5 and
     * 1.0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ThetaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThetaType, char, ::xsd::cxx::tree::schema_type::double_ > ThetaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ThetaType&
    getTheta () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ThetaType&
    getTheta ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTheta (const ThetaType& x);

    //@}

    /**
     * @name storageCharacteristics
     *
     * @brief Accessor and modifier functions for the %storageCharacteristics
     * required element.
     *
     * Storage characteristics of the reservoir: The storage S as a function
     * of the water level h can be provided as a table or formula.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StorageCharacteristicsComplexType StorageCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageCharacteristicsType, char > StorageCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageCharacteristicsType&
    getStorageCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageCharacteristicsType&
    getStorageCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageCharacteristics (const StorageCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > p);

    //@}

    /**
     * @name controlledOutlet
     *
     * @brief Accessor and modifier functions for the %controlledOutlet
     * sequence element.
     *
     * Controlled outlet, release can be defined by external input or rule
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ControlledOutletComplexType ControlledOutletType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ControlledOutletType > ControlledOutletSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ControlledOutletSequence::iterator ControlledOutletIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ControlledOutletSequence::const_iterator ControlledOutletConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ControlledOutletType, char > ControlledOutletTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ControlledOutletSequence&
    getControlledOutlet () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ControlledOutletSequence&
    getControlledOutlet ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setControlledOutlet (const ControlledOutletSequence& s);

    //@}

    /**
     * @name uncontrolledOutlet
     *
     * @brief Accessor and modifier functions for the %uncontrolledOutlet
     * sequence element.
     *
     * Uncontrolled outlet, the release is a function of the water level h in
     * the reservoir
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UncontrolledOutletComplexType UncontrolledOutletType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< UncontrolledOutletType > UncontrolledOutletSequence;

    /**
     * @brief Element iterator type.
     */
    typedef UncontrolledOutletSequence::iterator UncontrolledOutletIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef UncontrolledOutletSequence::const_iterator UncontrolledOutletConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UncontrolledOutletType, char > UncontrolledOutletTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const UncontrolledOutletSequence&
    getUncontrolledOutlet () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    UncontrolledOutletSequence&
    getUncontrolledOutlet ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setUncontrolledOutlet (const UncontrolledOutletSequence& s);

    //@}

    /**
     * @name tailwater
     *
     * @brief Accessor and modifier functions for the %tailwater
     * optional element.
     *
     * Tailwater rating curve
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TailwaterComplexType TailwaterType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TailwaterType > TailwaterOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TailwaterType, char > TailwaterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TailwaterOptional&
    getTailwater () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TailwaterOptional&
    getTailwater ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTailwater (const TailwaterType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTailwater (const TailwaterOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTailwater (::std::auto_ptr< TailwaterType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirComplexType (const ModeType&,
                          const ThetaType&,
                          const StorageCharacteristicsType&,
                          const InputType&,
                          const OutputType&,
                          const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReservoirComplexType (const ModeType&,
                          const ThetaType&,
                          ::std::auto_ptr< StorageCharacteristicsType >&,
                          ::std::auto_ptr< InputType >&,
                          ::std::auto_ptr< OutputType >&,
                          const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirComplexType (const ReservoirComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ModeType > mode_;
    ::xsd::cxx::tree::one< ThetaType > theta_;
    ::xsd::cxx::tree::one< StorageCharacteristicsType > storageCharacteristics_;
    ControlledOutletSequence controlledOutlet_;
    UncontrolledOutletSequence uncontrolledOutlet_;
    TailwaterOptional tailwater_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RoutingComplexType schema type.
   *
   * @nosubgrouping
   */
  class RoutingComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name inflow
     *
     * @brief Accessor and modifier functions for the %inflow
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InflowComplexType InflowType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InflowType > InflowSequence;

    /**
     * @brief Element iterator type.
     */
    typedef InflowSequence::iterator InflowIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef InflowSequence::const_iterator InflowConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InflowType, char > InflowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InflowSequence&
    getInflow () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InflowSequence&
    getInflow ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setInflow (const InflowSequence& s);

    //@}

    /**
     * @name reservoirRouting
     *
     * @brief Accessor and modifier functions for the %reservoirRouting
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirRoutingComplexType ReservoirRoutingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReservoirRoutingType > ReservoirRoutingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReservoirRoutingType, char > ReservoirRoutingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReservoirRoutingOptional&
    getReservoirRouting () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReservoirRoutingOptional&
    getReservoirRouting ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReservoirRouting (const ReservoirRoutingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReservoirRouting (const ReservoirRoutingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReservoirRouting (::std::auto_ptr< ReservoirRoutingType > p);

    //@}

    /**
     * @name dischargeRef
     *
     * @brief Accessor and modifier functions for the %dischargeRef
     * optional element.
     *
     * Reference to timeseries in data configuration
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String DischargeRefType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DischargeRefType > DischargeRefOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeRefType, char > DischargeRefTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DischargeRefOptional&
    getDischargeRef () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DischargeRefOptional&
    getDischargeRef ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDischargeRef (const DischargeRefType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDischargeRef (const DischargeRefOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDischargeRef (::std::auto_ptr< DischargeRefType > p);

    //@}

    /**
     * @name outputReferences
     *
     * @brief Accessor and modifier functions for the %outputReferences
     * required element.
     *
     * Contains references to the output timeseries in the data configuration
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RoutingOutputComplexType OutputReferencesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputReferencesType, char > OutputReferencesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputReferencesType&
    getOutputReferences () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputReferencesType&
    getOutputReferences ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutputReferences (const OutputReferencesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutputReferences (::std::auto_ptr< OutputReferencesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RoutingComplexType (const OutputReferencesType&,
                        const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    RoutingComplexType (::std::auto_ptr< OutputReferencesType >&,
                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RoutingComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RoutingComplexType (const RoutingComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RoutingComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RoutingComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    InflowSequence inflow_;
    ReservoirRoutingOptional reservoirRouting_;
    DischargeRefOptional dischargeRef_;
    ::xsd::cxx::tree::one< OutputReferencesType > outputReferences_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NeuralNetworkComplexType schema type.
   *
   * @nosubgrouping
   */
  class NeuralNetworkComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name layer
     *
     * @brief Accessor and modifier functions for the %layer
     * sequence element.
     *
     * arbitrary number of layers
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LayerComplexType LayerType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< LayerType > LayerSequence;

    /**
     * @brief Element iterator type.
     */
    typedef LayerSequence::iterator LayerIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef LayerSequence::const_iterator LayerConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LayerType, char > LayerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const LayerSequence&
    getLayer () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    LayerSequence&
    getLayer ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setLayer (const LayerSequence& s);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuralNetworkComplexType (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuralNetworkComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuralNetworkComplexType (const NeuralNetworkComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuralNetworkComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuralNetworkComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LayerSequence layer_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LayerComplexType schema type.
   *
   * @nosubgrouping
   */
  class LayerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name neuron
     *
     * @brief Accessor and modifier functions for the %neuron
     * sequence element.
     *
     * arbitrary number of neurons within one of the layers
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NeuronComplexType NeuronType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< NeuronType > NeuronSequence;

    /**
     * @brief Element iterator type.
     */
    typedef NeuronSequence::iterator NeuronIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef NeuronSequence::const_iterator NeuronConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NeuronType, char > NeuronTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const NeuronSequence&
    getNeuron () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    NeuronSequence&
    getNeuron ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setNeuron (const NeuronSequence& s);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::LayerIDSimpleType IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LayerComplexType (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LayerComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LayerComplexType (const LayerComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LayerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LayerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NeuronSequence neuron_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NeuronComplexType schema type.
   *
   * @nosubgrouping
   */
  class NeuronComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name bias
     *
     * @brief Accessor and modifier functions for the %bias
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BiasType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BiasType, char > BiasTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BiasType&
    getBias () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BiasType&
    getBias ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBias (const BiasType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBias (::std::auto_ptr< BiasType > p);

    //@}

    /**
     * @name transferFunction
     *
     * @brief Accessor and modifier functions for the %transferFunction
     * required element.
     *
     * transfer function: sigmoid, linear etc.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TransferFunctionEnumStringType TransferFunctionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TransferFunctionType, char > TransferFunctionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TransferFunctionType&
    getTransferFunction () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TransferFunctionType&
    getTransferFunction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTransferFunction (const TransferFunctionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTransferFunction (::std::auto_ptr< TransferFunctionType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NeuronInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NeuronOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::NeuronIDSimpleType IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuronComplexType (const BiasType&,
                       const TransferFunctionType&,
                       const InputType&,
                       const OutputType&,
                       const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    NeuronComplexType (const BiasType&,
                       const TransferFunctionType&,
                       ::std::auto_ptr< InputType >&,
                       ::std::auto_ptr< OutputType >&,
                       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuronComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuronComplexType (const NeuronComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuronComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuronComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BiasType > bias_;
    ::xsd::cxx::tree::one< TransferFunctionType > transferFunction_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NeuronInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class NeuronInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name external
     *
     * @brief Accessor and modifier functions for the %external
     * sequence element.
     *
     * reference to time series ID
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::External ExternalType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ExternalType > ExternalSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ExternalSequence::iterator ExternalIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ExternalSequence::const_iterator ExternalConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExternalType, char > ExternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ExternalSequence&
    getExternal () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ExternalSequence&
    getExternal ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setExternal (const ExternalSequence& s);

    //@}

    /**
     * @name internal
     *
     * @brief Accessor and modifier functions for the %internal
     * sequence element.
     *
     * Supply neuron id! This can be any neuron in the network, also the
     * neuron itself and neurons in the following layers. In this case, the
     * output of the last time step is used -> recurrent network
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Internal InternalType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InternalType > InternalSequence;

    /**
     * @brief Element iterator type.
     */
    typedef InternalSequence::iterator InternalIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef InternalSequence::const_iterator InternalConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InternalType, char > InternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InternalSequence&
    getInternal () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InternalSequence&
    getInternal ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setInternal (const InternalSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuronInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuronInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuronInputComplexType (const NeuronInputComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuronInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuronInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExternalSequence external_;
    InternalSequence internal_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NeuronOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class NeuronOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     *
     * result of the transfer function
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     *
     * result of the summation of weighted input (intermediate result)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuronOutputComplexType (const XType&,
                             const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuronOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuronOutputComplexType (const NeuronOutputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuronOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuronOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HydraulicModelComplexType schema type.
   *
   * @nosubgrouping
   */
  class HydraulicModelComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydraulicModelModeEnumStringType ModeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ModeType&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ModeType&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    //@}

    /**
     * @name sequentialImplicitSettings
     *
     * @brief Accessor and modifier functions for the %sequentialImplicitSettings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydraulicModelSequentialImplicitComplexType SequentialImplicitSettingsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SequentialImplicitSettingsType > SequentialImplicitSettingsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SequentialImplicitSettingsType, char > SequentialImplicitSettingsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SequentialImplicitSettingsOptional&
    getSequentialImplicitSettings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SequentialImplicitSettingsOptional&
    getSequentialImplicitSettings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSequentialImplicitSettings (const SequentialImplicitSettingsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSequentialImplicitSettings (const SequentialImplicitSettingsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSequentialImplicitSettings (::std::auto_ptr< SequentialImplicitSettingsType > p);

    //@}

    /**
     * @name simultaneousSettings
     *
     * @brief Accessor and modifier functions for the %simultaneousSettings
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydraulicModelSimultaneousComplexType SimultaneousSettingsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SimultaneousSettingsType > SimultaneousSettingsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimultaneousSettingsType, char > SimultaneousSettingsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SimultaneousSettingsOptional&
    getSimultaneousSettings () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SimultaneousSettingsOptional&
    getSimultaneousSettings ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSimultaneousSettings (const SimultaneousSettingsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSimultaneousSettings (const SimultaneousSettingsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSimultaneousSettings (::std::auto_ptr< SimultaneousSettingsType > p);

    //@}

    /**
     * @name numericalTolerance
     *
     * @brief Accessor and modifier functions for the %numericalTolerance
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double NumericalToleranceType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumericalToleranceType, char, ::xsd::cxx::tree::schema_type::double_ > NumericalToleranceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NumericalToleranceType&
    getNumericalTolerance () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NumericalToleranceType&
    getNumericalTolerance ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumericalTolerance (const NumericalToleranceType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static NumericalToleranceType
    getNumericalToleranceDefaultValue ();

    //@}

    /**
     * @name node
     *
     * @brief Accessor and modifier functions for the %node
     * sequence element.
     *
     * Storage nodes
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NodeComplexType NodeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< NodeType > NodeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef NodeSequence::iterator NodeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef NodeSequence::const_iterator NodeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const NodeSequence&
    getNode () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    NodeSequence&
    getNode ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setNode (const NodeSequence& s);

    //@}

    /**
     * @name branch
     *
     * @brief Accessor and modifier functions for the %branch
     * sequence element.
     *
     * Flow branches
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BranchComplexType BranchType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< BranchType > BranchSequence;

    /**
     * @brief Element iterator type.
     */
    typedef BranchSequence::iterator BranchIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef BranchSequence::const_iterator BranchConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BranchType, char > BranchTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const BranchSequence&
    getBranch () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    BranchSequence&
    getBranch ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setBranch (const BranchSequence& s);

    //@}

    /**
     * @name hydraulicStructure
     *
     * @brief Accessor and modifier functions for the %hydraulicStructure
     * sequence element.
     *
     * Hydraulic structures
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydraulicStructureComplexType HydraulicStructureType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< HydraulicStructureType > HydraulicStructureSequence;

    /**
     * @brief Element iterator type.
     */
    typedef HydraulicStructureSequence::iterator HydraulicStructureIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef HydraulicStructureSequence::const_iterator HydraulicStructureConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HydraulicStructureType, char > HydraulicStructureTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const HydraulicStructureSequence&
    getHydraulicStructure () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    HydraulicStructureSequence&
    getHydraulicStructure ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setHydraulicStructure (const HydraulicStructureSequence& s);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::HydraulicModelOutputComplexType OutputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OutputType > OutputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OutputOptional&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OutputOptional&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOutput (const OutputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HydraulicModelComplexType (const ModeType&,
                               const NumericalToleranceType&,
                               const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydraulicModelComplexType (const HydraulicModelComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydraulicModelComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HydraulicModelComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ModeType > mode_;
    SequentialImplicitSettingsOptional sequentialImplicitSettings_;
    SimultaneousSettingsOptional simultaneousSettings_;
    ::xsd::cxx::tree::one< NumericalToleranceType > numericalTolerance_;
    NodeSequence node_;
    BranchSequence branch_;
    HydraulicStructureSequence hydraulicStructure_;
    OutputOptional output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HydraulicModelSequentialImplicitComplexType schema type.
   *
   * @nosubgrouping
   */
  class HydraulicModelSequentialImplicitComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name theta
     *
     * @brief Accessor and modifier functions for the %theta
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ThetaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThetaType, char, ::xsd::cxx::tree::schema_type::double_ > ThetaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ThetaType&
    getTheta () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ThetaType&
    getTheta ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTheta (const ThetaType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ThetaType
    getThetaDefaultValue ();

    //@}

    /**
     * @name convergenceThreshold
     *
     * @brief Accessor and modifier functions for the %convergenceThreshold
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ConvergenceThresholdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConvergenceThresholdType, char, ::xsd::cxx::tree::schema_type::double_ > ConvergenceThresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ConvergenceThresholdType&
    getConvergenceThreshold () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ConvergenceThresholdType&
    getConvergenceThreshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConvergenceThreshold (const ConvergenceThresholdType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ConvergenceThresholdType
    getConvergenceThresholdDefaultValue ();

    //@}

    /**
     * @name treatNonConvergenceAsError
     *
     * @brief Accessor and modifier functions for the %treatNonConvergenceAsError
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean TreatNonConvergenceAsErrorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatNonConvergenceAsErrorType, char > TreatNonConvergenceAsErrorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreatNonConvergenceAsErrorType&
    getTreatNonConvergenceAsError () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreatNonConvergenceAsErrorType&
    getTreatNonConvergenceAsError ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatNonConvergenceAsError (const TreatNonConvergenceAsErrorType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static TreatNonConvergenceAsErrorType
    getTreatNonConvergenceAsErrorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HydraulicModelSequentialImplicitComplexType (const ThetaType&,
                                                 const ConvergenceThresholdType&,
                                                 const TreatNonConvergenceAsErrorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelSequentialImplicitComplexType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydraulicModelSequentialImplicitComplexType (const HydraulicModelSequentialImplicitComplexType& x,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydraulicModelSequentialImplicitComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HydraulicModelSequentialImplicitComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ThetaType > theta_;
    ::xsd::cxx::tree::one< ConvergenceThresholdType > convergenceThreshold_;
    ::xsd::cxx::tree::one< TreatNonConvergenceAsErrorType > treatNonConvergenceAsError_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HydraulicModelSimultaneousComplexType schema type.
   *
   * @nosubgrouping
   */
  class HydraulicModelSimultaneousComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name theta
     *
     * @brief Accessor and modifier functions for the %theta
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ThetaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThetaType, char, ::xsd::cxx::tree::schema_type::double_ > ThetaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ThetaType&
    getTheta () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ThetaType&
    getTheta ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTheta (const ThetaType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ThetaType
    getThetaDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HydraulicModelSimultaneousComplexType (const ThetaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelSimultaneousComplexType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydraulicModelSimultaneousComplexType (const HydraulicModelSimultaneousComplexType& x,
                                           ::xml_schema::Flags f = 0,
                                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydraulicModelSimultaneousComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HydraulicModelSimultaneousComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ThetaType > theta_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HydraulicModelOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class HydraulicModelOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nJac
     *
     * @brief Accessor and modifier functions for the %nJac
     * required element.
     *
     * number of evaluations of the Jacobian
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NJacType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NJacType, char > NJacTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NJacType&
    getNJac () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NJacType&
    getNJac ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNJac (const NJacType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNJac (::std::auto_ptr< NJacType > p);

    //@}

    /**
     * @name nFun
     *
     * @brief Accessor and modifier functions for the %nFun
     * required element.
     *
     * number of function evaluations
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType NFunType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NFunType, char > NFunTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NFunType&
    getNFun () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NFunType&
    getNFun ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNFun (const NFunType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNFun (::std::auto_ptr< NFunType > p);

    //@}

    /**
     * @name res
     *
     * @brief Accessor and modifier functions for the %res
     * required element.
     *
     * residuum at last iteration step, 0.5*sum(SQR(ri))
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ResType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResType, char > ResTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ResType&
    getRes () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ResType&
    getRes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRes (const ResType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRes (::std::auto_ptr< ResType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HydraulicModelOutputComplexType (const NJacType&,
                                     const NFunType&,
                                     const ResType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelOutputComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydraulicModelOutputComplexType (const HydraulicModelOutputComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydraulicModelOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HydraulicModelOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NJacType > nJac_;
    ::xsd::cxx::tree::one< NFunType > nFun_;
    ::xsd::cxx::tree::one< ResType > res_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConnectionInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConnectionInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name upstreamLevel
     *
     * @brief Accessor and modifier functions for the %upstreamLevel
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UpstreamLevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpstreamLevelType, char > UpstreamLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const UpstreamLevelType&
    getUpstreamLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    UpstreamLevelType&
    getUpstreamLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpstreamLevel (const UpstreamLevelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setUpstreamLevel (::std::auto_ptr< UpstreamLevelType > p);

    //@}

    /**
     * @name downstreamLevel
     *
     * @brief Accessor and modifier functions for the %downstreamLevel
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DownstreamLevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DownstreamLevelType, char > DownstreamLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DownstreamLevelType&
    getDownstreamLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DownstreamLevelType&
    getDownstreamLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDownstreamLevel (const DownstreamLevelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDownstreamLevel (::std::auto_ptr< DownstreamLevelType > p);

    //@}

    /**
     * @name discharge
     *
     * @brief Accessor and modifier functions for the %discharge
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DischargeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeType, char > DischargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DischargeType&
    getDischarge () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DischargeType&
    getDischarge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDischarge (const DischargeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDischarge (::std::auto_ptr< DischargeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConnectionInputComplexType (const UpstreamLevelType&,
                                const DownstreamLevelType&,
                                const DischargeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConnectionInputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConnectionInputComplexType (const ConnectionInputComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConnectionInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConnectionInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UpstreamLevelType > upstreamLevel_;
    ::xsd::cxx::tree::one< DownstreamLevelType > downstreamLevel_;
    ::xsd::cxx::tree::one< DischargeType > discharge_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConnectionOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConnectionOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name discharge
     *
     * @brief Accessor and modifier functions for the %discharge
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DischargeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeType, char > DischargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DischargeType&
    getDischarge () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DischargeType&
    getDischarge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDischarge (const DischargeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDischarge (::std::auto_ptr< DischargeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConnectionOutputComplexType (const DischargeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConnectionOutputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConnectionOutputComplexType (const ConnectionOutputComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConnectionOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConnectionOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DischargeType > discharge_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RoutingOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class RoutingOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name discharge
     *
     * @brief Accessor and modifier functions for the %discharge
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DischargeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DischargeType > DischargeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeType, char > DischargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DischargeOptional&
    getDischarge () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DischargeOptional&
    getDischarge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDischarge (const DischargeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDischarge (const DischargeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDischarge (::std::auto_ptr< DischargeType > p);

    //@}

    /**
     * @name error
     *
     * @brief Accessor and modifier functions for the %error
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ErrorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ErrorType > ErrorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ErrorOptional&
    getError () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ErrorOptional&
    getError ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setError (const ErrorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setError (const ErrorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setError (::std::auto_ptr< ErrorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RoutingOutputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RoutingOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RoutingOutputComplexType (const RoutingOutputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RoutingOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RoutingOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DischargeOptional discharge_;
    ErrorOptional error_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirRoutingComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirRoutingComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name simpleReservoir
     *
     * @brief Accessor and modifier functions for the %simpleReservoir
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SimpleReservoirComplexType SimpleReservoirType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SimpleReservoirType > SimpleReservoirSequence;

    /**
     * @brief Element iterator type.
     */
    typedef SimpleReservoirSequence::iterator SimpleReservoirIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SimpleReservoirSequence::const_iterator SimpleReservoirConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SimpleReservoirType, char > SimpleReservoirTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SimpleReservoirSequence&
    getSimpleReservoir () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SimpleReservoirSequence&
    getSimpleReservoir ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSimpleReservoir (const SimpleReservoirSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirRoutingComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirRoutingComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirRoutingComplexType (const ReservoirRoutingComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirRoutingComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirRoutingComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SimpleReservoirSequence simpleReservoir_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SimpleReservoirComplexType schema type.
   *
   * @nosubgrouping
   */
  class SimpleReservoirComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name storageCharacteristics
     *
     * @brief Accessor and modifier functions for the %storageCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StorageCharacteristicsComplexType StorageCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageCharacteristicsType, char > StorageCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageCharacteristicsType&
    getStorageCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageCharacteristicsType&
    getStorageCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageCharacteristics (const StorageCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > p);

    //@}

    /**
     * @name capacityCharacteristics
     *
     * @brief Accessor and modifier functions for the %capacityCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CapacityCharacteristicsComplexType CapacityCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityCharacteristicsType, char > CapacityCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CapacityCharacteristicsType&
    getCapacityCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CapacityCharacteristicsType&
    getCapacityCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityCharacteristics (const CapacityCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > p);

    //@}

    /**
     * @name multiplier
     *
     * @brief Accessor and modifier functions for the %multiplier
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::Multiplier MultiplierType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultiplierType, char > MultiplierTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MultiplierType&
    getMultiplier () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MultiplierType&
    getMultiplier ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMultiplier (const MultiplierType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMultiplier (::std::auto_ptr< MultiplierType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static MultiplierType
    getMultiplierDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SimpleReservoirComplexType (const StorageCharacteristicsType&,
                                const CapacityCharacteristicsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SimpleReservoirComplexType (::std::auto_ptr< StorageCharacteristicsType >&,
                                ::std::auto_ptr< CapacityCharacteristicsType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SimpleReservoirComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SimpleReservoirComplexType (const SimpleReservoirComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SimpleReservoirComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SimpleReservoirComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StorageCharacteristicsType > storageCharacteristics_;
    ::xsd::cxx::tree::one< CapacityCharacteristicsType > capacityCharacteristics_;
    ::xsd::cxx::tree::one< MultiplierType > multiplier_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConnectionCoefficientsComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConnectionCoefficientsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AType&
    getA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA (const AType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setA (::std::auto_ptr< AType > p);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BType, char > BTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BType&
    getB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BType&
    getB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setB (const BType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setB (::std::auto_ptr< BType > p);

    //@}

    /**
     * @name c
     *
     * @brief Accessor and modifier functions for the %c
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CType&
    getC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CType&
    getC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setC (const CType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setC (::std::auto_ptr< CType > p);

    //@}

    /**
     * @name d
     *
     * @brief Accessor and modifier functions for the %d
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType DType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DType&
    getD () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DType&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConnectionCoefficientsComplexType (const AType&,
                                       const BType&,
                                       const CType&,
                                       const DType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConnectionCoefficientsComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConnectionCoefficientsComplexType (const ConnectionCoefficientsComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConnectionCoefficientsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConnectionCoefficientsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AType > a_;
    ::xsd::cxx::tree::one< BType > b_;
    ::xsd::cxx::tree::one< CType > c_;
    ::xsd::cxx::tree::one< DType > d_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RulesComplexType schema type.
   *
   * @nosubgrouping
   */
  class RulesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name rule
     *
     * @brief Accessor and modifier functions for the %rule
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleComplexType RuleType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RuleType > RuleSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RuleSequence::iterator RuleIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RuleSequence::const_iterator RuleConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RuleType, char > RuleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RuleSequence&
    getRule () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RuleSequence&
    getRule ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRule (const RuleSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RulesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RulesComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RulesComplexType (const RulesComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RulesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RulesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RuleSequence rule_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class RuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name constant
     *
     * @brief Accessor and modifier functions for the %constant
     * optional element.
     *
     * Simple rule with constant value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ConstantRuleComplexType ConstantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConstantType > ConstantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstantType, char > ConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConstantOptional&
    getConstant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ConstantOptional&
    getConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstant (const ConstantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstant (const ConstantOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConstant (::std::auto_ptr< ConstantType > p);

    //@}

    /**
     * @name dateLookupTable
     *
     * @brief Accessor and modifier functions for the %dateLookupTable
     * optional element.
     *
     * Date lookup table, output y is a function of date and an input value
     * x, the interpolation on the date / value axis can be BLOCK or LINEAR,
     * the number of records should be constant for each date record
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateLookupTableComplexType DateLookupTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DateLookupTableType > DateLookupTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateLookupTableType, char > DateLookupTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DateLookupTableOptional&
    getDateLookupTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DateLookupTableOptional&
    getDateLookupTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDateLookupTable (const DateLookupTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDateLookupTable (const DateLookupTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDateLookupTable (::std::auto_ptr< DateLookupTableType > p);

    //@}

    /**
     * @name deadBandValue
     *
     * @brief Accessor and modifier functions for the %deadBandValue
     * optional element.
     *
     * Deadband threshold, yNew will become yOld, if the change yNew-yOld is
     * smaller than the threshold value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandValueComplexType DeadBandValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeadBandValueType > DeadBandValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeadBandValueType, char > DeadBandValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeadBandValueOptional&
    getDeadBandValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeadBandValueOptional&
    getDeadBandValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeadBandValue (const DeadBandValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeadBandValue (const DeadBandValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeadBandValue (::std::auto_ptr< DeadBandValueType > p);

    //@}

    /**
     * @name deadBandTime
     *
     * @brief Accessor and modifier functions for the %deadBandTime
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandTimeComplexType DeadBandTimeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeadBandTimeType > DeadBandTimeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeadBandTimeType, char > DeadBandTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeadBandTimeOptional&
    getDeadBandTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeadBandTimeOptional&
    getDeadBandTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeadBandTime (const DeadBandTimeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeadBandTime (const DeadBandTimeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeadBandTime (::std::auto_ptr< DeadBandTimeType > p);

    //@}

    /**
     * @name dedicated-Aebi
     *
     * @brief Accessor and modifier functions for the %dedicated-Aebi
     * optional element.
     *
     * Dedicated rule for the control of Bielersee, Canton Bern, CH
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AebiRuleComplexType Dedicated_AebiType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Dedicated_AebiType > Dedicated_AebiOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Dedicated_AebiType, char > Dedicated_AebiTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Dedicated_AebiOptional&
    getDedicated_Aebi () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Dedicated_AebiOptional&
    getDedicated_Aebi ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDedicated_Aebi (const Dedicated_AebiType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDedicated_Aebi (const Dedicated_AebiOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDedicated_Aebi (::std::auto_ptr< Dedicated_AebiType > p);

    //@}

    /**
     * @name dedicated-Thunersee
     *
     * @brief Accessor and modifier functions for the %dedicated-Thunersee
     * optional element.
     *
     * Dedicated rule for the control of Thunersee, Canton Bern, CH
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ThunerseeRuleComplexType Dedicated_ThunerseeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Dedicated_ThunerseeType > Dedicated_ThunerseeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Dedicated_ThunerseeType, char > Dedicated_ThunerseeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Dedicated_ThunerseeOptional&
    getDedicated_Thunersee () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Dedicated_ThunerseeOptional&
    getDedicated_Thunersee ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDedicated_Thunersee (const Dedicated_ThunerseeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDedicated_Thunersee (const Dedicated_ThunerseeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDedicated_Thunersee (::std::auto_ptr< Dedicated_ThunerseeType > p);

    //@}

    /**
     * @name expression
     *
     * @brief Accessor and modifier functions for the %expression
     * optional element.
     *
     * mathematical expression
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExpressionComplexType ExpressionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExpressionType > ExpressionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExpressionType, char > ExpressionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExpressionOptional&
    getExpression () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExpressionOptional&
    getExpression ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpression (const ExpressionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpression (const ExpressionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExpression (::std::auto_ptr< ExpressionType > p);

    //@}

    /**
     * @name guideband
     *
     * @brief Accessor and modifier functions for the %guideband
     * optional element.
     *
     * Guide band rule, output get 0 if input less equal xMin, 1 if input
     * greater equal xMax, linear interpolation otherwise xMin and xMax can
     * be a function of date, main application in combination with a relative
     * release of a reservoir outlet
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GuideBandRuleComplexType GuidebandType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GuidebandType > GuidebandOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GuidebandType, char > GuidebandTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GuidebandOptional&
    getGuideband () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GuidebandOptional&
    getGuideband ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGuideband (const GuidebandType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGuideband (const GuidebandOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGuideband (::std::auto_ptr< GuidebandType > p);

    //@}

    /**
     * @name interval
     *
     * @brief Accessor and modifier functions for the %interval
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IntervalComplexType IntervalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IntervalType > IntervalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IntervalType, char > IntervalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IntervalOptional&
    getInterval () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IntervalOptional&
    getInterval ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInterval (const IntervalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInterval (const IntervalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInterval (::std::auto_ptr< IntervalType > p);

    //@}

    /**
     * @name limiter
     *
     * @brief Accessor and modifier functions for the %limiter
     * optional element.
     *
     * Limiter for limiting the change of a variable in a time step to a
     * relative (PERCENTAGE) or absolute  (ABSOLUTE) change
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LimiterComplexType LimiterType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LimiterType > LimiterOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LimiterType, char > LimiterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LimiterOptional&
    getLimiter () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LimiterOptional&
    getLimiter ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLimiter (const LimiterType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLimiter (const LimiterOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLimiter (::std::auto_ptr< LimiterType > p);

    //@}

    /**
     * @name lookupTable
     *
     * @brief Accessor and modifier functions for the %lookupTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LookupTableComplexType LookupTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LookupTableType > LookupTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LookupTableType, char > LookupTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LookupTableOptional&
    getLookupTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LookupTableOptional&
    getLookupTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLookupTable (const LookupTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLookupTable (const LookupTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLookupTable (::std::auto_ptr< LookupTableType > p);

    //@}

    /**
     * @name lookup2DTable
     *
     * @brief Accessor and modifier functions for the %lookup2DTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Lookup2DTableComplexType Lookup2DTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Lookup2DTableType > Lookup2DTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Lookup2DTableType, char > Lookup2DTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Lookup2DTableOptional&
    getLookup2DTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Lookup2DTableOptional&
    getLookup2DTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLookup2DTable (const Lookup2DTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLookup2DTable (const Lookup2DTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLookup2DTable (::std::auto_ptr< Lookup2DTableType > p);

    //@}

    /**
     * @name merger
     *
     * @brief Accessor and modifier functions for the %merger
     * optional element.
     *
     * Data hierarchy, highest input has highest priority
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerComplexType MergerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MergerType > MergerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MergerType, char > MergerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MergerOptional&
    getMerger () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MergerOptional&
    getMerger ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMerger (const MergerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMerger (const MergerOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMerger (::std::auto_ptr< MergerType > p);

    //@}

    /**
     * @name pid
     *
     * @brief Accessor and modifier functions for the %pid
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PidComplexType PidType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PidType > PidOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PidType, char > PidTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PidOptional&
    getPid () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PidOptional&
    getPid ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPid (const PidType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPid (const PidOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPid (::std::auto_ptr< PidType > p);

    //@}

    /**
     * @name timeAbsolute
     *
     * @brief Accessor and modifier functions for the %timeAbsolute
     * optional element.
     *
     * absolute time controller
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeAbsoluteComplexType TimeAbsoluteType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeAbsoluteType > TimeAbsoluteOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeAbsoluteType, char > TimeAbsoluteTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeAbsoluteOptional&
    getTimeAbsolute () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeAbsoluteOptional&
    getTimeAbsolute ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeAbsolute (const TimeAbsoluteType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeAbsolute (const TimeAbsoluteOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeAbsolute (::std::auto_ptr< TimeAbsoluteType > p);

    //@}

    /**
     * @name timeRelative
     *
     * @brief Accessor and modifier functions for the %timeRelative
     * optional element.
     *
     * relative time controller
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeRelativeComplexType TimeRelativeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeRelativeType > TimeRelativeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeRelativeType, char > TimeRelativeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeRelativeOptional&
    getTimeRelative () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeRelativeOptional&
    getTimeRelative ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeRelative (const TimeRelativeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeRelative (const TimeRelativeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeRelative (::std::auto_ptr< TimeRelativeType > p);

    //@}

    /**
     * @name unitDelay
     *
     * @brief Accessor and modifier functions for the %unitDelay
     * optional element.
     *
     * Unit delay operator for  delaying a value by n times the time step of
     * the model.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UnitDelayComplexType UnitDelayType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnitDelayType > UnitDelayOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitDelayType, char > UnitDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnitDelayOptional&
    getUnitDelay () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UnitDelayOptional&
    getUnitDelay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUnitDelay (const UnitDelayType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUnitDelay (const UnitDelayOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnitDelay (::std::auto_ptr< UnitDelayType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RuleComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RuleComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RuleComplexType (const RuleComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ConstantOptional constant_;
    DateLookupTableOptional dateLookupTable_;
    DeadBandValueOptional deadBandValue_;
    DeadBandTimeOptional deadBandTime_;
    Dedicated_AebiOptional dedicated_Aebi_;
    Dedicated_ThunerseeOptional dedicated_Thunersee_;
    ExpressionOptional expression_;
    GuidebandOptional guideband_;
    IntervalOptional interval_;
    LimiterOptional limiter_;
    LookupTableOptional lookupTable_;
    Lookup2DTableOptional lookup2DTable_;
    MergerOptional merger_;
    PidOptional pid_;
    TimeAbsoluteOptional timeAbsolute_;
    TimeRelativeOptional timeRelative_;
    UnitDelayOptional unitDelay_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ThunerseeRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class ThunerseeRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name levelSetpoint
     *
     * @brief Accessor and modifier functions for the %levelSetpoint
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double LevelSetpointType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelSetpointType, char, ::xsd::cxx::tree::schema_type::double_ > LevelSetpointTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LevelSetpointType&
    getLevelSetpoint () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LevelSetpointType&
    getLevelSetpoint ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevelSetpoint (const LevelSetpointType& x);

    //@}

    /**
     * @name releaseLimiterPercentage
     *
     * @brief Accessor and modifier functions for the %releaseLimiterPercentage
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ReleaseLimiterPercentageType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseLimiterPercentageType, char, ::xsd::cxx::tree::schema_type::double_ > ReleaseLimiterPercentageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseLimiterPercentageType&
    getReleaseLimiterPercentage () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseLimiterPercentageType&
    getReleaseLimiterPercentage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReleaseLimiterPercentage (const ReleaseLimiterPercentageType& x);

    //@}

    /**
     * @name reservoir
     *
     * @brief Accessor and modifier functions for the %reservoir
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ReservoirThunerseeRuleComplexType ReservoirType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReservoirType, char > ReservoirTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReservoirType&
    getReservoir () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReservoirType&
    getReservoir ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReservoir (const ReservoirType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setReservoir (::std::auto_ptr< ReservoirType > p);

    //@}

    /**
     * @name weir
     *
     * @brief Accessor and modifier functions for the %weir
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::WeirThunerseeRuleComplexType WeirType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeirType, char > WeirTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WeirType&
    getWeir () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WeirType&
    getWeir ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeir (const WeirType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWeir (::std::auto_ptr< WeirType > p);

    //@}

    /**
     * @name tunnel
     *
     * @brief Accessor and modifier functions for the %tunnel
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TunnelThunerseeRuleComplexType TunnelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TunnelType, char > TunnelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TunnelType&
    getTunnel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TunnelType&
    getTunnel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTunnel (const TunnelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTunnel (::std::auto_ptr< TunnelType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ThunerseeRuleInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ThunerseeRuleOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ThunerseeRuleComplexType (const LevelSetpointType&,
                              const ReleaseLimiterPercentageType&,
                              const ReservoirType&,
                              const WeirType&,
                              const TunnelType&,
                              const InputType&,
                              const OutputType&,
                              const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ThunerseeRuleComplexType (const LevelSetpointType&,
                              const ReleaseLimiterPercentageType&,
                              ::std::auto_ptr< ReservoirType >&,
                              ::std::auto_ptr< WeirType >&,
                              ::std::auto_ptr< TunnelType >&,
                              ::std::auto_ptr< InputType >&,
                              ::std::auto_ptr< OutputType >&,
                              const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ThunerseeRuleComplexType (const ThunerseeRuleComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ThunerseeRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ThunerseeRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LevelSetpointType > levelSetpoint_;
    ::xsd::cxx::tree::one< ReleaseLimiterPercentageType > releaseLimiterPercentage_;
    ::xsd::cxx::tree::one< ReservoirType > reservoir_;
    ::xsd::cxx::tree::one< WeirType > weir_;
    ::xsd::cxx::tree::one< TunnelType > tunnel_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirThunerseeRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirThunerseeRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name storageCharacteristics
     *
     * @brief Accessor and modifier functions for the %storageCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StorageCharacteristicsComplexType StorageCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageCharacteristicsType, char > StorageCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageCharacteristicsType&
    getStorageCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageCharacteristicsType&
    getStorageCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageCharacteristics (const StorageCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirThunerseeRuleComplexType (const StorageCharacteristicsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReservoirThunerseeRuleComplexType (::std::auto_ptr< StorageCharacteristicsType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirThunerseeRuleComplexType (const ReservoirThunerseeRuleComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirThunerseeRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirThunerseeRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StorageCharacteristicsType > storageCharacteristics_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %WeirThunerseeRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class WeirThunerseeRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name capacityCharacteristics
     *
     * @brief Accessor and modifier functions for the %capacityCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CapacityCharacteristicsComplexType CapacityCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityCharacteristicsType, char > CapacityCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CapacityCharacteristicsType&
    getCapacityCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CapacityCharacteristicsType&
    getCapacityCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityCharacteristics (const CapacityCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    WeirThunerseeRuleComplexType (const CapacityCharacteristicsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    WeirThunerseeRuleComplexType (::std::auto_ptr< CapacityCharacteristicsType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    WeirThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WeirThunerseeRuleComplexType (const WeirThunerseeRuleComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual WeirThunerseeRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~WeirThunerseeRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CapacityCharacteristicsType > capacityCharacteristics_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TunnelThunerseeRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class TunnelThunerseeRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name levelThreshold
     *
     * @brief Accessor and modifier functions for the %levelThreshold
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double LevelThresholdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelThresholdType, char, ::xsd::cxx::tree::schema_type::double_ > LevelThresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LevelThresholdType&
    getLevelThreshold () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LevelThresholdType&
    getLevelThreshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevelThreshold (const LevelThresholdType& x);

    //@}

    /**
     * @name capacityCharacteristics
     *
     * @brief Accessor and modifier functions for the %capacityCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CapacityCharacteristicsComplexType CapacityCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityCharacteristicsType, char > CapacityCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CapacityCharacteristicsType&
    getCapacityCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CapacityCharacteristicsType&
    getCapacityCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityCharacteristics (const CapacityCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TunnelThunerseeRuleComplexType (const LevelThresholdType&,
                                    const CapacityCharacteristicsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TunnelThunerseeRuleComplexType (const LevelThresholdType&,
                                    ::std::auto_ptr< CapacityCharacteristicsType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TunnelThunerseeRuleComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TunnelThunerseeRuleComplexType (const TunnelThunerseeRuleComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TunnelThunerseeRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TunnelThunerseeRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LevelThresholdType > levelThreshold_;
    ::xsd::cxx::tree::one< CapacityCharacteristicsType > capacityCharacteristics_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ThunerseeRuleInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ThunerseeRuleInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name inflow
     *
     * @brief Accessor and modifier functions for the %inflow
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InflowType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InflowType, char > InflowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InflowType&
    getInflow () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InflowType&
    getInflow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInflow (const InflowType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInflow (::std::auto_ptr< InflowType > p);

    //@}

    /**
     * @name level
     *
     * @brief Accessor and modifier functions for the %level
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelType, char > LevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LevelType&
    getLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LevelType&
    getLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevel (const LevelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLevel (::std::auto_ptr< LevelType > p);

    //@}

    /**
     * @name catchment
     *
     * @brief Accessor and modifier functions for the %catchment
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType CatchmentType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CatchmentType, char > CatchmentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CatchmentType&
    getCatchment () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CatchmentType&
    getCatchment ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCatchment (const CatchmentType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCatchment (::std::auto_ptr< CatchmentType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ThunerseeRuleInputComplexType (const InflowType&,
                                   const LevelType&,
                                   const CatchmentType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ThunerseeRuleInputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ThunerseeRuleInputComplexType (const ThunerseeRuleInputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ThunerseeRuleInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ThunerseeRuleInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InflowType > inflow_;
    ::xsd::cxx::tree::one< LevelType > level_;
    ::xsd::cxx::tree::one< CatchmentType > catchment_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ThunerseeRuleOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ThunerseeRuleOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name releaseWeir
     *
     * @brief Accessor and modifier functions for the %releaseWeir
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseWeirType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseWeirType, char > ReleaseWeirTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseWeirType&
    getReleaseWeir () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseWeirType&
    getReleaseWeir ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReleaseWeir (const ReleaseWeirType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setReleaseWeir (::std::auto_ptr< ReleaseWeirType > p);

    //@}

    /**
     * @name releaseTunnel
     *
     * @brief Accessor and modifier functions for the %releaseTunnel
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseTunnelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseTunnelType, char > ReleaseTunnelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseTunnelType&
    getReleaseTunnel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseTunnelType&
    getReleaseTunnel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReleaseTunnel (const ReleaseTunnelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setReleaseTunnel (::std::auto_ptr< ReleaseTunnelType > p);

    //@}

    /**
     * @name releaseTotal
     *
     * @brief Accessor and modifier functions for the %releaseTotal
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseTotalType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseTotalType, char > ReleaseTotalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseTotalType&
    getReleaseTotal () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseTotalType&
    getReleaseTotal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReleaseTotal (const ReleaseTotalType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setReleaseTotal (::std::auto_ptr< ReleaseTotalType > p);

    //@}

    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ActiveType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActiveType > ActiveOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActiveOptional&
    getActive () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ActiveOptional&
    getActive ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setActive (const ActiveType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setActive (const ActiveOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActive (::std::auto_ptr< ActiveType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ThunerseeRuleOutputComplexType (const ReleaseWeirType&,
                                    const ReleaseTunnelType&,
                                    const ReleaseTotalType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ThunerseeRuleOutputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ThunerseeRuleOutputComplexType (const ThunerseeRuleOutputComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ThunerseeRuleOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ThunerseeRuleOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ReleaseWeirType > releaseWeir_;
    ::xsd::cxx::tree::one< ReleaseTunnelType > releaseTunnel_;
    ::xsd::cxx::tree::one< ReleaseTotalType > releaseTotal_;
    ActiveOptional active_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AebiRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class AebiRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name FactorRTG
     *
     * @brief Accessor and modifier functions for the %FactorRTG
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double FactorRTGType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorRTGType, char, ::xsd::cxx::tree::schema_type::double_ > FactorRTGTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FactorRTGType&
    getFactorRTG () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FactorRTGType&
    getFactorRTG ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFactorRTG (const FactorRTGType& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static FactorRTGType
    getFactorRTGDefaultValue ();

    //@}

    /**
     * @name LangeteFall
     *
     * @brief Accessor and modifier functions for the %LangeteFall
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CaseLangetenEnumStringType LangeteFallType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LangeteFallType, char > LangeteFallTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LangeteFallType&
    getLangeteFall () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LangeteFallType&
    getLangeteFall ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLangeteFall (const LangeteFallType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLangeteFall (::std::auto_ptr< LangeteFallType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AebiRuleInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::AebiRuleOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AebiRuleComplexType (const FactorRTGType&,
                         const LangeteFallType&,
                         const InputType&,
                         const OutputType&,
                         const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AebiRuleComplexType (const FactorRTGType&,
                         const LangeteFallType&,
                         ::std::auto_ptr< InputType >&,
                         ::std::auto_ptr< OutputType >&,
                         const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AebiRuleComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AebiRuleComplexType (const AebiRuleComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AebiRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AebiRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FactorRTGType > FactorRTG_;
    ::xsd::cxx::tree::one< LangeteFallType > LangeteFall_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AebiRuleInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class AebiRuleInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name AareBruegg
     *
     * @brief Accessor and modifier functions for the %AareBruegg
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType AareBrueggType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AareBrueggType, char > AareBrueggTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AareBrueggType&
    getAareBruegg () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AareBrueggType&
    getAareBruegg ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAareBruegg (const AareBrueggType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAareBruegg (::std::auto_ptr< AareBrueggType > p);

    //@}

    /**
     * @name AareBrueggMin2
     *
     * @brief Accessor and modifier functions for the %AareBrueggMin2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType AareBrueggMin2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AareBrueggMin2Type, char > AareBrueggMin2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AareBrueggMin2Type&
    getAareBrueggMin2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AareBrueggMin2Type&
    getAareBrueggMin2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAareBrueggMin2 (const AareBrueggMin2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAareBrueggMin2 (::std::auto_ptr< AareBrueggMin2Type > p);

    //@}

    /**
     * @name Emenmatt
     *
     * @brief Accessor and modifier functions for the %Emenmatt
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EmenmattType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EmenmattType, char > EmenmattTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EmenmattType&
    getEmenmatt () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EmenmattType&
    getEmenmatt ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEmenmatt (const EmenmattType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEmenmatt (::std::auto_ptr< EmenmattType > p);

    //@}

    /**
     * @name EmenmattMin4
     *
     * @brief Accessor and modifier functions for the %EmenmattMin4
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EmenmattMin4Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EmenmattMin4Type, char > EmenmattMin4Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EmenmattMin4Type&
    getEmenmattMin4 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EmenmattMin4Type&
    getEmenmattMin4 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEmenmattMin4 (const EmenmattMin4Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEmenmattMin4 (::std::auto_ptr< EmenmattMin4Type > p);

    //@}

    /**
     * @name Langeten
     *
     * @brief Accessor and modifier functions for the %Langeten
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LangetenType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LangetenType, char > LangetenTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LangetenType&
    getLangeten () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LangetenType&
    getLangeten ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLangeten (const LangetenType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLangeten (::std::auto_ptr< LangetenType > p);

    //@}

    /**
     * @name LangetenMin4
     *
     * @brief Accessor and modifier functions for the %LangetenMin4
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LangetenMin4Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LangetenMin4Type, char > LangetenMin4Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LangetenMin4Type&
    getLangetenMin4 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LangetenMin4Type&
    getLangetenMin4 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLangetenMin4 (const LangetenMin4Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLangetenMin4 (::std::auto_ptr< LangetenMin4Type > p);

    //@}

    /**
     * @name AareMurg
     *
     * @brief Accessor and modifier functions for the %AareMurg
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType AareMurgType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AareMurgType, char > AareMurgTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AareMurgType&
    getAareMurg () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AareMurgType&
    getAareMurg ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAareMurg (const AareMurgType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAareMurg (::std::auto_ptr< AareMurgType > p);

    //@}

    /**
     * @name PegelBielersee
     *
     * @brief Accessor and modifier functions for the %PegelBielersee
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PegelBielerseeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PegelBielerseeType, char > PegelBielerseeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PegelBielerseeType&
    getPegelBielersee () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PegelBielerseeType&
    getPegelBielersee ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPegelBielersee (const PegelBielerseeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPegelBielersee (::std::auto_ptr< PegelBielerseeType > p);

    //@}

    /**
     * @name AbflussReglementPort
     *
     * @brief Accessor and modifier functions for the %AbflussReglementPort
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType AbflussReglementPortType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AbflussReglementPortType, char > AbflussReglementPortTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AbflussReglementPortType&
    getAbflussReglementPort () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AbflussReglementPortType&
    getAbflussReglementPort ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAbflussReglementPort (const AbflussReglementPortType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAbflussReglementPort (::std::auto_ptr< AbflussReglementPortType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AebiRuleInputComplexType (const AareBrueggType&,
                              const AareBrueggMin2Type&,
                              const EmenmattType&,
                              const EmenmattMin4Type&,
                              const LangetenType&,
                              const LangetenMin4Type&,
                              const AareMurgType&,
                              const PegelBielerseeType&,
                              const AbflussReglementPortType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AebiRuleInputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AebiRuleInputComplexType (const AebiRuleInputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AebiRuleInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AebiRuleInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AareBrueggType > AareBruegg_;
    ::xsd::cxx::tree::one< AareBrueggMin2Type > AareBrueggMin2_;
    ::xsd::cxx::tree::one< EmenmattType > Emenmatt_;
    ::xsd::cxx::tree::one< EmenmattMin4Type > EmenmattMin4_;
    ::xsd::cxx::tree::one< LangetenType > Langeten_;
    ::xsd::cxx::tree::one< LangetenMin4Type > LangetenMin4_;
    ::xsd::cxx::tree::one< AareMurgType > AareMurg_;
    ::xsd::cxx::tree::one< PegelBielerseeType > PegelBielersee_;
    ::xsd::cxx::tree::one< AbflussReglementPortType > AbflussReglementPort_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AebiRuleOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class AebiRuleOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name RTG
     *
     * @brief Accessor and modifier functions for the %RTG
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RTGType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RTGType, char > RTGTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RTGType&
    getRTG () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RTGType&
    getRTG ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRTG (const RTGType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRTG (::std::auto_ptr< RTGType > p);

    //@}

    /**
     * @name AareMurg_oKWMin1
     *
     * @brief Accessor and modifier functions for the %AareMurg_oKWMin1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType AareMurg_oKWMin1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AareMurg_oKWMin1Type, char > AareMurg_oKWMin1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AareMurg_oKWMin1Type&
    getAareMurg_oKWMin1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AareMurg_oKWMin1Type&
    getAareMurg_oKWMin1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAareMurg_oKWMin1 (const AareMurg_oKWMin1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAareMurg_oKWMin1 (::std::auto_ptr< AareMurg_oKWMin1Type > p);

    //@}

    /**
     * @name ProvMaxAbflussPort
     *
     * @brief Accessor and modifier functions for the %ProvMaxAbflussPort
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ProvMaxAbflussPortType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ProvMaxAbflussPortType, char > ProvMaxAbflussPortTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ProvMaxAbflussPortType&
    getProvMaxAbflussPort () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ProvMaxAbflussPortType&
    getProvMaxAbflussPort ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setProvMaxAbflussPort (const ProvMaxAbflussPortType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setProvMaxAbflussPort (::std::auto_ptr< ProvMaxAbflussPortType > p);

    //@}

    /**
     * @name MaxAbflussPort
     *
     * @brief Accessor and modifier functions for the %MaxAbflussPort
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType MaxAbflussPortType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxAbflussPortType, char > MaxAbflussPortTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MaxAbflussPortType&
    getMaxAbflussPort () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MaxAbflussPortType&
    getMaxAbflussPort ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMaxAbflussPort (const MaxAbflussPortType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMaxAbflussPort (::std::auto_ptr< MaxAbflussPortType > p);

    //@}

    /**
     * @name AbflussaenderungPort
     *
     * @brief Accessor and modifier functions for the %AbflussaenderungPort
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType AbflussaenderungPortType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AbflussaenderungPortType, char > AbflussaenderungPortTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AbflussaenderungPortType&
    getAbflussaenderungPort () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AbflussaenderungPortType&
    getAbflussaenderungPort ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAbflussaenderungPort (const AbflussaenderungPortType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAbflussaenderungPort (::std::auto_ptr< AbflussaenderungPortType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AebiRuleOutputComplexType (const RTGType&,
                               const AareMurg_oKWMin1Type&,
                               const ProvMaxAbflussPortType&,
                               const MaxAbflussPortType&,
                               const AbflussaenderungPortType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AebiRuleOutputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AebiRuleOutputComplexType (const AebiRuleOutputComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AebiRuleOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AebiRuleOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RTGType > RTG_;
    ::xsd::cxx::tree::one< AareMurg_oKWMin1Type > AareMurg_oKWMin1_;
    ::xsd::cxx::tree::one< ProvMaxAbflussPortType > ProvMaxAbflussPort_;
    ::xsd::cxx::tree::one< MaxAbflussPortType > MaxAbflussPort_;
    ::xsd::cxx::tree::one< AbflussaenderungPortType > AbflussaenderungPort_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LookupTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class LookupTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name property
     *
     * @brief Accessor and modifier functions for the %property
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Property PropertyType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PropertyType > PropertySequence;

    /**
     * @brief Element iterator type.
     */
    typedef PropertySequence::iterator PropertyIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef PropertySequence::const_iterator PropertyConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PropertyType, char > PropertyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PropertySequence&
    getProperty () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PropertySequence&
    getProperty ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setProperty (const PropertySequence& s);

    //@}

    /**
     * @name table
     *
     * @brief Accessor and modifier functions for the %table
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TableLookupTableComplexType TableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TableType > TableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TableType, char > TableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TableOptional&
    getTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TableOptional&
    getTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTable (const TableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTable (const TableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTable (::std::auto_ptr< TableType > p);

    //@}

    /**
     * @name tableExternal
     *
     * @brief Accessor and modifier functions for the %tableExternal
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String TableExternalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TableExternalType > TableExternalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TableExternalType, char > TableExternalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TableExternalOptional&
    getTableExternal () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TableExternalOptional&
    getTableExternal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTableExternal (const TableExternalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTableExternal (const TableExternalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTableExternal (::std::auto_ptr< TableExternalType > p);

    //@}

    /**
     * @name interpolationOption
     *
     * @brief Accessor and modifier functions for the %interpolationOption
     * optional element.
     *
     * table interpolation can be BLOCK or LINEAR, default setting if not
     * provided is LINEAR
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InterpolationOptionEnumStringType InterpolationOptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InterpolationOptionType > InterpolationOptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterpolationOptionType, char > InterpolationOptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InterpolationOptionOptional&
    getInterpolationOption () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InterpolationOptionOptional&
    getInterpolationOption ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInterpolationOption (const InterpolationOptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInterpolationOption (const InterpolationOptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInterpolationOption (::std::auto_ptr< InterpolationOptionType > p);

    //@}

    /**
     * @name extrapolationOption
     *
     * @brief Accessor and modifier functions for the %extrapolationOption
     * optional element.
     *
     * table interpolation can be BLOCK or LINEAR, default setting if not
     * provided is LINEAR
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InterpolationOptionEnumStringType ExtrapolationOptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtrapolationOptionType > ExtrapolationOptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtrapolationOptionType, char > ExtrapolationOptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtrapolationOptionOptional&
    getExtrapolationOption () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtrapolationOptionOptional&
    getExtrapolationOption ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtrapolationOption (const ExtrapolationOptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtrapolationOption (const ExtrapolationOptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtrapolationOption (::std::auto_ptr< ExtrapolationOptionType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LookupTableInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LookupTableOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LookupTableComplexType (const InputType&,
                            const OutputType&,
                            const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LookupTableComplexType (::std::auto_ptr< InputType >&,
                            ::std::auto_ptr< OutputType >&,
                            const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LookupTableComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LookupTableComplexType (const LookupTableComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LookupTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LookupTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PropertySequence property_;
    TableOptional table_;
    TableExternalOptional tableExternal_;
    InterpolationOptionOptional interpolationOption_;
    ExtrapolationOptionOptional extrapolationOption_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TableLookupTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class TableLookupTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name record
     *
     * @brief Accessor and modifier functions for the %record
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateRecord2DataComplexType RecordType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RecordType > RecordSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RecordSequence::iterator RecordIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RecordSequence::const_iterator RecordConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RecordType, char > RecordTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RecordSequence&
    getRecord () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RecordSequence&
    getRecord ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRecord (const RecordSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TableLookupTableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TableLookupTableComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TableLookupTableComplexType (const TableLookupTableComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TableLookupTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TableLookupTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RecordSequence record_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Lookup2DTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class Lookup2DTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name table
     *
     * @brief Accessor and modifier functions for the %table
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Table2DLookupTableComplexType TableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TableType, char > TableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TableType&
    getTable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TableType&
    getTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTable (const TableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTable (::std::auto_ptr< TableType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Lookup2DTableInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Lookup2DTableOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Lookup2DTableComplexType (const TableType&,
                              const InputType&,
                              const OutputType&,
                              const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Lookup2DTableComplexType (::std::auto_ptr< TableType >&,
                              ::std::auto_ptr< InputType >&,
                              ::std::auto_ptr< OutputType >&,
                              const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Lookup2DTableComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Lookup2DTableComplexType (const Lookup2DTableComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Lookup2DTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Lookup2DTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TableType > table_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Table2DLookupTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class Table2DLookupTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ValueArrayComplexType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ValueArrayComplexType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name matrix
     *
     * @brief Accessor and modifier functions for the %matrix
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::XDimComplexType MatrixType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MatrixType, char > MatrixTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MatrixType&
    getMatrix () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MatrixType&
    getMatrix ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMatrix (const MatrixType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMatrix (::std::auto_ptr< MatrixType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Table2DLookupTableComplexType (const XType&,
                                   const YType&,
                                   const MatrixType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Table2DLookupTableComplexType (::std::auto_ptr< XType >&,
                                   ::std::auto_ptr< YType >&,
                                   ::std::auto_ptr< MatrixType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Table2DLookupTableComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Table2DLookupTableComplexType (const Table2DLookupTableComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Table2DLookupTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Table2DLookupTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< YType > y_;
    ::xsd::cxx::tree::one< MatrixType > matrix_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %XDimComplexType schema type.
   *
   * @nosubgrouping
   */
  class XDimComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name xDim
     *
     * @brief Accessor and modifier functions for the %xDim
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::YDimComplexType XDimType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< XDimType > XDimSequence;

    /**
     * @brief Element iterator type.
     */
    typedef XDimSequence::iterator XDimIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef XDimSequence::const_iterator XDimConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XDimType, char > XDimTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const XDimSequence&
    getXDim () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    XDimSequence&
    getXDim ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setXDim (const XDimSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    XDimComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    XDimComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    XDimComplexType (const XDimComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual XDimComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~XDimComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    XDimSequence xDim_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %YDimComplexType schema type.
   *
   * @nosubgrouping
   */
  class YDimComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name yDim
     *
     * @brief Accessor and modifier functions for the %yDim
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Float YDimType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< YDimType > YDimSequence;

    /**
     * @brief Element iterator type.
     */
    typedef YDimSequence::iterator YDimIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef YDimSequence::const_iterator YDimConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YDimType, char > YDimTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const YDimSequence&
    getYDim () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    YDimSequence&
    getYDim ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setYDim (const YDimSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    YDimComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    YDimComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    YDimComplexType (const YDimComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual YDimComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~YDimComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    YDimSequence yDim_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ValueArrayComplexType schema type.
   *
   * @nosubgrouping
   */
  class ValueArrayComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Float ValueType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ValueType > ValueSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ValueSequence::iterator ValueIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ValueSequence::const_iterator ValueConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ValueSequence&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ValueSequence&
    getValue ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setValue (const ValueSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ValueArrayComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ValueArrayComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ValueArrayComplexType (const ValueArrayComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ValueArrayComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ValueArrayComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueSequence value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IntervalComplexType schema type.
   *
   * @nosubgrouping
   */
  class IntervalComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name settingBelow
     *
     * @brief Accessor and modifier functions for the %settingBelow
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingBelowType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingBelowType, char, ::xsd::cxx::tree::schema_type::double_ > SettingBelowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SettingBelowType&
    getSettingBelow () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SettingBelowType&
    getSettingBelow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingBelow (const SettingBelowType& x);

    //@}

    /**
     * @name settingAbove
     *
     * @brief Accessor and modifier functions for the %settingAbove
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingAboveType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingAboveType, char, ::xsd::cxx::tree::schema_type::double_ > SettingAboveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SettingAboveType&
    getSettingAbove () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SettingAboveType&
    getSettingAbove ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingAbove (const SettingAboveType& x);

    //@}

    /**
     * @name settingMaxSpeed
     *
     * @brief Accessor and modifier functions for the %settingMaxSpeed
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingMaxSpeedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SettingMaxSpeedType > SettingMaxSpeedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingMaxSpeedType, char, ::xsd::cxx::tree::schema_type::double_ > SettingMaxSpeedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SettingMaxSpeedOptional&
    getSettingMaxSpeed () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SettingMaxSpeedOptional&
    getSettingMaxSpeed ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingMaxSpeed (const SettingMaxSpeedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSettingMaxSpeed (const SettingMaxSpeedOptional& x);

    //@}

    /**
     * @name settingMaxStep
     *
     * @brief Accessor and modifier functions for the %settingMaxStep
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingMaxStepType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SettingMaxStepType > SettingMaxStepOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingMaxStepType, char, ::xsd::cxx::tree::schema_type::double_ > SettingMaxStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SettingMaxStepOptional&
    getSettingMaxStep () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SettingMaxStepOptional&
    getSettingMaxStep ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingMaxStep (const SettingMaxStepType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSettingMaxStep (const SettingMaxStepOptional& x);

    //@}

    /**
     * @name deadbandSetpointAbsolute
     *
     * @brief Accessor and modifier functions for the %deadbandSetpointAbsolute
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DeadbandSetpointAbsoluteType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeadbandSetpointAbsoluteType > DeadbandSetpointAbsoluteOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeadbandSetpointAbsoluteType, char, ::xsd::cxx::tree::schema_type::double_ > DeadbandSetpointAbsoluteTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeadbandSetpointAbsoluteOptional&
    getDeadbandSetpointAbsolute () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeadbandSetpointAbsoluteOptional&
    getDeadbandSetpointAbsolute ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeadbandSetpointAbsolute (const DeadbandSetpointAbsoluteType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeadbandSetpointAbsolute (const DeadbandSetpointAbsoluteOptional& x);

    //@}

    /**
     * @name deadbandSetpointRelative
     *
     * @brief Accessor and modifier functions for the %deadbandSetpointRelative
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DeadbandSetpointRelativeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeadbandSetpointRelativeType > DeadbandSetpointRelativeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeadbandSetpointRelativeType, char, ::xsd::cxx::tree::schema_type::double_ > DeadbandSetpointRelativeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeadbandSetpointRelativeOptional&
    getDeadbandSetpointRelative () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeadbandSetpointRelativeOptional&
    getDeadbandSetpointRelative ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeadbandSetpointRelative (const DeadbandSetpointRelativeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeadbandSetpointRelative (const DeadbandSetpointRelativeOptional& x);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IntervalInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::IntervalOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IntervalComplexType (const SettingBelowType&,
                         const SettingAboveType&,
                         const InputType&,
                         const OutputType&,
                         const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    IntervalComplexType (const SettingBelowType&,
                         const SettingAboveType&,
                         ::std::auto_ptr< InputType >&,
                         ::std::auto_ptr< OutputType >&,
                         const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IntervalComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntervalComplexType (const IntervalComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IntervalComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IntervalComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SettingBelowType > settingBelow_;
    ::xsd::cxx::tree::one< SettingAboveType > settingAbove_;
    SettingMaxSpeedOptional settingMaxSpeed_;
    SettingMaxStepOptional settingMaxStep_;
    DeadbandSetpointAbsoluteOptional deadbandSetpointAbsolute_;
    DeadbandSetpointRelativeOptional deadbandSetpointRelative_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IntervalInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class IntervalInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     *
     * reference to time series ID
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name setpoint
     *
     * @brief Accessor and modifier functions for the %setpoint
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SetpointType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetpointType, char > SetpointTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SetpointType&
    getSetpoint () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SetpointType&
    getSetpoint ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetpoint (const SetpointType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSetpoint (::std::auto_ptr< SetpointType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IntervalInputComplexType (const XType&,
                              const SetpointType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    IntervalInputComplexType (::std::auto_ptr< XType >&,
                              const SetpointType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IntervalInputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntervalInputComplexType (const IntervalInputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IntervalInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IntervalInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< SetpointType > setpoint_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IntervalOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class IntervalOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name status
     *
     * @brief Accessor and modifier functions for the %status
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StatusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StatusType&
    getStatus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StatusType&
    getStatus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStatus (const StatusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStatus (::std::auto_ptr< StatusType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IntervalOutputComplexType (const YType&,
                               const StatusType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IntervalOutputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntervalOutputComplexType (const IntervalOutputComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IntervalOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IntervalOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;
    ::xsd::cxx::tree::one< StatusType > status_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateLookupTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateLookupTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name interpolationOptions
     *
     * @brief Accessor and modifier functions for the %interpolationOptions
     * required element.
     *
     * Interpolation option BLOCK / LINEAR for the two inputs date and value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InterpolationOptionsComplexType InterpolationOptionsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterpolationOptionsType, char > InterpolationOptionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InterpolationOptionsType&
    getInterpolationOptions () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InterpolationOptionsType&
    getInterpolationOptions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInterpolationOptions (const InterpolationOptionsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInterpolationOptions (::std::auto_ptr< InterpolationOptionsType > p);

    //@}

    /**
     * @name dateRecord
     *
     * @brief Accessor and modifier functions for the %dateRecord
     * sequence element.
     *
     * Lookup table at a date location
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateRecord2ComplexType DateRecordType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DateRecordType > DateRecordSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DateRecordSequence::iterator DateRecordIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DateRecordSequence::const_iterator DateRecordConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateRecordType, char > DateRecordTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DateRecordSequence&
    getDateRecord () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DateRecordSequence&
    getDateRecord ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDateRecord (const DateRecordSequence& s);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateLookupTableInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateLookupTableOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateLookupTableComplexType (const InterpolationOptionsType&,
                                const InputType&,
                                const OutputType&,
                                const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DateLookupTableComplexType (::std::auto_ptr< InterpolationOptionsType >&,
                                ::std::auto_ptr< InputType >&,
                                ::std::auto_ptr< OutputType >&,
                                const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateLookupTableComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateLookupTableComplexType (const DateLookupTableComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateLookupTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateLookupTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InterpolationOptionsType > interpolationOptions_;
    DateRecordSequence dateRecord_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InterpolationOptionsComplexType schema type.
   *
   * @nosubgrouping
   */
  class InterpolationOptionsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name date
     *
     * @brief Accessor and modifier functions for the %date
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InterpolationOptionEnumStringType DateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateType, char > DateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DateType&
    getDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DateType&
    getDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDate (const DateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDate (::std::auto_ptr< DateType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InterpolationOptionEnumStringType ValueType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValue (::std::auto_ptr< ValueType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InterpolationOptionsComplexType (const DateType&,
                                     const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InterpolationOptionsComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InterpolationOptionsComplexType (const InterpolationOptionsComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InterpolationOptionsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InterpolationOptionsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DateType > date_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateRecord2ComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateRecord2ComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name record
     *
     * @brief Accessor and modifier functions for the %record
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateRecord2DataComplexType RecordType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RecordType > RecordSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RecordSequence::iterator RecordIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RecordSequence::const_iterator RecordConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RecordType, char > RecordTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RecordSequence&
    getRecord () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RecordSequence&
    getRecord ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRecord (const RecordSequence& s);

    //@}

    /**
     * @name monthDay
     *
     * @brief Accessor and modifier functions for the %monthDay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::GmonthDay MonthDayType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MonthDayType, char > MonthDayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MonthDayType&
    getMonthDay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MonthDayType&
    getMonthDay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMonthDay (const MonthDayType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMonthDay (::std::auto_ptr< MonthDayType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateRecord2ComplexType (const MonthDayType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateRecord2ComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateRecord2ComplexType (const DateRecord2ComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateRecord2ComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateRecord2ComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RecordSequence record_;
    ::xsd::cxx::tree::one< MonthDayType > monthDay_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateRecord2DataComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateRecord2DataComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double XType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char, ::xsd::cxx::tree::schema_type::double_ > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    XType&
    getX ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX (const XType& x);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double YType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char, ::xsd::cxx::tree::schema_type::double_ > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    YType&
    getY ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setY (const YType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateRecord2DataComplexType (const XType&,
                                const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateRecord2DataComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateRecord2DataComplexType (const DateRecord2DataComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateRecord2DataComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateRecord2DataComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateLookupTableInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateLookupTableInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YType > YOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YOptional&
    getY () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YOptional&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setY (const YOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateLookupTableInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateLookupTableInputComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateLookupTableInputComplexType (const DateLookupTableInputComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateLookupTableInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateLookupTableInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    YOptional y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateLookupTableOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateLookupTableOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name active
     *
     * @brief Accessor and modifier functions for the %active
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ActiveType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActiveType > ActiveOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActiveOptional&
    getActive () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ActiveOptional&
    getActive ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setActive (const ActiveType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setActive (const ActiveOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActive (::std::auto_ptr< ActiveType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateLookupTableOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateLookupTableOutputComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateLookupTableOutputComplexType (const DateLookupTableOutputComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateLookupTableOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateLookupTableOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;
    ActiveOptional active_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LookupTableInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class LookupTableInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     *
     * reference to time series ID
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X1 XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YType > YOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YOptional&
    getY () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YOptional&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setY (const YOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LookupTableInputComplexType (const XType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LookupTableInputComplexType (::std::auto_ptr< XType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LookupTableInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LookupTableInputComplexType (const LookupTableInputComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LookupTableInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LookupTableInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    YOptional y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LookupTableOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class LookupTableOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LookupTableOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LookupTableOutputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LookupTableOutputComplexType (const LookupTableOutputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LookupTableOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LookupTableOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Lookup2DTableInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class Lookup2DTableInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name z
     *
     * @brief Accessor and modifier functions for the %z
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ZType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ZType > ZOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ZType, char > ZTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ZOptional&
    getZ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ZOptional&
    getZ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setZ (const ZType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setZ (const ZOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setZ (::std::auto_ptr< ZType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Lookup2DTableInputComplexType (const XType&,
                                   const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Lookup2DTableInputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Lookup2DTableInputComplexType (const Lookup2DTableInputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Lookup2DTableInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Lookup2DTableInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< YType > y_;
    ZOptional z_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Lookup2DTableOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class Lookup2DTableOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name z
     *
     * @brief Accessor and modifier functions for the %z
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ZType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ZType, char > ZTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ZType&
    getZ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ZType&
    getZ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setZ (const ZType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setZ (::std::auto_ptr< ZType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Lookup2DTableOutputComplexType (const ZType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Lookup2DTableOutputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Lookup2DTableOutputComplexType (const Lookup2DTableOutputComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Lookup2DTableOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Lookup2DTableOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ZType > z_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PolygonLookupComplexType schema type.
   *
   * @nosubgrouping
   */
  class PolygonLookupComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name polygons
     *
     * @brief Accessor and modifier functions for the %polygons
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PolygonsComplexType PolygonsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PolygonsType, char > PolygonsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PolygonsType&
    getPolygons () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PolygonsType&
    getPolygons ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPolygons (const PolygonsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPolygons (::std::auto_ptr< PolygonsType > p);

    //@}

    /**
     * @name default
     *
     * @brief Accessor and modifier functions for the %default
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DefaultType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultType > DefaultOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultType, char, ::xsd::cxx::tree::schema_type::double_ > DefaultTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultOptional&
    getDefault () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DefaultOptional&
    getDefault ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDefault (const DefaultType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDefault (const DefaultOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static DefaultType
    getDefaultDefaultValue ();

    //@}

    /**
     * @name true
     *
     * @brief Accessor and modifier functions for the %true
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType TrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TrueType > TrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TrueType, char > TrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TrueOptional&
    getTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TrueOptional&
    getTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTrue (const TrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTrue (const TrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTrue (::std::auto_ptr< TrueType > p);

    //@}

    /**
     * @name false
     *
     * @brief Accessor and modifier functions for the %false
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType FalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FalseType > FalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FalseType, char > FalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FalseOptional&
    getFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FalseOptional&
    getFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFalse (const FalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFalse (const FalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFalse (::std::auto_ptr< FalseType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PolygonLookupInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PolygonLookupOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PolygonLookupComplexType (const PolygonsType&,
                              const InputType&,
                              const OutputType&,
                              const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PolygonLookupComplexType (::std::auto_ptr< PolygonsType >&,
                              ::std::auto_ptr< InputType >&,
                              ::std::auto_ptr< OutputType >&,
                              const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PolygonLookupComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PolygonLookupComplexType (const PolygonLookupComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PolygonLookupComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PolygonLookupComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PolygonsType > polygons_;
    DefaultOptional default__;
    TrueOptional true__;
    FalseOptional false__;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PolygonsComplexType schema type.
   *
   * @nosubgrouping
   */
  class PolygonsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name polygon
     *
     * @brief Accessor and modifier functions for the %polygon
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PolygonComplexType PolygonType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PolygonType > PolygonSequence;

    /**
     * @brief Element iterator type.
     */
    typedef PolygonSequence::iterator PolygonIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef PolygonSequence::const_iterator PolygonConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PolygonType, char > PolygonTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PolygonSequence&
    getPolygon () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PolygonSequence&
    getPolygon ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setPolygon (const PolygonSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PolygonsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PolygonsComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PolygonsComplexType (const PolygonsComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PolygonsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PolygonsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PolygonSequence polygon_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PolygonComplexType schema type.
   *
   * @nosubgrouping
   */
  class PolygonComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ValueOptional&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ValueOptional&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setValue (const ValueOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ValueType
    getValueDefaultValue ();

    //@}

    /**
     * @name edges
     *
     * @brief Accessor and modifier functions for the %edges
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EdgesComplexType EdgesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EdgesType, char > EdgesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EdgesType&
    getEdges () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EdgesType&
    getEdges ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEdges (const EdgesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEdges (::std::auto_ptr< EdgesType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdOptional&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    IdOptional&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setId (const IdOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PolygonComplexType (const EdgesType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PolygonComplexType (::std::auto_ptr< EdgesType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PolygonComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PolygonComplexType (const PolygonComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PolygonComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PolygonComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional value_;
    ::xsd::cxx::tree::one< EdgesType > edges_;
    IdOptional id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EdgesComplexType schema type.
   *
   * @nosubgrouping
   */
  class EdgesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name edge
     *
     * @brief Accessor and modifier functions for the %edge
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EdgeComplexType EdgeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< EdgeType > EdgeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef EdgeSequence::iterator EdgeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef EdgeSequence::const_iterator EdgeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EdgeType, char > EdgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const EdgeSequence&
    getEdge () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    EdgeSequence&
    getEdge ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setEdge (const EdgeSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EdgesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EdgesComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EdgesComplexType (const EdgesComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EdgesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EdgesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    EdgeSequence edge_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EdgeComplexType schema type.
   *
   * @nosubgrouping
   */
  class EdgeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1
     *
     * @brief Accessor and modifier functions for the %x1
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double X1Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1Type, char, ::xsd::cxx::tree::schema_type::double_ > X1Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const X1Type&
    getX1 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    X1Type&
    getX1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX1 (const X1Type& x);

    //@}

    /**
     * @name x2
     *
     * @brief Accessor and modifier functions for the %x2
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double X2Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2Type, char, ::xsd::cxx::tree::schema_type::double_ > X2Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const X2Type&
    getX2 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    X2Type&
    getX2 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX2 (const X2Type& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EdgeComplexType (const X1Type&,
                     const X2Type&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EdgeComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EdgeComplexType (const EdgeComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EdgeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EdgeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< X1Type > x1_;
    ::xsd::cxx::tree::one< X2Type > x2_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PolygonLookupInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class PolygonLookupInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1
     *
     * @brief Accessor and modifier functions for the %x1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X11 X1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1Type, char > X1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const X1Type&
    getX1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    X1Type&
    getX1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1 (const X1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX1 (::std::auto_ptr< X1Type > p);

    //@}

    /**
     * @name x2
     *
     * @brief Accessor and modifier functions for the %x2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X2 X2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2Type, char > X2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const X2Type&
    getX2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    X2Type&
    getX2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2 (const X2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX2 (::std::auto_ptr< X2Type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PolygonLookupInputComplexType (const X1Type&,
                                   const X2Type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PolygonLookupInputComplexType (::std::auto_ptr< X1Type >&,
                                   ::std::auto_ptr< X2Type >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PolygonLookupInputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PolygonLookupInputComplexType (const PolygonLookupInputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PolygonLookupInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PolygonLookupInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< X1Type > x1_;
    ::xsd::cxx::tree::one< X2Type > x2_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PolygonLookupOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class PolygonLookupOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name status
     *
     * @brief Accessor and modifier functions for the %status
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StatusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StatusType&
    getStatus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StatusType&
    getStatus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStatus (const StatusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStatus (::std::auto_ptr< StatusType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PolygonLookupOutputComplexType (const StatusType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PolygonLookupOutputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PolygonLookupOutputComplexType (const PolygonLookupOutputComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PolygonLookupOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PolygonLookupOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StatusType > status_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SpreadsheetComplexType schema type.
   *
   * @nosubgrouping
   */
  class SpreadsheetComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name validPeriods
     *
     * @brief Accessor and modifier functions for the %validPeriods
     * optional element.
     *
     * optional period of the year for which the trigger is active
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ValidPeriodsComplexType ValidPeriodsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ValidPeriodsType > ValidPeriodsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValidPeriodsType, char > ValidPeriodsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ValidPeriodsOptional&
    getValidPeriods () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ValidPeriodsOptional&
    getValidPeriods ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValidPeriods (const ValidPeriodsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setValidPeriods (const ValidPeriodsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setValidPeriods (::std::auto_ptr< ValidPeriodsType > p);

    //@}

    /**
     * @name defaultInputValue
     *
     * @brief Accessor and modifier functions for the %defaultInputValue
     * optional element.
     *
     * default input value, if input is NaN or infinity
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DefaultInputValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultInputValueType > DefaultInputValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultInputValueType, char, ::xsd::cxx::tree::schema_type::double_ > DefaultInputValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultInputValueOptional&
    getDefaultInputValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DefaultInputValueOptional&
    getDefaultInputValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDefaultInputValue (const DefaultInputValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDefaultInputValue (const DefaultInputValueOptional& x);

    //@}

    /**
     * @name defaultOutputValue
     *
     * @brief Accessor and modifier functions for the %defaultOutputValue
     * optional element.
     *
     * default output, if no combination of the table applies
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DefaultOutputValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultOutputValueType > DefaultOutputValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultOutputValueType, char, ::xsd::cxx::tree::schema_type::double_ > DefaultOutputValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultOutputValueOptional&
    getDefaultOutputValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DefaultOutputValueOptional&
    getDefaultOutputValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDefaultOutputValue (const DefaultOutputValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDefaultOutputValue (const DefaultOutputValueOptional& x);

    //@}

    /**
     * @name tolerance
     *
     * @brief Accessor and modifier functions for the %tolerance
     * required element.
     *
     * tolerance for finding a match, keep in mind that the all variable are
     * stored in doubles
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ToleranceType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ToleranceType, char, ::xsd::cxx::tree::schema_type::double_ > ToleranceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ToleranceType&
    getTolerance () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ToleranceType&
    getTolerance ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTolerance (const ToleranceType& x);

    //@}

    /**
     * @name tables
     *
     * @brief Accessor and modifier functions for the %tables
     * required element.
     *
     * number of tables with input, output values, the initial state can be
     * taken into account optionally
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpreadsheetTablesComplexType TablesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TablesType, char > TablesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TablesType&
    getTables () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TablesType&
    getTables ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTables (const TablesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTables (::std::auto_ptr< TablesType > p);

    //@}

    /**
     * @name true
     *
     * @brief Accessor and modifier functions for the %true
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType TrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TrueType > TrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TrueType, char > TrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TrueOptional&
    getTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TrueOptional&
    getTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTrue (const TrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTrue (const TrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTrue (::std::auto_ptr< TrueType > p);

    //@}

    /**
     * @name false
     *
     * @brief Accessor and modifier functions for the %false
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType FalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FalseType > FalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FalseType, char > FalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FalseOptional&
    getFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FalseOptional&
    getFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFalse (const FalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFalse (const FalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFalse (::std::auto_ptr< FalseType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpreadsheetInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpreadsheetOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpreadsheetComplexType (const ToleranceType&,
                            const TablesType&,
                            const InputType&,
                            const OutputType&,
                            const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SpreadsheetComplexType (const ToleranceType&,
                            ::std::auto_ptr< TablesType >&,
                            ::std::auto_ptr< InputType >&,
                            ::std::auto_ptr< OutputType >&,
                            const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpreadsheetComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpreadsheetComplexType (const SpreadsheetComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpreadsheetComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpreadsheetComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValidPeriodsOptional validPeriods_;
    DefaultInputValueOptional defaultInputValue_;
    DefaultOutputValueOptional defaultOutputValue_;
    ::xsd::cxx::tree::one< ToleranceType > tolerance_;
    ::xsd::cxx::tree::one< TablesType > tables_;
    TrueOptional true__;
    FalseOptional false__;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ValidPeriodsComplexType schema type.
   *
   * @nosubgrouping
   */
  class ValidPeriodsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name validPeriod
     *
     * @brief Accessor and modifier functions for the %validPeriod
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ValidPeriodComplexType ValidPeriodType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ValidPeriodType > ValidPeriodSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ValidPeriodSequence::iterator ValidPeriodIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ValidPeriodSequence::const_iterator ValidPeriodConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValidPeriodType, char > ValidPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ValidPeriodSequence&
    getValidPeriod () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ValidPeriodSequence&
    getValidPeriod ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setValidPeriod (const ValidPeriodSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ValidPeriodsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ValidPeriodsComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ValidPeriodsComplexType (const ValidPeriodsComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ValidPeriodsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ValidPeriodsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValidPeriodSequence validPeriod_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ValidPeriodComplexType schema type.
   *
   * @nosubgrouping
   */
  class ValidPeriodComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name startDate
     *
     * @brief Accessor and modifier functions for the %startDate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateComplexType StartDateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StartDateType, char > StartDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StartDateType&
    getStartDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StartDateType&
    getStartDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStartDate (const StartDateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStartDate (::std::auto_ptr< StartDateType > p);

    //@}

    /**
     * @name endDate
     *
     * @brief Accessor and modifier functions for the %endDate
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateComplexType EndDateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EndDateType, char > EndDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EndDateType&
    getEndDate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EndDateType&
    getEndDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEndDate (const EndDateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEndDate (::std::auto_ptr< EndDateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ValidPeriodComplexType (const StartDateType&,
                            const EndDateType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ValidPeriodComplexType (::std::auto_ptr< StartDateType >&,
                            ::std::auto_ptr< EndDateType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ValidPeriodComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ValidPeriodComplexType (const ValidPeriodComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ValidPeriodComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ValidPeriodComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StartDateType > startDate_;
    ::xsd::cxx::tree::one< EndDateType > endDate_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name monthDay
     *
     * @brief Accessor and modifier functions for the %monthDay
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::GmonthDay MonthDayType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MonthDayType, char > MonthDayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MonthDayType&
    getMonthDay () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MonthDayType&
    getMonthDay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMonthDay (const MonthDayType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMonthDay (::std::auto_ptr< MonthDayType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateComplexType (const MonthDayType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateComplexType (const DateComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MonthDayType > monthDay_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SpreadsheetTablesComplexType schema type.
   *
   * @nosubgrouping
   */
  class SpreadsheetTablesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name table
     *
     * @brief Accessor and modifier functions for the %table
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpreadsheetTableComplexType TableType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TableType > TableSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TableSequence::iterator TableIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TableSequence::const_iterator TableConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TableType, char > TableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TableSequence&
    getTable () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TableSequence&
    getTable ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTable (const TableSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpreadsheetTablesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpreadsheetTablesComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpreadsheetTablesComplexType (const SpreadsheetTablesComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpreadsheetTablesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpreadsheetTablesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TableSequence table_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SpreadsheetTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class SpreadsheetTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name record
     *
     * @brief Accessor and modifier functions for the %record
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpreadsheetRecordComplexType RecordType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RecordType > RecordSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RecordSequence::iterator RecordIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RecordSequence::const_iterator RecordConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RecordType, char > RecordTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RecordSequence&
    getRecord () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RecordSequence&
    getRecord ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRecord (const RecordSequence& s);

    //@}

    /**
     * @name initialState
     *
     * @brief Accessor and modifier functions for the %initialState
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InitialStateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InitialStateType > InitialStateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialStateType, char, ::xsd::cxx::tree::schema_type::double_ > InitialStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InitialStateOptional&
    getInitialState () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    InitialStateOptional&
    getInitialState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitialState (const InitialStateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInitialState (const InitialStateOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpreadsheetTableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpreadsheetTableComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpreadsheetTableComplexType (const SpreadsheetTableComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpreadsheetTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpreadsheetTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RecordSequence record_;
    InitialStateOptional initialState_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SpreadsheetRecordComplexType schema type.
   *
   * @nosubgrouping
   */
  class SpreadsheetRecordComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1
     *
     * @brief Accessor and modifier functions for the %x1
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double X1Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1Type, char, ::xsd::cxx::tree::schema_type::double_ > X1Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const X1Type&
    getX1 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    X1Type&
    getX1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX1 (const X1Type& x);

    //@}

    /**
     * @name x2
     *
     * @brief Accessor and modifier functions for the %x2
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double X2Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2Type, char, ::xsd::cxx::tree::schema_type::double_ > X2Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const X2Type&
    getX2 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    X2Type&
    getX2 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX2 (const X2Type& x);

    //@}

    /**
     * @name x3
     *
     * @brief Accessor and modifier functions for the %x3
     * optional attribute.
     *
     * optionally third input
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double X3Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X3Type > X3Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< X3Type, char, ::xsd::cxx::tree::schema_type::double_ > X3Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X3Optional&
    getX3 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    X3Optional&
    getX3 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX3 (const X3Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setX3 (const X3Optional& x);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double YType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char, ::xsd::cxx::tree::schema_type::double_ > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    YType&
    getY ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setY (const YType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpreadsheetRecordComplexType (const X1Type&,
                                  const X2Type&,
                                  const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpreadsheetRecordComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpreadsheetRecordComplexType (const SpreadsheetRecordComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpreadsheetRecordComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpreadsheetRecordComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< X1Type > x1_;
    ::xsd::cxx::tree::one< X2Type > x2_;
    X3Optional x3_;
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SpreadsheetInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class SpreadsheetInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1
     *
     * @brief Accessor and modifier functions for the %x1
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X12 X1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1Type, char > X1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const X1Type&
    getX1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    X1Type&
    getX1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1 (const X1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX1 (::std::auto_ptr< X1Type > p);

    //@}

    /**
     * @name x2
     *
     * @brief Accessor and modifier functions for the %x2
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X21 X2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2Type, char > X2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const X2Type&
    getX2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    X2Type&
    getX2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2 (const X2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX2 (::std::auto_ptr< X2Type > p);

    //@}

    /**
     * @name x3
     *
     * @brief Accessor and modifier functions for the %x3
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X3 X3Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X3Type > X3Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X3Type, char > X3Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X3Optional&
    getX3 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X3Optional&
    getX3 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX3 (const X3Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX3 (const X3Optional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX3 (::std::auto_ptr< X3Type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpreadsheetInputComplexType (const X1Type&,
                                 const X2Type&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SpreadsheetInputComplexType (::std::auto_ptr< X1Type >&,
                                 ::std::auto_ptr< X2Type >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpreadsheetInputComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpreadsheetInputComplexType (const SpreadsheetInputComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpreadsheetInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpreadsheetInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< X1Type > x1_;
    ::xsd::cxx::tree::one< X2Type > x2_;
    X3Optional x3_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SpreadsheetOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class SpreadsheetOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name status
     *
     * @brief Accessor and modifier functions for the %status
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StatusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StatusType&
    getStatus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StatusType&
    getStatus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStatus (const StatusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStatus (::std::auto_ptr< StatusType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SpreadsheetOutputComplexType (const StatusType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpreadsheetOutputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpreadsheetOutputComplexType (const SpreadsheetOutputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpreadsheetOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SpreadsheetOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StatusType > status_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MergerComplexType schema type.
   *
   * @nosubgrouping
   */
  class MergerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MergerComplexType (const InputType&,
                       const OutputType&,
                       const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    MergerComplexType (::std::auto_ptr< InputType >&,
                       ::std::auto_ptr< OutputType >&,
                       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerComplexType (const MergerComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MergerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MergerInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class MergerInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X4 XType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< XType > XSequence;

    /**
     * @brief Element iterator type.
     */
    typedef XSequence::iterator XIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef XSequence::const_iterator XConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const XSequence&
    getX () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    XSequence&
    getX ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setX (const XSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MergerInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerInputComplexType (const MergerInputComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MergerInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    XSequence x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MergerOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class MergerOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YType > YOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YOptional&
    getY () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YOptional&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setY (const YOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name ySum
     *
     * @brief Accessor and modifier functions for the %ySum
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YSumType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YSumType > YSumOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YSumType, char > YSumTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YSumOptional&
    getYSum () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YSumOptional&
    getYSum ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYSum (const YSumType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYSum (const YSumOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYSum (::std::auto_ptr< YSumType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MergerOutputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerOutputComplexType (const MergerOutputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MergerOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    YOptional y_;
    YSumOptional ySum_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MergerSplitterComplexType schema type.
   *
   * @nosubgrouping
   */
  class MergerSplitterComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerSplitterEnumStringType ModeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ModeType&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ModeType&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerSplitterInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerSplitterOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MergerSplitterComplexType (const ModeType&,
                               const InputType&,
                               const OutputType&,
                               const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    MergerSplitterComplexType (const ModeType&,
                               ::std::auto_ptr< InputType >&,
                               ::std::auto_ptr< OutputType >&,
                               const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerSplitterComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerSplitterComplexType (const MergerSplitterComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerSplitterComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MergerSplitterComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ModeType > mode_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MergerSplitterInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class MergerSplitterInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X5 XType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< XType > XSequence;

    /**
     * @brief Element iterator type.
     */
    typedef XSequence::iterator XIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef XSequence::const_iterator XConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const XSequence&
    getX () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    XSequence&
    getX ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setX (const XSequence& s);

    //@}

    /**
     * @name xVector
     *
     * @brief Accessor and modifier functions for the %xVector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::XVector XVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< XVectorType > XVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XVectorType, char > XVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const XVectorOptional&
    getXVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    XVectorOptional&
    getXVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setXVector (const XVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setXVector (const XVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setXVector (::std::auto_ptr< XVectorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MergerSplitterInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerSplitterInputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerSplitterInputComplexType (const MergerSplitterInputComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerSplitterInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MergerSplitterInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    XSequence x_;
    XVectorOptional xVector_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MergerSplitterOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class MergerSplitterOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Y1 YType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< YType > YSequence;

    /**
     * @brief Element iterator type.
     */
    typedef YSequence::iterator YIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef YSequence::const_iterator YConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const YSequence&
    getY () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    YSequence&
    getY ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setY (const YSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MergerSplitterOutputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerSplitterOutputComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerSplitterOutputComplexType (const MergerSplitterOutputComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerSplitterOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MergerSplitterOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    YSequence y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeAbsoluteComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeAbsoluteComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeAbsoluteInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeAbsoluteOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeAbsoluteComplexType (const InputType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TimeAbsoluteComplexType (::std::auto_ptr< InputType >&,
                             ::std::auto_ptr< OutputType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeAbsoluteComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeAbsoluteComplexType (const TimeAbsoluteComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeAbsoluteComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeAbsoluteComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeAbsoluteInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeAbsoluteInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeAbsoluteInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeAbsoluteInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeAbsoluteInputComplexType (const TimeAbsoluteInputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeAbsoluteInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeAbsoluteInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeAbsoluteOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeAbsoluteOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeAbsoluteOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeAbsoluteOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeAbsoluteOutputComplexType (const TimeAbsoluteOutputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeAbsoluteOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeAbsoluteOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeRelativeComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeRelativeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * optional element.
     *
     * timeRelative mode, either "NATIVE" or "RETAINVALUEWHENINACTIVE"
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Mode ModeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModeType > ModeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModeOptional&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ModeOptional&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMode (const ModeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const ModeType&
    getModeDefaultValue ();

    //@}

    /**
     * @name valueOption
     *
     * @brief Accessor and modifier functions for the %valueOption
     * required element.
     *
     * setting if the control table provides the absolute value or the
     * relative value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeRelativeEnumStringType ValueOptionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueOptionType, char > ValueOptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueOptionType&
    getValueOption () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueOptionType&
    getValueOption ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValueOption (const ValueOptionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValueOption (::std::auto_ptr< ValueOptionType > p);

    //@}

    /**
     * @name maximumPeriod
     *
     * @brief Accessor and modifier functions for the %maximumPeriod
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double MaximumPeriodType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaximumPeriodType > MaximumPeriodOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaximumPeriodType, char, ::xsd::cxx::tree::schema_type::double_ > MaximumPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaximumPeriodOptional&
    getMaximumPeriod () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MaximumPeriodOptional&
    getMaximumPeriod ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMaximumPeriod (const MaximumPeriodType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMaximumPeriod (const MaximumPeriodOptional& x);

    //@}

    /**
     * @name interpolationOption
     *
     * @brief Accessor and modifier functions for the %interpolationOption
     * optional element.
     *
     * table interpolation can be BLOCK or LINEAR, default setting if not
     * provided is LINEAR
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InterpolationOptionEnumStringType InterpolationOptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InterpolationOptionType > InterpolationOptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterpolationOptionType, char > InterpolationOptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InterpolationOptionOptional&
    getInterpolationOption () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InterpolationOptionOptional&
    getInterpolationOption ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInterpolationOption (const InterpolationOptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInterpolationOption (const InterpolationOptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInterpolationOption (::std::auto_ptr< InterpolationOptionType > p);

    //@}

    /**
     * @name controlTable
     *
     * @brief Accessor and modifier functions for the %controlTable
     * required element.
     *
     * table with time [s] / value records
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeRelativeControlTableComplexType ControlTableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ControlTableType, char > ControlTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ControlTableType&
    getControlTable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ControlTableType&
    getControlTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setControlTable (const ControlTableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setControlTable (::std::auto_ptr< ControlTableType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeRelativeInputComplexType InputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InputType > InputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InputOptional&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InputOptional&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInput (const InputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeRelativeOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeRelativeComplexType (const ValueOptionType&,
                             const ControlTableType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TimeRelativeComplexType (const ValueOptionType&,
                             ::std::auto_ptr< ControlTableType >&,
                             ::std::auto_ptr< OutputType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeRelativeComplexType (const TimeRelativeComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeRelativeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeRelativeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ModeOptional mode_;
    static const ModeType mode_default_value_;
    ::xsd::cxx::tree::one< ValueOptionType > valueOption_;
    MaximumPeriodOptional maximumPeriod_;
    InterpolationOptionOptional interpolationOption_;
    ::xsd::cxx::tree::one< ControlTableType > controlTable_;
    InputOptional input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeRelativeControlTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeRelativeControlTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name record
     *
     * @brief Accessor and modifier functions for the %record
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeRelativeControlTableRecordComplexType RecordType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RecordType > RecordSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RecordSequence::iterator RecordIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RecordSequence::const_iterator RecordConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RecordType, char > RecordTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RecordSequence&
    getRecord () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RecordSequence&
    getRecord ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRecord (const RecordSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeRelativeControlTableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeControlTableComplexType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeRelativeControlTableComplexType (const TimeRelativeControlTableComplexType& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeRelativeControlTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeRelativeControlTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RecordSequence record_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeRelativeControlTableRecordComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeRelativeControlTableRecordComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char, ::xsd::cxx::tree::schema_type::double_ > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeRelativeControlTableRecordComplexType (const TimeType&,
                                               const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeControlTableRecordComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeRelativeControlTableRecordComplexType (const TimeRelativeControlTableRecordComplexType& x,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeRelativeControlTableRecordComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeRelativeControlTableRecordComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeRelativeInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeRelativeInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     *
     * optional input for deriving the timeActive in case of the relative
     * from Value option
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeRelativeInputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeRelativeInputComplexType (const TimeRelativeInputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeRelativeInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeRelativeInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimeRelativeOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TimeRelativeOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name timeActive
     *
     * @brief Accessor and modifier functions for the %timeActive
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TimeActiveType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeActiveType, char > TimeActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TimeActiveType&
    getTimeActive () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TimeActiveType&
    getTimeActive ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeActive (const TimeActiveType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTimeActive (::std::auto_ptr< TimeActiveType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeRelativeOutputComplexType (const YType&,
                                   const TimeActiveType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeRelativeOutputComplexType (const TimeRelativeOutputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeRelativeOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeRelativeOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;
    ::xsd::cxx::tree::one< TimeActiveType > timeActive_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ExpressionComplexType schema type.
   *
   * @nosubgrouping
   */
  class ExpressionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1Value
     *
     * @brief Accessor and modifier functions for the %x1Value
     * optional element.
     *
     * user-configured constant value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType X1ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1ValueType > X1ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1ValueType, char > X1ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1ValueOptional&
    getX1Value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1ValueOptional&
    getX1Value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Value (const X1ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Value (const X1ValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1Value (::std::auto_ptr< X1ValueType > p);

    //@}

    /**
     * @name x1Series
     *
     * @brief Accessor and modifier functions for the %x1Series
     * optional element.
     *
     * reference to time series ID
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X1Series X1SeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1SeriesType > X1SeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1SeriesType, char > X1SeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1SeriesOptional&
    getX1Series () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1SeriesOptional&
    getX1Series ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Series (const X1SeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Series (const X1SeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1Series (::std::auto_ptr< X1SeriesType > p);

    //@}

    /**
     * @name x1SeriesVector
     *
     * @brief Accessor and modifier functions for the %x1SeriesVector
     * optional element.
     *
     * reference to time series ID vector
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X1SeriesVector X1SeriesVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1SeriesVectorType > X1SeriesVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1SeriesVectorType, char > X1SeriesVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1SeriesVectorOptional&
    getX1SeriesVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1SeriesVectorOptional&
    getX1SeriesVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1SeriesVector (const X1SeriesVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1SeriesVector (const X1SeriesVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1SeriesVector (::std::auto_ptr< X1SeriesVectorType > p);

    //@}

    /**
     * @name mathematicalOperator
     *
     * @brief Accessor and modifier functions for the %mathematicalOperator
     * required element.
     *
     * mathematical operator: + (summation), - (substraction), *
     * (multiplication), / (division), min, max, ^ (power)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MathematicalOperatorEnumStringType MathematicalOperatorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MathematicalOperatorType, char > MathematicalOperatorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MathematicalOperatorType&
    getMathematicalOperator () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MathematicalOperatorType&
    getMathematicalOperator ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMathematicalOperator (const MathematicalOperatorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMathematicalOperator (::std::auto_ptr< MathematicalOperatorType > p);

    //@}

    /**
     * @name x2Value
     *
     * @brief Accessor and modifier functions for the %x2Value
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType X2ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2ValueType > X2ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2ValueType, char > X2ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2ValueOptional&
    getX2Value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2ValueOptional&
    getX2Value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Value (const X2ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Value (const X2ValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2Value (::std::auto_ptr< X2ValueType > p);

    //@}

    /**
     * @name x2Series
     *
     * @brief Accessor and modifier functions for the %x2Series
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X2Series X2SeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2SeriesType > X2SeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2SeriesType, char > X2SeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2SeriesOptional&
    getX2Series () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2SeriesOptional&
    getX2Series ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Series (const X2SeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Series (const X2SeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2Series (::std::auto_ptr< X2SeriesType > p);

    //@}

    /**
     * @name x2SeriesVector
     *
     * @brief Accessor and modifier functions for the %x2SeriesVector
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X2SeriesVector X2SeriesVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2SeriesVectorType > X2SeriesVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2SeriesVectorType, char > X2SeriesVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2SeriesVectorOptional&
    getX2SeriesVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2SeriesVectorOptional&
    getX2SeriesVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2SeriesVector (const X2SeriesVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2SeriesVector (const X2SeriesVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2SeriesVector (::std::auto_ptr< X2SeriesVectorType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * optional element.
     *
     * time series ID of resulting value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YType > YOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YOptional&
    getY () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YOptional&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setY (const YOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name yVector
     *
     * @brief Accessor and modifier functions for the %yVector
     * optional element.
     *
     * time series ID vector of resulting value
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YVectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YVectorType > YVectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YVectorType, char > YVectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YVectorOptional&
    getYVector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YVectorOptional&
    getYVector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYVector (const YVectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYVector (const YVectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYVector (::std::auto_ptr< YVectorType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ExpressionComplexType (const MathematicalOperatorType&,
                           const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ExpressionComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ExpressionComplexType (const ExpressionComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ExpressionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ExpressionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    X1ValueOptional x1Value_;
    X1SeriesOptional x1Series_;
    X1SeriesVectorOptional x1SeriesVector_;
    ::xsd::cxx::tree::one< MathematicalOperatorType > mathematicalOperator_;
    X2ValueOptional x2Value_;
    X2SeriesOptional x2Series_;
    X2SeriesVectorOptional x2SeriesVector_;
    YOptional y_;
    YVectorOptional yVector_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandValueComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandValueComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name threshold
     *
     * @brief Accessor and modifier functions for the %threshold
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ThresholdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThresholdType, char, ::xsd::cxx::tree::schema_type::double_ > ThresholdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ThresholdType&
    getThreshold () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ThresholdType&
    getThreshold ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setThreshold (const ThresholdType& x);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandValueInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandValueComplexType (const ThresholdType&,
                              const InputType&,
                              const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DeadBandValueComplexType (const ThresholdType&,
                              ::std::auto_ptr< InputType >&,
                              const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandValueComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandValueComplexType (const DeadBandValueComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandValueComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandValueComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ThresholdType > threshold_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandValueInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandValueInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandValueInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandValueInputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandValueInputComplexType (const DeadBandValueInputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandValueInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandValueInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandTimeComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandTimeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name discrete
     *
     * @brief Accessor and modifier functions for the %discrete
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandTimeDiscreteComplexType DiscreteType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiscreteType, char > DiscreteTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DiscreteType&
    getDiscrete () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DiscreteType&
    getDiscrete ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDiscrete (const DiscreteType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDiscrete (::std::auto_ptr< DiscreteType > p);

    //@}

    /**
     * @name true
     *
     * @brief Accessor and modifier functions for the %true
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType TrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TrueType > TrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TrueType, char > TrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TrueOptional&
    getTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TrueOptional&
    getTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTrue (const TrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTrue (const TrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTrue (::std::auto_ptr< TrueType > p);

    //@}

    /**
     * @name false
     *
     * @brief Accessor and modifier functions for the %false
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType FalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FalseType > FalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FalseType, char > FalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FalseOptional&
    getFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FalseOptional&
    getFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFalse (const FalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFalse (const FalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFalse (::std::auto_ptr< FalseType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandTimeInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandTimeOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandTimeComplexType (const DiscreteType&,
                             const InputType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DeadBandTimeComplexType (::std::auto_ptr< DiscreteType >&,
                             ::std::auto_ptr< InputType >&,
                             ::std::auto_ptr< OutputType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandTimeComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandTimeComplexType (const DeadBandTimeComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandTimeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandTimeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DiscreteType > discrete_;
    TrueOptional true__;
    FalseOptional false__;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandTimeDiscreteComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandTimeDiscreteComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name numberOfStepsUp
     *
     * @brief Accessor and modifier functions for the %numberOfStepsUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int NumberOfStepsUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberOfStepsUpType, char > NumberOfStepsUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NumberOfStepsUpType&
    getNumberOfStepsUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NumberOfStepsUpType&
    getNumberOfStepsUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumberOfStepsUp (const NumberOfStepsUpType& x);

    //@}

    /**
     * @name numberOfStepsDown
     *
     * @brief Accessor and modifier functions for the %numberOfStepsDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int NumberOfStepsDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberOfStepsDownType, char > NumberOfStepsDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NumberOfStepsDownType&
    getNumberOfStepsDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NumberOfStepsDownType&
    getNumberOfStepsDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumberOfStepsDown (const NumberOfStepsDownType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandTimeDiscreteComplexType (const NumberOfStepsUpType&,
                                     const NumberOfStepsDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandTimeDiscreteComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandTimeDiscreteComplexType (const DeadBandTimeDiscreteComplexType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandTimeDiscreteComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandTimeDiscreteComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NumberOfStepsUpType > numberOfStepsUp_;
    ::xsd::cxx::tree::one< NumberOfStepsDownType > numberOfStepsDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandTimeInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandTimeInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X6 XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandTimeInputComplexType (const XType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DeadBandTimeInputComplexType (::std::auto_ptr< XType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandTimeInputComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandTimeInputComplexType (const DeadBandTimeInputComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandTimeInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandTimeInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandTimeOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandTimeOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name status
     *
     * @brief Accessor and modifier functions for the %status
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StatusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StatusType&
    getStatus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StatusType&
    getStatus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStatus (const StatusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStatus (::std::auto_ptr< StatusType > p);

    //@}

    /**
     * @name stepsUp
     *
     * @brief Accessor and modifier functions for the %stepsUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StepsUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StepsUpType, char > StepsUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StepsUpType&
    getStepsUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StepsUpType&
    getStepsUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStepsUp (const StepsUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStepsUp (::std::auto_ptr< StepsUpType > p);

    //@}

    /**
     * @name stepsDown
     *
     * @brief Accessor and modifier functions for the %stepsDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StepsDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StepsDownType, char > StepsDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StepsDownType&
    getStepsDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StepsDownType&
    getStepsDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStepsDown (const StepsDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStepsDown (::std::auto_ptr< StepsDownType > p);

    //@}

    /**
     * @name timeTrue
     *
     * @brief Accessor and modifier functions for the %timeTrue
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TimeTrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeTrueType > TimeTrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeTrueType, char > TimeTrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeTrueOptional&
    getTimeTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeTrueOptional&
    getTimeTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeTrue (const TimeTrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeTrue (const TimeTrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeTrue (::std::auto_ptr< TimeTrueType > p);

    //@}

    /**
     * @name timeFalse
     *
     * @brief Accessor and modifier functions for the %timeFalse
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TimeFalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeFalseType > TimeFalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeFalseType, char > TimeFalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeFalseOptional&
    getTimeFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeFalseOptional&
    getTimeFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeFalse (const TimeFalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeFalse (const TimeFalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeFalse (::std::auto_ptr< TimeFalseType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandTimeOutputComplexType (const StatusType&,
                                   const StepsUpType&,
                                   const StepsDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandTimeOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandTimeOutputComplexType (const DeadBandTimeOutputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandTimeOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandTimeOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StatusType > status_;
    ::xsd::cxx::tree::one< StepsUpType > stepsUp_;
    ::xsd::cxx::tree::one< StepsDownType > stepsDown_;
    TimeTrueOptional timeTrue_;
    TimeFalseOptional timeFalse_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LimiterComplexType schema type.
   *
   * @nosubgrouping
   */
  class LimiterComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LimiterOptionEnumStringType ModeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ModeType&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ModeType&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LimiterInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LimiterComplexType (const ModeType&,
                        const InputType&,
                        const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LimiterComplexType (const ModeType&,
                        ::std::auto_ptr< InputType >&,
                        const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimiterComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimiterComplexType (const LimiterComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LimiterComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LimiterComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ModeType > mode_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LimiterInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class LimiterInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name thresholdSeries
     *
     * @brief Accessor and modifier functions for the %thresholdSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ThresholdSeries ThresholdSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ThresholdSeriesType > ThresholdSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThresholdSeriesType, char > ThresholdSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ThresholdSeriesOptional&
    getThresholdSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ThresholdSeriesOptional&
    getThresholdSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setThresholdSeries (const ThresholdSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setThresholdSeries (const ThresholdSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setThresholdSeries (::std::auto_ptr< ThresholdSeriesType > p);

    //@}

    /**
     * @name thresholdValue
     *
     * @brief Accessor and modifier functions for the %thresholdValue
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ThresholdValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ThresholdValueType > ThresholdValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ThresholdValueType, char, ::xsd::cxx::tree::schema_type::double_ > ThresholdValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ThresholdValueOptional&
    getThresholdValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ThresholdValueOptional&
    getThresholdValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setThresholdValue (const ThresholdValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setThresholdValue (const ThresholdValueOptional& x);

    //@}

    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LimiterInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimiterInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimiterInputComplexType (const LimiterInputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LimiterInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LimiterInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ThresholdSeriesOptional thresholdSeries_;
    ThresholdValueOptional thresholdValue_;
    ::xsd::cxx::tree::one< XType > x_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TriggersComplexType schema type.
   *
   * @nosubgrouping
   */
  class TriggersComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name trigger
     *
     * @brief Accessor and modifier functions for the %trigger
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerComplexType TriggerType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TriggerType > TriggerSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TriggerSequence::iterator TriggerIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TriggerSequence::const_iterator TriggerConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TriggerType, char > TriggerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TriggerSequence&
    getTrigger () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TriggerSequence&
    getTrigger ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTrigger (const TriggerSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TriggersComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TriggersComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggersComplexType (const TriggersComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TriggersComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TriggersComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TriggerSequence trigger_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TriggerComplexType schema type.
   *
   * @nosubgrouping
   */
  class TriggerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name standard
     *
     * @brief Accessor and modifier functions for the %standard
     * optional element.
     *
     * standard trigger
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StandardTriggerComplexType StandardType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StandardType > StandardOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StandardType, char > StandardTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StandardOptional&
    getStandard () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StandardOptional&
    getStandard ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStandard (const StandardType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStandard (const StandardOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStandard (::std::auto_ptr< StandardType > p);

    //@}

    /**
     * @name deadBand
     *
     * @brief Accessor and modifier functions for the %deadBand
     * optional element.
     *
     * trigger with deadband
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandTriggerComplexType DeadBandType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeadBandType > DeadBandOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeadBandType, char > DeadBandTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeadBandOptional&
    getDeadBand () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeadBandOptional&
    getDeadBand ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeadBand (const DeadBandType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeadBand (const DeadBandOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeadBand (::std::auto_ptr< DeadBandType > p);

    //@}

    /**
     * @name deadBandTime
     *
     * @brief Accessor and modifier functions for the %deadBandTime
     * optional element.
     *
     * trigger with time deadband
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DeadBandTimeComplexType DeadBandTimeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeadBandTimeType > DeadBandTimeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeadBandTimeType, char > DeadBandTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeadBandTimeOptional&
    getDeadBandTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeadBandTimeOptional&
    getDeadBandTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeadBandTime (const DeadBandTimeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeadBandTime (const DeadBandTimeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeadBandTime (::std::auto_ptr< DeadBandTimeType > p);

    //@}

    /**
     * @name expression
     *
     * @brief Accessor and modifier functions for the %expression
     * optional element.
     *
     * mathematical expression
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExpressionComplexType ExpressionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExpressionType > ExpressionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExpressionType, char > ExpressionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExpressionOptional&
    getExpression () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExpressionOptional&
    getExpression ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpression (const ExpressionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpression (const ExpressionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExpression (::std::auto_ptr< ExpressionType > p);

    //@}

    /**
     * @name lookupTable
     *
     * @brief Accessor and modifier functions for the %lookupTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LookupTableComplexType LookupTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LookupTableType > LookupTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LookupTableType, char > LookupTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LookupTableOptional&
    getLookupTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LookupTableOptional&
    getLookupTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLookupTable (const LookupTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLookupTable (const LookupTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLookupTable (::std::auto_ptr< LookupTableType > p);

    //@}

    /**
     * @name merger
     *
     * @brief Accessor and modifier functions for the %merger
     * optional element.
     *
     * Data hierarchy, highest input has highest priority
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::MergerComplexType MergerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MergerType > MergerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MergerType, char > MergerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MergerOptional&
    getMerger () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MergerOptional&
    getMerger ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMerger (const MergerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMerger (const MergerOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMerger (::std::auto_ptr< MergerType > p);

    //@}

    /**
     * @name polygonLookup
     *
     * @brief Accessor and modifier functions for the %polygonLookup
     * optional element.
     *
     * trigger with two-dimensional lookup table, trigger results are defined
     * by polygons
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PolygonLookupComplexType PolygonLookupType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PolygonLookupType > PolygonLookupOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PolygonLookupType, char > PolygonLookupTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PolygonLookupOptional&
    getPolygonLookup () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PolygonLookupOptional&
    getPolygonLookup ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPolygonLookup (const PolygonLookupType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPolygonLookup (const PolygonLookupOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPolygonLookup (::std::auto_ptr< PolygonLookupType > p);

    //@}

    /**
     * @name ruleReference
     *
     * @brief Accessor and modifier functions for the %ruleReference
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String RuleReferenceType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RuleReferenceType > RuleReferenceOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RuleReferenceType, char > RuleReferenceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RuleReferenceOptional&
    getRuleReference () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RuleReferenceOptional&
    getRuleReference ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRuleReference (const RuleReferenceType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRuleReference (const RuleReferenceOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRuleReference (::std::auto_ptr< RuleReferenceType > p);

    //@}

    /**
     * @name set
     *
     * @brief Accessor and modifier functions for the %set
     * optional element.
     *
     * set of triggers
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SetTriggerComplexType SetType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetType > SetOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetType, char > SetTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetOptional&
    getSet () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetOptional&
    getSet ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSet (const SetType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSet (const SetOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSet (::std::auto_ptr< SetType > p);

    //@}

    /**
     * @name spreadsheet
     *
     * @brief Accessor and modifier functions for the %spreadsheet
     * optional element.
     *
     * spread sheet trigger
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpreadsheetComplexType SpreadsheetType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SpreadsheetType > SpreadsheetOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SpreadsheetType, char > SpreadsheetTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SpreadsheetOptional&
    getSpreadsheet () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SpreadsheetOptional&
    getSpreadsheet ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSpreadsheet (const SpreadsheetType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSpreadsheet (const SpreadsheetOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSpreadsheet (::std::auto_ptr< SpreadsheetType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TriggerComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TriggerComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggerComplexType (const TriggerComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TriggerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TriggerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    StandardOptional standard_;
    DeadBandOptional deadBand_;
    DeadBandTimeOptional deadBandTime_;
    ExpressionOptional expression_;
    LookupTableOptional lookupTable_;
    MergerOptional merger_;
    PolygonLookupOptional polygonLookup_;
    RuleReferenceOptional ruleReference_;
    SetOptional set_;
    SpreadsheetOptional spreadsheet_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EifelRurRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class EifelRurRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double AType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char, ::xsd::cxx::tree::schema_type::double_ > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AType&
    getA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA (const AType& x);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double BType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BType, char, ::xsd::cxx::tree::schema_type::double_ > BTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BType&
    getB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BType&
    getB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setB (const BType& x);

    //@}

    /**
     * @name minimumRelativeStorage
     *
     * @brief Accessor and modifier functions for the %minimumRelativeStorage
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTableComplexType MinimumRelativeStorageType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinimumRelativeStorageType, char > MinimumRelativeStorageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MinimumRelativeStorageType&
    getMinimumRelativeStorage () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MinimumRelativeStorageType&
    getMinimumRelativeStorage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMinimumRelativeStorage (const MinimumRelativeStorageType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMinimumRelativeStorage (::std::auto_ptr< MinimumRelativeStorageType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EifelRurRuleComplexType (const AType&,
                             const BType&,
                             const MinimumRelativeStorageType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    EifelRurRuleComplexType (const AType&,
                             const BType&,
                             ::std::auto_ptr< MinimumRelativeStorageType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EifelRurRuleComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EifelRurRuleComplexType (const EifelRurRuleComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EifelRurRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EifelRurRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AType > a_;
    ::xsd::cxx::tree::one< BType > b_;
    ::xsd::cxx::tree::one< MinimumRelativeStorageType > minimumRelativeStorage_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GuideBandRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class GuideBandRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name xMin
     *
     * @brief Accessor and modifier functions for the %xMin
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTableComplexType XMinType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XMinType, char > XMinTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XMinType&
    getXMin () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XMinType&
    getXMin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setXMin (const XMinType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setXMin (::std::auto_ptr< XMinType > p);

    //@}

    /**
     * @name xMax
     *
     * @brief Accessor and modifier functions for the %xMax
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTableComplexType XMaxType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XMaxType, char > XMaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XMaxType&
    getXMax () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XMaxType&
    getXMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setXMax (const XMaxType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setXMax (::std::auto_ptr< XMaxType > p);

    //@}

    /**
     * @name yMin
     *
     * @brief Accessor and modifier functions for the %yMin
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double YMinType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMinType > YMinOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMinType, char, ::xsd::cxx::tree::schema_type::double_ > YMinTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMinOptional&
    getYMin () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMinOptional&
    getYMin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMin (const YMinType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMin (const YMinOptional& x);

    //@}

    /**
     * @name yMinSeries
     *
     * @brief Accessor and modifier functions for the %yMinSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YMinSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMinSeriesType > YMinSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMinSeriesType, char > YMinSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMinSeriesOptional&
    getYMinSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMinSeriesOptional&
    getYMinSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMinSeries (const YMinSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMinSeries (const YMinSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYMinSeries (::std::auto_ptr< YMinSeriesType > p);

    //@}

    /**
     * @name yMax
     *
     * @brief Accessor and modifier functions for the %yMax
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double YMaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMaxType > YMaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMaxType, char, ::xsd::cxx::tree::schema_type::double_ > YMaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMaxOptional&
    getYMax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMaxOptional&
    getYMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMax (const YMaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMax (const YMaxOptional& x);

    //@}

    /**
     * @name yMaxSeries
     *
     * @brief Accessor and modifier functions for the %yMaxSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YMaxSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YMaxSeriesType > YMaxSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YMaxSeriesType, char > YMaxSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YMaxSeriesOptional&
    getYMaxSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YMaxSeriesOptional&
    getYMaxSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setYMaxSeries (const YMaxSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setYMaxSeries (const YMaxSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setYMaxSeries (::std::auto_ptr< YMaxSeriesType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GuideBandRuleInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::GuideBandRuleOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GuideBandRuleComplexType (const XMinType&,
                              const XMaxType&,
                              const InputType&,
                              const OutputType&,
                              const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GuideBandRuleComplexType (::std::auto_ptr< XMinType >&,
                              ::std::auto_ptr< XMaxType >&,
                              ::std::auto_ptr< InputType >&,
                              ::std::auto_ptr< OutputType >&,
                              const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GuideBandRuleComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GuideBandRuleComplexType (const GuideBandRuleComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GuideBandRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GuideBandRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XMinType > xMin_;
    ::xsd::cxx::tree::one< XMaxType > xMax_;
    YMinOptional yMin_;
    YMinSeriesOptional yMinSeries_;
    YMaxOptional yMax_;
    YMaxSeriesOptional yMaxSeries_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GuideBandRuleInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class GuideBandRuleInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YType > YOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YOptional&
    getY () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    YOptional&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setY (const YOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GuideBandRuleInputComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GuideBandRuleInputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GuideBandRuleInputComplexType (const GuideBandRuleInputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GuideBandRuleInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GuideBandRuleInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    YOptional y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GuideBandRuleOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class GuideBandRuleOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GuideBandRuleOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GuideBandRuleOutputComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GuideBandRuleOutputComplexType (const GuideBandRuleOutputComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GuideBandRuleOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GuideBandRuleOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConstantRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConstantRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name constant
     *
     * @brief Accessor and modifier functions for the %constant
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ConstantType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstantType, char, ::xsd::cxx::tree::schema_type::double_ > ConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ConstantType&
    getConstant () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ConstantType&
    getConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstant (const ConstantType& x);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ConstantRuleOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConstantRuleComplexType (const ConstantType&,
                             const OutputType&,
                             const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ConstantRuleComplexType (const ConstantType&,
                             ::std::auto_ptr< OutputType >&,
                             const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConstantRuleComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConstantRuleComplexType (const ConstantRuleComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConstantRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConstantRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConstantType > constant_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConstantRuleOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConstantRuleOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConstantRuleOutputComplexType (const YType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConstantRuleOutputComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConstantRuleOutputComplexType (const ConstantRuleOutputComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConstantRuleOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConstantRuleOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MinSimpleRuleComplexType schema type.
   *
   * @nosubgrouping
   */
  class MinSimpleRuleComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name zones
     *
     * @brief Accessor and modifier functions for the %zones
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ZonesComplexType ZonesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ZonesType > ZonesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ZonesType, char > ZonesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ZonesOptional&
    getZones () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ZonesOptional&
    getZones ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setZones (const ZonesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setZones (const ZonesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setZones (::std::auto_ptr< ZonesType > p);

    //@}

    /**
     * @name dateTable
     *
     * @brief Accessor and modifier functions for the %dateTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTableComplexType DateTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DateTableType > DateTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateTableType, char > DateTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DateTableOptional&
    getDateTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DateTableOptional&
    getDateTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDateTable (const DateTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDateTable (const DateTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDateTable (::std::auto_ptr< DateTableType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MinSimpleRuleComplexType (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MinSimpleRuleComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MinSimpleRuleComplexType (const MinSimpleRuleComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MinSimpleRuleComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MinSimpleRuleComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ZonesOptional zones_;
    DateTableOptional dateTable_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StorageCharacteristicsComplexType schema type.
   *
   * @nosubgrouping
   */
  class StorageCharacteristicsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name storageTable
     *
     * @brief Accessor and modifier functions for the %storageTable
     * optional element.
     *
     * Storage table with pairs of elevation h and storage S
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType StorageTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StorageTableType > StorageTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageTableType, char > StorageTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StorageTableOptional&
    getStorageTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StorageTableOptional&
    getStorageTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageTable (const StorageTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStorageTable (const StorageTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStorageTable (::std::auto_ptr< StorageTableType > p);

    //@}

    /**
     * @name storageEquation
     *
     * @brief Accessor and modifier functions for the %storageEquation
     * optional element.
     *
     * Storage equation, storage S = f(water level h)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EquationsComplexType StorageEquationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StorageEquationType > StorageEquationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageEquationType, char > StorageEquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StorageEquationOptional&
    getStorageEquation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StorageEquationOptional&
    getStorageEquation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageEquation (const StorageEquationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStorageEquation (const StorageEquationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStorageEquation (::std::auto_ptr< StorageEquationType > p);

    //@}

    /**
     * @name maximumLevel
     *
     * @brief Accessor and modifier functions for the %maximumLevel
     * optional element.
     *
     * Maximum water level h in the reservoir: this optional value does not
     * limit the water level, it is used however to compute the relative
     * filling percentage of the reservoir according to s =
     * S/S(maximumLevel), where S is the absolute storage volume
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double MaximumLevelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaximumLevelType > MaximumLevelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaximumLevelType, char, ::xsd::cxx::tree::schema_type::double_ > MaximumLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaximumLevelOptional&
    getMaximumLevel () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MaximumLevelOptional&
    getMaximumLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMaximumLevel (const MaximumLevelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMaximumLevel (const MaximumLevelOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StorageCharacteristicsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StorageCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StorageCharacteristicsComplexType (const StorageCharacteristicsComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StorageCharacteristicsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StorageCharacteristicsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    StorageTableOptional storageTable_;
    StorageEquationOptional storageEquation_;
    MaximumLevelOptional maximumLevel_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CapacityCharacteristicsComplexType schema type.
   *
   * @nosubgrouping
   */
  class CapacityCharacteristicsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name capacityTable
     *
     * @brief Accessor and modifier functions for the %capacityTable
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType CapacityTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacityTableType > CapacityTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityTableType, char > CapacityTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacityTableOptional&
    getCapacityTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacityTableOptional&
    getCapacityTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityTable (const CapacityTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacityTable (const CapacityTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacityTable (::std::auto_ptr< CapacityTableType > p);

    //@}

    /**
     * @name capacityEquation
     *
     * @brief Accessor and modifier functions for the %capacityEquation
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EquationsComplexType CapacityEquationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacityEquationType > CapacityEquationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityEquationType, char > CapacityEquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacityEquationOptional&
    getCapacityEquation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacityEquationOptional&
    getCapacityEquation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityEquation (const CapacityEquationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacityEquation (const CapacityEquationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacityEquation (::std::auto_ptr< CapacityEquationType > p);

    //@}

    /**
     * @name reference
     *
     * @brief Accessor and modifier functions for the %reference
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::CapacityReferenceEnumStringType ReferenceType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReferenceType > ReferenceOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReferenceType, char > ReferenceTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReferenceOptional&
    getReference () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ReferenceOptional&
    getReference ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setReference (const ReferenceType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setReference (const ReferenceOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReference (::std::auto_ptr< ReferenceType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CapacityCharacteristicsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CapacityCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CapacityCharacteristicsComplexType (const CapacityCharacteristicsComplexType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CapacityCharacteristicsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CapacityCharacteristicsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapacityTableOptional capacityTable_;
    CapacityEquationOptional capacityEquation_;
    ReferenceOptional reference_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineCharacteristicsComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineCharacteristicsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name efficiencyTable
     *
     * @brief Accessor and modifier functions for the %efficiencyTable
     * required element.
     *
     * efficiency table unit power output [MW / m3/s] as function of head [m]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType EfficiencyTableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EfficiencyTableType, char > EfficiencyTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EfficiencyTableType&
    getEfficiencyTable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EfficiencyTableType&
    getEfficiencyTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEfficiencyTable (const EfficiencyTableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEfficiencyTable (::std::auto_ptr< EfficiencyTableType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineOutputCharacteristicsComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineCharacteristicsComplexType (const EfficiencyTableType&,
                                       const OutputType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TurbineCharacteristicsComplexType (::std::auto_ptr< EfficiencyTableType >&,
                                       ::std::auto_ptr< OutputType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineCharacteristicsComplexType (const TurbineCharacteristicsComplexType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineCharacteristicsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineCharacteristicsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EfficiencyTableType > efficiencyTable_;
    ::xsd::cxx::tree::one< OutputType > output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineOutputCharacteristicsComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineOutputCharacteristicsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name power
     *
     * @brief Accessor and modifier functions for the %power
     * required element.
     *
     * power output [MW]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PowerType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PowerType, char > PowerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PowerType&
    getPower () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PowerType&
    getPower ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPower (const PowerType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPower (::std::auto_ptr< PowerType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineOutputCharacteristicsComplexType (const PowerType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineOutputCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineOutputCharacteristicsComplexType (const TurbineOutputCharacteristicsComplexType& x,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineOutputCharacteristicsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineOutputCharacteristicsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PowerType > power_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ElevationTableComplexType schema type.
   *
   * Table containing data for different elevations. Type of element
   * 'value'
   * depends on purpose for which table is used.
   *
   * @nosubgrouping
   */
  class ElevationTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name elevationRecord
     *
     * @brief Accessor and modifier functions for the %elevationRecord
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationRecordComplexType ElevationRecordType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ElevationRecordType > ElevationRecordSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ElevationRecordSequence::iterator ElevationRecordIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ElevationRecordSequence::const_iterator ElevationRecordConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ElevationRecordType, char > ElevationRecordTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ElevationRecordSequence&
    getElevationRecord () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ElevationRecordSequence&
    getElevationRecord ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setElevationRecord (const ElevationRecordSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ElevationTableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ElevationTableComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElevationTableComplexType (const ElevationTableComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ElevationTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ElevationTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ElevationRecordSequence elevationRecord_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TailwaterComplexType schema type.
   *
   * Table containing data for different elevations. Type of element
   * 'value'
   * depends on purpose for which table is used.
   *
   * @nosubgrouping
   */
  class TailwaterComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name constant
     *
     * @brief Accessor and modifier functions for the %constant
     * optional element.
     *
     * Constant tailwater level [m]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ConstantType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConstantType > ConstantOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConstantType, char, ::xsd::cxx::tree::schema_type::double_ > ConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConstantOptional&
    getConstant () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ConstantOptional&
    getConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConstant (const ConstantType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setConstant (const ConstantOptional& x);

    //@}

    /**
     * @name ratingCurve
     *
     * @brief Accessor and modifier functions for the %ratingCurve
     * optional element.
     *
     * Tailwater depending on discharge computed by a rating curve
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType RatingCurveType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RatingCurveType > RatingCurveOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RatingCurveType, char > RatingCurveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RatingCurveOptional&
    getRatingCurve () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RatingCurveOptional&
    getRatingCurve ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRatingCurve (const RatingCurveType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRatingCurve (const RatingCurveOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRatingCurve (::std::auto_ptr< RatingCurveType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TailwaterOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TailwaterComplexType (const OutputType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TailwaterComplexType (::std::auto_ptr< OutputType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TailwaterComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TailwaterComplexType (const TailwaterComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TailwaterComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TailwaterComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ConstantOptional constant_;
    RatingCurveOptional ratingCurve_;
    ::xsd::cxx::tree::one< OutputType > output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TailwaterOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TailwaterOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name level
     *
     * @brief Accessor and modifier functions for the %level
     * required element.
     *
     * tailwater level [m]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelType, char > LevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LevelType&
    getLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LevelType&
    getLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevel (const LevelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLevel (::std::auto_ptr< LevelType > p);

    //@}

    /**
     * @name head
     *
     * @brief Accessor and modifier functions for the %head
     * required element.
     *
     * head [m]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HeadType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HeadType, char > HeadTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HeadType&
    getHead () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HeadType&
    getHead ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHead (const HeadType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHead (::std::auto_ptr< HeadType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TailwaterOutputComplexType (const LevelType&,
                                const HeadType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TailwaterOutputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TailwaterOutputComplexType (const TailwaterOutputComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TailwaterOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TailwaterOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LevelType > level_;
    ::xsd::cxx::tree::one< HeadType > head_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ElevationRecordComplexType schema type.
   *
   * @nosubgrouping
   */
  class ElevationRecordComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name elevation
     *
     * @brief Accessor and modifier functions for the %elevation
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ElevationType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ElevationType, char, ::xsd::cxx::tree::schema_type::double_ > ElevationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ElevationType&
    getElevation () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ElevationType&
    getElevation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setElevation (const ElevationType& x);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalParameterSimpleType ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValue (::std::auto_ptr< ValueType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ElevationRecordComplexType (const ElevationType&,
                                const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ElevationRecordComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ElevationRecordComplexType (const ElevationRecordComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ElevationRecordComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ElevationRecordComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ElevationType > elevation_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ControlledOutletComplexType schema type.
   *
   * @nosubgrouping
   */
  class ControlledOutletComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name capacityCharacteristics
     *
     * @brief Accessor and modifier functions for the %capacityCharacteristics
     * required element.
     *
     * Maximum capacity of outlet as function of the water level h, minimum
     * capacity is assumed to be zero
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CapacityCharacteristicsComplexType CapacityCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityCharacteristicsType, char > CapacityCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CapacityCharacteristicsType&
    getCapacityCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CapacityCharacteristicsType&
    getCapacityCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityCharacteristics (const CapacityCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > p);

    //@}

    /**
     * @name turbineCharacteristics
     *
     * @brief Accessor and modifier functions for the %turbineCharacteristics
     * optional element.
     *
     * Characteristics of optional turbine
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineCharacteristicsComplexType TurbineCharacteristicsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TurbineCharacteristicsType > TurbineCharacteristicsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TurbineCharacteristicsType, char > TurbineCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TurbineCharacteristicsOptional&
    getTurbineCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TurbineCharacteristicsOptional&
    getTurbineCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTurbineCharacteristics (const TurbineCharacteristicsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTurbineCharacteristics (const TurbineCharacteristicsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTurbineCharacteristics (::std::auto_ptr< TurbineCharacteristicsType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutletInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutletOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ControlledOutletComplexType (const CapacityCharacteristicsType&,
                                 const InputType&,
                                 const OutputType&,
                                 const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ControlledOutletComplexType (::std::auto_ptr< CapacityCharacteristicsType >&,
                                 ::std::auto_ptr< InputType >&,
                                 ::std::auto_ptr< OutputType >&,
                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ControlledOutletComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ControlledOutletComplexType (const ControlledOutletComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ControlledOutletComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ControlledOutletComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CapacityCharacteristicsType > capacityCharacteristics_;
    TurbineCharacteristicsOptional turbineCharacteristics_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UncontrolledOutletComplexType schema type.
   *
   * @nosubgrouping
   */
  class UncontrolledOutletComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name capacityCharacteristics
     *
     * @brief Accessor and modifier functions for the %capacityCharacteristics
     * required element.
     *
     * Maximum capacity of outlet as function of the water level h, minimum
     * capacity is assumed to be zero
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CapacityCharacteristicsComplexType CapacityCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityCharacteristicsType, char > CapacityCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CapacityCharacteristicsType&
    getCapacityCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CapacityCharacteristicsType&
    getCapacityCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityCharacteristics (const CapacityCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::UOutletInputComplexType InputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InputType > InputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InputOptional&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InputOptional&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInput (const InputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutletOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UncontrolledOutletComplexType (const CapacityCharacteristicsType&,
                                   const OutputType&,
                                   const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    UncontrolledOutletComplexType (::std::auto_ptr< CapacityCharacteristicsType >&,
                                   ::std::auto_ptr< OutputType >&,
                                   const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UncontrolledOutletComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UncontrolledOutletComplexType (const UncontrolledOutletComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UncontrolledOutletComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UncontrolledOutletComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CapacityCharacteristicsType > capacityCharacteristics_;
    InputOptional input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %UOutletInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class UOutletInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name release
     *
     * @brief Accessor and modifier functions for the %release
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseType, char > ReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseType&
    getRelease () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseType&
    getRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelease (const ReleaseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRelease (::std::auto_ptr< ReleaseType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UOutletInputComplexType (const ReleaseType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UOutletInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UOutletInputComplexType (const UOutletInputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UOutletInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UOutletInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ReleaseType > release_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EquationsComplexType schema type.
   *
   * @nosubgrouping
   */
  class EquationsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name equation
     *
     * @brief Accessor and modifier functions for the %equation
     * sequence element.
     *
     * Power equation for optional segments with lower and upper water level
     * bounds, y = a*(x+b)^c
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EquationComplexType EquationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< EquationType > EquationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef EquationSequence::iterator EquationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef EquationSequence::const_iterator EquationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EquationType, char > EquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const EquationSequence&
    getEquation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    EquationSequence&
    getEquation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setEquation (const EquationSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EquationsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EquationsComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EquationsComplexType (const EquationsComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EquationsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EquationsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    EquationSequence equation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EquationComplexType schema type.
   *
   * @nosubgrouping
   */
  class EquationComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name lowerLevel
     *
     * @brief Accessor and modifier functions for the %lowerLevel
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double LowerLevelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerLevelType > LowerLevelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerLevelType, char, ::xsd::cxx::tree::schema_type::double_ > LowerLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerLevelOptional&
    getLowerLevel () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LowerLevelOptional&
    getLowerLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLowerLevel (const LowerLevelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLowerLevel (const LowerLevelOptional& x);

    //@}

    /**
     * @name upperLevel
     *
     * @brief Accessor and modifier functions for the %upperLevel
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double UpperLevelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperLevelType > UpperLevelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperLevelType, char, ::xsd::cxx::tree::schema_type::double_ > UpperLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperLevelOptional&
    getUpperLevel () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UpperLevelOptional&
    getUpperLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUpperLevel (const UpperLevelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUpperLevel (const UpperLevelOptional& x);

    //@}

    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType AType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AType&
    getA ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setA (const AType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setA (::std::auto_ptr< AType > p);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType BType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BType, char > BTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BType&
    getB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BType&
    getB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setB (const BType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setB (::std::auto_ptr< BType > p);

    //@}

    /**
     * @name c
     *
     * @brief Accessor and modifier functions for the %c
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType CType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CType&
    getC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CType&
    getC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setC (const CType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setC (::std::auto_ptr< CType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EquationComplexType (const AType&,
                         const BType&,
                         const CType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EquationComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EquationComplexType (const EquationComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EquationComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EquationComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LowerLevelOptional lowerLevel_;
    UpperLevelOptional upperLevel_;
    ::xsd::cxx::tree::one< AType > a_;
    ::xsd::cxx::tree::one< BType > b_;
    ::xsd::cxx::tree::one< CType > c_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ZonesComplexType schema type.
   *
   * @nosubgrouping
   */
  class ZonesComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name zone
     *
     * @brief Accessor and modifier functions for the %zone
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ZoneComplexType ZoneType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ZoneType > ZoneSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ZoneSequence::iterator ZoneIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ZoneSequence::const_iterator ZoneConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ZoneType, char > ZoneTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ZoneSequence&
    getZone () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ZoneSequence&
    getZone ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setZone (const ZoneSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ZonesComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZonesComplexType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ZonesComplexType (const ZonesComplexType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ZonesComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ZonesComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ZoneSequence zone_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ZoneComplexType schema type.
   *
   * @nosubgrouping
   */
  class ZoneComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name dateTable
     *
     * @brief Accessor and modifier functions for the %dateTable
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateTableComplexType DateTableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateTableType, char > DateTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DateTableType&
    getDateTable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DateTableType&
    getDateTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDateTable (const DateTableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDateTable (::std::auto_ptr< DateTableType > p);

    //@}

    /**
     * @name min
     *
     * @brief Accessor and modifier functions for the %min
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::TimeSeriesSimpleType MinType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MinType > MinOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinType, char > MinTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MinOptional&
    getMin () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MinOptional&
    getMin ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMin (const MinType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMin (const MinOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMin (::std::auto_ptr< MinType > p);

    //@}

    /**
     * @name max
     *
     * @brief Accessor and modifier functions for the %max
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::TimeSeriesSimpleType MaxType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxType > MaxOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxOptional&
    getMax () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxOptional&
    getMax ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMax (const MaxType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMax (const MaxOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMax (::std::auto_ptr< MaxType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ZoneComplexType (const DateTableType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ZoneComplexType (::std::auto_ptr< DateTableType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ZoneComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ZoneComplexType (const ZoneComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ZoneComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ZoneComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DateTableType > dateTable_;
    MinOptional min_;
    MaxOptional max_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateTableComplexType schema type.
   *
   * @nosubgrouping
   */
  class DateTableComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name data
     *
     * @brief Accessor and modifier functions for the %data
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::DateRecordComplexType DataType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DataType > DataSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DataSequence::iterator DataIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DataSequence::const_iterator DataConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DataType, char > DataTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DataSequence&
    getData () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DataSequence&
    getData ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setData (const DataSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateTableComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateTableComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateTableComplexType (const DateTableComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateTableComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateTableComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DataSequence data_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DateRecordComplexType schema type.
   *
   * defined data input as per time series format date time (defined either
   * by dateTime or time or
   * month day) and value
   *
   * @nosubgrouping
   */
  class DateRecordComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name monthDay
     *
     * @brief Accessor and modifier functions for the %monthDay
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::GmonthDay MonthDayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MonthDayType > MonthDayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MonthDayType, char > MonthDayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MonthDayOptional&
    getMonthDay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MonthDayOptional&
    getMonthDay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMonthDay (const MonthDayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMonthDay (const MonthDayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMonthDay (::std::auto_ptr< MonthDayType > p);

    //@}

    /**
     * @name dateTime
     *
     * @brief Accessor and modifier functions for the %dateTime
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::DateTime DateTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DateTimeType > DateTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateTimeType, char > DateTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DateTimeOptional&
    getDateTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DateTimeOptional&
    getDateTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDateTime (const DateTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDateTime (const DateTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDateTime (::std::auto_ptr< DateTimeType > p);

    //@}

    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Time TimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeType > TimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeOptional&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TimeOptional&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setTime (const TimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTime (::std::auto_ptr< TimeType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name comment
     *
     * @brief Accessor and modifier functions for the %comment
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String CommentType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CommentType > CommentOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CommentType, char > CommentTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CommentOptional&
    getComment () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CommentOptional&
    getComment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setComment (const CommentType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setComment (const CommentOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setComment (::std::auto_ptr< CommentType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DateRecordComplexType (const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateRecordComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateRecordComplexType (const DateRecordComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateRecordComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DateRecordComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MonthDayOptional monthDay_;
    DateTimeOptional dateTime_;
    TimeOptional time_;
    ::xsd::cxx::tree::one< ValueType > value_;
    CommentOptional comment_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name inflow
     *
     * @brief Accessor and modifier functions for the %inflow
     * sequence element.
     *
     * Upstream inflows [m3/s] into the reservoir, can be more than one for
     * aggregation the inflows from several upstream reservoirs or river
     * reaches
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InflowType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InflowType > InflowSequence;

    /**
     * @brief Element iterator type.
     */
    typedef InflowSequence::iterator InflowIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef InflowSequence::const_iterator InflowConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InflowType, char > InflowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InflowSequence&
    getInflow () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InflowSequence&
    getInflow ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setInflow (const InflowSequence& s);

    //@}

    /**
     * @name level
     *
     * @brief Accessor and modifier functions for the %level
     * optional element.
     *
     * Optional level [m] for updating the simulated level by an observed
     * water level (simple data assimilation), if provided the error output
     * is equal to the mass balance correction
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LevelType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LevelType > LevelOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelType, char > LevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LevelOptional&
    getLevel () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LevelOptional&
    getLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevel (const LevelType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLevel (const LevelOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLevel (::std::auto_ptr< LevelType > p);

    //@}

    /**
     * @name precipitation
     *
     * @brief Accessor and modifier functions for the %precipitation
     * optional element.
     *
     * Direct precitation into the reservoir [mm/time step], the value will
     * be multiplied by the current water surface area of the reservoir
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PrecipitationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PrecipitationType > PrecipitationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PrecipitationType, char > PrecipitationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PrecipitationOptional&
    getPrecipitation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PrecipitationOptional&
    getPrecipitation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrecipitation (const PrecipitationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrecipitation (const PrecipitationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrecipitation (::std::auto_ptr< PrecipitationType > p);

    //@}

    /**
     * @name evaporation
     *
     * @brief Accessor and modifier functions for the %evaporation
     * optional element.
     *
     * Direct evaporation from the reservoir [mm/time step]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType EvaporationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EvaporationType > EvaporationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EvaporationType, char > EvaporationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EvaporationOptional&
    getEvaporation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EvaporationOptional&
    getEvaporation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEvaporation (const EvaporationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEvaporation (const EvaporationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEvaporation (::std::auto_ptr< EvaporationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirInputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirInputComplexType (const ReservoirInputComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    InflowSequence inflow_;
    LevelOptional level_;
    PrecipitationOptional precipitation_;
    EvaporationOptional evaporation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name inflow
     *
     * @brief Accessor and modifier functions for the %inflow
     * required element.
     *
     * aggregated inflows [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InflowType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InflowType, char > InflowTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InflowType&
    getInflow () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InflowType&
    getInflow ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInflow (const InflowType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInflow (::std::auto_ptr< InflowType > p);

    //@}

    /**
     * @name release
     *
     * @brief Accessor and modifier functions for the %release
     * required element.
     *
     * aggregated release [m3/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseType, char > ReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseType&
    getRelease () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseType&
    getRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelease (const ReleaseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRelease (::std::auto_ptr< ReleaseType > p);

    //@}

    /**
     * @name storage
     *
     * @brief Accessor and modifier functions for the %storage
     * required element.
     *
     * storage [m3] (state variable)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StorageType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageType, char > StorageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageType&
    getStorage () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageType&
    getStorage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorage (const StorageType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorage (::std::auto_ptr< StorageType > p);

    //@}

    /**
     * @name relativeStorage
     *
     * @brief Accessor and modifier functions for the %relativeStorage
     * optional element.
     *
     * relative storage [-] typically between 0 and 1 depending on the
     * definition of the maximum level above]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RelativeStorageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RelativeStorageType > RelativeStorageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelativeStorageType, char > RelativeStorageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RelativeStorageOptional&
    getRelativeStorage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RelativeStorageOptional&
    getRelativeStorage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelativeStorage (const RelativeStorageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRelativeStorage (const RelativeStorageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRelativeStorage (::std::auto_ptr< RelativeStorageType > p);

    //@}

    /**
     * @name level
     *
     * @brief Accessor and modifier functions for the %level
     * required element.
     *
     * water level [m] in the reservoir
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LevelType, char > LevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LevelType&
    getLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LevelType&
    getLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLevel (const LevelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLevel (::std::auto_ptr< LevelType > p);

    //@}

    /**
     * @name error
     *
     * @brief Accessor and modifier functions for the %error
     * optional element.
     *
     * optional error output [m3/s] which is non-zero if the simple data
     * assimilation option for overruling the simulated water level is used
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ErrorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ErrorType > ErrorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ErrorOptional&
    getError () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ErrorOptional&
    getError ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setError (const ErrorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setError (const ErrorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setError (::std::auto_ptr< ErrorType > p);

    //@}

    /**
     * @name residuum
     *
     * @brief Accessor and modifier functions for the %residuum
     * optional element.
     *
     * optional residuum of the implicit solution
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ResiduumType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ResiduumType > ResiduumOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResiduumType, char > ResiduumTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ResiduumOptional&
    getResiduum () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ResiduumOptional&
    getResiduum ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setResiduum (const ResiduumType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setResiduum (const ResiduumOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setResiduum (::std::auto_ptr< ResiduumType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirOutputComplexType (const InflowType&,
                                const ReleaseType&,
                                const StorageType&,
                                const LevelType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirOutputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirOutputComplexType (const ReservoirOutputComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InflowType > inflow_;
    ::xsd::cxx::tree::one< ReleaseType > release_;
    ::xsd::cxx::tree::one< StorageType > storage_;
    RelativeStorageOptional relativeStorage_;
    ::xsd::cxx::tree::one< LevelType > level_;
    ErrorOptional error_;
    ResiduumOptional residuum_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReservoirGradientComplexType schema type.
   *
   * @nosubgrouping
   */
  class ReservoirGradientComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name lambda
     *
     * @brief Accessor and modifier functions for the %lambda
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LambdaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LambdaType, char > LambdaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LambdaType&
    getLambda () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LambdaType&
    getLambda ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLambda (const LambdaType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLambda (::std::auto_ptr< LambdaType > p);

    //@}

    /**
     * @name lambdaDown
     *
     * @brief Accessor and modifier functions for the %lambdaDown
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LambdaDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LambdaDownType > LambdaDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LambdaDownType, char > LambdaDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LambdaDownOptional&
    getLambdaDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LambdaDownOptional&
    getLambdaDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLambdaDown (const LambdaDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLambdaDown (const LambdaDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLambdaDown (::std::auto_ptr< LambdaDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReservoirGradientComplexType (const LambdaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReservoirGradientComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReservoirGradientComplexType (const ReservoirGradientComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReservoirGradientComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReservoirGradientComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LambdaType > lambda_;
    LambdaDownOptional lambdaDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NodeGradientComplexType schema type.
   *
   * @nosubgrouping
   */
  class NodeGradientComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name lambda
     *
     * @brief Accessor and modifier functions for the %lambda
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType LambdaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LambdaType, char > LambdaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LambdaType&
    getLambda () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LambdaType&
    getLambda ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLambda (const LambdaType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLambda (::std::auto_ptr< LambdaType > p);

    //@}

    /**
     * @name surfaceArea
     *
     * @brief Accessor and modifier functions for the %surfaceArea
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SurfaceAreaType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SurfaceAreaType, char > SurfaceAreaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SurfaceAreaType&
    getSurfaceArea () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SurfaceAreaType&
    getSurfaceArea ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSurfaceArea (const SurfaceAreaType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSurfaceArea (::std::auto_ptr< SurfaceAreaType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NodeGradientComplexType (const LambdaType&,
                             const SurfaceAreaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NodeGradientComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NodeGradientComplexType (const NodeGradientComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NodeGradientComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NodeGradientComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LambdaType > lambda_;
    ::xsd::cxx::tree::one< SurfaceAreaType > surfaceArea_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutletInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutletInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name release
     *
     * @brief Accessor and modifier functions for the %release
     * optional element.
     *
     * Reference to timeseries in data configuration containg an absolute
     * release. (ONLY FOR CONTROLLED OUTLET)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReleaseType > ReleaseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseType, char > ReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReleaseOptional&
    getRelease () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReleaseOptional&
    getRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelease (const ReleaseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRelease (const ReleaseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRelease (::std::auto_ptr< ReleaseType > p);

    //@}

    /**
     * @name relativeRelease
     *
     * @brief Accessor and modifier functions for the %relativeRelease
     * sequence element.
     *
     * Reference to timeseries in data configuration containg the relative
     * release (values inbetween 0 and 1). (ONLY FOR CONTROLLED OUTLET)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RelativeReleaseType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RelativeReleaseType > RelativeReleaseSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RelativeReleaseSequence::iterator RelativeReleaseIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RelativeReleaseSequence::const_iterator RelativeReleaseConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelativeReleaseType, char > RelativeReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RelativeReleaseSequence&
    getRelativeRelease () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RelativeReleaseSequence&
    getRelativeRelease ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRelativeRelease (const RelativeReleaseSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutletInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutletInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutletInputComplexType (const OutletInputComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutletInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutletInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ReleaseOptional release_;
    RelativeReleaseSequence relativeRelease_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutletOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutletOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name release
     *
     * @brief Accessor and modifier functions for the %release
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseType, char > ReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ReleaseType&
    getRelease () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ReleaseType&
    getRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelease (const ReleaseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRelease (::std::auto_ptr< ReleaseType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutletOutputComplexType (const ReleaseType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutletOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutletOutputComplexType (const OutletOutputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutletOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutletOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ReleaseType > release_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeadBandTriggerComplexType schema type.
   *
   * @nosubgrouping
   */
  class DeadBandTriggerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name conditionOn
     *
     * @brief Accessor and modifier functions for the %conditionOn
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RelationalConditionComplexType ConditionOnType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConditionOnType, char > ConditionOnTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ConditionOnType&
    getConditionOn () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ConditionOnType&
    getConditionOn ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConditionOn (const ConditionOnType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setConditionOn (::std::auto_ptr< ConditionOnType > p);

    //@}

    /**
     * @name conditionOff
     *
     * @brief Accessor and modifier functions for the %conditionOff
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RelationalConditionComplexType ConditionOffType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConditionOffType, char > ConditionOffTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ConditionOffType&
    getConditionOff () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ConditionOffType&
    getConditionOff ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setConditionOff (const ConditionOffType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setConditionOff (::std::auto_ptr< ConditionOffType > p);

    //@}

    /**
     * @name default
     *
     * @brief Accessor and modifier functions for the %default
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean DefaultType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultType > DefaultOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultType, char > DefaultTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultOptional&
    getDefault () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DefaultOptional&
    getDefault ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDefault (const DefaultType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDefault (const DefaultOptional& x);

    //@}

    /**
     * @name true
     *
     * @brief Accessor and modifier functions for the %true
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType TrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TrueType > TrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TrueType, char > TrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TrueOptional&
    getTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TrueOptional&
    getTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTrue (const TrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTrue (const TrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTrue (::std::auto_ptr< TrueType > p);

    //@}

    /**
     * @name false
     *
     * @brief Accessor and modifier functions for the %false
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType FalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FalseType > FalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FalseType, char > FalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FalseOptional&
    getFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FalseOptional&
    getFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFalse (const FalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFalse (const FalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFalse (::std::auto_ptr< FalseType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeadBandTriggerComplexType (const ConditionOnType&,
                                const ConditionOffType&,
                                const OutputType&,
                                const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DeadBandTriggerComplexType (::std::auto_ptr< ConditionOnType >&,
                                ::std::auto_ptr< ConditionOffType >&,
                                ::std::auto_ptr< OutputType >&,
                                const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeadBandTriggerComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeadBandTriggerComplexType (const DeadBandTriggerComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeadBandTriggerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeadBandTriggerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionOnType > conditionOn_;
    ::xsd::cxx::tree::one< ConditionOffType > conditionOff_;
    DefaultOptional default__;
    TrueOptional true__;
    FalseOptional false__;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TriggerInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TriggerInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name status
     *
     * @brief Accessor and modifier functions for the %status
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StatusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StatusType&
    getStatus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StatusType&
    getStatus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStatus (const StatusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStatus (::std::auto_ptr< StatusType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TriggerInputComplexType (const StatusType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TriggerInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggerInputComplexType (const TriggerInputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TriggerInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TriggerInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StatusType > status_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TriggerOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TriggerOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name status
     *
     * @brief Accessor and modifier functions for the %status
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StatusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StatusType&
    getStatus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StatusType&
    getStatus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStatus (const StatusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStatus (::std::auto_ptr< StatusType > p);

    //@}

    /**
     * @name timeTrue
     *
     * @brief Accessor and modifier functions for the %timeTrue
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TimeTrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeTrueType > TimeTrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeTrueType, char > TimeTrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeTrueOptional&
    getTimeTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeTrueOptional&
    getTimeTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeTrue (const TimeTrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeTrue (const TimeTrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeTrue (::std::auto_ptr< TimeTrueType > p);

    //@}

    /**
     * @name timeFalse
     *
     * @brief Accessor and modifier functions for the %timeFalse
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType TimeFalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeFalseType > TimeFalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeFalseType, char > TimeFalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeFalseOptional&
    getTimeFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimeFalseOptional&
    getTimeFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimeFalse (const TimeFalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimeFalse (const TimeFalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeFalse (::std::auto_ptr< TimeFalseType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TriggerOutputComplexType (const StatusType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TriggerOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggerOutputComplexType (const TriggerOutputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TriggerOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TriggerOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StatusType > status_;
    TimeTrueOptional timeTrue_;
    TimeFalseOptional timeFalse_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StandardTriggerComplexType schema type.
   *
   * @nosubgrouping
   */
  class StandardTriggerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name condition
     *
     * @brief Accessor and modifier functions for the %condition
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RelationalConditionComplexType ConditionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ConditionType&
    getCondition () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ConditionType&
    getCondition ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCondition (const ConditionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCondition (::std::auto_ptr< ConditionType > p);

    //@}

    /**
     * @name default
     *
     * @brief Accessor and modifier functions for the %default
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean DefaultType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultType > DefaultOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultType, char > DefaultTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultOptional&
    getDefault () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DefaultOptional&
    getDefault ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDefault (const DefaultType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDefault (const DefaultOptional& x);

    //@}

    /**
     * @name true
     *
     * @brief Accessor and modifier functions for the %true
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType TrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TrueType > TrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TrueType, char > TrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TrueOptional&
    getTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TrueOptional&
    getTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTrue (const TrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTrue (const TrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTrue (::std::auto_ptr< TrueType > p);

    //@}

    /**
     * @name false
     *
     * @brief Accessor and modifier functions for the %false
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType FalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FalseType > FalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FalseType, char > FalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FalseOptional&
    getFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FalseOptional&
    getFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFalse (const FalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFalse (const FalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFalse (::std::auto_ptr< FalseType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StandardTriggerComplexType (const ConditionType&,
                                const OutputType&,
                                const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    StandardTriggerComplexType (::std::auto_ptr< ConditionType >&,
                                ::std::auto_ptr< OutputType >&,
                                const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StandardTriggerComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StandardTriggerComplexType (const StandardTriggerComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StandardTriggerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StandardTriggerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionType > condition_;
    DefaultOptional default__;
    TrueOptional true__;
    FalseOptional false__;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RelationalConditionComplexType schema type.
   *
   * @nosubgrouping
   */
  class RelationalConditionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1Value
     *
     * @brief Accessor and modifier functions for the %x1Value
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType X1ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1ValueType > X1ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1ValueType, char > X1ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1ValueOptional&
    getX1Value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1ValueOptional&
    getX1Value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Value (const X1ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Value (const X1ValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1Value (::std::auto_ptr< X1ValueType > p);

    //@}

    /**
     * @name x1Series
     *
     * @brief Accessor and modifier functions for the %x1Series
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X1Series1 X1SeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1SeriesType > X1SeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1SeriesType, char > X1SeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1SeriesOptional&
    getX1Series () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1SeriesOptional&
    getX1Series ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Series (const X1SeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Series (const X1SeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1Series (::std::auto_ptr< X1SeriesType > p);

    //@}

    /**
     * @name relationalOperator
     *
     * @brief Accessor and modifier functions for the %relationalOperator
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RelationalOperatorEnumStringType RelationalOperatorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelationalOperatorType, char > RelationalOperatorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RelationalOperatorType&
    getRelationalOperator () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RelationalOperatorType&
    getRelationalOperator ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelationalOperator (const RelationalOperatorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRelationalOperator (::std::auto_ptr< RelationalOperatorType > p);

    //@}

    /**
     * @name x2Value
     *
     * @brief Accessor and modifier functions for the %x2Value
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ExternalParameterSimpleType X2ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2ValueType > X2ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2ValueType, char > X2ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2ValueOptional&
    getX2Value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2ValueOptional&
    getX2Value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Value (const X2ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Value (const X2ValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2Value (::std::auto_ptr< X2ValueType > p);

    //@}

    /**
     * @name x2Series
     *
     * @brief Accessor and modifier functions for the %x2Series
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X2Series1 X2SeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2SeriesType > X2SeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2SeriesType, char > X2SeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2SeriesOptional&
    getX2Series () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2SeriesOptional&
    getX2Series ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Series (const X2SeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Series (const X2SeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2Series (::std::auto_ptr< X2SeriesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RelationalConditionComplexType (const RelationalOperatorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RelationalConditionComplexType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RelationalConditionComplexType (const RelationalConditionComplexType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RelationalConditionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RelationalConditionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    X1ValueOptional x1Value_;
    X1SeriesOptional x1Series_;
    ::xsd::cxx::tree::one< RelationalOperatorType > relationalOperator_;
    X2ValueOptional x2Value_;
    X2SeriesOptional x2Series_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SetTriggerComplexType schema type.
   *
   * @nosubgrouping
   */
  class SetTriggerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x1Value
     *
     * @brief Accessor and modifier functions for the %x1Value
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean X1ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1ValueType > X1ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1ValueType, char > X1ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1ValueOptional&
    getX1Value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1ValueOptional&
    getX1Value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Value (const X1ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Value (const X1ValueOptional& x);

    //@}

    /**
     * @name x1Series
     *
     * @brief Accessor and modifier functions for the %x1Series
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X1Series2 X1SeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1SeriesType > X1SeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1SeriesType, char > X1SeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1SeriesOptional&
    getX1Series () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1SeriesOptional&
    getX1Series ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Series (const X1SeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Series (const X1SeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1Series (::std::auto_ptr< X1SeriesType > p);

    //@}

    /**
     * @name x1Trigger
     *
     * @brief Accessor and modifier functions for the %x1Trigger
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerComplexType X1TriggerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X1TriggerType > X1TriggerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X1TriggerType, char > X1TriggerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X1TriggerOptional&
    getX1Trigger () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X1TriggerOptional&
    getX1Trigger ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX1Trigger (const X1TriggerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX1Trigger (const X1TriggerOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX1Trigger (::std::auto_ptr< X1TriggerType > p);

    //@}

    /**
     * @name logicalOperator
     *
     * @brief Accessor and modifier functions for the %logicalOperator
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::LogicalOperatorEnumStringType LogicalOperatorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LogicalOperatorType, char > LogicalOperatorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LogicalOperatorType&
    getLogicalOperator () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LogicalOperatorType&
    getLogicalOperator ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLogicalOperator (const LogicalOperatorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLogicalOperator (::std::auto_ptr< LogicalOperatorType > p);

    //@}

    /**
     * @name x2Value
     *
     * @brief Accessor and modifier functions for the %x2Value
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean X2ValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2ValueType > X2ValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2ValueType, char > X2ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2ValueOptional&
    getX2Value () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2ValueOptional&
    getX2Value ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Value (const X2ValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Value (const X2ValueOptional& x);

    //@}

    /**
     * @name x2Series
     *
     * @brief Accessor and modifier functions for the %x2Series
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::X2Series2 X2SeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2SeriesType > X2SeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2SeriesType, char > X2SeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2SeriesOptional&
    getX2Series () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2SeriesOptional&
    getX2Series ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Series (const X2SeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Series (const X2SeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2Series (::std::auto_ptr< X2SeriesType > p);

    //@}

    /**
     * @name x2Trigger
     *
     * @brief Accessor and modifier functions for the %x2Trigger
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerComplexType X2TriggerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< X2TriggerType > X2TriggerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< X2TriggerType, char > X2TriggerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const X2TriggerOptional&
    getX2Trigger () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    X2TriggerOptional&
    getX2Trigger ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX2Trigger (const X2TriggerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setX2Trigger (const X2TriggerOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setX2Trigger (::std::auto_ptr< X2TriggerType > p);

    //@}

    /**
     * @name default
     *
     * @brief Accessor and modifier functions for the %default
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Boolean DefaultType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultType > DefaultOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultType, char > DefaultTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultOptional&
    getDefault () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DefaultOptional&
    getDefault ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDefault (const DefaultType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDefault (const DefaultOptional& x);

    //@}

    /**
     * @name true
     *
     * @brief Accessor and modifier functions for the %true
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType TrueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TrueType > TrueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TrueType, char > TrueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TrueOptional&
    getTrue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TrueOptional&
    getTrue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTrue (const TrueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTrue (const TrueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTrue (::std::auto_ptr< TrueType > p);

    //@}

    /**
     * @name false
     *
     * @brief Accessor and modifier functions for the %false
     * optional element.
     *
     * link the trigger event to either an other trigger           or to a
     * rule. Use the item ID as link to rules
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RuleTriggerComplexType FalseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FalseType > FalseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FalseType, char > FalseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FalseOptional&
    getFalse () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FalseOptional&
    getFalse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFalse (const FalseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFalse (const FalseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFalse (::std::auto_ptr< FalseType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetTriggerComplexType (const LogicalOperatorType&,
                           const OutputType&,
                           const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SetTriggerComplexType (const LogicalOperatorType&,
                           ::std::auto_ptr< OutputType >&,
                           const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetTriggerComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetTriggerComplexType (const SetTriggerComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetTriggerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetTriggerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    X1ValueOptional x1Value_;
    X1SeriesOptional x1Series_;
    X1TriggerOptional x1Trigger_;
    ::xsd::cxx::tree::one< LogicalOperatorType > logicalOperator_;
    X2ValueOptional x2Value_;
    X2SeriesOptional x2Series_;
    X2TriggerOptional x2Trigger_;
    DefaultOptional default__;
    TrueOptional true__;
    FalseOptional false__;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RuleTriggerComplexType schema type.
   *
   * @nosubgrouping
   */
  class RuleTriggerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name trigger
     *
     * @brief Accessor and modifier functions for the %trigger
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TriggerComplexType TriggerType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TriggerType > TriggerSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TriggerSequence::iterator TriggerIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TriggerSequence::const_iterator TriggerConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TriggerType, char > TriggerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TriggerSequence&
    getTrigger () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TriggerSequence&
    getTrigger ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTrigger (const TriggerSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RuleTriggerComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RuleTriggerComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RuleTriggerComplexType (const RuleTriggerComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RuleTriggerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RuleTriggerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TriggerSequence trigger_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ResultComplexType schema type.
   *
   * @nosubgrouping
   */
  class ResultComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer ValueType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ResultComplexType (const OutputType&,
                       const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ResultComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ResultComplexType (const ResultComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ResultComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ResultComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ConditionComplexType schema type.
   *
   * @nosubgrouping
   */
  class ConditionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name lessThan
     *
     * @brief Accessor and modifier functions for the %lessThan
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double LessThanType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LessThanType > LessThanOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LessThanType, char, ::xsd::cxx::tree::schema_type::double_ > LessThanTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LessThanOptional&
    getLessThan () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LessThanOptional&
    getLessThan ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLessThan (const LessThanType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLessThan (const LessThanOptional& x);

    //@}

    /**
     * @name greaterThan
     *
     * @brief Accessor and modifier functions for the %greaterThan
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double GreaterThanType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GreaterThanType > GreaterThanOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GreaterThanType, char, ::xsd::cxx::tree::schema_type::double_ > GreaterThanTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GreaterThanOptional&
    getGreaterThan () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GreaterThanOptional&
    getGreaterThan ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGreaterThan (const GreaterThanType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGreaterThan (const GreaterThanOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ConditionComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ConditionComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ConditionComplexType (const ConditionComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ConditionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ConditionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LessThanOptional lessThan_;
    GreaterThanOptional greaterThan_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RuleStateTriggerComplexType schema type.
   *
   * @nosubgrouping
   */
  class RuleStateTriggerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name ruleId
     *
     * @brief Accessor and modifier functions for the %ruleId
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String RuleIdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RuleIdType, char > RuleIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RuleIdType&
    getRuleId () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RuleIdType&
    getRuleId ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRuleId (const RuleIdType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRuleId (::std::auto_ptr< RuleIdType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RuleStateTriggerComplexType (const RuleIdType&,
                                 const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RuleStateTriggerComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RuleStateTriggerComplexType (const RuleStateTriggerComplexType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RuleStateTriggerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RuleStateTriggerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RuleIdType > ruleId_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InflowComplexType schema type.
   *
   * @nosubgrouping
   */
  class InflowComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name factor
     *
     * @brief Accessor and modifier functions for the %factor
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FactorType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FactorType > FactorOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorType, char, ::xsd::cxx::tree::schema_type::double_ > FactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FactorOptional&
    getFactor () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    FactorOptional&
    getFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFactor (const FactorType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setFactor (const FactorOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InflowComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InflowComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InflowComplexType (const InflowComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InflowComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InflowComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FactorOptional factor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NodeComplexType schema type.
   *
   * @nosubgrouping
   */
  class NodeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name storageCharacteristics
     *
     * @brief Accessor and modifier functions for the %storageCharacteristics
     * required element.
     *
     * Storage characteristics of the node: The storage as a function of
     * water level h. It can be provided as table or as a formula.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::StorageCharacteristicsComplexType StorageCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageCharacteristicsType, char > StorageCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageCharacteristicsType&
    getStorageCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageCharacteristicsType&
    getStorageCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageCharacteristics (const StorageCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageCharacteristics (::std::auto_ptr< StorageCharacteristicsType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NodeInputComplexType InputType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InputType > InputOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InputOptional&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InputOptional&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInput (const InputOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::NodeOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double XType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< XType > XOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char, ::xsd::cxx::tree::schema_type::double_ > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const XOptional&
    getX () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    XOptional&
    getX ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setX (const XOptional& x);

    //@}

    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double YType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< YType > YOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char, ::xsd::cxx::tree::schema_type::double_ > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const YOptional&
    getY () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    YOptional&
    getY ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setY (const YOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NodeComplexType (const StorageCharacteristicsType&,
                     const OutputType&,
                     const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    NodeComplexType (::std::auto_ptr< StorageCharacteristicsType >&,
                     ::std::auto_ptr< OutputType >&,
                     const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NodeComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NodeComplexType (const NodeComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NodeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NodeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StorageCharacteristicsType > storageCharacteristics_;
    InputOptional input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    XOptional x_;
    YOptional y_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NodeInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class NodeInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HBC
     *
     * @brief Accessor and modifier functions for the %HBC
     * optional element.
     *
     * Time series with the water level boundary condition, note that a value
     * MUST be provided at all time steps, otherwise the model stops with an
     * error message
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HBCType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HBCType > HBCOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HBCType, char > HBCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HBCOptional&
    getHBC () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HBCOptional&
    getHBC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHBC (const HBCType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHBC (const HBCOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHBC (::std::auto_ptr< HBCType > p);

    //@}

    /**
     * @name HUpdate
     *
     * @brief Accessor and modifier functions for the %HUpdate
     * optional element.
     *
     * Time series with an optional water level for model updating
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpdateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HUpdateType > HUpdateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpdateType, char > HUpdateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HUpdateOptional&
    getHUpdate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HUpdateOptional&
    getHUpdate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUpdate (const HUpdateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHUpdate (const HUpdateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHUpdate (::std::auto_ptr< HUpdateType > p);

    //@}

    /**
     * @name QBC
     *
     * @brief Accessor and modifier functions for the %QBC
     * sequence element.
     *
     * Time series with an inflow bounday condition, note that a value MUST
     * be provided at all time steps
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::QBC QBCType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< QBCType > QBCSequence;

    /**
     * @brief Element iterator type.
     */
    typedef QBCSequence::iterator QBCIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef QBCSequence::const_iterator QBCConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QBCType, char > QBCTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const QBCSequence&
    getQBC () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    QBCSequence&
    getQBC ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setQBC (const QBCSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NodeInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NodeInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NodeInputComplexType (const NodeInputComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NodeInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NodeInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    HBCOptional HBC_;
    HUpdateOptional HUpdate_;
    QBCSequence QBC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NodeOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class NodeOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name H
     *
     * @brief Accessor and modifier functions for the %H
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HType, char > HTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HType&
    getH () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HType&
    getH ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setH (const HType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setH (::std::auto_ptr< HType > p);

    //@}

    /**
     * @name S
     *
     * @brief Accessor and modifier functions for the %S
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SType, char > STraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SType&
    getS () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SType&
    getS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setS (const SType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setS (::std::auto_ptr< SType > p);

    //@}

    /**
     * @name R
     *
     * @brief Accessor and modifier functions for the %R
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RType > ROptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RType, char > RTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ROptional&
    getR () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ROptional&
    getR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setR (const RType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setR (const ROptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setR (::std::auto_ptr< RType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NodeOutputComplexType (const HType&,
                           const SType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NodeOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NodeOutputComplexType (const NodeOutputComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NodeOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NodeOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HType > H_;
    ::xsd::cxx::tree::one< SType > S_;
    ROptional R_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BranchComplexType schema type.
   *
   * @nosubgrouping
   */
  class BranchComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name equationType
     *
     * @brief Accessor and modifier functions for the %equationType
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EquationEnumStringType EquationTypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EquationTypeType > EquationTypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EquationTypeType, char > EquationTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EquationTypeOptional&
    getEquationType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EquationTypeOptional&
    getEquationType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEquationType (const EquationTypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEquationType (const EquationTypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEquationType (::std::auto_ptr< EquationTypeType > p);

    //@}

    /**
     * @name spatialScheme
     *
     * @brief Accessor and modifier functions for the %spatialScheme
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::SpatialEnumStringType SpatialSchemeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SpatialSchemeType > SpatialSchemeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SpatialSchemeType, char > SpatialSchemeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SpatialSchemeOptional&
    getSpatialScheme () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SpatialSchemeOptional&
    getSpatialScheme ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSpatialScheme (const SpatialSchemeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSpatialScheme (const SpatialSchemeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSpatialScheme (::std::auto_ptr< SpatialSchemeType > p);

    //@}

    /**
     * @name crossSection
     *
     * @brief Accessor and modifier functions for the %crossSection
     * required element.
     *
     * Cross section in the center of the flow branch.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CrossSectionComplexType CrossSectionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CrossSectionType, char > CrossSectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CrossSectionType&
    getCrossSection () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CrossSectionType&
    getCrossSection ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCrossSection (const CrossSectionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCrossSection (::std::auto_ptr< CrossSectionType > p);

    //@}

    /**
     * @name roughness
     *
     * @brief Accessor and modifier functions for the %roughness
     * required element.
     *
     * Roughness (Chezy) as a function of elevation h
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::CrossSectionRoughnessComplexType RoughnessType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RoughnessType, char > RoughnessTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RoughnessType&
    getRoughness () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RoughnessType&
    getRoughness ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRoughness (const RoughnessType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRoughness (::std::auto_ptr< RoughnessType > p);

    //@}

    /**
     * @name length
     *
     * @brief Accessor and modifier functions for the %length
     * required element.
     *
     * Length of the flow branch
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double LengthType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LengthType, char, ::xsd::cxx::tree::schema_type::double_ > LengthTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LengthType&
    getLength () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LengthType&
    getLength ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLength (const LengthType& x);

    //@}

    /**
     * @name slope
     *
     * @brief Accessor and modifier functions for the %slope
     * optional element.
     *
     * slope for optional kinematic wave branch
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SlopeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SlopeType > SlopeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SlopeType, char, ::xsd::cxx::tree::schema_type::double_ > SlopeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SlopeOptional&
    getSlope () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SlopeOptional&
    getSlope ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSlope (const SlopeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSlope (const SlopeOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static SlopeType
    getSlopeDefaultValue ();

    //@}

    /**
     * @name alpha1
     *
     * @brief Accessor and modifier functions for the %alpha1
     * optional element.
     *
     * the wind friction coefficient is given by Cw = alpha1 + alpha2 * Vw,
     * with wind velocity Vw
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Alpha1Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Alpha1Type > Alpha1Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Alpha1Type, char, ::xsd::cxx::tree::schema_type::double_ > Alpha1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Alpha1Optional&
    getAlpha1 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Alpha1Optional&
    getAlpha1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAlpha1 (const Alpha1Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAlpha1 (const Alpha1Optional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static Alpha1Type
    getAlpha1DefaultValue ();

    //@}

    /**
     * @name alpha2
     *
     * @brief Accessor and modifier functions for the %alpha2
     * optional element.
     *
     * the wind friction coefficient is given by Cw = alpha1 + alpha2 * Vw,
     * with wind velocity Vw
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double Alpha2Type;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Alpha2Type > Alpha2Optional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< Alpha2Type, char, ::xsd::cxx::tree::schema_type::double_ > Alpha2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Alpha2Optional&
    getAlpha2 () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    Alpha2Optional&
    getAlpha2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAlpha2 (const Alpha2Type& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAlpha2 (const Alpha2Optional& x);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BranchInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::BranchOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BranchComplexType (const CrossSectionType&,
                       const RoughnessType&,
                       const LengthType&,
                       const InputType&,
                       const OutputType&,
                       const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    BranchComplexType (::std::auto_ptr< CrossSectionType >&,
                       ::std::auto_ptr< RoughnessType >&,
                       const LengthType&,
                       ::std::auto_ptr< InputType >&,
                       ::std::auto_ptr< OutputType >&,
                       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchComplexType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BranchComplexType (const BranchComplexType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BranchComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BranchComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    EquationTypeOptional equationType_;
    SpatialSchemeOptional spatialScheme_;
    ::xsd::cxx::tree::one< CrossSectionType > crossSection_;
    ::xsd::cxx::tree::one< RoughnessType > roughness_;
    ::xsd::cxx::tree::one< LengthType > length_;
    SlopeOptional slope_;
    Alpha1Optional alpha1_;
    Alpha2Optional alpha2_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CrossSectionComplexType schema type.
   *
   * @nosubgrouping
   */
  class CrossSectionComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name crossSectionTable
     *
     * @brief Accessor and modifier functions for the %crossSectionTable
     * required element.
     *
     * Tabulated cross section, pairs of elevation h and width b
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType CrossSectionTableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CrossSectionTableType, char > CrossSectionTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CrossSectionTableType&
    getCrossSectionTable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CrossSectionTableType&
    getCrossSectionTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCrossSectionTable (const CrossSectionTableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCrossSectionTable (::std::auto_ptr< CrossSectionTableType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CrossSectionComplexType (const CrossSectionTableType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    CrossSectionComplexType (::std::auto_ptr< CrossSectionTableType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CrossSectionComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CrossSectionComplexType (const CrossSectionComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CrossSectionComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CrossSectionComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CrossSectionTableType > crossSectionTable_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CrossSectionRoughnessComplexType schema type.
   *
   * @nosubgrouping
   */
  class CrossSectionRoughnessComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name roughnessTable
     *
     * @brief Accessor and modifier functions for the %roughnessTable
     * required element.
     *
     * Pairs of elevation h and roughness C (according to Chezy)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType RoughnessTableType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RoughnessTableType, char > RoughnessTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RoughnessTableType&
    getRoughnessTable () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RoughnessTableType&
    getRoughnessTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRoughnessTable (const RoughnessTableType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRoughnessTable (::std::auto_ptr< RoughnessTableType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CrossSectionRoughnessComplexType (const RoughnessTableType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    CrossSectionRoughnessComplexType (::std::auto_ptr< RoughnessTableType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CrossSectionRoughnessComplexType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CrossSectionRoughnessComplexType (const CrossSectionRoughnessComplexType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CrossSectionRoughnessComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CrossSectionRoughnessComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RoughnessTableType > roughnessTable_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BranchInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class BranchInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     *
     * ID of upstream node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * required element.
     *
     * ID of downstream node
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HDownType&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HDownType&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name ux
     *
     * @brief Accessor and modifier functions for the %ux
     * optional element.
     *
     * optional wind velocity at an elevation of 10 m above the water surface
     * (x-direction), implementation is for the inertial model only
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UxType > UxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UxType, char > UxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UxOptional&
    getUx () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UxOptional&
    getUx ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUx (const UxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUx (const UxOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUx (::std::auto_ptr< UxType > p);

    //@}

    /**
     * @name uy
     *
     * @brief Accessor and modifier functions for the %uy
     * optional element.
     *
     * optional wind velocity at an elevation of 10 m above the water surface
     * (y-direction), implementation is for the inertial model only
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType UyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UyType > UyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UyType, char > UyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UyOptional&
    getUy () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UyOptional&
    getUy ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUy (const UyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUy (const UyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUy (::std::auto_ptr< UyType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BranchInputComplexType (const HUpType&,
                            const HDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchInputComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BranchInputComplexType (const BranchInputComplexType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BranchInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BranchInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    ::xsd::cxx::tree::one< HDownType > HDown_;
    UxOptional ux_;
    UyOptional uy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BranchOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class BranchOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BranchOutputComplexType (const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchOutputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BranchOutputComplexType (const BranchOutputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BranchOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BranchOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QType > Q_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HydraulicStructureComplexType schema type.
   *
   * @nosubgrouping
   */
  class HydraulicStructureComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name orifice
     *
     * @brief Accessor and modifier functions for the %orifice
     * optional element.
     *
     * Orifice according to definition in SOBEK-Rural
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OrificeComplexType OrificeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OrificeType > OrificeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OrificeType, char > OrificeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OrificeOptional&
    getOrifice () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OrificeOptional&
    getOrifice ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOrifice (const OrificeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOrifice (const OrificeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOrifice (::std::auto_ptr< OrificeType > p);

    //@}

    /**
     * @name weir
     *
     * @brief Accessor and modifier functions for the %weir
     * optional element.
     *
     * Weir according to definition in SOBEK-River
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RiverWeirComplexType WeirType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeirType > WeirOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeirType, char > WeirTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeirOptional&
    getWeir () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeirOptional&
    getWeir ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeir (const WeirType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeir (const WeirOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeir (::std::auto_ptr< WeirType > p);

    //@}

    /**
     * @name pump
     *
     * @brief Accessor and modifier functions for the %pump
     * optional element.
     *
     * Pump
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PumpComplexType PumpType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PumpType > PumpOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PumpType, char > PumpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PumpOptional&
    getPump () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PumpOptional&
    getPump ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPump (const PumpType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPump (const PumpOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPump (::std::auto_ptr< PumpType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HydraulicStructureComplexType (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicStructureComplexType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydraulicStructureComplexType (const HydraulicStructureComplexType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydraulicStructureComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HydraulicStructureComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OrificeOptional orifice_;
    WeirOptional weir_;
    PumpOptional pump_;
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PumpComplexType schema type.
   *
   * @nosubgrouping
   */
  class PumpComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PumpInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::PumpOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PumpComplexType (const InputType&,
                     const OutputType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PumpComplexType (::std::auto_ptr< InputType >&,
                     ::std::auto_ptr< OutputType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PumpComplexType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PumpComplexType (const PumpComplexType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PumpComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PumpComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PumpInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class PumpInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HDownType&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HDownType&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PumpInputComplexType (const HUpType&,
                          const HDownType&,
                          const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PumpInputComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PumpInputComplexType (const PumpInputComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PumpInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PumpInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    ::xsd::cxx::tree::one< HDownType > HDown_;
    ::xsd::cxx::tree::one< QType > Q_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PumpOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class PumpOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PumpOutputComplexType (const QType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PumpOutputComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PumpOutputComplexType (const PumpOutputComplexType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PumpOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PumpOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QType > Q_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PumpGradientComplexType schema type.
   *
   * @nosubgrouping
   */
  class PumpGradientComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name storageUp
     *
     * @brief Accessor and modifier functions for the %storageUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StorageUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageUpType, char > StorageUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageUpType&
    getStorageUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageUpType&
    getStorageUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageUp (const StorageUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageUp (::std::auto_ptr< StorageUpType > p);

    //@}

    /**
     * @name storageDown
     *
     * @brief Accessor and modifier functions for the %storageDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StorageDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageDownType, char > StorageDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageDownType&
    getStorageDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageDownType&
    getStorageDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageDown (const StorageDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageDown (::std::auto_ptr< StorageDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PumpGradientComplexType (const StorageUpType&,
                             const StorageDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PumpGradientComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PumpGradientComplexType (const PumpGradientComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PumpGradientComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PumpGradientComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StorageUpType > storageUp_;
    ::xsd::cxx::tree::one< StorageDownType > storageDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name nodeUp
     *
     * @brief Accessor and modifier functions for the %nodeUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeUpType, char > NodeUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeUpType&
    getNodeUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeUpType&
    getNodeUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeUp (const NodeUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeUp (::std::auto_ptr< NodeUpType > p);

    //@}

    /**
     * @name nodeDown
     *
     * @brief Accessor and modifier functions for the %nodeDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String NodeDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NodeDownType, char > NodeDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NodeDownType&
    getNodeDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NodeDownType&
    getNodeDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNodeDown (const NodeDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNodeDown (::std::auto_ptr< NodeDownType > p);

    //@}

    /**
     * @name capacityCharacteristics
     *
     * @brief Accessor and modifier functions for the %capacityCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineCapacityCharacteristicsComplexType CapacityCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityCharacteristicsType, char > CapacityCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CapacityCharacteristicsType&
    getCapacityCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CapacityCharacteristicsType&
    getCapacityCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityCharacteristics (const CapacityCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCapacityCharacteristics (::std::auto_ptr< CapacityCharacteristicsType > p);

    //@}

    /**
     * @name efficiencyCharacteristics
     *
     * @brief Accessor and modifier functions for the %efficiencyCharacteristics
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineEfficiencyCharacteristicsComplexType EfficiencyCharacteristicsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EfficiencyCharacteristicsType, char > EfficiencyCharacteristicsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EfficiencyCharacteristicsType&
    getEfficiencyCharacteristics () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EfficiencyCharacteristicsType&
    getEfficiencyCharacteristics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEfficiencyCharacteristics (const EfficiencyCharacteristicsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEfficiencyCharacteristics (::std::auto_ptr< EfficiencyCharacteristicsType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TurbineOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineComplexType (const NodeUpType&,
                        const NodeDownType&,
                        const CapacityCharacteristicsType&,
                        const EfficiencyCharacteristicsType&,
                        const InputType&,
                        const OutputType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TurbineComplexType (const NodeUpType&,
                        const NodeDownType&,
                        ::std::auto_ptr< CapacityCharacteristicsType >&,
                        ::std::auto_ptr< EfficiencyCharacteristicsType >&,
                        ::std::auto_ptr< InputType >&,
                        ::std::auto_ptr< OutputType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineComplexType (const TurbineComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NodeUpType > nodeUp_;
    ::xsd::cxx::tree::one< NodeDownType > nodeDown_;
    ::xsd::cxx::tree::one< CapacityCharacteristicsType > capacityCharacteristics_;
    ::xsd::cxx::tree::one< EfficiencyCharacteristicsType > efficiencyCharacteristics_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineCapacityCharacteristicsComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineCapacityCharacteristicsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name capacityTable
     *
     * @brief Accessor and modifier functions for the %capacityTable
     * optional element.
     *
     * capacity table of hydropower turbine as a function of the water head
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::ElevationTableComplexType CapacityTableType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacityTableType > CapacityTableOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityTableType, char > CapacityTableTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacityTableOptional&
    getCapacityTable () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacityTableOptional&
    getCapacityTable ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityTable (const CapacityTableType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacityTable (const CapacityTableOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacityTable (::std::auto_ptr< CapacityTableType > p);

    //@}

    /**
     * @name capacityEquation
     *
     * @brief Accessor and modifier functions for the %capacityEquation
     * optional element.
     *
     * capacity equation of hydropower turbine as a function of the water
    head */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::EquationsComplexType CapacityEquationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacityEquationType > CapacityEquationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityEquationType, char > CapacityEquationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacityEquationOptional&
    getCapacityEquation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacityEquationOptional&
    getCapacityEquation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityEquation (const CapacityEquationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacityEquation (const CapacityEquationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacityEquation (::std::auto_ptr< CapacityEquationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineCapacityCharacteristicsComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineCapacityCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineCapacityCharacteristicsComplexType (const TurbineCapacityCharacteristicsComplexType& x,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineCapacityCharacteristicsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineCapacityCharacteristicsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapacityTableOptional capacityTable_;
    CapacityEquationOptional capacityEquation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineEfficiencyCharacteristicsComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineEfficiencyCharacteristicsComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name efficiencyConstant
     *
     * @brief Accessor and modifier functions for the %efficiencyConstant
     * required element.
     *
     * constant efficiency over all discharges, typical range is [0.80, 0.90]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double EfficiencyConstantType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EfficiencyConstantType, char, ::xsd::cxx::tree::schema_type::double_ > EfficiencyConstantTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EfficiencyConstantType&
    getEfficiencyConstant () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EfficiencyConstantType&
    getEfficiencyConstant ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEfficiencyConstant (const EfficiencyConstantType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineEfficiencyCharacteristicsComplexType (const EfficiencyConstantType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineEfficiencyCharacteristicsComplexType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineEfficiencyCharacteristicsComplexType (const TurbineEfficiencyCharacteristicsComplexType& x,
                                                 ::xml_schema::Flags f = 0,
                                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineEfficiencyCharacteristicsComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineEfficiencyCharacteristicsComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EfficiencyConstantType > efficiencyConstant_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name release
     *
     * @brief Accessor and modifier functions for the %release
     * optional element.
     *
     * provision of absolute turbine release
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType ReleaseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReleaseType > ReleaseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReleaseType, char > ReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReleaseOptional&
    getRelease () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReleaseOptional&
    getRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelease (const ReleaseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRelease (const ReleaseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRelease (::std::auto_ptr< ReleaseType > p);

    //@}

    /**
     * @name relativeRelease
     *
     * @brief Accessor and modifier functions for the %relativeRelease
     * optional element.
     *
     * provision of relative turbine release, 1 = maximum capacity
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType RelativeReleaseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RelativeReleaseType > RelativeReleaseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelativeReleaseType, char > RelativeReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RelativeReleaseOptional&
    getRelativeRelease () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RelativeReleaseOptional&
    getRelativeRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelativeRelease (const RelativeReleaseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRelativeRelease (const RelativeReleaseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRelativeRelease (::std::auto_ptr< RelativeReleaseType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineInputComplexType ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineInputComplexType (const TurbineInputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ReleaseOptional release_;
    RelativeReleaseOptional relativeRelease_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TurbineOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class TurbineOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name discharge
     *
     * @brief Accessor and modifier functions for the %discharge
     * required element.
     *
     * discharge in m3/s
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DischargeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DischargeType, char > DischargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DischargeType&
    getDischarge () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DischargeType&
    getDischarge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDischarge (const DischargeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDischarge (::std::auto_ptr< DischargeType > p);

    //@}

    /**
     * @name powerProduction
     *
     * @brief Accessor and modifier functions for the %powerProduction
     * required element.
     *
     * power production in MW
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType PowerProductionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PowerProductionType, char > PowerProductionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PowerProductionType&
    getPowerProduction () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PowerProductionType&
    getPowerProduction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPowerProduction (const PowerProductionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPowerProduction (::std::auto_ptr< PowerProductionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TurbineOutputComplexType (const DischargeType&,
                              const PowerProductionType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TurbineOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TurbineOutputComplexType (const TurbineOutputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TurbineOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TurbineOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DischargeType > discharge_;
    ::xsd::cxx::tree::one< PowerProductionType > powerProduction_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OrificeComplexType schema type.
   *
   * @nosubgrouping
   */
  class OrificeComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name width
     *
     * @brief Accessor and modifier functions for the %width
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double WidthType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WidthType, char, ::xsd::cxx::tree::schema_type::double_ > WidthTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WidthType&
    getWidth () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WidthType&
    getWidth ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWidth (const WidthType& x);

    //@}

    /**
     * @name crestLevel
     *
     * @brief Accessor and modifier functions for the %crestLevel
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double CrestLevelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CrestLevelType, char, ::xsd::cxx::tree::schema_type::double_ > CrestLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CrestLevelType&
    getCrestLevel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CrestLevelType&
    getCrestLevel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCrestLevel (const CrestLevelType& x);

    //@}

    /**
     * @name contractionCoefficient
     *
     * @brief Accessor and modifier functions for the %contractionCoefficient
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ContractionCoefficientType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ContractionCoefficientType, char, ::xsd::cxx::tree::schema_type::double_ > ContractionCoefficientTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ContractionCoefficientType&
    getContractionCoefficient () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ContractionCoefficientType&
    getContractionCoefficient ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setContractionCoefficient (const ContractionCoefficientType& x);

    //@}

    /**
     * @name exponentGateFormula
     *
     * @brief Accessor and modifier functions for the %exponentGateFormula
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ExponentGateFormulaType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExponentGateFormulaType > ExponentGateFormulaOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExponentGateFormulaType, char, ::xsd::cxx::tree::schema_type::double_ > ExponentGateFormulaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExponentGateFormulaOptional&
    getExponentGateFormula () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExponentGateFormulaOptional&
    getExponentGateFormula ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExponentGateFormula (const ExponentGateFormulaType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExponentGateFormula (const ExponentGateFormulaOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ExponentGateFormulaType
    getExponentGateFormulaDefaultValue ();

    //@}

    /**
     * @name exponentWeirFormula
     *
     * @brief Accessor and modifier functions for the %exponentWeirFormula
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ExponentWeirFormulaType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExponentWeirFormulaType > ExponentWeirFormulaOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExponentWeirFormulaType, char, ::xsd::cxx::tree::schema_type::double_ > ExponentWeirFormulaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExponentWeirFormulaOptional&
    getExponentWeirFormula () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExponentWeirFormulaOptional&
    getExponentWeirFormula ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExponentWeirFormula (const ExponentWeirFormulaType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExponentWeirFormula (const ExponentWeirFormulaOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ExponentWeirFormulaType
    getExponentWeirFormulaDefaultValue ();

    //@}

    /**
     * @name flowDirection
     *
     * @brief Accessor and modifier functions for the %flowDirection
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FlowDirectionEnumStringType FlowDirectionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlowDirectionType > FlowDirectionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlowDirectionType, char > FlowDirectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlowDirectionOptional&
    getFlowDirection () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlowDirectionOptional&
    getFlowDirection ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlowDirection (const FlowDirectionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlowDirection (const FlowDirectionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlowDirection (::std::auto_ptr< FlowDirectionType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OrificeInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OrificeOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OrificeComplexType (const WidthType&,
                        const CrestLevelType&,
                        const ContractionCoefficientType&,
                        const InputType&,
                        const OutputType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    OrificeComplexType (const WidthType&,
                        const CrestLevelType&,
                        const ContractionCoefficientType&,
                        ::std::auto_ptr< InputType >&,
                        ::std::auto_ptr< OutputType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OrificeComplexType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OrificeComplexType (const OrificeComplexType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OrificeComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OrificeComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< WidthType > width_;
    ::xsd::cxx::tree::one< CrestLevelType > crestLevel_;
    ::xsd::cxx::tree::one< ContractionCoefficientType > contractionCoefficient_;
    ExponentGateFormulaOptional exponentGateFormula_;
    ExponentWeirFormulaOptional exponentWeirFormula_;
    FlowDirectionOptional flowDirection_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OrificeInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class OrificeInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name DeltaHUp
     *
     * @brief Accessor and modifier functions for the %DeltaHUp
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DeltaHUpType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeltaHUpType > DeltaHUpOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeltaHUpType, char > DeltaHUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeltaHUpOptional&
    getDeltaHUp () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeltaHUpOptional&
    getDeltaHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeltaHUp (const DeltaHUpType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeltaHUp (const DeltaHUpOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeltaHUp (::std::auto_ptr< DeltaHUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HDownType&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HDownType&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name DeltaHDown
     *
     * @brief Accessor and modifier functions for the %DeltaHDown
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DeltaHDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeltaHDownType > DeltaHDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeltaHDownType, char > DeltaHDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeltaHDownOptional&
    getDeltaHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeltaHDownOptional&
    getDeltaHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeltaHDown (const DeltaHDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeltaHDown (const DeltaHDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeltaHDown (::std::auto_ptr< DeltaHDownType > p);

    //@}

    /**
     * @name DConst
     *
     * @brief Accessor and modifier functions for the %DConst
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DConstType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DConstType > DConstOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DConstType, char, ::xsd::cxx::tree::schema_type::double_ > DConstTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DConstOptional&
    getDConst () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DConstOptional&
    getDConst ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDConst (const DConstType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDConst (const DConstOptional& x);

    //@}

    /**
     * @name DSeries
     *
     * @brief Accessor and modifier functions for the %DSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DSeriesType > DSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DSeriesType, char > DSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DSeriesOptional&
    getDSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DSeriesOptional&
    getDSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDSeries (const DSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDSeries (const DSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDSeries (::std::auto_ptr< DSeriesType > p);

    //@}

    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * optional element.
     *
     * deprecated
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DType > DOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DOptional&
    getD () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DOptional&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setD (const DOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OrificeInputComplexType (const HUpType&,
                             const HDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OrificeInputComplexType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OrificeInputComplexType (const OrificeInputComplexType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OrificeInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OrificeInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    DeltaHUpOptional DeltaHUp_;
    ::xsd::cxx::tree::one< HDownType > HDown_;
    DeltaHDownOptional DeltaHDown_;
    DConstOptional DConst_;
    DSeriesOptional DSeries_;
    DOptional D_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OrificeOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class OrificeOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name D
     *
     * @brief Accessor and modifier functions for the %D
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DType&
    getD () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DType&
    getD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setD (const DType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setD (::std::auto_ptr< DType > p);

    //@}

    /**
     * @name flowType
     *
     * @brief Accessor and modifier functions for the %flowType
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlowTypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlowTypeType > FlowTypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlowTypeType, char > FlowTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlowTypeOptional&
    getFlowType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlowTypeOptional&
    getFlowType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlowType (const FlowTypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlowType (const FlowTypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlowType (::std::auto_ptr< FlowTypeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OrificeOutputComplexType (const QType&,
                              const DType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OrificeOutputComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OrificeOutputComplexType (const OrificeOutputComplexType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OrificeOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OrificeOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QType > Q_;
    ::xsd::cxx::tree::one< DType > D_;
    FlowTypeOptional flowType_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BranchGradientComplexType schema type.
   *
   * @nosubgrouping
   */
  class BranchGradientComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name storageUp
     *
     * @brief Accessor and modifier functions for the %storageUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StorageUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageUpType, char > StorageUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageUpType&
    getStorageUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageUpType&
    getStorageUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageUp (const StorageUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageUp (::std::auto_ptr< StorageUpType > p);

    //@}

    /**
     * @name surfaceAreaUp
     *
     * @brief Accessor and modifier functions for the %surfaceAreaUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SurfaceAreaUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SurfaceAreaUpType, char > SurfaceAreaUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SurfaceAreaUpType&
    getSurfaceAreaUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SurfaceAreaUpType&
    getSurfaceAreaUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSurfaceAreaUp (const SurfaceAreaUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSurfaceAreaUp (::std::auto_ptr< SurfaceAreaUpType > p);

    //@}

    /**
     * @name storageDown
     *
     * @brief Accessor and modifier functions for the %storageDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType StorageDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StorageDownType, char > StorageDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StorageDownType&
    getStorageDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StorageDownType&
    getStorageDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStorageDown (const StorageDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStorageDown (::std::auto_ptr< StorageDownType > p);

    //@}

    /**
     * @name surfaceAreaDown
     *
     * @brief Accessor and modifier functions for the %surfaceAreaDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SurfaceAreaDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SurfaceAreaDownType, char > SurfaceAreaDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SurfaceAreaDownType&
    getSurfaceAreaDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SurfaceAreaDownType&
    getSurfaceAreaDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSurfaceAreaDown (const SurfaceAreaDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSurfaceAreaDown (::std::auto_ptr< SurfaceAreaDownType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BranchGradientComplexType (const StorageUpType&,
                               const SurfaceAreaUpType&,
                               const StorageDownType&,
                               const SurfaceAreaDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchGradientComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BranchGradientComplexType (const BranchGradientComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BranchGradientComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BranchGradientComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< StorageUpType > storageUp_;
    ::xsd::cxx::tree::one< SurfaceAreaUpType > surfaceAreaUp_;
    ::xsd::cxx::tree::one< StorageDownType > storageDown_;
    ::xsd::cxx::tree::one< SurfaceAreaDownType > surfaceAreaDown_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RiverWeirComplexType schema type.
   *
   * @nosubgrouping
   */
  class RiverWeirComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name width
     *
     * @brief Accessor and modifier functions for the %width
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double WidthType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WidthType, char, ::xsd::cxx::tree::schema_type::double_ > WidthTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const WidthType&
    getWidth () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    WidthType&
    getWidth ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWidth (const WidthType& x);

    //@}

    /**
     * @name exponentWeirFormula
     *
     * @brief Accessor and modifier functions for the %exponentWeirFormula
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ExponentWeirFormulaType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExponentWeirFormulaType > ExponentWeirFormulaOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExponentWeirFormulaType, char, ::xsd::cxx::tree::schema_type::double_ > ExponentWeirFormulaTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExponentWeirFormulaOptional&
    getExponentWeirFormula () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExponentWeirFormulaOptional&
    getExponentWeirFormula ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExponentWeirFormula (const ExponentWeirFormulaType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExponentWeirFormula (const ExponentWeirFormulaOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static ExponentWeirFormulaType
    getExponentWeirFormulaDefaultValue ();

    //@}

    /**
     * @name submergedFlowRatio
     *
     * @brief Accessor and modifier functions for the %submergedFlowRatio
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SubmergedFlowRatioType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SubmergedFlowRatioType > SubmergedFlowRatioOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SubmergedFlowRatioType, char, ::xsd::cxx::tree::schema_type::double_ > SubmergedFlowRatioTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SubmergedFlowRatioOptional&
    getSubmergedFlowRatio () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SubmergedFlowRatioOptional&
    getSubmergedFlowRatio ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSubmergedFlowRatio (const SubmergedFlowRatioType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSubmergedFlowRatio (const SubmergedFlowRatioOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static SubmergedFlowRatioType
    getSubmergedFlowRatioDefaultValue ();

    //@}

    /**
     * @name submergedFlowFactor
     *
     * @brief Accessor and modifier functions for the %submergedFlowFactor
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SubmergedFlowFactorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SubmergedFlowFactorType > SubmergedFlowFactorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SubmergedFlowFactorType, char, ::xsd::cxx::tree::schema_type::double_ > SubmergedFlowFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SubmergedFlowFactorOptional&
    getSubmergedFlowFactor () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SubmergedFlowFactorOptional&
    getSubmergedFlowFactor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSubmergedFlowFactor (const SubmergedFlowFactorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSubmergedFlowFactor (const SubmergedFlowFactorOptional& x);

    /**
     * @brief Return the default value for the element.
     *
     * @return The element's default value.
     */
    static SubmergedFlowFactorType
    getSubmergedFlowFactorDefaultValue ();

    //@}

    /**
     * @name flowDirection
     *
     * @brief Accessor and modifier functions for the %flowDirection
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::FlowDirectionEnumStringType FlowDirectionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlowDirectionType > FlowDirectionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlowDirectionType, char > FlowDirectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlowDirectionOptional&
    getFlowDirection () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlowDirectionOptional&
    getFlowDirection ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlowDirection (const FlowDirectionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlowDirection (const FlowDirectionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlowDirection (::std::auto_ptr< FlowDirectionType > p);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RiverWeirInputComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::RiverWeirOutputComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RiverWeirComplexType (const WidthType&,
                          const InputType&,
                          const OutputType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    RiverWeirComplexType (const WidthType&,
                          ::std::auto_ptr< InputType >&,
                          ::std::auto_ptr< OutputType >&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RiverWeirComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RiverWeirComplexType (const RiverWeirComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RiverWeirComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RiverWeirComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< WidthType > width_;
    ExponentWeirFormulaOptional exponentWeirFormula_;
    SubmergedFlowRatioOptional submergedFlowRatio_;
    SubmergedFlowFactorOptional submergedFlowFactor_;
    FlowDirectionOptional flowDirection_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RiverWeirInputComplexType schema type.
   *
   * @nosubgrouping
   */
  class RiverWeirInputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name HUp
     *
     * @brief Accessor and modifier functions for the %HUp
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HUpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HUpType, char > HUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HUpType&
    getHUp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HUpType&
    getHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHUp (const HUpType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHUp (::std::auto_ptr< HUpType > p);

    //@}

    /**
     * @name DeltaHUp
     *
     * @brief Accessor and modifier functions for the %DeltaHUp
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DeltaHUpType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeltaHUpType > DeltaHUpOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeltaHUpType, char > DeltaHUpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeltaHUpOptional&
    getDeltaHUp () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeltaHUpOptional&
    getDeltaHUp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeltaHUp (const DeltaHUpType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeltaHUp (const DeltaHUpOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeltaHUp (::std::auto_ptr< DeltaHUpType > p);

    //@}

    /**
     * @name HDown
     *
     * @brief Accessor and modifier functions for the %HDown
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType HDownType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HDownType, char > HDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HDownType&
    getHDown () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HDownType&
    getHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHDown (const HDownType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHDown (::std::auto_ptr< HDownType > p);

    //@}

    /**
     * @name DeltaHDown
     *
     * @brief Accessor and modifier functions for the %DeltaHDown
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DeltaHDownType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeltaHDownType > DeltaHDownOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeltaHDownType, char > DeltaHDownTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeltaHDownOptional&
    getDeltaHDown () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeltaHDownOptional&
    getDeltaHDown ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeltaHDown (const DeltaHDownType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeltaHDown (const DeltaHDownOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeltaHDown (::std::auto_ptr< DeltaHDownType > p);

    //@}

    /**
     * @name CConst
     *
     * @brief Accessor and modifier functions for the %CConst
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double CConstType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CConstType > CConstOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CConstType, char, ::xsd::cxx::tree::schema_type::double_ > CConstTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CConstOptional&
    getCConst () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CConstOptional&
    getCConst ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCConst (const CConstType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCConst (const CConstOptional& x);

    //@}

    /**
     * @name CSeries
     *
     * @brief Accessor and modifier functions for the %CSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType CSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CSeriesType > CSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CSeriesType, char > CSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CSeriesOptional&
    getCSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CSeriesOptional&
    getCSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCSeries (const CSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCSeries (const CSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCSeries (::std::auto_ptr< CSeriesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RiverWeirInputComplexType (const HUpType&,
                               const HDownType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RiverWeirInputComplexType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RiverWeirInputComplexType (const RiverWeirInputComplexType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RiverWeirInputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RiverWeirInputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HUpType > HUp_;
    DeltaHUpOptional DeltaHUp_;
    ::xsd::cxx::tree::one< HDownType > HDown_;
    DeltaHDownOptional DeltaHDown_;
    CConstOptional CConst_;
    CSeriesOptional CSeries_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RiverWeirOutputComplexType schema type.
   *
   * @nosubgrouping
   */
  class RiverWeirOutputComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name Q
     *
     * @brief Accessor and modifier functions for the %Q
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType QType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const QType&
    getQ () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    QType&
    getQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQ (const QType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setQ (::std::auto_ptr< QType > p);

    //@}

    /**
     * @name C
     *
     * @brief Accessor and modifier functions for the %C
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType CType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CType&
    getC () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CType&
    getC ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setC (const CType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setC (::std::auto_ptr< CType > p);

    //@}

    /**
     * @name flowType
     *
     * @brief Accessor and modifier functions for the %flowType
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType FlowTypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FlowTypeType > FlowTypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FlowTypeType, char > FlowTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FlowTypeOptional&
    getFlowType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FlowTypeOptional&
    getFlowType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFlowType (const FlowTypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFlowType (const FlowTypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFlowType (::std::auto_ptr< FlowTypeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RiverWeirOutputComplexType (const QType&,
                                const CType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RiverWeirOutputComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RiverWeirOutputComplexType (const RiverWeirOutputComplexType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RiverWeirOutputComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RiverWeirOutputComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< QType > Q_;
    ::xsd::cxx::tree::one< CType > C_;
    FlowTypeOptional flowType_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %poolRoutingEnumStringType
   * schema type.
   *
   * Type of pool routing.
   */
  class PoolRoutingEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      ForwardEuler,
      BackwardEuler,
      Theta
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    PoolRoutingEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    PoolRoutingEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    PoolRoutingEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    PoolRoutingEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PoolRoutingEnumStringType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PoolRoutingEnumStringType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PoolRoutingEnumStringType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PoolRoutingEnumStringType (const PoolRoutingEnumStringType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PoolRoutingEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    PoolRoutingEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_PoolRoutingEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_PoolRoutingEnumStringType_convert () const;

    public:
    static const char* const _xsd_PoolRoutingEnumStringType_literals_[3];
    static const Value _xsd_PoolRoutingEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %interpolationOptionEnumStringType
   * schema type.
   *
   * Type of interpolation
   */
  class InterpolationOptionEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      BLOCK,
      LINEAR
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    InterpolationOptionEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    InterpolationOptionEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    InterpolationOptionEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    InterpolationOptionEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InterpolationOptionEnumStringType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InterpolationOptionEnumStringType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InterpolationOptionEnumStringType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InterpolationOptionEnumStringType (const InterpolationOptionEnumStringType& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InterpolationOptionEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    InterpolationOptionEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_InterpolationOptionEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_InterpolationOptionEnumStringType_convert () const;

    public:
    static const char* const _xsd_InterpolationOptionEnumStringType_literals_[2];
    static const Value _xsd_InterpolationOptionEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %limiterOptionEnumStringType
   * schema type.
   *
   * Type of limiting
   */
  class LimiterOptionEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      PERCENTAGE,
      ABSOLUTE
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    LimiterOptionEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    LimiterOptionEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    LimiterOptionEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    LimiterOptionEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimiterOptionEnumStringType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimiterOptionEnumStringType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimiterOptionEnumStringType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimiterOptionEnumStringType (const LimiterOptionEnumStringType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LimiterOptionEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    LimiterOptionEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_LimiterOptionEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_LimiterOptionEnumStringType_convert () const;

    public:
    static const char* const _xsd_LimiterOptionEnumStringType_literals_[2];
    static const Value _xsd_LimiterOptionEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %timeRelativeEnumStringType
   * schema type.
   *
   * Value option
   */
  class TimeRelativeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      ABSOLUTE,
      RELATIVE
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    TimeRelativeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    TimeRelativeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    TimeRelativeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    TimeRelativeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeEnumStringType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeEnumStringType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeRelativeEnumStringType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeRelativeEnumStringType (const TimeRelativeEnumStringType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeRelativeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    TimeRelativeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_TimeRelativeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_TimeRelativeEnumStringType_convert () const;

    public:
    static const char* const _xsd_TimeRelativeEnumStringType_literals_[2];
    static const Value _xsd_TimeRelativeEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %caseLangetenEnumStringType
   * schema type.
   */
  class CaseLangetenEnumStringType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @brief Create an instance from a fundamental type value.
     *
     * @param v A fundamental type value.
     */
    CaseLangetenEnumStringType (::xml_schema::Int v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CaseLangetenEnumStringType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CaseLangetenEnumStringType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CaseLangetenEnumStringType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CaseLangetenEnumStringType (const CaseLangetenEnumStringType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CaseLangetenEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;
  };

  /**
   * @brief Union class corresponding to the %flowDirectionEnumStringType
   * schema type.
   *
   * The mapping represents unions as strings.
   *
   * flow direction
   */
  class FlowDirectionEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    FlowDirectionEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    FlowDirectionEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FlowDirectionEnumStringType (const FlowDirectionEnumStringType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FlowDirectionEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;
  };

  /**
   * @brief Enumeration class corresponding to the %logicalOperatorEnumStringType
   * schema type.
   *
   * logical operator
   */
  class LogicalOperatorEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      AND,
      OR,
      XOR
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    LogicalOperatorEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    LogicalOperatorEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    LogicalOperatorEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    LogicalOperatorEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LogicalOperatorEnumStringType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LogicalOperatorEnumStringType (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LogicalOperatorEnumStringType (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LogicalOperatorEnumStringType (const LogicalOperatorEnumStringType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LogicalOperatorEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    LogicalOperatorEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_LogicalOperatorEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_LogicalOperatorEnumStringType_convert () const;

    public:
    static const char* const _xsd_LogicalOperatorEnumStringType_literals_[3];
    static const Value _xsd_LogicalOperatorEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %relationalOperatorEnumStringType
   * schema type.
   *
   * relational operator
   */
  class RelationalOperatorEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      Less,
      LessEqual,
      Equal,
      Unequal,
      GreaterEqual,
      Greater
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    RelationalOperatorEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    RelationalOperatorEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    RelationalOperatorEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    RelationalOperatorEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RelationalOperatorEnumStringType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RelationalOperatorEnumStringType (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RelationalOperatorEnumStringType (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RelationalOperatorEnumStringType (const RelationalOperatorEnumStringType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RelationalOperatorEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    RelationalOperatorEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_RelationalOperatorEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_RelationalOperatorEnumStringType_convert () const;

    public:
    static const char* const _xsd_RelationalOperatorEnumStringType_literals_[6];
    static const Value _xsd_RelationalOperatorEnumStringType_indexes_[6];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %MathematicalOperatorEnumStringType
   * schema type.
   *
   * mathematical operators
   */
  class MathematicalOperatorEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      cxx_,
      cxx_1,
      cxx_2,
      cxx_3,
      min,
      max,
      cxx_4
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MathematicalOperatorEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MathematicalOperatorEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MathematicalOperatorEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MathematicalOperatorEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MathematicalOperatorEnumStringType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MathematicalOperatorEnumStringType (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MathematicalOperatorEnumStringType (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MathematicalOperatorEnumStringType (const MathematicalOperatorEnumStringType& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MathematicalOperatorEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MathematicalOperatorEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MathematicalOperatorEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MathematicalOperatorEnumStringType_convert () const;

    public:
    static const char* const _xsd_MathematicalOperatorEnumStringType_literals_[7];
    static const Value _xsd_MathematicalOperatorEnumStringType_indexes_[7];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %SpatialEnumStringType
   * schema type.
   *
   * options for spatial schetization
   */
  class SpatialEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      CENTRAL,
      UPWIND
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    SpatialEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    SpatialEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    SpatialEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    SpatialEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpatialEnumStringType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpatialEnumStringType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SpatialEnumStringType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SpatialEnumStringType (const SpatialEnumStringType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SpatialEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    SpatialEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_SpatialEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_SpatialEnumStringType_convert () const;

    public:
    static const char* const _xsd_SpatialEnumStringType_literals_[2];
    static const Value _xsd_SpatialEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %CapacityReferenceEnumStringType
   * schema type.
   *
   * reference for capacity
   */
  class CapacityReferenceEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      UPSTREAMLEVEL,
      HEAD
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    CapacityReferenceEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    CapacityReferenceEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    CapacityReferenceEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    CapacityReferenceEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CapacityReferenceEnumStringType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CapacityReferenceEnumStringType (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CapacityReferenceEnumStringType (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CapacityReferenceEnumStringType (const CapacityReferenceEnumStringType& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CapacityReferenceEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    CapacityReferenceEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_CapacityReferenceEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_CapacityReferenceEnumStringType_convert () const;

    public:
    static const char* const _xsd_CapacityReferenceEnumStringType_literals_[2];
    static const Value _xsd_CapacityReferenceEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %inputReferenceEnumStringType
   * schema type.
   */
  class InputReferenceEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      EXPLICIT,
      IMPLICIT
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    InputReferenceEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    InputReferenceEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    InputReferenceEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    InputReferenceEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputReferenceEnumStringType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputReferenceEnumStringType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputReferenceEnumStringType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputReferenceEnumStringType (const InputReferenceEnumStringType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputReferenceEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    InputReferenceEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_InputReferenceEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_InputReferenceEnumStringType_convert () const;

    public:
    static const char* const _xsd_InputReferenceEnumStringType_literals_[2];
    static const Value _xsd_InputReferenceEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %BranchTypeEnumStringType
   * schema type.
   */
  class BranchTypeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      KINEMATIC,
      DIFFUSIVE,
      DIFFUSIVEPLUSLOCAL
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    BranchTypeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    BranchTypeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    BranchTypeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    BranchTypeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchTypeEnumStringType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchTypeEnumStringType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BranchTypeEnumStringType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BranchTypeEnumStringType (const BranchTypeEnumStringType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BranchTypeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    BranchTypeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_BranchTypeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_BranchTypeEnumStringType_convert () const;

    public:
    static const char* const _xsd_BranchTypeEnumStringType_literals_[3];
    static const Value _xsd_BranchTypeEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %EquationEnumStringType
   * schema type.
   */
  class EquationEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      KINEMATIC,
      DIFFUSIVE,
      INERTIAL
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    EquationEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    EquationEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    EquationEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    EquationEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EquationEnumStringType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EquationEnumStringType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EquationEnumStringType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EquationEnumStringType (const EquationEnumStringType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EquationEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    EquationEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_EquationEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_EquationEnumStringType_convert () const;

    public:
    static const char* const _xsd_EquationEnumStringType_literals_[3];
    static const Value _xsd_EquationEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %MergerSplitterEnumStringType
   * schema type.
   */
  class MergerSplitterEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      AVERAGE,
      DATAHIERARCHY,
      SUM
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MergerSplitterEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MergerSplitterEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MergerSplitterEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MergerSplitterEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerSplitterEnumStringType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerSplitterEnumStringType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MergerSplitterEnumStringType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MergerSplitterEnumStringType (const MergerSplitterEnumStringType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MergerSplitterEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MergerSplitterEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MergerSplitterEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MergerSplitterEnumStringType_convert () const;

    public:
    static const char* const _xsd_MergerSplitterEnumStringType_literals_[3];
    static const Value _xsd_MergerSplitterEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %HydraulicModelModeEnumStringType
   * schema type.
   */
  class HydraulicModelModeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      SEQUENTIAL_EXPLICIT,
      SEQUENTIAL_IMPLICIT,
      SIMULTANEOUS
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    HydraulicModelModeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    HydraulicModelModeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    HydraulicModelModeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    HydraulicModelModeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelModeEnumStringType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelModeEnumStringType (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HydraulicModelModeEnumStringType (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HydraulicModelModeEnumStringType (const HydraulicModelModeEnumStringType& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HydraulicModelModeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    HydraulicModelModeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_HydraulicModelModeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_HydraulicModelModeEnumStringType_convert () const;

    public:
    static const char* const _xsd_HydraulicModelModeEnumStringType_literals_[3];
    static const Value _xsd_HydraulicModelModeEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %transferFunctionEnumStringType
   * schema type.
   *
   * Type of transfer function.
   */
  class TransferFunctionEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      Linear,
      SigmoidLogistic,
      Tansig
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    TransferFunctionEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    TransferFunctionEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    TransferFunctionEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    TransferFunctionEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TransferFunctionEnumStringType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TransferFunctionEnumStringType (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TransferFunctionEnumStringType (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TransferFunctionEnumStringType (const TransferFunctionEnumStringType& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TransferFunctionEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    TransferFunctionEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_TransferFunctionEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_TransferFunctionEnumStringType_convert () const;

    public:
    static const char* const _xsd_TransferFunctionEnumStringType_literals_[3];
    static const Value _xsd_TransferFunctionEnumStringType_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PidComplexType schema type.
   *
   * @nosubgrouping
   */
  class PidComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name mode
     *
     * @brief Accessor and modifier functions for the %mode
     * optional element.
     *
     * pid mode, either "NATIVE" or "SOBEK2" or "PIDPOS" or PIDVEL"
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Mode1 ModeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModeType > ModeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModeOptional&
    getMode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ModeOptional&
    getMode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMode (const ModeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMode (::std::auto_ptr< ModeType > p);

    /**
     * @brief Return the default value for the element.
     *
     * @return A read-only (constant) reference to the element's
     * default value.
     */
    static const ModeType&
    getModeDefaultValue ();

    //@}

    /**
     * @name settingMin
     *
     * @brief Accessor and modifier functions for the %settingMin
     * required element.
     *
     * minimum setting of the actuator
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingMinType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingMinType, char, ::xsd::cxx::tree::schema_type::double_ > SettingMinTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SettingMinType&
    getSettingMin () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SettingMinType&
    getSettingMin ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingMin (const SettingMinType& x);

    //@}

    /**
     * @name settingMax
     *
     * @brief Accessor and modifier functions for the %settingMax
     * required element.
     *
     * maximum setting of the actuator
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingMaxType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingMaxType, char, ::xsd::cxx::tree::schema_type::double_ > SettingMaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SettingMaxType&
    getSettingMax () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SettingMaxType&
    getSettingMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingMax (const SettingMaxType& x);

    //@}

    /**
     * @name settingMaxSpeed
     *
     * @brief Accessor and modifier functions for the %settingMaxSpeed
     * required element.
     *
     * maximum speed of the actuation in [unit/s]
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SettingMaxSpeedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SettingMaxSpeedType, char, ::xsd::cxx::tree::schema_type::double_ > SettingMaxSpeedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SettingMaxSpeedType&
    getSettingMaxSpeed () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SettingMaxSpeedType&
    getSettingMaxSpeed ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSettingMaxSpeed (const SettingMaxSpeedType& x);

    //@}

    /**
     * @name kp
     *
     * @brief Accessor and modifier functions for the %kp
     * required element.
     *
     * factor on the proportional part kp*e
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double KpType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KpType, char, ::xsd::cxx::tree::schema_type::double_ > KpTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KpType&
    getKp () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KpType&
    getKp ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setKp (const KpType& x);

    //@}

    /**
     * @name ki
     *
     * @brief Accessor and modifier functions for the %ki
     * required element.
     *
     * factor on the integral part ki*integral(e)dt
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double KiType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KiType, char, ::xsd::cxx::tree::schema_type::double_ > KiTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KiType&
    getKi () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KiType&
    getKi ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setKi (const KiType& x);

    //@}

    /**
     * @name kd
     *
     * @brief Accessor and modifier functions for the %kd
     * required element.
     *
     * fatcor on differential part kd*de/dt
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double KdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< KdType, char, ::xsd::cxx::tree::schema_type::double_ > KdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const KdType&
    getKd () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    KdType&
    getKd ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setKd (const KdType& x);

    //@}

    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::InputPidComplexType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name output
     *
     * @brief Accessor and modifier functions for the %output
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::OutputPidComplexType OutputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const OutputType&
    getOutput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    OutputType&
    getOutput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOutput (const OutputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOutput (::std::auto_ptr< OutputType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::auto_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PidComplexType (const SettingMinType&,
                    const SettingMaxType&,
                    const SettingMaxSpeedType&,
                    const KpType&,
                    const KiType&,
                    const KdType&,
                    const InputType&,
                    const OutputType&,
                    const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (auto_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    PidComplexType (const SettingMinType&,
                    const SettingMaxType&,
                    const SettingMaxSpeedType&,
                    const KpType&,
                    const KiType&,
                    const KdType&,
                    ::std::auto_ptr< InputType >&,
                    ::std::auto_ptr< OutputType >&,
                    const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PidComplexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PidComplexType (const PidComplexType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PidComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PidComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ModeOptional mode_;
    static const ModeType mode_default_value_;
    ::xsd::cxx::tree::one< SettingMinType > settingMin_;
    ::xsd::cxx::tree::one< SettingMaxType > settingMax_;
    ::xsd::cxx::tree::one< SettingMaxSpeedType > settingMaxSpeed_;
    ::xsd::cxx::tree::one< KpType > kp_;
    ::xsd::cxx::tree::one< KiType > ki_;
    ::xsd::cxx::tree::one< KdType > kd_;
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< OutputType > output_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InputPidComplexType schema type.
   *
   * @nosubgrouping
   */
  class InputPidComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name x
     *
     * @brief Accessor and modifier functions for the %x
     * required element.
     *
     * controllable variable
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType XType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const XType&
    getX () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    XType&
    getX ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setX (const XType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setX (::std::auto_ptr< XType > p);

    //@}

    /**
     * @name setpointSeries
     *
     * @brief Accessor and modifier functions for the %setpointSeries
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType SetpointSeriesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetpointSeriesType > SetpointSeriesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetpointSeriesType, char > SetpointSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetpointSeriesOptional&
    getSetpointSeries () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetpointSeriesOptional&
    getSetpointSeries ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetpointSeries (const SetpointSeriesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetpointSeries (const SetpointSeriesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSetpointSeries (::std::auto_ptr< SetpointSeriesType > p);

    //@}

    /**
     * @name setpointValue
     *
     * @brief Accessor and modifier functions for the %setpointValue
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double SetpointValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SetpointValueType > SetpointValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SetpointValueType, char, ::xsd::cxx::tree::schema_type::double_ > SetpointValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SetpointValueOptional&
    getSetpointValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SetpointValueOptional&
    getSetpointValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSetpointValue (const SetpointValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSetpointValue (const SetpointValueOptional& x);

    //@}

    /**
     * @name disturbance
     *
     * @brief Accessor and modifier functions for the %disturbance
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::Disturbance DisturbanceType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DisturbanceType > DisturbanceOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DisturbanceType, char > DisturbanceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DisturbanceOptional&
    getDisturbance () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DisturbanceOptional&
    getDisturbance ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDisturbance (const DisturbanceType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDisturbance (const DisturbanceOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDisturbance (::std::auto_ptr< DisturbanceType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InputPidComplexType (const XType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InputPidComplexType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InputPidComplexType (const InputPidComplexType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InputPidComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InputPidComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    SetpointSeriesOptional setpointSeries_;
    SetpointValueOptional setpointValue_;
    DisturbanceOptional disturbance_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OutputPidComplexType schema type.
   *
   * @nosubgrouping
   */
  class OutputPidComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name y
     *
     * @brief Accessor and modifier functions for the %y
     * required element.
     *
     * setting of the actuator
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType YType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const YType&
    getY () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    YType&
    getY ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setY (const YType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setY (::std::auto_ptr< YType > p);

    //@}

    /**
     * @name integralPart
     *
     * @brief Accessor and modifier functions for the %integralPart
     * required element.
     *
     * memory of integral part: integral(e)dt
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType IntegralPartType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IntegralPartType, char > IntegralPartTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const IntegralPartType&
    getIntegralPart () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    IntegralPartType&
    getIntegralPart ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIntegralPart (const IntegralPartType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setIntegralPart (::std::auto_ptr< IntegralPartType > p);

    //@}

    /**
     * @name differentialPart
     *
     * @brief Accessor and modifier functions for the %differentialPart
     * required element.
     *
     * memory of differential part (in fact e of the last time step)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType DifferentialPartType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DifferentialPartType, char > DifferentialPartTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DifferentialPartType&
    getDifferentialPart () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DifferentialPartType&
    getDifferentialPart ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDifferentialPart (const DifferentialPartType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDifferentialPart (::std::auto_ptr< DifferentialPartType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OutputPidComplexType (const YType&,
                          const IntegralPartType&,
                          const DifferentialPartType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OutputPidComplexType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OutputPidComplexType (const OutputPidComplexType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OutputPidComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OutputPidComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< YType > y_;
    ::xsd::cxx::tree::one< IntegralPartType > integralPart_;
    ::xsd::cxx::tree::one< DifferentialPartType > differentialPart_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TriggerControllerComplexType schema type.
   *
   * @nosubgrouping
   */
  class TriggerControllerComplexType: public ::xml_schema::Type
  {
    public:
    /**
     * @name input
     *
     * @brief Accessor and modifier functions for the %input
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::fews::TimeSeriesSimpleType InputType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InputType&
    getInput () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InputType&
    getInput ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInput (const InputType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInput (::std::auto_ptr< InputType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Integer ValueType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TriggerControllerComplexType (const InputType&,
                                  const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TriggerControllerComplexType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggerControllerComplexType (const TriggerControllerComplexType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TriggerControllerComplexType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TriggerControllerComplexType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InputType > input_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LayerIDSimpleType schema type.
   *
   * @nosubgrouping
   */
  class LayerIDSimpleType: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    LayerIDSimpleType ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    LayerIDSimpleType (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    LayerIDSimpleType (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LayerIDSimpleType (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LayerIDSimpleType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LayerIDSimpleType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LayerIDSimpleType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LayerIDSimpleType (const LayerIDSimpleType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LayerIDSimpleType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LayerIDSimpleType ();
  };

  /**
   * @brief Class corresponding to the %NeuronIDSimpleType schema type.
   *
   * @nosubgrouping
   */
  class NeuronIDSimpleType: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    NeuronIDSimpleType ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    NeuronIDSimpleType (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    NeuronIDSimpleType (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeuronIDSimpleType (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuronIDSimpleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuronIDSimpleType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeuronIDSimpleType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeuronIDSimpleType (const NeuronIDSimpleType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeuronIDSimpleType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeuronIDSimpleType ();
  };

  /**
   * @brief Enumeration class corresponding to the %UnitTypeEnumStringType
   * schema type.
   */
  class UnitTypeEnumStringType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      SI,
      Imperial
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    UnitTypeEnumStringType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    UnitTypeEnumStringType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    UnitTypeEnumStringType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    UnitTypeEnumStringType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitTypeEnumStringType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitTypeEnumStringType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UnitTypeEnumStringType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UnitTypeEnumStringType (const UnitTypeEnumStringType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UnitTypeEnumStringType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    UnitTypeEnumStringType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_UnitTypeEnumStringType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_UnitTypeEnumStringType_convert () const;

    public:
    static const char* const _xsd_UnitTypeEnumStringType_literals_[2];
    static const Value _xsd_UnitTypeEnumStringType_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %row schema type.
   *
   * @nosubgrouping
   */
  class Row: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Row (const IdType&,
         const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Row (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Row (const Row& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Row*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Row ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %y schema type.
   *
   * @nosubgrouping
   */
  class Y: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::auto_ptr< IdType > p);

    //@}

    /**
     * @name selectingColumnId
     *
     * @brief Accessor and modifier functions for the %selectingColumnId
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String SelectingColumnIdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SelectingColumnIdType > SelectingColumnIdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SelectingColumnIdType, char > SelectingColumnIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SelectingColumnIdOptional&
    getSelectingColumnId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SelectingColumnIdOptional&
    getSelectingColumnId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSelectingColumnId (const SelectingColumnIdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSelectingColumnId (const SelectingColumnIdOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSelectingColumnId (::std::auto_ptr< SelectingColumnIdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Y (const IdType&);

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Y (const char*,
       const IdType&);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Y (const ::std::string&,
       const IdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Y (const ::xml_schema::String&,
       const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Y (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f = 0,
       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Y (const Y& x,
       ::xml_schema::Flags f = 0,
       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Y*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Y ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    SelectingColumnIdOptional selectingColumnId_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %monthOfYear
   * schema type.
   */
  class MonthOfYear: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      January,
      February,
      March,
      April,
      May,
      June,
      July,
      August,
      September,
      October,
      November,
      December
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MonthOfYear (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MonthOfYear (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MonthOfYear (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MonthOfYear (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonthOfYear (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonthOfYear (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonthOfYear (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonthOfYear (const MonthOfYear& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MonthOfYear*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MonthOfYear&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MonthOfYear_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MonthOfYear_convert () const;

    public:
    static const char* const _xsd_MonthOfYear_literals_[12];
    static const Value _xsd_MonthOfYear_indexes_[12];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %QSPercentage schema type.
   *
   * @nosubgrouping
   */
  class QSPercentage: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name useAbsoluteAsSpillCap
     *
     * @brief Accessor and modifier functions for the %useAbsoluteAsSpillCap
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean UseAbsoluteAsSpillCapType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UseAbsoluteAsSpillCapType > UseAbsoluteAsSpillCapOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UseAbsoluteAsSpillCapType, char > UseAbsoluteAsSpillCapTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UseAbsoluteAsSpillCapOptional&
    getUseAbsoluteAsSpillCap () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    UseAbsoluteAsSpillCapOptional&
    getUseAbsoluteAsSpillCap ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    QSPercentage ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    QSPercentage (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    QSPercentage (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    QSPercentage (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    QSPercentage (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    QSPercentage (const QSPercentage& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual QSPercentage*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~QSPercentage ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UseAbsoluteAsSpillCapOptional useAbsoluteAsSpillCap_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %QSPercentageValue schema type.
   *
   * @nosubgrouping
   */
  class QSPercentageValue: public ::fews::ExternalParameterSimpleType
  {
    public:
    /**
     * @name useAbsoluteAsSpillCap
     *
     * @brief Accessor and modifier functions for the %useAbsoluteAsSpillCap
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean UseAbsoluteAsSpillCapType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UseAbsoluteAsSpillCapType > UseAbsoluteAsSpillCapOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UseAbsoluteAsSpillCapType, char > UseAbsoluteAsSpillCapTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UseAbsoluteAsSpillCapOptional&
    getUseAbsoluteAsSpillCap () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    UseAbsoluteAsSpillCapOptional&
    getUseAbsoluteAsSpillCap ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setUseAbsoluteAsSpillCap (const UseAbsoluteAsSpillCapOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    QSPercentageValue (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    QSPercentageValue (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    QSPercentageValue (const ::fews::ExternalParameterSimpleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    QSPercentageValue (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    QSPercentageValue (const QSPercentageValue& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual QSPercentageValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~QSPercentageValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UseAbsoluteAsSpillCapOptional useAbsoluteAsSpillCap_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %external schema type.
   *
   * @nosubgrouping
   */
  class External: public ::xml_schema::String
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightType, char > WeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const WeightType&
    getWeight () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    WeightType&
    getWeight ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setWeight (const WeightType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWeight (::std::auto_ptr< WeightType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    External (const WeightType&);

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    External (const char*,
              const WeightType&);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    External (const ::std::string&,
              const WeightType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    External (const ::xml_schema::String&,
              const WeightType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    External (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    External (const External& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual External*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~External ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< WeightType > weight_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %internal schema type.
   *
   * @nosubgrouping
   */
  class Internal: public ::xml_schema::String
  {
    public:
    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::ExternalParameterSimpleType WeightType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightType, char > WeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const WeightType&
    getWeight () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    WeightType&
    getWeight ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setWeight (const WeightType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setWeight (::std::auto_ptr< WeightType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Internal (const WeightType&);

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Internal (const char*,
              const WeightType&);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Internal (const ::std::string&,
              const WeightType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Internal (const ::xml_schema::String&,
              const WeightType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Internal (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Internal (const Internal& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Internal*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Internal ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< WeightType > weight_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %multiplier schema type.
   *
   * @nosubgrouping
   */
  class Multiplier: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Multiplier (const ::xml_schema::Integer&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Multiplier (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Multiplier (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Multiplier (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Multiplier (const Multiplier& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Multiplier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Multiplier ();
  };

  /**
   * @brief Enumeration class corresponding to the %property
   * schema type.
   */
  class Property: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      MONOTON,
      POSITIVE
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Property (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Property (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Property (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Property (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Property (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Property (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Property (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Property (const Property& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Property*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Property&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Property_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Property_convert () const;

    public:
    static const char* const _xsd_Property_literals_[2];
    static const Value _xsd_Property_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x schema type.
   *
   * @nosubgrouping
   */
  class X: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f = 0,
       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X (const X& x,
       ::xml_schema::Flags f = 0,
       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x1 schema type.
   *
   * @nosubgrouping
   */
  class X1: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X1 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X1 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X1 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X1 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X1 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X1 (const X1& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x11 schema type.
   *
   * @nosubgrouping
   */
  class X11: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X11 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X11 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X11 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X11 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X11 (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X11 (const X11& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X11*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X11 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x2 schema type.
   *
   * @nosubgrouping
   */
  class X2: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X2 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X2 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X2 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X2 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X2 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X2 (const X2& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X2 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x12 schema type.
   *
   * @nosubgrouping
   */
  class X12: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X12 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X12 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X12 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X12 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X12 (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X12 (const X12& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X12*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X12 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x21 schema type.
   *
   * @nosubgrouping
   */
  class X21: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X21 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X21 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X21 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X21 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X21 (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X21 (const X21& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X21*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X21 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x3 schema type.
   *
   * @nosubgrouping
   */
  class X3: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X3 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X3 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X3 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X3 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X3 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X3 (const X3& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X3*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X3 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x4 schema type.
   *
   * @nosubgrouping
   */
  class X4: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X4 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X4 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X4 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X4 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X4 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X4 (const X4& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X4*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X4 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x5 schema type.
   *
   * @nosubgrouping
   */
  class X5: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name factor
     *
     * @brief Accessor and modifier functions for the %factor
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorType, char, ::xsd::cxx::tree::schema_type::double_ > FactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FactorType&
    getFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FactorType&
    getFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFactor (const FactorType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static FactorType
    getFactorDefaultValue ();

    //@}

    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X5 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X5 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X5 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X5 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X5 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X5 (const X5& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X5*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X5 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FactorType > factor_;
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %xVector schema type.
   *
   * @nosubgrouping
   */
  class XVector: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name nStepSeriesStart
     *
     * @brief Accessor and modifier functions for the %nStepSeriesStart
     * optional attribute.
     *
     * optional external time series providing the start index in the array
     * with input data, default is 0, i.e. the first element
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::TimeSeriesSimpleType NStepSeriesStartType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepSeriesStartType > NStepSeriesStartOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepSeriesStartType, char > NStepSeriesStartTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepSeriesStartOptional&
    getNStepSeriesStart () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NStepSeriesStartOptional&
    getNStepSeriesStart ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setNStepSeriesStart (const NStepSeriesStartType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setNStepSeriesStart (const NStepSeriesStartOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepSeriesStart (::std::auto_ptr< NStepSeriesStartType > p);

    //@}

    /**
     * @name nStepSeries
     *
     * @brief Accessor and modifier functions for the %nStepSeries
     * optional attribute.
     *
     * optional external time series providing the end index in the array
     * with input data, default is nSeries-1, i.e. the last element
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::TimeSeriesSimpleType NStepSeriesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NStepSeriesType > NStepSeriesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NStepSeriesType, char > NStepSeriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NStepSeriesOptional&
    getNStepSeries () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NStepSeriesOptional&
    getNStepSeries ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setNStepSeries (const NStepSeriesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setNStepSeries (const NStepSeriesOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNStepSeries (::std::auto_ptr< NStepSeriesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    XVector ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    XVector (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    XVector (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    XVector (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    XVector (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    XVector (const XVector& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual XVector*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~XVector ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;
    NStepSeriesStartOptional nStepSeriesStart_;
    NStepSeriesOptional nStepSeries_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %y1 schema type.
   *
   * @nosubgrouping
   */
  class Y1: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name factor
     *
     * @brief Accessor and modifier functions for the %factor
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorType, char, ::xsd::cxx::tree::schema_type::double_ > FactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FactorType&
    getFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FactorType&
    getFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFactor (const FactorType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static FactorType
    getFactorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Y1 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Y1 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Y1 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Y1 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Y1 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Y1 (const Y1& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Y1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Y1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FactorType > factor_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %mode
   * schema type.
   */
  class Mode: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      NATIVE,
      RETAINVALUEWHENINACTIVE
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Mode (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Mode (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Mode (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Mode (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mode (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mode (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mode (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mode (const Mode& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Mode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Mode&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Mode_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Mode_convert () const;

    public:
    static const char* const _xsd_Mode_literals_[2];
    static const Value _xsd_Mode_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x1Series schema type.
   *
   * @nosubgrouping
   */
  class X1Series: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X1Series ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X1Series (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X1Series (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X1Series (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X1Series (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X1Series (const X1Series& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X1Series*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X1Series ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x1SeriesVector schema type.
   *
   * @nosubgrouping
   */
  class X1SeriesVector: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X1SeriesVector ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X1SeriesVector (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X1SeriesVector (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X1SeriesVector (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X1SeriesVector (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X1SeriesVector (const X1SeriesVector& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X1SeriesVector*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X1SeriesVector ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x2Series schema type.
   *
   * @nosubgrouping
   */
  class X2Series: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X2Series ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X2Series (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X2Series (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X2Series (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X2Series (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X2Series (const X2Series& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X2Series*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X2Series ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x2SeriesVector schema type.
   *
   * @nosubgrouping
   */
  class X2SeriesVector: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X2SeriesVector ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X2SeriesVector (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X2SeriesVector (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X2SeriesVector (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X2SeriesVector (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X2SeriesVector (const X2SeriesVector& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X2SeriesVector*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X2SeriesVector ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x6 schema type.
   *
   * @nosubgrouping
   */
  class X6: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X6 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X6 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X6 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X6 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X6 (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X6 (const X6& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X6*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X6 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %thresholdSeries schema type.
   *
   * @nosubgrouping
   */
  class ThresholdSeries: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    ThresholdSeries ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    ThresholdSeries (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    ThresholdSeries (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ThresholdSeries (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ThresholdSeries (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ThresholdSeries (const ThresholdSeries& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ThresholdSeries*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ThresholdSeries ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x1Series1 schema type.
   *
   * @nosubgrouping
   */
  class X1Series1: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X1Series1 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X1Series1 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X1Series1 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X1Series1 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X1Series1 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X1Series1 (const X1Series1& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X1Series1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X1Series1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x2Series1 schema type.
   *
   * @nosubgrouping
   */
  class X2Series1: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X2Series1 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X2Series1 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X2Series1 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X2Series1 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X2Series1 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X2Series1 (const X2Series1& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X2Series1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X2Series1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x1Series2 schema type.
   *
   * @nosubgrouping
   */
  class X1Series2: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X1Series2 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X1Series2 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X1Series2 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X1Series2 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X1Series2 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X1Series2 (const X1Series2& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X1Series2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X1Series2 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %x2Series2 schema type.
   *
   * @nosubgrouping
   */
  class X2Series2: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name ref
     *
     * @brief Accessor and modifier functions for the %ref
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::fews::InputReferenceEnumStringType RefType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RefType&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RefType&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRef (::std::auto_ptr< RefType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const RefType&
    getRefDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    X2Series2 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    X2Series2 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    X2Series2 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    X2Series2 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    X2Series2 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    X2Series2 (const X2Series2& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual X2Series2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~X2Series2 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RefType > ref_;
    static const RefType ref_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %QBC schema type.
   *
   * @nosubgrouping
   */
  class QBC: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name factor
     *
     * @brief Accessor and modifier functions for the %factor
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorType, char, ::xsd::cxx::tree::schema_type::double_ > FactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FactorType&
    getFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FactorType&
    getFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFactor (const FactorType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static FactorType
    getFactorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    QBC ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    QBC (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    QBC (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    QBC (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    QBC (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    QBC (const QBC& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual QBC*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~QBC ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FactorType > factor_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %flowDirectionEnumStringType_member
   * schema type.
   */
  class FlowDirectionEnumStringType_member: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      POSITIVE,
      NEGATIVE,
      BOTH
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    FlowDirectionEnumStringType_member (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    FlowDirectionEnumStringType_member (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    FlowDirectionEnumStringType_member (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    FlowDirectionEnumStringType_member (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType_member (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType_member (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType_member (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FlowDirectionEnumStringType_member (const FlowDirectionEnumStringType_member& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FlowDirectionEnumStringType_member*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    FlowDirectionEnumStringType_member&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_FlowDirectionEnumStringType_member_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_FlowDirectionEnumStringType_member_convert () const;

    public:
    static const char* const _xsd_FlowDirectionEnumStringType_member_literals_[3];
    static const Value _xsd_FlowDirectionEnumStringType_member_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %flowDirectionEnumStringType_member1 schema type.
   *
   * @nosubgrouping
   */
  class FlowDirectionEnumStringType_member1: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    FlowDirectionEnumStringType_member1 ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    FlowDirectionEnumStringType_member1 (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    FlowDirectionEnumStringType_member1 (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    FlowDirectionEnumStringType_member1 (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType_member1 (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType_member1 (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    FlowDirectionEnumStringType_member1 (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    FlowDirectionEnumStringType_member1 (const FlowDirectionEnumStringType_member1& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual FlowDirectionEnumStringType_member1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~FlowDirectionEnumStringType_member1 ();
  };

  /**
   * @brief Enumeration class corresponding to the %mode1
   * schema type.
   */
  class Mode1: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      NATIVE,
      SOBEK2,
      PIDPOS,
      PIDVEL
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Mode1 (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Mode1 (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Mode1 (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Mode1 (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mode1 (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mode1 (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mode1 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mode1 (const Mode1& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Mode1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Mode1&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Mode1_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Mode1_convert () const;

    public:
    static const char* const _xsd_Mode1_literals_[4];
    static const Value _xsd_Mode1_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %disturbance schema type.
   *
   * @nosubgrouping
   */
  class Disturbance: public ::fews::TimeSeriesSimpleType
  {
    public:
    /**
     * @name factor
     *
     * @brief Accessor and modifier functions for the %factor
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FactorType, char, ::xsd::cxx::tree::schema_type::double_ > FactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FactorType&
    getFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FactorType&
    getFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFactor (const FactorType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static FactorType
    getFactorDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Disturbance ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Disturbance (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Disturbance (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Disturbance (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Disturbance (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Disturbance (const Disturbance& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Disturbance*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Disturbance ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FactorType > factor_;

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace fews
{
  /**
   * @name Parsing functions for the %rtcToolsConfig document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::std::string& uri,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::std::string& uri,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::std::string& uri,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       const ::std::string& id,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       const ::std::string& id,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::std::istream& is,
                       const ::std::string& id,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xercesc::InputSource& is,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xercesc::InputSource& is,
                       ::xml_schema::ErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xercesc::InputSource& is,
                       ::xercesc::DOMErrorHandler& eh,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (const ::xercesc::DOMDocument& d,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::auto_ptr< ::fews::RtcToolsConfigComplexType >
  parseRtcToolsConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::Flags f = 0,
                       const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace fews
{
  /**
   * @name Serialization functions for the %rtcToolsConfig document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeRtcToolsConfig (::std::ostream& os,
                           const ::fews::RtcToolsConfigComplexType& x, 
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcToolsConfig (::std::ostream& os,
                           const ::fews::RtcToolsConfigComplexType& x, 
                           ::xml_schema::ErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcToolsConfig (::std::ostream& os,
                           const ::fews::RtcToolsConfigComplexType& x, 
                           ::xercesc::DOMErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeRtcToolsConfig (::xercesc::XMLFormatTarget& ft,
                           const ::fews::RtcToolsConfigComplexType& x, 
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcToolsConfig (::xercesc::XMLFormatTarget& ft,
                           const ::fews::RtcToolsConfigComplexType& x, 
                           ::xml_schema::ErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeRtcToolsConfig (::xercesc::XMLFormatTarget& ft,
                           const ::fews::RtcToolsConfigComplexType& x, 
                           ::xercesc::DOMErrorHandler& eh,
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           const ::std::string& e = "UTF-8",
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  serializeRtcToolsConfig (::xercesc::DOMDocument& d,
                           const ::fews::RtcToolsConfigComplexType& x,
                           ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeRtcToolsConfig (const ::fews::RtcToolsConfigComplexType& x, 
                           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                           ::xml_schema::Flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const RtcToolsConfigComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GeneralModuleConfigComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AllocationTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ATableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputATableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputATableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HydrologicalModelComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SubmodelComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReleaseTotalComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterReleaseTotalComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputReleaseTotalComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EvaporationPotentialComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterEvaporationPotentialComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputEvaporationPotentialComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputEvaporationPotentialComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TypicalProfileComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DataTypicalProfileComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SnowRainJunctionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterSnowRainJunctionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputSnowRainJunctionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputSnowRainJunctionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const StorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const StorageSystemSettingsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NodeStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputNodeStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LinkStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputLinkStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MeltRefreezingStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterMeltRefreezingStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReleaseWaterContentStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterReleaseWaterContentStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EvaporationInterceptionStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputEvaporationInterceptionStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterEvaporationInterceptionStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReleaseAboveThresholdStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterReleaseAboveThresholdStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputReleaseAboveThresholdStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IrrigationStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterIrrigationStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const WaterDistributionConstantStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterWaterDistributionConstantStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputWaterDistributionConstantStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const WaterDistributionVariableStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterWaterDistributionVariableStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputWaterDistributionVariableStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GroundwaterFlowStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputGroundwaterFlowStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParametergroundwaterFlowStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EvaporationActualStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputEvaporationActualStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterEvaporationActualStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SoilRunoffStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputSoilRunoffStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterSoilRunoffStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const CapillaryFlowStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputCapillaryFlowStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterCapillaryFlowStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ResponseStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterResponseStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputResponseStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PercolationStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterPercolationStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputPercolationStorageSystemComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ArmaComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ArmaInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ArmaOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AccumulationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AccumulationInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AccumulationOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GradientComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GradientInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GradientOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversParameterSoilComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversParameterResponseComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversStateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversStateUpdateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LorentGeversOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVParameterInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVParameterSnowComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVParameterInterceptionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVParameterSoilComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVParameterResponseComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVLinkComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVStateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVStateUpdateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HBVOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SRMComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SRMParameterComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SRMParameterZoneComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SRMInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SRMStateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SRMOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitDelayComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitDelayInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitDelayOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitHydrographComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitHydrographWeightComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitHydrographWeightTriangularComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitHydrographWeightCustomComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitHydrographInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitHydrographOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirCompactComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LevelStorageEquationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TailwaterEquationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TailwaterTidalEquationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineEfficiencyTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ColumnsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RowComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MaxFlowsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirCompactInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirCompactOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RoutingComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NeuralNetworkComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LayerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NeuronComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NeuronInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NeuronOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HydraulicModelComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HydraulicModelSequentialImplicitComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HydraulicModelSimultaneousComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HydraulicModelOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConnectionInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConnectionOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RoutingOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirRoutingComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SimpleReservoirComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConnectionCoefficientsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RulesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ThunerseeRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirThunerseeRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const WeirThunerseeRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TunnelThunerseeRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ThunerseeRuleInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ThunerseeRuleOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AebiRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AebiRuleInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const AebiRuleOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LookupTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TableLookupTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const Lookup2DTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const Table2DLookupTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const XDimComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const YDimComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ValueArrayComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IntervalComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IntervalInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const IntervalOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateLookupTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InterpolationOptionsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateRecord2ComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateRecord2DataComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateLookupTableInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateLookupTableOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LookupTableInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LookupTableOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const Lookup2DTableInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const Lookup2DTableOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PolygonLookupComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PolygonsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PolygonComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EdgesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EdgeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PolygonLookupInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PolygonLookupOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SpreadsheetComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ValidPeriodsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ValidPeriodComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SpreadsheetTablesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SpreadsheetTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SpreadsheetRecordComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SpreadsheetInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SpreadsheetOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerSplitterComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerSplitterInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerSplitterOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeAbsoluteComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeAbsoluteInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeAbsoluteOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeRelativeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeRelativeControlTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeRelativeControlTableRecordComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeRelativeInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeRelativeOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ExpressionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandValueComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandValueInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandTimeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandTimeDiscreteComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandTimeInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandTimeOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LimiterComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LimiterInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TriggersComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TriggerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EifelRurRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GuideBandRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GuideBandRuleInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const GuideBandRuleOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConstantRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConstantRuleOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const MinSimpleRuleComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const StorageCharacteristicsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const CapacityCharacteristicsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineCharacteristicsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineOutputCharacteristicsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ElevationTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TailwaterComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TailwaterOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ElevationRecordComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ControlledOutletComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UncontrolledOutletComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const UOutletInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EquationsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const EquationComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ZonesComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ZoneComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateTableComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DateRecordComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ReservoirGradientComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NodeGradientComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutletInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutletOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const DeadBandTriggerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TriggerInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TriggerOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const StandardTriggerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RelationalConditionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const SetTriggerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RuleTriggerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ResultComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const ConditionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RuleStateTriggerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InflowComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NodeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NodeInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const NodeOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BranchComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const CrossSectionComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const CrossSectionRoughnessComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BranchInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BranchOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const HydraulicStructureComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PumpComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PumpInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PumpOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PumpGradientComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineCapacityCharacteristicsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineEfficiencyCharacteristicsComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TurbineOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OrificeComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OrificeInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OrificeOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const BranchGradientComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RiverWeirComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RiverWeirInputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const RiverWeirOutputComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const PoolRoutingEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const PoolRoutingEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const PoolRoutingEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const InterpolationOptionEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const InterpolationOptionEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const InterpolationOptionEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const LimiterOptionEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const LimiterOptionEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const LimiterOptionEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const TimeRelativeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeRelativeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeRelativeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const CaseLangetenEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const CaseLangetenEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const CaseLangetenEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const FlowDirectionEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const FlowDirectionEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const FlowDirectionEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const LogicalOperatorEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const LogicalOperatorEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const LogicalOperatorEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const RelationalOperatorEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const RelationalOperatorEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const RelationalOperatorEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const MathematicalOperatorEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const MathematicalOperatorEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const MathematicalOperatorEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const SpatialEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const SpatialEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const SpatialEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const CapacityReferenceEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const CapacityReferenceEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const CapacityReferenceEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const InputReferenceEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const InputReferenceEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const InputReferenceEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const BranchTypeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const BranchTypeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const BranchTypeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const EquationEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const EquationEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const EquationEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const MergerSplitterEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const MergerSplitterEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const MergerSplitterEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const HydraulicModelModeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const HydraulicModelModeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const HydraulicModelModeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const TransferFunctionEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const TransferFunctionEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const TransferFunctionEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const PidComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const InputPidComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const OutputPidComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const TriggerControllerComplexType&);

  void
  operator<< (::xercesc::DOMElement&, const LayerIDSimpleType&);

  void
  operator<< (::xercesc::DOMAttr&, const LayerIDSimpleType&);

  void
  operator<< (::xml_schema::ListStream&,
              const LayerIDSimpleType&);

  void
  operator<< (::xercesc::DOMElement&, const NeuronIDSimpleType&);

  void
  operator<< (::xercesc::DOMAttr&, const NeuronIDSimpleType&);

  void
  operator<< (::xml_schema::ListStream&,
              const NeuronIDSimpleType&);

  void
  operator<< (::xercesc::DOMElement&, const UnitTypeEnumStringType&);

  void
  operator<< (::xercesc::DOMAttr&, const UnitTypeEnumStringType&);

  void
  operator<< (::xml_schema::ListStream&,
              const UnitTypeEnumStringType&);

  void
  operator<< (::xercesc::DOMElement&, const Row&);

  void
  operator<< (::xercesc::DOMElement&, const Y&);

  void
  operator<< (::xercesc::DOMElement&, const MonthOfYear&);

  void
  operator<< (::xercesc::DOMAttr&, const MonthOfYear&);

  void
  operator<< (::xml_schema::ListStream&,
              const MonthOfYear&);

  void
  operator<< (::xercesc::DOMElement&, const QSPercentage&);

  void
  operator<< (::xercesc::DOMElement&, const QSPercentageValue&);

  void
  operator<< (::xercesc::DOMElement&, const External&);

  void
  operator<< (::xercesc::DOMElement&, const Internal&);

  void
  operator<< (::xercesc::DOMElement&, const Multiplier&);

  void
  operator<< (::xercesc::DOMAttr&, const Multiplier&);

  void
  operator<< (::xml_schema::ListStream&,
              const Multiplier&);

  void
  operator<< (::xercesc::DOMElement&, const Property&);

  void
  operator<< (::xercesc::DOMAttr&, const Property&);

  void
  operator<< (::xml_schema::ListStream&,
              const Property&);

  void
  operator<< (::xercesc::DOMElement&, const X&);

  void
  operator<< (::xercesc::DOMElement&, const X1&);

  void
  operator<< (::xercesc::DOMElement&, const X11&);

  void
  operator<< (::xercesc::DOMElement&, const X2&);

  void
  operator<< (::xercesc::DOMElement&, const X12&);

  void
  operator<< (::xercesc::DOMElement&, const X21&);

  void
  operator<< (::xercesc::DOMElement&, const X3&);

  void
  operator<< (::xercesc::DOMElement&, const X4&);

  void
  operator<< (::xercesc::DOMElement&, const X5&);

  void
  operator<< (::xercesc::DOMElement&, const XVector&);

  void
  operator<< (::xercesc::DOMElement&, const Y1&);

  void
  operator<< (::xercesc::DOMElement&, const Mode&);

  void
  operator<< (::xercesc::DOMAttr&, const Mode&);

  void
  operator<< (::xml_schema::ListStream&,
              const Mode&);

  void
  operator<< (::xercesc::DOMElement&, const X1Series&);

  void
  operator<< (::xercesc::DOMElement&, const X1SeriesVector&);

  void
  operator<< (::xercesc::DOMElement&, const X2Series&);

  void
  operator<< (::xercesc::DOMElement&, const X2SeriesVector&);

  void
  operator<< (::xercesc::DOMElement&, const X6&);

  void
  operator<< (::xercesc::DOMElement&, const ThresholdSeries&);

  void
  operator<< (::xercesc::DOMElement&, const X1Series1&);

  void
  operator<< (::xercesc::DOMElement&, const X2Series1&);

  void
  operator<< (::xercesc::DOMElement&, const X1Series2&);

  void
  operator<< (::xercesc::DOMElement&, const X2Series2&);

  void
  operator<< (::xercesc::DOMElement&, const QBC&);

  void
  operator<< (::xercesc::DOMElement&, const FlowDirectionEnumStringType_member&);

  void
  operator<< (::xercesc::DOMAttr&, const FlowDirectionEnumStringType_member&);

  void
  operator<< (::xml_schema::ListStream&,
              const FlowDirectionEnumStringType_member&);

  void
  operator<< (::xercesc::DOMElement&, const FlowDirectionEnumStringType_member1&);

  void
  operator<< (::xercesc::DOMAttr&, const FlowDirectionEnumStringType_member1&);

  void
  operator<< (::xml_schema::ListStream&,
              const FlowDirectionEnumStringType_member1&);

  void
  operator<< (::xercesc::DOMElement&, const Mode1&);

  void
  operator<< (::xercesc::DOMAttr&, const Mode1&);

  void
  operator<< (::xml_schema::ListStream&,
              const Mode1&);

  void
  operator<< (::xercesc::DOMElement&, const Disturbance&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // RTC_TOOLS_CONFIG_HXX
