// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rtcDataConfig.hxx"

namespace fews
{
  // RTCDataConfigComplexType
  // 

  const RTCDataConfigComplexType::ImportSeriesType& RTCDataConfigComplexType::
  getImportSeries () const
  {
    return this->importSeries_.get ();
  }

  RTCDataConfigComplexType::ImportSeriesType& RTCDataConfigComplexType::
  getImportSeries ()
  {
    return this->importSeries_.get ();
  }

  void RTCDataConfigComplexType::
  setImportSeries (const ImportSeriesType& x)
  {
    this->importSeries_.set (x);
  }

  void RTCDataConfigComplexType::
  setImportSeries (::std::auto_ptr< ImportSeriesType > x)
  {
    this->importSeries_.set (x);
  }

  const RTCDataConfigComplexType::ExportSeriesType& RTCDataConfigComplexType::
  getExportSeries () const
  {
    return this->exportSeries_.get ();
  }

  RTCDataConfigComplexType::ExportSeriesType& RTCDataConfigComplexType::
  getExportSeries ()
  {
    return this->exportSeries_.get ();
  }

  void RTCDataConfigComplexType::
  setExportSeries (const ExportSeriesType& x)
  {
    this->exportSeries_.set (x);
  }

  void RTCDataConfigComplexType::
  setExportSeries (::std::auto_ptr< ExportSeriesType > x)
  {
    this->exportSeries_.set (x);
  }


  // RTCSeriesImportComplexType
  // 

  const RTCSeriesImportComplexType::PITimeSeriesFileOptional& RTCSeriesImportComplexType::
  getPITimeSeriesFile () const
  {
    return this->PITimeSeriesFile_;
  }

  RTCSeriesImportComplexType::PITimeSeriesFileOptional& RTCSeriesImportComplexType::
  getPITimeSeriesFile ()
  {
    return this->PITimeSeriesFile_;
  }

  void RTCSeriesImportComplexType::
  setPITimeSeriesFile (const PITimeSeriesFileType& x)
  {
    this->PITimeSeriesFile_.set (x);
  }

  void RTCSeriesImportComplexType::
  setPITimeSeriesFile (const PITimeSeriesFileOptional& x)
  {
    this->PITimeSeriesFile_ = x;
  }

  void RTCSeriesImportComplexType::
  setPITimeSeriesFile (::std::auto_ptr< PITimeSeriesFileType > x)
  {
    this->PITimeSeriesFile_.set (x);
  }

  const RTCSeriesImportComplexType::TimeSeriesSequence& RTCSeriesImportComplexType::
  getTimeSeries () const
  {
    return this->timeSeries_;
  }

  RTCSeriesImportComplexType::TimeSeriesSequence& RTCSeriesImportComplexType::
  getTimeSeries ()
  {
    return this->timeSeries_;
  }

  void RTCSeriesImportComplexType::
  setTimeSeries (const TimeSeriesSequence& s)
  {
    this->timeSeries_ = s;
  }


  // RTCSeriesExportComplexType
  // 

  const RTCSeriesExportComplexType::CSVTimeSeriesFileOptional& RTCSeriesExportComplexType::
  getCSVTimeSeriesFile () const
  {
    return this->CSVTimeSeriesFile_;
  }

  RTCSeriesExportComplexType::CSVTimeSeriesFileOptional& RTCSeriesExportComplexType::
  getCSVTimeSeriesFile ()
  {
    return this->CSVTimeSeriesFile_;
  }

  void RTCSeriesExportComplexType::
  setCSVTimeSeriesFile (const CSVTimeSeriesFileType& x)
  {
    this->CSVTimeSeriesFile_.set (x);
  }

  void RTCSeriesExportComplexType::
  setCSVTimeSeriesFile (const CSVTimeSeriesFileOptional& x)
  {
    this->CSVTimeSeriesFile_ = x;
  }

  void RTCSeriesExportComplexType::
  setCSVTimeSeriesFile (::std::auto_ptr< CSVTimeSeriesFileType > x)
  {
    this->CSVTimeSeriesFile_.set (x);
  }

  const RTCSeriesExportComplexType::PITimeSeriesFileOptional& RTCSeriesExportComplexType::
  getPITimeSeriesFile () const
  {
    return this->PITimeSeriesFile_;
  }

  RTCSeriesExportComplexType::PITimeSeriesFileOptional& RTCSeriesExportComplexType::
  getPITimeSeriesFile ()
  {
    return this->PITimeSeriesFile_;
  }

  void RTCSeriesExportComplexType::
  setPITimeSeriesFile (const PITimeSeriesFileType& x)
  {
    this->PITimeSeriesFile_.set (x);
  }

  void RTCSeriesExportComplexType::
  setPITimeSeriesFile (const PITimeSeriesFileOptional& x)
  {
    this->PITimeSeriesFile_ = x;
  }

  void RTCSeriesExportComplexType::
  setPITimeSeriesFile (::std::auto_ptr< PITimeSeriesFileType > x)
  {
    this->PITimeSeriesFile_.set (x);
  }

  const RTCSeriesExportComplexType::TimeSeriesSequence& RTCSeriesExportComplexType::
  getTimeSeries () const
  {
    return this->timeSeries_;
  }

  RTCSeriesExportComplexType::TimeSeriesSequence& RTCSeriesExportComplexType::
  getTimeSeries ()
  {
    return this->timeSeries_;
  }

  void RTCSeriesExportComplexType::
  setTimeSeries (const TimeSeriesSequence& s)
  {
    this->timeSeries_ = s;
  }


  // RTCTimeSeriesComplexType
  // 

  const RTCTimeSeriesComplexType::PITimeSeriesOptional& RTCTimeSeriesComplexType::
  getPITimeSeries () const
  {
    return this->PITimeSeries_;
  }

  RTCTimeSeriesComplexType::PITimeSeriesOptional& RTCTimeSeriesComplexType::
  getPITimeSeries ()
  {
    return this->PITimeSeries_;
  }

  void RTCTimeSeriesComplexType::
  setPITimeSeries (const PITimeSeriesType& x)
  {
    this->PITimeSeries_.set (x);
  }

  void RTCTimeSeriesComplexType::
  setPITimeSeries (const PITimeSeriesOptional& x)
  {
    this->PITimeSeries_ = x;
  }

  void RTCTimeSeriesComplexType::
  setPITimeSeries (::std::auto_ptr< PITimeSeriesType > x)
  {
    this->PITimeSeries_.set (x);
  }

  const RTCTimeSeriesComplexType::OpenMIExchangeItemOptional& RTCTimeSeriesComplexType::
  getOpenMIExchangeItem () const
  {
    return this->OpenMIExchangeItem_;
  }

  RTCTimeSeriesComplexType::OpenMIExchangeItemOptional& RTCTimeSeriesComplexType::
  getOpenMIExchangeItem ()
  {
    return this->OpenMIExchangeItem_;
  }

  void RTCTimeSeriesComplexType::
  setOpenMIExchangeItem (const OpenMIExchangeItemType& x)
  {
    this->OpenMIExchangeItem_.set (x);
  }

  void RTCTimeSeriesComplexType::
  setOpenMIExchangeItem (const OpenMIExchangeItemOptional& x)
  {
    this->OpenMIExchangeItem_ = x;
  }

  void RTCTimeSeriesComplexType::
  setOpenMIExchangeItem (::std::auto_ptr< OpenMIExchangeItemType > x)
  {
    this->OpenMIExchangeItem_.set (x);
  }

  const RTCTimeSeriesComplexType::IdType& RTCTimeSeriesComplexType::
  getId () const
  {
    return this->id_.get ();
  }

  RTCTimeSeriesComplexType::IdType& RTCTimeSeriesComplexType::
  getId ()
  {
    return this->id_.get ();
  }

  void RTCTimeSeriesComplexType::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void RTCTimeSeriesComplexType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const RTCTimeSeriesComplexType::VectorLengthOptional& RTCTimeSeriesComplexType::
  getVectorLength () const
  {
    return this->vectorLength_;
  }

  RTCTimeSeriesComplexType::VectorLengthOptional& RTCTimeSeriesComplexType::
  getVectorLength ()
  {
    return this->vectorLength_;
  }

  void RTCTimeSeriesComplexType::
  setVectorLength (const VectorLengthType& x)
  {
    this->vectorLength_.set (x);
  }

  void RTCTimeSeriesComplexType::
  setVectorLength (const VectorLengthOptional& x)
  {
    this->vectorLength_ = x;
  }

  void RTCTimeSeriesComplexType::
  setVectorLength (::std::auto_ptr< VectorLengthType > x)
  {
    this->vectorLength_.set (x);
  }

  const RTCTimeSeriesComplexType::ValidationOptional& RTCTimeSeriesComplexType::
  getValidation () const
  {
    return this->validation_;
  }

  RTCTimeSeriesComplexType::ValidationOptional& RTCTimeSeriesComplexType::
  getValidation ()
  {
    return this->validation_;
  }

  void RTCTimeSeriesComplexType::
  setValidation (const ValidationType& x)
  {
    this->validation_.set (x);
  }

  void RTCTimeSeriesComplexType::
  setValidation (const ValidationOptional& x)
  {
    this->validation_ = x;
  }

  void RTCTimeSeriesComplexType::
  setValidation (::std::auto_ptr< ValidationType > x)
  {
    this->validation_.set (x);
  }


  // PITimeSeriesComplexType
  // 

  const PITimeSeriesComplexType::LocationIdType& PITimeSeriesComplexType::
  getLocationId () const
  {
    return this->locationId_.get ();
  }

  PITimeSeriesComplexType::LocationIdType& PITimeSeriesComplexType::
  getLocationId ()
  {
    return this->locationId_.get ();
  }

  void PITimeSeriesComplexType::
  setLocationId (const LocationIdType& x)
  {
    this->locationId_.set (x);
  }

  void PITimeSeriesComplexType::
  setLocationId (::std::auto_ptr< LocationIdType > x)
  {
    this->locationId_.set (x);
  }

  const PITimeSeriesComplexType::ParameterIdType& PITimeSeriesComplexType::
  getParameterId () const
  {
    return this->parameterId_.get ();
  }

  PITimeSeriesComplexType::ParameterIdType& PITimeSeriesComplexType::
  getParameterId ()
  {
    return this->parameterId_.get ();
  }

  void PITimeSeriesComplexType::
  setParameterId (const ParameterIdType& x)
  {
    this->parameterId_.set (x);
  }

  void PITimeSeriesComplexType::
  setParameterId (::std::auto_ptr< ParameterIdType > x)
  {
    this->parameterId_.set (x);
  }

  const PITimeSeriesComplexType::QualifierIdSequence& PITimeSeriesComplexType::
  getQualifierId () const
  {
    return this->qualifierId_;
  }

  PITimeSeriesComplexType::QualifierIdSequence& PITimeSeriesComplexType::
  getQualifierId ()
  {
    return this->qualifierId_;
  }

  void PITimeSeriesComplexType::
  setQualifierId (const QualifierIdSequence& s)
  {
    this->qualifierId_ = s;
  }

  const PITimeSeriesComplexType::TimeStepOptional& PITimeSeriesComplexType::
  getTimeStep () const
  {
    return this->timeStep_;
  }

  PITimeSeriesComplexType::TimeStepOptional& PITimeSeriesComplexType::
  getTimeStep ()
  {
    return this->timeStep_;
  }

  void PITimeSeriesComplexType::
  setTimeStep (const TimeStepType& x)
  {
    this->timeStep_.set (x);
  }

  void PITimeSeriesComplexType::
  setTimeStep (const TimeStepOptional& x)
  {
    this->timeStep_ = x;
  }

  void PITimeSeriesComplexType::
  setTimeStep (::std::auto_ptr< TimeStepType > x)
  {
    this->timeStep_.set (x);
  }

  const PITimeSeriesComplexType::UnitOptional& PITimeSeriesComplexType::
  getUnit () const
  {
    return this->unit_;
  }

  PITimeSeriesComplexType::UnitOptional& PITimeSeriesComplexType::
  getUnit ()
  {
    return this->unit_;
  }

  void PITimeSeriesComplexType::
  setUnit (const UnitType& x)
  {
    this->unit_.set (x);
  }

  void PITimeSeriesComplexType::
  setUnit (const UnitOptional& x)
  {
    this->unit_ = x;
  }

  void PITimeSeriesComplexType::
  setUnit (::std::auto_ptr< UnitType > x)
  {
    this->unit_.set (x);
  }

  const PITimeSeriesComplexType::InterpolationOptionOptional& PITimeSeriesComplexType::
  getInterpolationOption () const
  {
    return this->interpolationOption_;
  }

  PITimeSeriesComplexType::InterpolationOptionOptional& PITimeSeriesComplexType::
  getInterpolationOption ()
  {
    return this->interpolationOption_;
  }

  void PITimeSeriesComplexType::
  setInterpolationOption (const InterpolationOptionType& x)
  {
    this->interpolationOption_.set (x);
  }

  void PITimeSeriesComplexType::
  setInterpolationOption (const InterpolationOptionOptional& x)
  {
    this->interpolationOption_ = x;
  }

  void PITimeSeriesComplexType::
  setInterpolationOption (::std::auto_ptr< InterpolationOptionType > x)
  {
    this->interpolationOption_.set (x);
  }

  const PITimeSeriesComplexType::ExtrapolationOptionOptional& PITimeSeriesComplexType::
  getExtrapolationOption () const
  {
    return this->extrapolationOption_;
  }

  PITimeSeriesComplexType::ExtrapolationOptionOptional& PITimeSeriesComplexType::
  getExtrapolationOption ()
  {
    return this->extrapolationOption_;
  }

  void PITimeSeriesComplexType::
  setExtrapolationOption (const ExtrapolationOptionType& x)
  {
    this->extrapolationOption_.set (x);
  }

  void PITimeSeriesComplexType::
  setExtrapolationOption (const ExtrapolationOptionOptional& x)
  {
    this->extrapolationOption_ = x;
  }

  void PITimeSeriesComplexType::
  setExtrapolationOption (::std::auto_ptr< ExtrapolationOptionType > x)
  {
    this->extrapolationOption_.set (x);
  }


  // PIInterpolationOptionEnumStringType
  // 

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (Value v)
  : ::xml_schema::String (_xsd_PIInterpolationOptionEnumStringType_literals_[v])
  {
  }

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const PIInterpolationOptionEnumStringType& v,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PIInterpolationOptionEnumStringType& PIInterpolationOptionEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PIInterpolationOptionEnumStringType_literals_[v]);

    return *this;
  }


  // PIExtrapolationOptionEnumStringType
  // 

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (Value v)
  : ::xml_schema::String (_xsd_PIExtrapolationOptionEnumStringType_literals_[v])
  {
  }

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const PIExtrapolationOptionEnumStringType& v,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PIExtrapolationOptionEnumStringType& PIExtrapolationOptionEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PIExtrapolationOptionEnumStringType_literals_[v]);

    return *this;
  }


  // OpenMIExchangeItemComplexType
  // 

  const OpenMIExchangeItemComplexType::ElementIdType& OpenMIExchangeItemComplexType::
  getElementId () const
  {
    return this->elementId_.get ();
  }

  OpenMIExchangeItemComplexType::ElementIdType& OpenMIExchangeItemComplexType::
  getElementId ()
  {
    return this->elementId_.get ();
  }

  void OpenMIExchangeItemComplexType::
  setElementId (const ElementIdType& x)
  {
    this->elementId_.set (x);
  }

  void OpenMIExchangeItemComplexType::
  setElementId (::std::auto_ptr< ElementIdType > x)
  {
    this->elementId_.set (x);
  }

  const OpenMIExchangeItemComplexType::QuantityIdType& OpenMIExchangeItemComplexType::
  getQuantityId () const
  {
    return this->quantityId_.get ();
  }

  OpenMIExchangeItemComplexType::QuantityIdType& OpenMIExchangeItemComplexType::
  getQuantityId ()
  {
    return this->quantityId_.get ();
  }

  void OpenMIExchangeItemComplexType::
  setQuantityId (const QuantityIdType& x)
  {
    this->quantityId_.set (x);
  }

  void OpenMIExchangeItemComplexType::
  setQuantityId (::std::auto_ptr< QuantityIdType > x)
  {
    this->quantityId_.set (x);
  }

  const OpenMIExchangeItemComplexType::UnitType& OpenMIExchangeItemComplexType::
  getUnit () const
  {
    return this->unit_.get ();
  }

  OpenMIExchangeItemComplexType::UnitType& OpenMIExchangeItemComplexType::
  getUnit ()
  {
    return this->unit_.get ();
  }

  void OpenMIExchangeItemComplexType::
  setUnit (const UnitType& x)
  {
    this->unit_.set (x);
  }

  void OpenMIExchangeItemComplexType::
  setUnit (::std::auto_ptr< UnitType > x)
  {
    this->unit_.set (x);
  }


  // UnitEnumStringType
  // 

  UnitEnumStringType::
  UnitEnumStringType (Value v)
  : ::xml_schema::String (_xsd_UnitEnumStringType_literals_[v])
  {
  }

  UnitEnumStringType::
  UnitEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  UnitEnumStringType::
  UnitEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  UnitEnumStringType::
  UnitEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  UnitEnumStringType::
  UnitEnumStringType (const UnitEnumStringType& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  UnitEnumStringType& UnitEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_UnitEnumStringType_literals_[v]);

    return *this;
  }


  // PITimeSeriesImportFileComplexType
  // 

  const PITimeSeriesImportFileComplexType::TimeSeriesFileType& PITimeSeriesImportFileComplexType::
  getTimeSeriesFile () const
  {
    return this->timeSeriesFile_.get ();
  }

  PITimeSeriesImportFileComplexType::TimeSeriesFileType& PITimeSeriesImportFileComplexType::
  getTimeSeriesFile ()
  {
    return this->timeSeriesFile_.get ();
  }

  void PITimeSeriesImportFileComplexType::
  setTimeSeriesFile (const TimeSeriesFileType& x)
  {
    this->timeSeriesFile_.set (x);
  }

  void PITimeSeriesImportFileComplexType::
  setTimeSeriesFile (::std::auto_ptr< TimeSeriesFileType > x)
  {
    this->timeSeriesFile_.set (x);
  }

  const PITimeSeriesImportFileComplexType::UseBinFileOptional& PITimeSeriesImportFileComplexType::
  getUseBinFile () const
  {
    return this->useBinFile_;
  }

  PITimeSeriesImportFileComplexType::UseBinFileOptional& PITimeSeriesImportFileComplexType::
  getUseBinFile ()
  {
    return this->useBinFile_;
  }

  void PITimeSeriesImportFileComplexType::
  setUseBinFile (const UseBinFileType& x)
  {
    this->useBinFile_.set (x);
  }

  void PITimeSeriesImportFileComplexType::
  setUseBinFile (const UseBinFileOptional& x)
  {
    this->useBinFile_ = x;
  }

  PITimeSeriesImportFileComplexType::UseBinFileType PITimeSeriesImportFileComplexType::
  getUseBinFileDefaultValue ()
  {
    return UseBinFileType (false);
  }


  // PITimeSeriesExportFileComplexType
  // 

  const PITimeSeriesExportFileComplexType::TimeSeriesFileType& PITimeSeriesExportFileComplexType::
  getTimeSeriesFile () const
  {
    return this->timeSeriesFile_.get ();
  }

  PITimeSeriesExportFileComplexType::TimeSeriesFileType& PITimeSeriesExportFileComplexType::
  getTimeSeriesFile ()
  {
    return this->timeSeriesFile_.get ();
  }

  void PITimeSeriesExportFileComplexType::
  setTimeSeriesFile (const TimeSeriesFileType& x)
  {
    this->timeSeriesFile_.set (x);
  }

  void PITimeSeriesExportFileComplexType::
  setTimeSeriesFile (::std::auto_ptr< TimeSeriesFileType > x)
  {
    this->timeSeriesFile_.set (x);
  }

  const PITimeSeriesExportFileComplexType::UseBinFileOptional& PITimeSeriesExportFileComplexType::
  getUseBinFile () const
  {
    return this->useBinFile_;
  }

  PITimeSeriesExportFileComplexType::UseBinFileOptional& PITimeSeriesExportFileComplexType::
  getUseBinFile ()
  {
    return this->useBinFile_;
  }

  void PITimeSeriesExportFileComplexType::
  setUseBinFile (const UseBinFileType& x)
  {
    this->useBinFile_.set (x);
  }

  void PITimeSeriesExportFileComplexType::
  setUseBinFile (const UseBinFileOptional& x)
  {
    this->useBinFile_ = x;
  }

  PITimeSeriesExportFileComplexType::UseBinFileType PITimeSeriesExportFileComplexType::
  getUseBinFileDefaultValue ()
  {
    return UseBinFileType (false);
  }

  const PITimeSeriesExportFileComplexType::AdjointOutputOptional& PITimeSeriesExportFileComplexType::
  getAdjointOutput () const
  {
    return this->adjointOutput_;
  }

  PITimeSeriesExportFileComplexType::AdjointOutputOptional& PITimeSeriesExportFileComplexType::
  getAdjointOutput ()
  {
    return this->adjointOutput_;
  }

  void PITimeSeriesExportFileComplexType::
  setAdjointOutput (const AdjointOutputType& x)
  {
    this->adjointOutput_.set (x);
  }

  void PITimeSeriesExportFileComplexType::
  setAdjointOutput (const AdjointOutputOptional& x)
  {
    this->adjointOutput_ = x;
  }

  PITimeSeriesExportFileComplexType::AdjointOutputType PITimeSeriesExportFileComplexType::
  getAdjointOutputDefaultValue ()
  {
    return AdjointOutputType (false);
  }


  // CSVTimeSeriesFileComplexType
  // 

  const CSVTimeSeriesFileComplexType::DecimalSeparatorType& CSVTimeSeriesFileComplexType::
  getDecimalSeparator () const
  {
    return this->decimalSeparator_.get ();
  }

  CSVTimeSeriesFileComplexType::DecimalSeparatorType& CSVTimeSeriesFileComplexType::
  getDecimalSeparator ()
  {
    return this->decimalSeparator_.get ();
  }

  void CSVTimeSeriesFileComplexType::
  setDecimalSeparator (const DecimalSeparatorType& x)
  {
    this->decimalSeparator_.set (x);
  }

  void CSVTimeSeriesFileComplexType::
  setDecimalSeparator (::std::auto_ptr< DecimalSeparatorType > x)
  {
    this->decimalSeparator_.set (x);
  }

  const CSVTimeSeriesFileComplexType::DecimalSeparatorType& CSVTimeSeriesFileComplexType::
  getDecimalSeparatorDefaultValue ()
  {
    return decimalSeparator_default_value_;
  }

  const CSVTimeSeriesFileComplexType::DelimiterType& CSVTimeSeriesFileComplexType::
  getDelimiter () const
  {
    return this->delimiter_.get ();
  }

  CSVTimeSeriesFileComplexType::DelimiterType& CSVTimeSeriesFileComplexType::
  getDelimiter ()
  {
    return this->delimiter_.get ();
  }

  void CSVTimeSeriesFileComplexType::
  setDelimiter (const DelimiterType& x)
  {
    this->delimiter_.set (x);
  }

  void CSVTimeSeriesFileComplexType::
  setDelimiter (::std::auto_ptr< DelimiterType > x)
  {
    this->delimiter_.set (x);
  }

  const CSVTimeSeriesFileComplexType::DelimiterType& CSVTimeSeriesFileComplexType::
  getDelimiterDefaultValue ()
  {
    return delimiter_default_value_;
  }

  const CSVTimeSeriesFileComplexType::AdjointOutputType& CSVTimeSeriesFileComplexType::
  getAdjointOutput () const
  {
    return this->adjointOutput_.get ();
  }

  CSVTimeSeriesFileComplexType::AdjointOutputType& CSVTimeSeriesFileComplexType::
  getAdjointOutput ()
  {
    return this->adjointOutput_.get ();
  }

  void CSVTimeSeriesFileComplexType::
  setAdjointOutput (const AdjointOutputType& x)
  {
    this->adjointOutput_.set (x);
  }

  CSVTimeSeriesFileComplexType::AdjointOutputType CSVTimeSeriesFileComplexType::
  getAdjointOutputDefaultValue ()
  {
    return AdjointOutputType (false);
  }


  // SeparatorEnumStringType
  // 

  SeparatorEnumStringType::
  SeparatorEnumStringType (Value v)
  : ::xml_schema::String (_xsd_SeparatorEnumStringType_literals_[v])
  {
  }

  SeparatorEnumStringType::
  SeparatorEnumStringType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  SeparatorEnumStringType::
  SeparatorEnumStringType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  SeparatorEnumStringType::
  SeparatorEnumStringType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  SeparatorEnumStringType::
  SeparatorEnumStringType (const SeparatorEnumStringType& v,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  SeparatorEnumStringType& SeparatorEnumStringType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_SeparatorEnumStringType_literals_[v]);

    return *this;
  }


  // Id
  // 


  // VectorLength
  // 


  // Validation
  // 

  Validation::
  Validation (Value v)
  : ::xml_schema::String (_xsd_Validation_literals_[v])
  {
  }

  Validation::
  Validation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Validation::
  Validation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Validation::
  Validation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Validation::
  Validation (const Validation& v,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Validation& Validation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Validation_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace fews
{
  // RTCDataConfigComplexType
  //

  RTCDataConfigComplexType::
  RTCDataConfigComplexType (const ImportSeriesType& importSeries,
                            const ExportSeriesType& exportSeries)
  : ::xml_schema::Type (),
    importSeries_ (importSeries, ::xml_schema::Flags (), this),
    exportSeries_ (exportSeries, ::xml_schema::Flags (), this)
  {
  }

  RTCDataConfigComplexType::
  RTCDataConfigComplexType (::std::auto_ptr< ImportSeriesType >& importSeries,
                            ::std::auto_ptr< ExportSeriesType >& exportSeries)
  : ::xml_schema::Type (),
    importSeries_ (importSeries, ::xml_schema::Flags (), this),
    exportSeries_ (exportSeries, ::xml_schema::Flags (), this)
  {
  }

  RTCDataConfigComplexType::
  RTCDataConfigComplexType (const RTCDataConfigComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    importSeries_ (x.importSeries_, f, this),
    exportSeries_ (x.exportSeries_, f, this)
  {
  }

  RTCDataConfigComplexType::
  RTCDataConfigComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    importSeries_ (f, this),
    exportSeries_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RTCDataConfigComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // importSeries
      //
      if (n.name () == "importSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ImportSeriesType > r (
          ImportSeriesTraits::create (i, f, this));

        if (!importSeries_.present ())
        {
          this->importSeries_.set (r);
          continue;
        }
      }

      // exportSeries
      //
      if (n.name () == "exportSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExportSeriesType > r (
          ExportSeriesTraits::create (i, f, this));

        if (!exportSeries_.present ())
        {
          this->exportSeries_.set (r);
          continue;
        }
      }

      break;
    }

    if (!importSeries_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "importSeries",
        "http://www.wldelft.nl/fews");
    }

    if (!exportSeries_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "exportSeries",
        "http://www.wldelft.nl/fews");
    }
  }

  RTCDataConfigComplexType* RTCDataConfigComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RTCDataConfigComplexType (*this, f, c);
  }

  RTCDataConfigComplexType::
  ~RTCDataConfigComplexType ()
  {
  }

  // RTCSeriesImportComplexType
  //

  RTCSeriesImportComplexType::
  RTCSeriesImportComplexType ()
  : ::xml_schema::Type (),
    PITimeSeriesFile_ (::xml_schema::Flags (), this),
    timeSeries_ (::xml_schema::Flags (), this)
  {
  }

  RTCSeriesImportComplexType::
  RTCSeriesImportComplexType (const RTCSeriesImportComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PITimeSeriesFile_ (x.PITimeSeriesFile_, f, this),
    timeSeries_ (x.timeSeries_, f, this)
  {
  }

  RTCSeriesImportComplexType::
  RTCSeriesImportComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PITimeSeriesFile_ (f, this),
    timeSeries_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RTCSeriesImportComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PITimeSeriesFile
      //
      if (n.name () == "PITimeSeriesFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PITimeSeriesFileType > r (
          PITimeSeriesFileTraits::create (i, f, this));

        if (!this->PITimeSeriesFile_)
        {
          this->PITimeSeriesFile_.set (r);
          continue;
        }
      }

      // timeSeries
      //
      if (n.name () == "timeSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeSeriesType > r (
          TimeSeriesTraits::create (i, f, this));

        this->timeSeries_.push_back (r);
        continue;
      }

      break;
    }
  }

  RTCSeriesImportComplexType* RTCSeriesImportComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RTCSeriesImportComplexType (*this, f, c);
  }

  RTCSeriesImportComplexType::
  ~RTCSeriesImportComplexType ()
  {
  }

  // RTCSeriesExportComplexType
  //

  RTCSeriesExportComplexType::
  RTCSeriesExportComplexType ()
  : ::xml_schema::Type (),
    CSVTimeSeriesFile_ (::xml_schema::Flags (), this),
    PITimeSeriesFile_ (::xml_schema::Flags (), this),
    timeSeries_ (::xml_schema::Flags (), this)
  {
  }

  RTCSeriesExportComplexType::
  RTCSeriesExportComplexType (const RTCSeriesExportComplexType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CSVTimeSeriesFile_ (x.CSVTimeSeriesFile_, f, this),
    PITimeSeriesFile_ (x.PITimeSeriesFile_, f, this),
    timeSeries_ (x.timeSeries_, f, this)
  {
  }

  RTCSeriesExportComplexType::
  RTCSeriesExportComplexType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CSVTimeSeriesFile_ (f, this),
    PITimeSeriesFile_ (f, this),
    timeSeries_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RTCSeriesExportComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CSVTimeSeriesFile
      //
      if (n.name () == "CSVTimeSeriesFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< CSVTimeSeriesFileType > r (
          CSVTimeSeriesFileTraits::create (i, f, this));

        if (!this->CSVTimeSeriesFile_)
        {
          this->CSVTimeSeriesFile_.set (r);
          continue;
        }
      }

      // PITimeSeriesFile
      //
      if (n.name () == "PITimeSeriesFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PITimeSeriesFileType > r (
          PITimeSeriesFileTraits::create (i, f, this));

        if (!this->PITimeSeriesFile_)
        {
          this->PITimeSeriesFile_.set (r);
          continue;
        }
      }

      // timeSeries
      //
      if (n.name () == "timeSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeSeriesType > r (
          TimeSeriesTraits::create (i, f, this));

        this->timeSeries_.push_back (r);
        continue;
      }

      break;
    }
  }

  RTCSeriesExportComplexType* RTCSeriesExportComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RTCSeriesExportComplexType (*this, f, c);
  }

  RTCSeriesExportComplexType::
  ~RTCSeriesExportComplexType ()
  {
  }

  // RTCTimeSeriesComplexType
  //

  RTCTimeSeriesComplexType::
  RTCTimeSeriesComplexType (const IdType& id)
  : ::xml_schema::Type (),
    PITimeSeries_ (::xml_schema::Flags (), this),
    OpenMIExchangeItem_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    vectorLength_ (::xml_schema::Flags (), this),
    validation_ (::xml_schema::Flags (), this)
  {
  }

  RTCTimeSeriesComplexType::
  RTCTimeSeriesComplexType (const RTCTimeSeriesComplexType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PITimeSeries_ (x.PITimeSeries_, f, this),
    OpenMIExchangeItem_ (x.OpenMIExchangeItem_, f, this),
    id_ (x.id_, f, this),
    vectorLength_ (x.vectorLength_, f, this),
    validation_ (x.validation_, f, this)
  {
  }

  RTCTimeSeriesComplexType::
  RTCTimeSeriesComplexType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PITimeSeries_ (f, this),
    OpenMIExchangeItem_ (f, this),
    id_ (f, this),
    vectorLength_ (f, this),
    validation_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void RTCTimeSeriesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PITimeSeries
      //
      if (n.name () == "PITimeSeries" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< PITimeSeriesType > r (
          PITimeSeriesTraits::create (i, f, this));

        if (!this->PITimeSeries_)
        {
          this->PITimeSeries_.set (r);
          continue;
        }
      }

      // OpenMIExchangeItem
      //
      if (n.name () == "OpenMIExchangeItem" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< OpenMIExchangeItemType > r (
          OpenMIExchangeItemTraits::create (i, f, this));

        if (!this->OpenMIExchangeItem_)
        {
          this->OpenMIExchangeItem_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "vectorLength" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< VectorLengthType > r (
          VectorLengthTraits::create (i, f, this));

        this->vectorLength_.set (r);
        continue;
      }

      if (n.name () == "validation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ValidationType > r (
          ValidationTraits::create (i, f, this));

        this->validation_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  RTCTimeSeriesComplexType* RTCTimeSeriesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RTCTimeSeriesComplexType (*this, f, c);
  }

  RTCTimeSeriesComplexType::
  ~RTCTimeSeriesComplexType ()
  {
  }

  // PITimeSeriesComplexType
  //

  PITimeSeriesComplexType::
  PITimeSeriesComplexType (const LocationIdType& locationId,
                           const ParameterIdType& parameterId)
  : ::xml_schema::Type (),
    locationId_ (locationId, ::xml_schema::Flags (), this),
    parameterId_ (parameterId, ::xml_schema::Flags (), this),
    qualifierId_ (::xml_schema::Flags (), this),
    timeStep_ (::xml_schema::Flags (), this),
    unit_ (::xml_schema::Flags (), this),
    interpolationOption_ (::xml_schema::Flags (), this),
    extrapolationOption_ (::xml_schema::Flags (), this)
  {
  }

  PITimeSeriesComplexType::
  PITimeSeriesComplexType (const PITimeSeriesComplexType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    locationId_ (x.locationId_, f, this),
    parameterId_ (x.parameterId_, f, this),
    qualifierId_ (x.qualifierId_, f, this),
    timeStep_ (x.timeStep_, f, this),
    unit_ (x.unit_, f, this),
    interpolationOption_ (x.interpolationOption_, f, this),
    extrapolationOption_ (x.extrapolationOption_, f, this)
  {
  }

  PITimeSeriesComplexType::
  PITimeSeriesComplexType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    locationId_ (f, this),
    parameterId_ (f, this),
    qualifierId_ (f, this),
    timeStep_ (f, this),
    unit_ (f, this),
    interpolationOption_ (f, this),
    extrapolationOption_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PITimeSeriesComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // locationId
      //
      if (n.name () == "locationId" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< LocationIdType > r (
          LocationIdTraits::create (i, f, this));

        if (!locationId_.present ())
        {
          this->locationId_.set (r);
          continue;
        }
      }

      // parameterId
      //
      if (n.name () == "parameterId" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ParameterIdType > r (
          ParameterIdTraits::create (i, f, this));

        if (!parameterId_.present ())
        {
          this->parameterId_.set (r);
          continue;
        }
      }

      // qualifierId
      //
      if (n.name () == "qualifierId" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QualifierIdType > r (
          QualifierIdTraits::create (i, f, this));

        this->qualifierId_.push_back (r);
        continue;
      }

      // timeStep
      //
      if (n.name () == "timeStep" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeStepType > r (
          TimeStepTraits::create (i, f, this));

        if (!this->timeStep_)
        {
          this->timeStep_.set (r);
          continue;
        }
      }

      // unit
      //
      if (n.name () == "unit" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitType > r (
          UnitTraits::create (i, f, this));

        if (!this->unit_)
        {
          this->unit_.set (r);
          continue;
        }
      }

      // interpolationOption
      //
      if (n.name () == "interpolationOption" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< InterpolationOptionType > r (
          InterpolationOptionTraits::create (i, f, this));

        if (!this->interpolationOption_)
        {
          this->interpolationOption_.set (r);
          continue;
        }
      }

      // extrapolationOption
      //
      if (n.name () == "extrapolationOption" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ExtrapolationOptionType > r (
          ExtrapolationOptionTraits::create (i, f, this));

        if (!this->extrapolationOption_)
        {
          this->extrapolationOption_.set (r);
          continue;
        }
      }

      break;
    }

    if (!locationId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locationId",
        "http://www.wldelft.nl/fews");
    }

    if (!parameterId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameterId",
        "http://www.wldelft.nl/fews");
    }
  }

  PITimeSeriesComplexType* PITimeSeriesComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PITimeSeriesComplexType (*this, f, c);
  }

  PITimeSeriesComplexType::
  ~PITimeSeriesComplexType ()
  {
  }

  // PIInterpolationOptionEnumStringType
  //

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PIInterpolationOptionEnumStringType_convert ();
  }

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PIInterpolationOptionEnumStringType_convert ();
  }

  PIInterpolationOptionEnumStringType::
  PIInterpolationOptionEnumStringType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PIInterpolationOptionEnumStringType_convert ();
  }

  PIInterpolationOptionEnumStringType* PIInterpolationOptionEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PIInterpolationOptionEnumStringType (*this, f, c);
  }

  PIInterpolationOptionEnumStringType::Value PIInterpolationOptionEnumStringType::
  _xsd_PIInterpolationOptionEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PIInterpolationOptionEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PIInterpolationOptionEnumStringType_indexes_,
                      _xsd_PIInterpolationOptionEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_PIInterpolationOptionEnumStringType_indexes_ + 2 || _xsd_PIInterpolationOptionEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PIInterpolationOptionEnumStringType::
  _xsd_PIInterpolationOptionEnumStringType_literals_[2] =
  {
    "BLOCK",
    "LINEAR"
  };

  const PIInterpolationOptionEnumStringType::Value PIInterpolationOptionEnumStringType::
  _xsd_PIInterpolationOptionEnumStringType_indexes_[2] =
  {
    ::fews::PIInterpolationOptionEnumStringType::BLOCK,
    ::fews::PIInterpolationOptionEnumStringType::LINEAR
  };

  // PIExtrapolationOptionEnumStringType
  //

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PIExtrapolationOptionEnumStringType_convert ();
  }

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PIExtrapolationOptionEnumStringType_convert ();
  }

  PIExtrapolationOptionEnumStringType::
  PIExtrapolationOptionEnumStringType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PIExtrapolationOptionEnumStringType_convert ();
  }

  PIExtrapolationOptionEnumStringType* PIExtrapolationOptionEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PIExtrapolationOptionEnumStringType (*this, f, c);
  }

  PIExtrapolationOptionEnumStringType::Value PIExtrapolationOptionEnumStringType::
  _xsd_PIExtrapolationOptionEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PIExtrapolationOptionEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PIExtrapolationOptionEnumStringType_indexes_,
                      _xsd_PIExtrapolationOptionEnumStringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_PIExtrapolationOptionEnumStringType_indexes_ + 2 || _xsd_PIExtrapolationOptionEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PIExtrapolationOptionEnumStringType::
  _xsd_PIExtrapolationOptionEnumStringType_literals_[2] =
  {
    "BLOCK",
    "PERIODIC"
  };

  const PIExtrapolationOptionEnumStringType::Value PIExtrapolationOptionEnumStringType::
  _xsd_PIExtrapolationOptionEnumStringType_indexes_[2] =
  {
    ::fews::PIExtrapolationOptionEnumStringType::BLOCK,
    ::fews::PIExtrapolationOptionEnumStringType::PERIODIC
  };

  // OpenMIExchangeItemComplexType
  //

  OpenMIExchangeItemComplexType::
  OpenMIExchangeItemComplexType (const ElementIdType& elementId,
                                 const QuantityIdType& quantityId,
                                 const UnitType& unit)
  : ::xml_schema::Type (),
    elementId_ (elementId, ::xml_schema::Flags (), this),
    quantityId_ (quantityId, ::xml_schema::Flags (), this),
    unit_ (unit, ::xml_schema::Flags (), this)
  {
  }

  OpenMIExchangeItemComplexType::
  OpenMIExchangeItemComplexType (const OpenMIExchangeItemComplexType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    elementId_ (x.elementId_, f, this),
    quantityId_ (x.quantityId_, f, this),
    unit_ (x.unit_, f, this)
  {
  }

  OpenMIExchangeItemComplexType::
  OpenMIExchangeItemComplexType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    elementId_ (f, this),
    quantityId_ (f, this),
    unit_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void OpenMIExchangeItemComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // elementId
      //
      if (n.name () == "elementId" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< ElementIdType > r (
          ElementIdTraits::create (i, f, this));

        if (!elementId_.present ())
        {
          this->elementId_.set (r);
          continue;
        }
      }

      // quantityId
      //
      if (n.name () == "quantityId" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< QuantityIdType > r (
          QuantityIdTraits::create (i, f, this));

        if (!quantityId_.present ())
        {
          this->quantityId_.set (r);
          continue;
        }
      }

      // unit
      //
      if (n.name () == "unit" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< UnitType > r (
          UnitTraits::create (i, f, this));

        if (!unit_.present ())
        {
          this->unit_.set (r);
          continue;
        }
      }

      break;
    }

    if (!elementId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "elementId",
        "http://www.wldelft.nl/fews");
    }

    if (!quantityId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "quantityId",
        "http://www.wldelft.nl/fews");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "unit",
        "http://www.wldelft.nl/fews");
    }
  }

  OpenMIExchangeItemComplexType* OpenMIExchangeItemComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OpenMIExchangeItemComplexType (*this, f, c);
  }

  OpenMIExchangeItemComplexType::
  ~OpenMIExchangeItemComplexType ()
  {
  }

  // UnitEnumStringType
  //

  UnitEnumStringType::
  UnitEnumStringType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_UnitEnumStringType_convert ();
  }

  UnitEnumStringType::
  UnitEnumStringType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_UnitEnumStringType_convert ();
  }

  UnitEnumStringType::
  UnitEnumStringType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_UnitEnumStringType_convert ();
  }

  UnitEnumStringType* UnitEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitEnumStringType (*this, f, c);
  }

  UnitEnumStringType::Value UnitEnumStringType::
  _xsd_UnitEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_UnitEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_UnitEnumStringType_indexes_,
                      _xsd_UnitEnumStringType_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_UnitEnumStringType_indexes_ + 5 || _xsd_UnitEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const UnitEnumStringType::
  _xsd_UnitEnumStringType_literals_[5] =
  {
    "m",
    "m^2",
    "m^3",
    "m^3/s",
    "s"
  };

  const UnitEnumStringType::Value UnitEnumStringType::
  _xsd_UnitEnumStringType_indexes_[5] =
  {
    ::fews::UnitEnumStringType::m,
    ::fews::UnitEnumStringType::m_2,
    ::fews::UnitEnumStringType::m_3,
    ::fews::UnitEnumStringType::m_3_s,
    ::fews::UnitEnumStringType::s
  };

  // PITimeSeriesImportFileComplexType
  //

  PITimeSeriesImportFileComplexType::
  PITimeSeriesImportFileComplexType (const TimeSeriesFileType& timeSeriesFile)
  : ::xml_schema::Type (),
    timeSeriesFile_ (timeSeriesFile, ::xml_schema::Flags (), this),
    useBinFile_ (::xml_schema::Flags (), this)
  {
  }

  PITimeSeriesImportFileComplexType::
  PITimeSeriesImportFileComplexType (const PITimeSeriesImportFileComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timeSeriesFile_ (x.timeSeriesFile_, f, this),
    useBinFile_ (x.useBinFile_, f, this)
  {
  }

  PITimeSeriesImportFileComplexType::
  PITimeSeriesImportFileComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timeSeriesFile_ (f, this),
    useBinFile_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PITimeSeriesImportFileComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timeSeriesFile
      //
      if (n.name () == "timeSeriesFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeSeriesFileType > r (
          TimeSeriesFileTraits::create (i, f, this));

        if (!timeSeriesFile_.present ())
        {
          this->timeSeriesFile_.set (r);
          continue;
        }
      }

      // useBinFile
      //
      if (n.name () == "useBinFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->useBinFile_)
        {
          this->useBinFile_.set (UseBinFileTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!timeSeriesFile_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeSeriesFile",
        "http://www.wldelft.nl/fews");
    }
  }

  PITimeSeriesImportFileComplexType* PITimeSeriesImportFileComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PITimeSeriesImportFileComplexType (*this, f, c);
  }

  PITimeSeriesImportFileComplexType::
  ~PITimeSeriesImportFileComplexType ()
  {
  }

  // PITimeSeriesExportFileComplexType
  //

  PITimeSeriesExportFileComplexType::
  PITimeSeriesExportFileComplexType (const TimeSeriesFileType& timeSeriesFile)
  : ::xml_schema::Type (),
    timeSeriesFile_ (timeSeriesFile, ::xml_schema::Flags (), this),
    useBinFile_ (::xml_schema::Flags (), this),
    adjointOutput_ (::xml_schema::Flags (), this)
  {
  }

  PITimeSeriesExportFileComplexType::
  PITimeSeriesExportFileComplexType (const PITimeSeriesExportFileComplexType& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timeSeriesFile_ (x.timeSeriesFile_, f, this),
    useBinFile_ (x.useBinFile_, f, this),
    adjointOutput_ (x.adjointOutput_, f, this)
  {
  }

  PITimeSeriesExportFileComplexType::
  PITimeSeriesExportFileComplexType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timeSeriesFile_ (f, this),
    useBinFile_ (f, this),
    adjointOutput_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PITimeSeriesExportFileComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timeSeriesFile
      //
      if (n.name () == "timeSeriesFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        ::std::auto_ptr< TimeSeriesFileType > r (
          TimeSeriesFileTraits::create (i, f, this));

        if (!timeSeriesFile_.present ())
        {
          this->timeSeriesFile_.set (r);
          continue;
        }
      }

      // useBinFile
      //
      if (n.name () == "useBinFile" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->useBinFile_)
        {
          this->useBinFile_.set (UseBinFileTraits::create (i, f, this));
          continue;
        }
      }

      // adjointOutput
      //
      if (n.name () == "adjointOutput" && n.namespace_ () == "http://www.wldelft.nl/fews")
      {
        if (!this->adjointOutput_)
        {
          this->adjointOutput_.set (AdjointOutputTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!timeSeriesFile_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timeSeriesFile",
        "http://www.wldelft.nl/fews");
    }
  }

  PITimeSeriesExportFileComplexType* PITimeSeriesExportFileComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PITimeSeriesExportFileComplexType (*this, f, c);
  }

  PITimeSeriesExportFileComplexType::
  ~PITimeSeriesExportFileComplexType ()
  {
  }

  // CSVTimeSeriesFileComplexType
  //

  const CSVTimeSeriesFileComplexType::DecimalSeparatorType CSVTimeSeriesFileComplexType::decimalSeparator_default_value_ (
    ".");

  const CSVTimeSeriesFileComplexType::DelimiterType CSVTimeSeriesFileComplexType::delimiter_default_value_ (
    ",");

  CSVTimeSeriesFileComplexType::
  CSVTimeSeriesFileComplexType ()
  : ::xml_schema::Type (),
    decimalSeparator_ (getDecimalSeparatorDefaultValue (), ::xml_schema::Flags (), this),
    delimiter_ (getDelimiterDefaultValue (), ::xml_schema::Flags (), this),
    adjointOutput_ (getAdjointOutputDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  CSVTimeSeriesFileComplexType::
  CSVTimeSeriesFileComplexType (const CSVTimeSeriesFileComplexType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    decimalSeparator_ (x.decimalSeparator_, f, this),
    delimiter_ (x.delimiter_, f, this),
    adjointOutput_ (x.adjointOutput_, f, this)
  {
  }

  CSVTimeSeriesFileComplexType::
  CSVTimeSeriesFileComplexType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    decimalSeparator_ (f, this),
    delimiter_ (f, this),
    adjointOutput_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void CSVTimeSeriesFileComplexType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "decimalSeparator" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DecimalSeparatorType > r (
          DecimalSeparatorTraits::create (i, f, this));

        this->decimalSeparator_.set (r);
        continue;
      }

      if (n.name () == "delimiter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< DelimiterType > r (
          DelimiterTraits::create (i, f, this));

        this->delimiter_.set (r);
        continue;
      }

      if (n.name () == "adjointOutput" && n.namespace_ ().empty ())
      {
        this->adjointOutput_.set (AdjointOutputTraits::create (i, f, this));
        continue;
      }
    }

    if (!decimalSeparator_.present ())
    {
      this->decimalSeparator_.set (getDecimalSeparatorDefaultValue ());
    }

    if (!delimiter_.present ())
    {
      this->delimiter_.set (getDelimiterDefaultValue ());
    }

    if (!adjointOutput_.present ())
    {
      this->adjointOutput_.set (getAdjointOutputDefaultValue ());
    }
  }

  CSVTimeSeriesFileComplexType* CSVTimeSeriesFileComplexType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CSVTimeSeriesFileComplexType (*this, f, c);
  }

  CSVTimeSeriesFileComplexType::
  ~CSVTimeSeriesFileComplexType ()
  {
  }

  // SeparatorEnumStringType
  //

  SeparatorEnumStringType::
  SeparatorEnumStringType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_SeparatorEnumStringType_convert ();
  }

  SeparatorEnumStringType::
  SeparatorEnumStringType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_SeparatorEnumStringType_convert ();
  }

  SeparatorEnumStringType::
  SeparatorEnumStringType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_SeparatorEnumStringType_convert ();
  }

  SeparatorEnumStringType* SeparatorEnumStringType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SeparatorEnumStringType (*this, f, c);
  }

  SeparatorEnumStringType::Value SeparatorEnumStringType::
  _xsd_SeparatorEnumStringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SeparatorEnumStringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_SeparatorEnumStringType_indexes_,
                      _xsd_SeparatorEnumStringType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_SeparatorEnumStringType_indexes_ + 3 || _xsd_SeparatorEnumStringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SeparatorEnumStringType::
  _xsd_SeparatorEnumStringType_literals_[3] =
  {
    ".",
    ",",
    ";"
  };

  const SeparatorEnumStringType::Value SeparatorEnumStringType::
  _xsd_SeparatorEnumStringType_indexes_[3] =
  {
    ::fews::SeparatorEnumStringType::cxx_1,
    ::fews::SeparatorEnumStringType::cxx_,
    ::fews::SeparatorEnumStringType::cxx_2
  };

  // Id
  //

  Id::
  Id ()
  : ::fews::TimeSeriesSimpleType ()
  {
  }

  Id::
  Id (const char* _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base)
  {
  }

  Id::
  Id (const ::std::string& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base)
  {
  }

  Id::
  Id (const ::xml_schema::String& _xsd_String_base)
  : ::fews::TimeSeriesSimpleType (_xsd_String_base)
  {
  }

  Id::
  Id (const Id& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (x, f, c)
  {
  }

  Id::
  Id (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (e, f, c)
  {
  }

  Id::
  Id (const ::xercesc::DOMAttr& a,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (a, f, c)
  {
  }

  Id::
  Id (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::fews::TimeSeriesSimpleType (s, e, f, c)
  {
  }

  Id* Id::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Id (*this, f, c);
  }

  Id::
  ~Id ()
  {
  }

  // VectorLength
  //

  VectorLength::
  VectorLength (const ::xml_schema::Int& _xsd_Int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (_xsd_Int_base)
  {
  }

  VectorLength::
  VectorLength (const VectorLength& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  VectorLength::
  VectorLength (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  VectorLength::
  VectorLength (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  VectorLength::
  VectorLength (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  VectorLength* VectorLength::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorLength (*this, f, c);
  }

  VectorLength::
  ~VectorLength ()
  {
  }

  // Validation
  //

  Validation::
  Validation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Validation_convert ();
  }

  Validation::
  Validation (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Validation_convert ();
  }

  Validation::
  Validation (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Validation_convert ();
  }

  Validation* Validation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Validation (*this, f, c);
  }

  Validation::Value Validation::
  _xsd_Validation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Validation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Validation_indexes_,
                      _xsd_Validation_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_Validation_indexes_ + 8 || _xsd_Validation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Validation::
  _xsd_Validation_literals_[8] =
  {
    "NO",
    "STATE",
    "UPDATE",
    "UPDATE_EXCEPT_STATE",
    "FORECAST",
    "FORECAST_EXCEPT_T0",
    "ALL",
    "ALL_EXCEPT_STATE"
  };

  const Validation::Value Validation::
  _xsd_Validation_indexes_[8] =
  {
    ::fews::Validation::ALL,
    ::fews::Validation::ALL_EXCEPT_STATE,
    ::fews::Validation::FORECAST,
    ::fews::Validation::FORECAST_EXCEPT_T0,
    ::fews::Validation::NO,
    ::fews::Validation::STATE,
    ::fews::Validation::UPDATE,
    ::fews::Validation::UPDATE_EXCEPT_STATE
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace fews
{
  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (const ::std::string& u,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
      ::fews::parseRtcDataConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (const ::std::string& u,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
      ::fews::parseRtcDataConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
      ::fews::parseRtcDataConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::std::istream& is,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcDataConfig (isrc, f, p);
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::std::istream& is,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcDataConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::fews::parseRtcDataConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcDataConfig (isrc, f, p);
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcDataConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::fews::parseRtcDataConfig (isrc, h, f, p);
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::xercesc::InputSource& i,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
      ::fews::parseRtcDataConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::xercesc::InputSource& i,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
      ::fews::parseRtcDataConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
      ::fews::parseRtcDataConfig (
        d, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (const ::xercesc::DOMDocument& d,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
        ::fews::parseRtcDataConfig (
          c, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "rtcDataConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
        ::xsd::cxx::tree::traits< ::fews::RTCDataConfigComplexType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rtcDataConfig",
      "http://www.wldelft.nl/fews");
  }

  ::std::auto_ptr< ::fews::RTCDataConfigComplexType >
  parseRtcDataConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "rtcDataConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      ::std::auto_ptr< ::fews::RTCDataConfigComplexType > r (
        ::xsd::cxx::tree::traits< ::fews::RTCDataConfigComplexType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "rtcDataConfig",
      "http://www.wldelft.nl/fews");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace fews
{
  void
  serializeRtcDataConfig (::std::ostream& o,
                          const ::fews::RTCDataConfigComplexType& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcDataConfig (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRtcDataConfig (::std::ostream& o,
                          const ::fews::RTCDataConfigComplexType& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcDataConfig (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcDataConfig (::std::ostream& o,
                          const ::fews::RTCDataConfigComplexType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcDataConfig (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcDataConfig (::xercesc::XMLFormatTarget& t,
                          const ::fews::RTCDataConfigComplexType& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcDataConfig (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRtcDataConfig (::xercesc::XMLFormatTarget& t,
                          const ::fews::RTCDataConfigComplexType& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcDataConfig (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcDataConfig (::xercesc::XMLFormatTarget& t,
                          const ::fews::RTCDataConfigComplexType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::fews::serializeRtcDataConfig (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRtcDataConfig (::xercesc::DOMDocument& d,
                          const ::fews::RTCDataConfigComplexType& s,
                          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "rtcDataConfig" &&
        n.namespace_ () == "http://www.wldelft.nl/fews")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "rtcDataConfig",
        "http://www.wldelft.nl/fews");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeRtcDataConfig (const ::fews::RTCDataConfigComplexType& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "rtcDataConfig",
        "http://www.wldelft.nl/fews",
        m, f));

    ::fews::serializeRtcDataConfig (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const RTCDataConfigComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // importSeries
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "importSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getImportSeries ();
    }

    // exportSeries
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exportSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getExportSeries ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RTCSeriesImportComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PITimeSeriesFile
    //
    if (i.getPITimeSeriesFile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PITimeSeriesFile",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPITimeSeriesFile ();
    }

    // timeSeries
    //
    for (RTCSeriesImportComplexType::TimeSeriesConstIterator
         b (i.getTimeSeries ().begin ()), n (i.getTimeSeries ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RTCSeriesExportComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // CSVTimeSeriesFile
    //
    if (i.getCSVTimeSeriesFile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CSVTimeSeriesFile",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getCSVTimeSeriesFile ();
    }

    // PITimeSeriesFile
    //
    if (i.getPITimeSeriesFile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PITimeSeriesFile",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPITimeSeriesFile ();
    }

    // timeSeries
    //
    for (RTCSeriesExportComplexType::TimeSeriesConstIterator
         b (i.getTimeSeries ().begin ()), n (i.getTimeSeries ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RTCTimeSeriesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PITimeSeries
    //
    if (i.getPITimeSeries ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PITimeSeries",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getPITimeSeries ();
    }

    // OpenMIExchangeItem
    //
    if (i.getOpenMIExchangeItem ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OpenMIExchangeItem",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getOpenMIExchangeItem ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }

    // vectorLength
    //
    if (i.getVectorLength ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "vectorLength",
          e));

      a << *i.getVectorLength ();
    }

    // validation
    //
    if (i.getValidation ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "validation",
          e));

      a << *i.getValidation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PITimeSeriesComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // locationId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "locationId",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getLocationId ();
    }

    // parameterId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterId",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getParameterId ();
    }

    // qualifierId
    //
    for (PITimeSeriesComplexType::QualifierIdConstIterator
         b (i.getQualifierId ().begin ()), n (i.getQualifierId ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "qualifierId",
          "http://www.wldelft.nl/fews",
          e));

      s << *b;
    }

    // timeStep
    //
    if (i.getTimeStep ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeStep",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getTimeStep ();
    }

    // unit
    //
    if (i.getUnit ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unit",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUnit ();
    }

    // interpolationOption
    //
    if (i.getInterpolationOption ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interpolationOption",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getInterpolationOption ();
    }

    // extrapolationOption
    //
    if (i.getExtrapolationOption ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extrapolationOption",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getExtrapolationOption ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PIInterpolationOptionEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PIInterpolationOptionEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PIInterpolationOptionEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PIExtrapolationOptionEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PIExtrapolationOptionEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PIExtrapolationOptionEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const OpenMIExchangeItemComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // elementId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elementId",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getElementId ();
    }

    // quantityId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "quantityId",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getQuantityId ();
    }

    // unit
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unit",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getUnit ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const UnitEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const UnitEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PITimeSeriesImportFileComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // timeSeriesFile
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeSeriesFile",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTimeSeriesFile ();
    }

    // useBinFile
    //
    if (i.getUseBinFile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "useBinFile",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUseBinFile ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PITimeSeriesExportFileComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // timeSeriesFile
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "timeSeriesFile",
          "http://www.wldelft.nl/fews",
          e));

      s << i.getTimeSeriesFile ();
    }

    // useBinFile
    //
    if (i.getUseBinFile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "useBinFile",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getUseBinFile ();
    }

    // adjointOutput
    //
    if (i.getAdjointOutput ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "adjointOutput",
          "http://www.wldelft.nl/fews",
          e));

      s << *i.getAdjointOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CSVTimeSeriesFileComplexType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // decimalSeparator
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "decimalSeparator",
          e));

      a << i.getDecimalSeparator ();
    }

    // delimiter
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "delimiter",
          e));

      a << i.getDelimiter ();
    }

    // adjointOutput
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "adjointOutput",
          e));

      a << i.getAdjointOutput ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SeparatorEnumStringType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SeparatorEnumStringType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const SeparatorEnumStringType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Id& i)
  {
    e << static_cast< const ::fews::TimeSeriesSimpleType& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Id& i)
  {
    a << static_cast< const ::fews::TimeSeriesSimpleType& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Id& i)
  {
    l << static_cast< const ::fews::TimeSeriesSimpleType& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VectorLength& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VectorLength& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VectorLength& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Validation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Validation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Validation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

